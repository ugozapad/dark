/*
@Copyright Looking Glass Studios, Inc.
1996,1997,1998,1999,2000 Unpublished Work.
*/

///////////////////////////////////////////////////////////////////////////////
// $Header: r:/prj/thief2/scripts/src/RCS/miss16.scr 1.25 1970/01/01 00:00:00 rsmith Exp $
//

#include "animlgte.h"
#include "victory.scr"
//#include "m16vic.h"  - since this won't be coorperative right now...

// ... transcript of m16vic.h
#define M16_GOAL_LEARN 0
#define M16_GOAL_MANUFACTURE 1
#define M16_GOAL_CONNECT 2
#define M16_GOAL_ADJUST_NORM 3
#define M16_GOAL_ADJUST_HARD 4
#define M16_GOAL_ADJUST_EXP 5
#define M16_GOAL_BESNEAKY 6
#define M16_GOAL_EXIT 7



//////////////////////
//////////////////////
//  SCRIPT FILE:  Miss16.SCR
//////////////////////
//////////////////////

//  To be used Mission 16 of Thief 2 - Endgame/Factory

//////////////////////
//////////////////////

// Script:	SoundPreload
// Placed on LoudspeakerRelay object in world.

#ifdef NOT_IN_USE
BEGIN_SCRIPT (SoundPreload, RootScript)

MESSAGES:
OnSim()
{
   if (message.starting)
   {
		// long intro schema
      Sound.PreLoad("kar1601A");
		// ramble schemas
      Sound.PreLoad("kar1602A");
      Sound.PreLoad("kar1602B");
      Sound.PreLoad("kar1602C");
      Sound.PreLoad("kar1602D");
      Sound.PreLoad("kar1602E");
      Sound.PreLoad("kar1602F");
      Sound.PreLoad("kar1602G");
      Sound.PreLoad("kar1602H");
      Sound.PreLoad("kar1602I");
      Sound.PreLoad("kar1602J");
      Sound.PreLoad("kar1602K");
      Sound.PreLoad("kar1602L");
      Sound.PreLoad("kar1602M");
      Sound.PreLoad("kar1602N");
      Sound.PreLoad("kar1602O");
      Sound.PreLoad("kar1602P");
      Sound.PreLoad("kar1602Q");
      Sound.PreLoad("kar1602R");
      Sound.PreLoad("kar1602S");
      Sound.PreLoad("kar1602T");
		// attack schemas
      Sound.PreLoad("kar1603A");
      Sound.PreLoad("kar1603B");
      Sound.PreLoad("kar1603C");
      Sound.PreLoad("kar1603D");
      Sound.PreLoad("kar1603E");
      Sound.PreLoad("kar1603F");
      Sound.PreLoad("kar1603G");
      Sound.PreLoad("kar1603H");
      Sound.PreLoad("kar1603I");
      Sound.PreLoad("kar1603J");
      Sound.PreLoad("kar1603K");
   }
}

END_SCRIPT (SoundPreload)
#endif NOT_IN_USE


// Script: Karras

// When Karras gets a TurnOn/TurnOff msg from his Alert3Response, he broadcasts it 
// out along any outgoing ControlDevice links.

BEGIN_SCRIPT (Karras, RootScript)

MESSAGES:
OnMessage()
{
	if ( (MessageIs("TurnOn")) || (MessageIs("TurnOff")) )
	{
		Link.BroadcastOnAllLinks(self,message.message,"ControlDevice",NULL);
	}
	DefaultOnMessage();
}

END_SCRIPT (Karras)



// Script:  HealingWaterFont

// almost identical to same in thief 1, miss 11 (RTC)

// When frobbed: heals the player, shuts off its own light, and de-charges - cannot be
// used to heal the player for a while.
// A certain amount of time later, it recharges, turns its light back on, and
// is able to heal the player again.

BEGIN_SCRIPT(HealingWaterFont, RootScript)


METHODS:

// heals the player and triggers the related de-charge side effects
METHOD void Heal(object Target)
{
	Damage.Damage(Target,self,GetHealAmount(),object("RestoreStim"));
	SetData("Charged",FALSE);
//	turn off light
	PostMessage(self,"TurnOff");
	// shut off the particle stream fountain effects
	if (Link.AnyExist("~ParticleAttachement",self))
	{
		Link.BroadcastOnAllLinks(self,"TurnOff","~ParticleAttachement");
	}

	SetOneShotTimer("Recharged",GetRechargeTime());
}

METHOD int GetHealAmount()
{
	// should be expressed as negative damage (eg "-4" heals 4 points)
	return -4;
}

METHOD float GetRechargeTime()
{
	// in seconds
	return 180.0;
}

MESSAGES:

OnSim()
{
	if (message.starting)
		SetData("Charged",TRUE);
	DefaultOnSim();
}

OnFrobWorldEnd()
{
	if ((boolean)GetData("Charged"))
		Heal(message.Frobber);

	DefaultOnFrobWorldEnd();
}

OnTimer()
{
	if (message.name == "Recharged")
	{
		SetData("Charged",TRUE);
		// turn on light
		PostMessage(self,"TurnOn");
		// turn on the particle stream fountain effect
		if (Link.AnyExist("~ParticleAttachement",self))
		{
			Link.BroadcastOnAllLinks(self,"TurnOn","~ParticleAttachement");
		}
	}

	DefaultOnTimer();
}

END_SCRIPT(HealingWaterFont)



// Script:	AntennaManager

// This script goes on a Marker object named "AntennaManager".
// The object is ~ControlDevice linked to the 8 antenna switches in the mission.
//  - ie - the 8 antenna switches are ControlDevice linked to it.
// When it gets either a "TurnOn" or a "TurnOff" message (presumably from one of the
// antenna switches), it scans through all the ~ControlDevice linked objects (ie - all
// the antenna switches) and counts how many are in the state that corresponds to "B" -
// the state the player is supposed to flip them to (they all start at "A").
// If the number that are in state "B" is >= X, then the "flip the antenna" objective
// is checked off, otherwise it is marked incomplete.
// X = the value of the mission quest variable that corresponds to
// the current difficulty level:
//   Normal =	num_antenna_norm
//   Hard =		num_antenna_hard
//	  Expert =	num_antenna_exp

BEGIN_SCRIPT (AntennaManager, RootScript)

METHODS:

// Searches through all the ~ControlDevice linked objects and checks to see how many are
// in the state that corresponds to 'B'.
int CountFlippedAntennas()
{
	int X=0;

	if (Link.AnyExist("~ControlDevice",self))
	{
		linkset Switches=Link.GetAll("~ControlDevice",self);
		while(Switches.AnyLinksLeft())
		{
			if (StateIsB(Switches.Link().To()))
			{
				X++;
			}

			Switches.NextLink();
		}
	}
	else
	{
		Debug.MPrint (" *** WARNING: object ",self," has no incoming ControlDevice links!");
	}

	return X;

}  // method: CountFlippedAntennas



// For the passed in object o, presumed to be an antenna switch, returns whether or not o
// is in the state that corresponds to position "B"
boolean StateIsB (object o)
{
	if (  (Property.Get(o,"StTweqJoints","AnimS")) == (0x00)  )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



// Returns the value of the appropriate mission quest variable, based on difficulty.
int GetNumRequiredFlips()
{
	int num;

	int difficulty = Quest.Get("difficulty");

	// EXPERT
	if (difficulty == 2)
	{
		num = Quest.Get("num_antenna_exp");
	}
	// HARD
	else if (difficulty == 1)
	{
		num = Quest.Get("num_antenna_hard");
	}
	// NORMAL
	else // if (difficulty == 0)  - best to return something
	{
		num = Quest.Get("num_antenna_norm");
	}

	return num;
}


MESSAGES:

OnMessage()
{
	if ( (MessageIs("TurnOn")) || (MessageIs("TurnOff")) )
	{
		int X = CountFlippedAntennas();

		if (X >= GetNumRequiredFlips() )
		{
			// mark objective complete
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_NORM),kGoalComplete,kQuestDataMission);
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_HARD),kGoalComplete,kQuestDataMission);
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_EXP),kGoalComplete,kQuestDataMission);

		}
		else
		{
			// mark objective incomplete
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_NORM),kGoalIncomplete,kQuestDataMission);
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_HARD),kGoalIncomplete,kQuestDataMission);
			Quest.Set("goal_state_"+string(M16_GOAL_ADJUST_EXP),kGoalIncomplete,kQuestDataMission);
		}

		// trigger associated VOs
		PostMessage(Object.Named("AntVORelay"),"TurnOn");

	}

	DefaultOnMessage();
}

END_SCRIPT (AntennaManager)



// Script: Socket

// Checks off the correct objective when it is unlocked (ie - when the Guiding Beacon
// has been slotted into it).
// @TODO: Is there a trigtrap way to implement this?

BEGIN_SCRIPT(Socket, RootScript)

MESSAGES:
OnNowUnlocked()
{
	Quest.Set("goal_state_"+string(M16_GOAL_CONNECT),kGoalComplete,kQuestDataMission);
	DefaultOnNowUnlocked();
}

END_SCRIPT(Socket)



// Script:	GuidingBeacon

// Triggers VO when picked up.  The GuidingBeacon is made in-game from
// out of the heirarchy, so we can't easily just do this w/ trig trap.

BEGIN_SCRIPT (GuidingBeacon, RootScript)

MESSAGES:
OnFrobWorldEnd()
{
	if (Object.Exists(Object.Named("GuidBeacVO")))
		PostMessage(Object.Named("GuidBeacVO"),"TurnOn");

	DefaultOnFrobWorldEnd();
}

END_SCRIPT (GuidingBeacon)



// Script:	TrapDelayer

// Metatrap that holds "TurnOn"s and "TurnOff"s
// for a time defined by the ScriptTiming property or 5 seconds if
// not set.
// Deals only reasonably gracefully w/ multiple msgs arriving
// before its timer expires, but the behvaior should be fine for
// this specific mission.

BEGIN_SCRIPT (TrapDelayer, RootScript)

METHODS:
// return value in ScriptTiming property or
// default to 5 (seconds) otherwise
float GetDelay()
{
	float delay = 5.0;

   if (Property.Possessed(self, "ScriptTiming"))
   {
      delay = Property.Get(self, "ScriptTiming");
   }
		
	return delay;
}


MESSAGES:
OnMessage()
{
	if ( (MessageIs("TurnOn")) || (MessageIs("TurnOff")) )
	{
		SetOneShotTimer("Delay",GetDelay(),message.message);
	}
	DefaultOnMessage();
}

OnTimer()
{
	if (message.name == "Delay")
	{
		Link.BroadcastOnAllLinks(self,message.data,"ControlDevice",NULL);
	}

	DefaultOnTimer();
}
END_SCRIPT (TrapDelayer)



// Script:	HomingInProgress

//  Goes on the HomingInProgress device.

BEGIN_SCRIPT (HomingInProgress, RootScript)

MESSAGES:

OnSim()
{
	if (message.starting)
		SetData("Stage",1);
	DefaultOnSim();
}


OnMessage()
{
	if (MessageIs("Transmogrify"))
	{
		if (	((object)message.from == Object.Named("Machine1")) && 
				(GetData("Stage") == 1) )
		{
			Property.Set(self,"ModelName","homing2");
			SetData("Stage",2);
		}
		if (	((object)message.from == Object.Named("Machine2")) && 
				(GetData("Stage") == 2) )
		{
			Property.Set(self,"ModelName","homing3");
			SetData("Stage",3);
		}
		if (	((object)message.from == Object.Named("Machine3")) && 
				(GetData("Stage") == 3) )
		{
			Property.Set(self,"ModelName","homing4");
			SetData("Stage",4);
		}
		if (	((object)message.from == Object.Named("Machine4")) && 
				(GetData("Stage") == 4) )
		{
			SetData("Stage",5);
			// teleport this object away and replace it with the GuidingBeacon
			vector P = Object.Position(Object.Named("GuidingBeacon"));
			vector F = Object.Facing(Object.Named("GuidingBeacon"));
			Object.Teleport(self, vector(0,0,0), vector(0,0,0), Object.Named("GuidingBeacon"));
			// @TODO: insert wait 5 seconds here
			Object.Teleport(Object.Named("GuidingBeacon"), vector(0,0,0), vector(0,0,0), 
						Link.GetOne("ControlDevice",Object.Named("Machine4")).To());

			// now check off the objective
			Quest.Set("goal_state_"+string(M16_GOAL_MANUFACTURE),kGoalComplete,kQuestDataMission);

		}

	}

	DefaultOnMessage();
}

END_SCRIPT (HomingInProgress)




// Script: Machine

// Other machine scripts inherit from this and overload methods.
// Or so I claim (I'm not currently using this like that).

// @NOTE: NOT BEING USED!  (See TransmogrifyMachine, below)

BEGIN_SCRIPT(Machine,Physics)

METHODS:
void Transmogrify (object o)
{
	PostMessage(o,"Transmogrify");
}


void LetObjectPassThrough (object o)
{
	// teleport the object to a ControlDevice linked object
	Object.Teleport(o, vector(0,0,0), vector(0,0,0), 
		Link.GetOne("ControlDevice",self).To());
}


MESSAGES:
OnBeginScript()
{
	Physics.SubscribeMsg(self, kCollisionMsg);
	DefaultOnBeginScript();
}
OnEndScript()
{
	Physics.UnsubscribeMsg(self, kCollisionMsg);
	DefaultOnEndScript();
}
OnPhysCollision()
{

	object WhatHitMe = message.collObj;
	SetData("WhatHitMe",WhatHitMe);
	bool   fakeout = FALSE;

	if (!Object.Exists(WhatHitMe))
		fakeout = TRUE;

	//make sure at least one of us is actually moving and 
	// this isn't some wierd spoof collision...
	vector hitmevel(0,0,0);
	if (Physics.HasPhysics(WhatHitMe))
		Physics.GetVelocity(WhatHitMe,hitmevel);
	if (hitmevel == vector(0,0,0))
		fakeout = TRUE;

	if (!fakeout)
	{
		// now delay a little to make it look like the machine is working on the object
		SetOneShotTimer("Delay",5.0);
	}

	DefaultOnPhysCollision();
}

OnTimer()
{
	if (message.name == "Delay")
	{
		//@TODO: big potential for inconsistency w/ this variable - storing it for 5 seconds...
		object WhatHitMe = (object)GetData("WhatHitMe");
		LetObjectPassThrough(WhatHitMe);
		Transmogrify(WhatHitMe);
	}

	DefaultOnTimer();
}

END_SCRIPT(Machine)



// Script:	BotStationManager

// This script goes on a Marker object and manages a "BotStation" - a place where
// sleeping robots lurk behind unfrobbable doors in small enclosed rooms, waiting to 
// rush off to thwart the player in response to being informed by a camera.
// The BotStation script controls the actions of the door, messages the robots at
// the correct times, and generally coordinates the experience.

// The behavior is triggered by a "TurnOn" message.

BEGIN_SCRIPT (BotStationManager, AI)

METHODS:

// returns an object that is ScriptParams linked to self
// and inherits from the passed in object
object GetSPLinked(object ToMatch)
{
	if (Link.AnyExist("ScriptParams",self))
	{
		linkset L=Link.GetAll("ScriptParams",self);
		while(L.AnyLinksLeft())
		{
			if (Object.InheritsFrom(L.Link().To(), ToMatch))
			{
				return L.Link().To();
			}

			L.NextLink();
		}
	}

	Debug.MPrint(" *** Warning: ",self," cannot find ScriptParams linked to obj that inherits from ",Object.GetName(ToMatch));
	return (object)NULL;
}

// sends passed in msg to all ScriptParams linked objects that
// inherit from passed in object
void BroadcastToThoseWhoInherit(string msg, object ToMatch)
{
	if (Link.AnyExist("ScriptParams",self))
	{
		linkset L=Link.GetAll("ScriptParams",self);
		while(L.AnyLinksLeft())
		{
			if (Object.InheritsFrom(L.Link().To(), ToMatch))
			{
				PostMessage(L.Link().To(),msg);
			}

			L.NextLink();
		}
	}
}


MESSAGES:

OnMessage()
{
	if (MessageIs("TurnOn"))
	{
		// open the door
		object TheDoor = GetSPLinked (Object.Named("Door"));
		PostMessage(TheDoor,"TurnOn");

		// alert the bots
		BroadcastToThoseWhoInherit("TurnOn",Object.Named("Robot"));
	}

	DefaultOnMessage();
}

END_SCRIPT (BotStationManager)





// Script:	BotStationBot

// This script goes on an AI (assumed to be a combat robot) that starts the mission
// in ASLEEP state as part of a Bot Station (see script BotStationManager, above).
// When the AI receives a "TurnOn", it goes to Normal state and
// runs somewhere.  This is either the ControlDevice-linked marker object if one
// exists or to the player object otherwise.  Furthermore, it clamps itself at alert 3
// for the time specified by Script::Timing or 1 minute if not set.

// @NOTE: bad assumption for multiplayer

BEGIN_SCRIPT (BotStationBot, AI)

METHODS:

object GetLinkedDest()
{
	if (Link.AnyExist("ControlDevice",self))
		return Link.GetOne("ControlDevice",self).To();
	else return (object)NULL;
}

float GetAlertTime()
{
	if ((int)Property.Get(self,"ScriptTiming") <= (int)0)
		return 60.0;
	else
		return (float)Property.Get(self,"ScriptTiming");
}

MESSAGES:

OnMessage()
{
	if (MessageIs("TurnOn"))
	{
		// wake up if not dead
		if ( (Property.Possessed(self,"AI_Mode")) && ((int)Property.Get(self,"AI_Mode") != (int)kAIM_Dead) )
			Property.Set(self,"AI_Mode",kAIM_Normal);

		// clamp at alert 3
		Property.Set(self,"AI_AlertCap","Min level",3);
		SetOneShotTimer("DeclampAlert",GetAlertTime());

		// run somewhere
		object dest = GetLinkedDest();
		if (dest == (object)NULL)
			dest = Object.Named("Player");

		GotoObjLoc(dest, kFast);
	}

	DefaultOnMessage();
}

// some special commands once the robot gets to where its supposed to go
// iff there is data on the ScriptParams link
OnObjActResult()
{
	string linkdata = Link.GetOne("~ScriptParams",self).GetData();

	if (linkdata == "")
	{
//		Debug.MPrint(" I got here.  No data.");
	}
	else
	{
		object dest = GetLinkedDest();
		if (dest == (object)NULL)
			dest = Object.Named("Player");

		if (SuccessfulGoto((object)dest))
		{
			if (linkdata == "patrol")
			{
				Property.Set(self,"AI_Patrol",TRUE);
			}
		}
	}

	DefaultOnObjActResult();
}


OnTimer()
{
	if (message.name == "DeclampAlert")
	{
		Property.Set(self,"AI_AlertCap","Min level",0);
	}
	DefaultOnTimer();
}

END_SCRIPT (BotStationBot)


// Script:	OnOffFlame

// Synchronizes appearance and dissapearance of flame object
// with application of fire stim radius propegator on the object.

// TurnOn - flame can be seen, causes damage
// TurnOff - flame cannot be seen, doesn't cause damamge

BEGIN_SCRIPT (OnOffFlame, RootScript)

MESSAGES:

OnMessage()
{
	if (MessageIs("TurnOn"))
	{
		Property.Set(self,"HasRefs",TRUE);
		while (!Object.HasMetaProperty(self, Object.Named("LowPeriodHeatSource")))
			Object.AddMetaProperty(self, Object.Named("LowPeriodHeatSource"));
	}
	else if (MessageIs("TurnOff"))
	{
		Property.Set(self,"HasRefs",FALSE);
		while (Object.HasMetaProperty(self, Object.Named("LowPeriodHeatSource")))
			Object.RemoveMetaProperty(self, Object.Named("LowPeriodHeatSource"));
	}

	DefaultOnMessage();
}

END_SCRIPT (OnOffFlame)


// constants used by LoudspeakerRelay
#define kSchemaNone     "None"
#define kSchemaAttack   "Attack"
#define kSchemaRamble   "Ramble"
#define kSchemaIntro    "Intro"
#define kSchemaOther    "Other"
// Script: LoudspeakerRelay

// Permits only 1 schema to play at a time on the loudspeakers.
// Allows "attack" schemas to pre-empt other kinds of schemas.  No other
// pre-emption is allowed.

BEGIN_SCRIPT(LoudspeakerRelay, RootScript)

METHODS:

// returns a string based on seeing which object the passed-in object
// is linked to (see constants, above):
//  KarrasAttack object = kSchemaAttack string
//  KarrasRamble object = kSchemaRamble string
//  KarrasIntro object  = kSchemaIntro string
//  none of the above   = kSchemaOther string
string ClassifySchema(object schema)
{
   if (Link.AnyExist("ScriptParams",Object.Named("KarrasAttack"),schema))
      return kSchemaAttack;
   else if (Link.AnyExist("ScriptParams",Object.Named("KarrasRamble"),schema))
      return kSchemaRamble;
   else if (Link.AnyExist("ScriptParams",Object.Named("KarrasIntro"),schema))
      return kSchemaIntro;
   else
      return kSchemaOther;
}

MESSAGES:

OnSim()
{
   if (message.starting)
   {
      SetData("CurrentSchema",kSchemaNone);
   }
   DefaultOnSim();
}

OnMessage()
{
   if (MessageIs("PlaySchema"))
   {
      object schema = (object)message.data;
      string schema_type = ClassifySchema(schema);
      
      if (!Object.Exists(schema))
      {
         Debug.MPrint(" *** WARNING: Requested schema obj ",schema," does not exist!");
         return;
      }
      
      // check for collisions
      if ((string)GetData("CurrentSchema") != kSchemaNone)
      {
         if ( (schema_type == kSchemaAttack) && ((string)GetData("CurrentSchema") != kSchemaAttack) )
         {
            // halt the old schemas on all the speakers
            linkset SpeakerList = Link.GetAll("ControlDevice", self);
            while (SpeakerList.AnyLinksLeft())
            {
               // Re-route the SchemaDone to the speaker object, because we don't want to hear about it.
               Sound.HaltSchema(SpeakerList.Link().To());  //, "", SpeakerList.Link().To());
               SpeakerList.NextLink();
            }
         }
         else
         {
            // disallow preemption
            return;
         }
      }

      // @NOTE: I have to cast to a const char *, because the multiparm can't 
      //  cast directly from a cStr
      SetData("CurrentSchema", (const char *)schema_type);

      // Clear our play-count
      SetData("SchemaCount", 0);

      // Play the schema over all objects connected by ControlDevice links 
      linkset SpeakerList = Link.GetAll("ControlDevice", self);		
      while (SpeakerList.AnyLinksLeft())
      {
         // play the schema on the loudspeaker obj, send the callback msg to me
         if (Sound.PlaySchema(self, schema, SpeakerList.Link().To()))
            SetData("SchemaCount", (integer)GetData("SchemaCount") + 1);

         SpeakerList.NextLink();
      }
   }

   DefaultOnMessage();
}

OnSchemaDone()
{
   integer SchemaCount = (integer)GetData("SchemaCount") - 1;
   SetData("SchemaCount", SchemaCount);

   if (SchemaCount == 0)
   {
      SetData("CurrentSchema", kSchemaNone);

      // Check if the schema is chained
      object SchemaObj = Object.Named(message.name);
      if (Link.AnyExist("ScriptParams", SchemaObj))
         PostMessage(self, "PlaySchema", Link.GetOne("ScriptParams", SchemaObj).To());
   }

   DefaultOnSchemaDone();
}

END_SCRIPT(LoudspeakerRelay)



// Script: BroadcastSchemaListNoRep

// Randomly selects a schema from its ScriptParam links and plays it from each object connected
// via ControlDevice links.  Will not repeat a schema until all have been played.

// TurnOn - selects a schema and plays it

BEGIN_SCRIPT (BroadcastSchemaListNoRep, RootScript)

MESSAGES:

OnSim()
{
   if (message.starting && Property.Possessed(self, "ScriptTiming"))
   {
      int delay = Property.Get(self, "ScriptTiming");
      SetData("SchemaDelay", delay);

      delay = (int)((float)delay * (float)Data.RandInt(80, 120) / 100.0);
      SetOneShotTimer(self, "FireSchema", delay);
   }

   DefaultOnSim();
}

OnTimer()
{
   if (message.name == "FireSchema")
   {
      int delay = GetData("SchemaDelay");

      if (delay != 0)
      {
         delay = (int)((float)delay * (float)Data.RandInt(80, 120) / 100.0);
         SetOneShotTimer(self, "FireSchema", delay);

         PostMessage(self, "TurnOn");
			// you'd think putting a TrapRelay script on the same object would do this automatically,
			// but guess what, it doesn't seem to.
			Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
   }

   DefaultOnTimer();
}

OnMessage()
{
   if (MessageIs("TurnOn"))
   {
      if (Link.AnyExist("ScriptParams", self))
      {
         int nValid = 0;

         // count the number of links to select from
         linkset SchemaList = Link.GetAll("ScriptParams", self);
         while (SchemaList.AnyLinksLeft())
         {
            if ((int)SchemaList.Link().GetData() != 1)
               nValid++;

            SchemaList.NextLink();
         }

         // If no valid links remaining, reset them all, and recompute the number of
         // links to pick randomly from
         if (nValid == 0)
         {
            linkset ResetList = Link.GetAll("ScriptParams", self);
            while (ResetList.AnyLinksLeft())
            {
               nValid++;
               ResetList.Link().SetData(0);
               ResetList.NextLink();
            }
         }

         // Randomly pick which to play
         int toPlay = Data.RandInt(1, nValid) - 1;

         // Advance to that link, and get the schema
         linkset PlayList = Link.GetAll("ScriptParams", self);

         while (PlayList.AnyLinksLeft())
         {
            if (PlayList.Link().GetData() == 0)
            {
               if (toPlay == 0)
                  break;
               else
                  toPlay--;
            }

            PlayList.NextLink();
         }

         if (Object.Exists(Object.Named("LoudspeakerRelay")))
         {
				// get the LoudspeakerRelay object
            object LoudspeakerRelay = Object.Named("LoudspeakerRelay");
				// tell it to play the schema we've selected
            PostMessage(LoudspeakerRelay,"PlaySchema",PlayList.Link().To());
         }
         else
            Debug.MPrint(" *** WARNING: object named LoudspeakerRelay does not exist.");

         // Adjust its link data
         PlayList.Link().SetData(1);
      }
   }

   DefaultOnMessage();
}

END_SCRIPT(BroadcastSchemaListNoRep)




// Script:  TrapAddMetaProp

// On "TurnOn": Iterates over all outgoing ControlDevice links and
// adds a Metaprop to the linked objects.  Metaprop to add should
// be ScriptParams linked to the trap.

BEGIN_SCRIPT (TrapAddMetaProp, RootScript)

MESSAGES:
OnMessage()
{
	if (MessageIs("TurnOn"))
	{
		if (Link.AnyExist("ScriptParams",self))
		{
			object MP=Link.GetOne("ScriptParams",self).To();
			if (Object.Exists(MP))
			{
				if (Link.AnyExist("ControlDevice",self))
				{
					linkset CDs=Link.GetAll("ControlDevice",self);
					while(CDs.AnyLinksLeft())
					{
						Object.AddMetaProperty (CDs.Link().To(),MP);

						CDs.NextLink();
					}  // while
				}  // if - ControlDevice
			}  // if - ObjectExists
		}   // if - ScriptParams
	}  // if - TurnOn

	DefaultOnMessage();
}

END_SCRIPT (TrapAddMetaProp)



// Script:	RenewableResource

// This script is on a Marker object.  The marker is ScriptParams-linked to a
// power-up archetype in the hierarchy.  The data on the ScriptParams link describes 
// how destitute the player has to be in this resource in order for this script to 
// produce a new instance of this resource in the world at its own location.  The
// script tracks whether there is already such an object at its location and will
// not produce a new one if so.

// This script hasn't been finished, tested, checked-in, or 
// added to the mission yet. 2/28/00 - RLS

BEGIN_SCRIPT (RenewableResource, RootScript)

METHODS:
// return something on the end of a ScriptParams link
// or (object)0 if none
object GetResource()
{
	if (Link.AnyExist("ScriptParams",self))
		return Link.GetOne("ScriptParams",self).To();
	else
		return (object)0;
}

// return value in ScriptTiming property or
// default to 180.0 (3 minutes) otherwise
float GetPeriod()
{
	float period = 180.0;

   if (Property.Possessed(self, "ScriptTiming"))
   {
      period = Property.Get(self, "ScriptTiming");
   }
		
	return period;
}

// create a new instance of my resource, add the
// "TrigWorldFrob" script to it, 
// put it at my location, and
// forge a CD-link from it to me
void SpawnResource()
{
	object new_obj;

	if ((object)GetResource() == (object)0)
	{
		Debug.MPrint(" ** WARNING: RenewableResource ",self," has no ScriptParams links.");
		return;
	}

	new_obj = Object.BeginCreate(GetResource());
	Object.EndCreate(new_obj);

	if (!Property.Possessed(new_obj,"Scripts"))
	{
		Property.Add(new_obj,"Scripts");
		Property.Set(new_obj,"Scripts","Script 0","TrigWorldFrob");
		Property.Set(new_obj,"Scripts","Script 1","");
		Property.Set(new_obj,"Scripts","Script 2","");
		Property.Set(new_obj,"Scripts","Script 3","");
	}
	else
	{
		// find the first blank spot and add my script to it
		if (Property.Get(new_obj,"Scripts","Script 0") == "")
			Property.Set(new_obj,"Scripts","Script 0","TrigWorldFrob");
		else if (Property.Get(new_obj,"Scripts","Script 1") == "")
			Property.Set(new_obj,"Scripts","Script 1","TrigWorldFrob");
		else if (Property.Get(new_obj,"Scripts","Script 2") == "")
			Property.Set(new_obj,"Scripts","Script 2","TrigWorldFrob");
		else if (Property.Get(new_obj,"Scripts","Script 3") == "")
			Property.Set(new_obj,"Scripts","Script 3","TrigWorldFrob");
	}

	Object.Teleport(new_obj,vector(0,0,0),vector(0,0,0),self);

	// if obj is a projectile, remove its physics
	if (Object.InheritsFrom(new_obj,Object.Named("Projectile")))
	{
		if (Property.Possessed(new_obj,"PhysInitVel"))
		{
			Property.Remove(new_obj,"PhysInitVel");
		}
		if (Property.Possessed(new_obj,"PhysType"))
		{
			Property.Remove(new_obj,"PhysType");
		}
	}

	// if obj is a grenade, remove its physics
	if (Object.InheritsFrom(new_obj,Object.Named("Grenadz")))
	{
		if (Property.Possessed(new_obj,"PhysType"))
		{
			Property.Remove(new_obj,"PhysType");
		}
	}


	Link.Create("ControlDevice",new_obj,self);
}

// scan through all outgoing Contains links from
// the player, check to see if any inherit from my 
// resource, keep a sum of the stack counts of those
// that do.  return (sum < the data
// on the ScriptParams link from me to the resource archetype)
boolean PlayerNeedsResource()
{
	int sum=0,x;
	object inv_item;

	if ((object)GetResource() == (object)0)
		return FALSE;

	//@NOTE: bad multiplayer assumption
	linkset Inv=Link.GetAll("Contains",Object.Named("Player"));
	while(Inv.AnyLinksLeft())
	{
		inv_item = Inv.Link().To();
		if (	(Object.InheritsFrom(inv_item,GetResource())) ||
				(Object.InheritsFrom(inv_item,CrystalToArrow(GetResource()))) )

		{
			if (Property.Possessed(inv_item,"StackCount"))
				x = (int)Property.Get(inv_item,"StackCount");
			else
				x=1;

			sum += x;
		}
		Inv.NextLink();
	}

//	Debug.MPrint(" Player has ",sum," of resource.");
//	Debug.MPrint(" Respawning if less than ",Link.GetOne("ScriptParams",self).GetData());

	return (sum < (int)Link.GetOne("ScriptParams",self).GetData());
}

object CrystalToArrow(object crystal)
{
	if (Object.InheritsFrom(crystal,Object.Named("WaterCrystal")))
		return Object.Named("water");
	else if (Object.InheritsFrom(crystal,Object.Named("FireCrystal")))
		return Object.Named("firearr");
	else if (Object.InheritsFrom(crystal,Object.Named("AirCrystal")))
		return Object.Named("GasArrow");
	else if (Object.InheritsFrom(crystal,Object.Named("EarthCrystal")))
		return Object.Named("EarthArrow");

	else return (object)0;
}


MESSAGES:
OnSim()
{
	if (message.starting)
	{
		SetOneShotTimer("Ping",GetPeriod());
		SpawnResource();  // assumes there is no resource instance there at sim start
	}
	DefaultOnSim();
}

OnTimer()
{
	if (message.name == "Ping")
	{
		// check for outgoing ~CD link,   if my it exists, my resource is still
		// here, so nevermind
		if (Link.AnyExist("~ControlDevice",self))
		{
//			Debug.MPrint(self," still has a resource, not spawning.");
		}
		else if (PlayerNeedsResource())
		{
			SpawnResource();
		}

		SetOneShotTimer("Ping",GetPeriod());
	}
	DefaultOnTimer();
}

OnMessage()
{
	if (MessageIs("TurnOn"))
	{
		// my resource has been picked up.  snap the CD link from it to me
		if (Link.AnyExist("ControlDevice",message.from,self))
			Link.Destroy(Link.GetOne("ControlDevice",message.from,self));
	}
	DefaultOnMessage();
}

END_SCRIPT (RenewableResource)


///////////////////////////////////////////////////////////////////////////////
//
//  Script: TransmogrifyMachine
//
// Base script for machine that converts one type of item or items into another.
// Specific conversion behavior is specified on derived scripts.
//

BEGIN_SCRIPT (TransmogrifyMachine, RootScript)

METHODS:

void PlaceAtOutput(integer slot, object obj)
{
   if ((integer)obj == OBJ_NULL)
      return;

	// if obj is a flashbomb, remove its physics
	if (Object.InheritsFrom(obj,Object.Named("Flashbomb")))
	{
		if (Property.Possessed(obj,"PhysType"))
		{
			Property.Remove(obj,"PhysType");
		}
	}

   vector facing;
   vector position;

   facing.x = position.x = 0;
   facing.y = position.y = 0;
   facing.z = position.z = 0;

   object outputPoint = OBJ_NULL;

   linkset OutputSet = Link.GetAll("ScriptParams", self);
   while (OutputSet.AnyLinksLeft())
   {
      if (OutputSet.Link().GetData() == slot)
      {
         outputPoint = OutputSet.Link().To();
         break;
      }

      OutputSet.NextLink();
   }

   if ((integer)outputPoint == OBJ_NULL)
      return;

   Object.Teleport(obj, position, facing, outputPoint);

   vector velocity;
   velocity.x = velocity.y = 0;
   velocity.z = 0.1;
   Physics.SetVelocity(obj, velocity);
}

// These methods should be overridden by deriving scripts
virtual void Transmogrify()
{
}

virtual void HandleInput(integer slot, object obj)
{
}

virtual void HandleRemoval(integer slot, object obj)
{
}

MESSAGES:

OnMessage()
{
   if (MessageIs("TurnOn"))
      Transmogrify();

   if (MessageIs("Enter"))
      HandleInput(message.data2, message.data);
   if (MessageIs("Exit"))
      HandleRemoval(message.data2, message.data);
      
   DefaultOnMessage();
}

END_SCRIPT(TransmogrifyMachine)

///////////////////////////////////////////////////////////////////////////////
//
//  Script: MachineSlot
//
// Script for detecting entrance of an object, and notification of the
// Transmogrify machine
//

BEGIN_SCRIPT(MachineSlot, Physics)

MESSAGES:

OnBeginScript()
{
   Physics.SubscribeMsg(self, kContactMsg);
   DefaultOnBeginScript();
}
OnEndScript()
{
   Physics.UnsubscribeMsg(self, kContactMsg);
   DefaultOnEndScript();
}

OnPhysContactCreate()
{
   // Filter on submodel 0, so we don't get multiple messages for each 
   // submodel of a contacting model
   if (message.contactSubmod == 0)
   {
      link toMachine = Link.GetOne("ScriptParams", self);
      PostMessage(toMachine.To(), "Enter", message.contactObj, (integer)toMachine.GetData());
   }

   DefaultOnPhysContactCreate();
}

OnPhysContactDestroy()
{
   if (message.contactSubmod == 0)
   {
      link toMachine = Link.GetOne("ScriptParams", self);
      PostMessage(toMachine.To(), "Exit", message.contactObj, (integer)toMachine.GetData());
   }

   DefaultOnPhysContactDestroy();
}

END_SCRIPT (MachineSlot)



//////////////////////////////////////////////////////////////////////////////
//
// Constants  - strings used as parameter to Object.Named()

#define kBellowPlot   "HIPStage0"

#define kRollingPlot  "HIPStage1"
#define kRollingPlot2 "PlateO'Metal"

#define kSealingPlot  "HIPStage2"
#define kSealingPlot2 "RegRound"

#define kFusingPlot   "HIPStage3"

#define kFinalPlot    "HomingIntact"

////////////////////////////////////////

#define kBellowExtra1   "FluxSpheroid"
#define kBellowExtra2   "BantamNode"
#define kBellowResult   "CameraGrenade"

#define kRollingExtra1  "FlareMixture"
#define kRollingExtra2  "PlateO'Metal"
#define kRollingExtra3  "CombatBotBoiler"
#define kRollingResult1 "Flare"
#define kRollingResult2 "QuoteList"

#define kSealingExtra1  "MineBulb"
#define kSealingExtra2  "PlateO'Metal"
#define kSealingExtra3  "BantamNode"
#define kSealingResult1 "Mine"
#define kSealingResult2 "ExplosiveCharge"

#define kLinkingExtra1  "InvGauge"
#define kLinkingExtra2  "BantamNode"
#define kLinkingResult  "RegRound"

#define kFusingExtra1   "AcidMixture"
#define kFusingExtra2   "WireSpool"
#define kFusingExtra3   "PlateO'Metal"
#define kFusingExtra4   "FluxSpheroid"
#define kFusingResult1  "FluxSpheroid"
#define kFusingResult2  "Flashbomb"

#define kAmalgExtra1    "IronChassis"
#define kAmalgExtra2    "QuickLimeMixture"
#define kAmalgExtra3    "AcidMixture"
#define kAmalgExtra4    "FlareMixture"
#define kAmalgResult1   "MineBulb"
#define kAmalgResult2   "FlareMixture"
#define kAmalgResult3   "FlashMine"

///////////////////////////////////////////////////////////////////////////////
//
//  Script: BellowingMachine
//

BEGIN_SCRIPT (BellowingMachine, TransmogrifyMachine)

METHODS:

void HandleInput(integer slot, object obj)
{
   object newObj = OBJ_NULL;

   if (Object.InheritsFrom(obj, Object.Named(kBellowPlot)))
   {
      newObj = Object.Create(Object.Named(kRollingPlot));
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kBellowExtra1)))
   {
      SetData("Extra1Count", (integer)GetData("Extra1Count") + 1);
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kBellowExtra2)))
   {
      SetData("Extra2Count", (integer)GetData("Extra2Count") + 1);
      Object.Destroy(obj);
   }
   else
      newObj = obj;

   if (((integer)newObj == OBJ_NULL) &&
       ((integer)GetData("Extra1Count") > 0) &&
       ((integer)GetData("Extra2Count") > 0))
   {
      newObj = Object.Create(Object.Named(kBellowResult));

      SetData("Extra1Count", (integer)GetData("Extra1Count") - 1);
      SetData("Extra2Count", (integer)GetData("Extra2Count") - 1);
   }

   PlaceAtOutput(1, newObj);
}

END_SCRIPT (BellowingMachine)

///////////////////////////////////////////////////////////////////////////////
//
//  Script: RollingMachine
//

BEGIN_SCRIPT (RollingMachine, TransmogrifyMachine)

METHODS:

void Transmogrify()
{
   object obj1 = GetData("InputObj1");
   object obj2 = GetData("InputObj2");
   object newObj = OBJ_NULL;

   if (Object.InheritsFrom(obj1, Object.Named(kRollingPlot)) &&
       Object.InheritsFrom(obj2, Object.Named(kRollingPlot2)))
   {
      newObj = Object.Create(Object.Named(kSealingPlot));
   }
   else
   if (Object.InheritsFrom(obj1, Object.Named(kRollingExtra1)) && 
       Object.InheritsFrom(obj2, Object.Named(kRollingExtra2)))
   {
      newObj = Object.Create(Object.Named(kRollingResult1));
   }
   else
   if (Object.InheritsFrom(obj1, Object.Named(kRollingExtra3)) && 
       Object.InheritsFrom(obj2, Object.Named(kRollingExtra2)))
   {
      SetData("Extra3Count", (integer)GetData("Extra3Count") + 1);

      int N=5;
      if ((integer)GetData("Extra3Count") >= N) 
      {
         newObj = Object.Create(Object.Named(kRollingResult2));
         SetData("Extra3Count", (integer)GetData("Extra3Count") - N);
      }
   }
   else
      newObj = obj1;

   if (newObj != obj1)
   {
      Object.Destroy(obj1);
      Object.Destroy(obj2);
   }

   PlaceAtOutput(1, newObj);
}

void HandleInput(integer slot, object obj)
{
   switch (slot)
   {
      case 1:
      {
         if (GetData("InputObj1") == OBJ_NULL)
            SetData("InputObj1", obj);
         break;
      }

      case 2:
      {
         if (GetData("InputObj2") == OBJ_NULL)
            SetData("InputObj2", obj);
         break;
      }
   }
}

void HandleRemoval(integer slot, object obj)
{
   switch (slot)
   {
      case 1:
      {
         if (GetData("InputObj1") == obj)
            SetData("InputObj1", OBJ_NULL);
         break;
      }

      case 2:
      {
         if (GetData("InputObj2") == obj)
            SetData("InputObj2", OBJ_NULL);
         break;
      }
   }
}

END_SCRIPT (RollingMachine)

///////////////////////////////////////////////////////////////////////////////
//
//  Script: SealingMachine
//

BEGIN_SCRIPT (SealingMachine, TransmogrifyMachine)

METHODS:

void Transmogrify()
{
   object obj1 = GetData("InputObj1");
   object obj2 = GetData("InputObj2");
   object newObj = OBJ_NULL;
   object newObj2 = OBJ_NULL;

   if (	(Object.InheritsFrom(obj1, Object.Named(kSealingPlot)) &&
         Object.InheritsFrom(obj2, Object.Named(kSealingPlot2)))
        ||
        (Object.InheritsFrom(obj2, Object.Named(kSealingPlot)) &&
         Object.InheritsFrom(obj1, Object.Named(kSealingPlot2))) )
   {    
      newObj = Object.Create(Object.Named(kFusingPlot));
   }
   else
   if (	(Object.InheritsFrom(obj1, Object.Named(kSealingExtra1)) && 
         Object.InheritsFrom(obj2, Object.Named(kSealingExtra2)))
        ||
        (Object.InheritsFrom(obj2, Object.Named(kSealingExtra1)) && 
         Object.InheritsFrom(obj1, Object.Named(kSealingExtra2))) )
   {    
      newObj = Object.Create(Object.Named(kSealingResult1));
   }
   else
   if (	(Object.InheritsFrom(obj1, Object.Named(kSealingExtra1)) && 
         Object.InheritsFrom(obj2, Object.Named(kSealingExtra3))) )
   {
      newObj = Object.Create(Object.Named(kSealingResult2));
      // tell secret its been scored
      PostMessage(Object.Named("ManufactureSecret3"),"TurnOn");
   }
   else
   {
      newObj = obj1;
      newObj2 = obj2;
   }

   if (newObj != obj1)
   {
      Object.Destroy(obj1);
      Object.Destroy(obj2);
   }

   PlaceAtOutput(1, newObj);
   PlaceAtOutput(2, newObj2);
}

void HandleInput(integer slot, object obj)
{
   switch (slot)
   {
      case 1:
      {
         if (GetData("InputObj1") == OBJ_NULL)
            SetData("InputObj1", obj);
         break;
      }

      case 2:
      {
         if (GetData("InputObj2") == OBJ_NULL)
            SetData("InputObj2", obj);
         break;
      }
   }
}

void HandleRemoval(integer slot, object obj)
{
   switch (slot)
   {
      case 1:
      {
         if (GetData("InputObj1") == obj)
            SetData("InputObj1", OBJ_NULL);
         break;
      }

      case 2:
      {
         if (GetData("InputObj2") == obj)
            SetData("InputObj2", OBJ_NULL);
         break;
      }
   }
}
 
END_SCRIPT (SealingMachine)

///////////////////////////////////////////////////////////////////////////////
//
//  Script: LinkingMachine
//

BEGIN_SCRIPT (LinkingMachine, TransmogrifyMachine)

METHODS:

void Transmogrify()
{
   if (((integer)GetData("Extra1Count") > 0) &&
       ((integer)GetData("Extra2Count") > 0))
   {
      SetData("Extra1Count", (integer)GetData("Extra1Count") - 1);
      SetData("Extra2Count", (integer)GetData("Extra2Count") - 1);

      object newObj = Object.Create(Object.Named(kLinkingResult));
      PlaceAtOutput(1, newObj);
   }
}

void HandleInput(integer slot, object obj)
{
   if (Object.InheritsFrom(obj, Object.Named(kLinkingExtra1)))
   {
      SetData("Extra1Count", (integer)GetData("Extra1Count") + 1);
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kLinkingExtra2)))
   {
      SetData("Extra2Count", (integer)GetData("Extra2Count") + 1);
      Object.Destroy(obj);
   }
   else
      PlaceAtOutput(1, obj);
}

END_SCRIPT (LinkingMachine)

///////////////////////////////////////////////////////////////////////////////
//
//  Script: FusingMachine
//

BEGIN_SCRIPT (FusingMachine, TransmogrifyMachine)

METHODS:

void Transmogrify()
{
   object obj = GetData("InputObj");
   object newObj = OBJ_NULL;

   if (Object.InheritsFrom(obj, Object.Named(kFusingPlot)))
   {
      Object.Destroy(obj);
		// mark the objective complete
		Quest.Set("goal_state_"+string(M16_GOAL_MANUFACTURE),kGoalComplete,kQuestDataMission);
      newObj = Object.Create(Object.Named(kFinalPlot));
   }

   // See if we should make a powerup
   if (((integer)newObj == OBJ_NULL) && 
       ((integer)GetData("Extra1Count") > 0) &&
       ((integer)GetData("Extra2Count") > 0))
   {
      newObj = Object.Create(Object.Named(kFusingResult1));

      SetData("Extra1Count", (integer)GetData("Extra1Count") - 1);
      SetData("Extra2Count", (integer)GetData("Extra2Count") - 1);
   }
	else
   if (((integer)newObj == OBJ_NULL) && 
       ((integer)GetData("Extra3Count") > 0) &&
       ((integer)GetData("Extra4Count") > 0))
   {
      newObj = Object.Create(Object.Named(kFusingResult2));

		// tell secret its been scored
		PostMessage(Object.Named("ManufactureSecret2"),"TurnOn");

      SetData("Extra3Count", (integer)GetData("Extra3Count") - 1);
      SetData("Extra4Count", (integer)GetData("Extra4Count") - 1);
   }


   // Place any output object at our output location
   PlaceAtOutput(1, newObj);
}

void HandleInput(integer slot, object obj)
{
   if (Object.InheritsFrom(obj, Object.Named(kFusingPlot)))
   {
      if (GetData("InputObj") == OBJ_NULL)
         SetData("InputObj", obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kFusingExtra1)))
   {
      SetData("Extra1Count", (integer)GetData("Extra1Count") + 1);
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kFusingExtra2)))
   {
      SetData("Extra2Count", (integer)GetData("Extra2Count") + 1);
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kFusingExtra3)))
   {
      SetData("Extra3Count", (integer)GetData("Extra3Count") + 1);
      Object.Destroy(obj);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kFusingExtra4)))
   {
      SetData("Extra4Count", (integer)GetData("Extra4Count") + 1);
      Object.Destroy(obj);
   }
   else
      PlaceAtOutput(2, obj);
}

END_SCRIPT (FusingMachine)
   
///////////////////////////////////////////////////////////////////////////////
//
//  Script: AmalgMachine
//

BEGIN_SCRIPT (AmalgMachine, TransmogrifyMachine)

METHODS:

void Transmogrify()
{
   if (((integer)GetData("Extra1Count") > 0) &&
       ((integer)GetData("Extra2Count") > 0))
   {
      object newObj = Object.Create(Object.Named(kAmalgResult1));
      PlaceAtOutput(1, newObj);

      SetData("Extra1Count", (integer)GetData("Extra1Count") - 1);
      SetData("Extra2Count", (integer)GetData("Extra2Count") - 1);
   }
   else
   if (((integer)GetData("Extra2Count") > 0) &&
       ((integer)GetData("Extra3Count") > 0))
   {
      object newObj = Object.Create(Object.Named(kAmalgResult2));
      PlaceAtOutput(1, newObj);

      SetData("Extra2Count", (integer)GetData("Extra2Count") - 1);
      SetData("Extra3Count", (integer)GetData("Extra3Count") - 1);
   }
   else
   if (((integer)GetData("Extra1Count") > 0) &&
       ((integer)GetData("Extra4Count") > 0))
   {
		// tell secret its been scored
		PostMessage(Object.Named("ManufactureSecret1"),"TurnOn");

      object newObj = Object.Create(Object.Named(kAmalgResult3));
      PlaceAtOutput(1, newObj);

      SetData("Extra1Count", (integer)GetData("Extra1Count") - 1);
      SetData("Extra4Count", (integer)GetData("Extra4Count") - 1);
   }
}

void HandleInput(integer slot, object obj)
{
   if (Object.InheritsFrom(obj, Object.Named(kAmalgExtra1)))
   {
      Object.Destroy(obj);
      SetData("Extra1Count", (integer)GetData("Extra1Count") + 1);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kAmalgExtra2)))
   {
      Object.Destroy(obj);
      SetData("Extra2Count", (integer)GetData("Extra2Count") + 1);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kAmalgExtra3)))
   {
      Object.Destroy(obj);
      SetData("Extra3Count", (integer)GetData("Extra3Count") + 1);
   }
   else
   if (Object.InheritsFrom(obj, Object.Named(kAmalgExtra4)))
   {
      Object.Destroy(obj);
      SetData("Extra4Count", (integer)GetData("Extra4Count") + 1);
   }
	else
      PlaceAtOutput(1, obj);
}

END_SCRIPT (AmalgMachine)
