head	 1.76;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.76
date	 2000.03.27.12.47.45;  author TJS;  state Exp;
branches ;
next	 1.75;

1.75
date	 2000.03.22.23.41.32;  author adurant;  state Exp;
branches ;
next	 1.74;

1.74
date	 2000.03.21.11.54.14;  author adurant;  state Exp;
branches ;
next	 1.73;

1.73
date	 2000.03.18.19.39.45;  author adurant;  state Exp;
branches ;
next	 1.72;

1.72
date	 2000.03.16.17.42.47;  author adurant;  state Exp;
branches ;
next	 1.71;

1.71
date	 2000.03.15.11.11.00;  author adurant;  state Exp;
branches ;
next	 1.70;

1.70
date	 2000.03.05.10.35.09;  author adurant;  state Exp;
branches ;
next	 1.69;

1.69
date	 2000.03.02.23.49.48;  author adurant;  state Exp;
branches ;
next	 1.68;

1.68
date	 2000.03.01.20.26.58;  author adurant;  state Exp;
branches ;
next	 1.67;

1.67
date	 2000.02.28.20.35.03;  author TJS;  state Exp;
branches ;
next	 1.66;

1.66
date	 2000.02.28.13.26.37;  author TJS;  state Exp;
branches ;
next	 1.65;

1.65
date	 2000.02.26.20.55.48;  author adurant;  state Exp;
branches ;
next	 1.64;

1.64
date	 2000.02.24.19.28.41;  author TJS;  state Exp;
branches ;
next	 1.63;

1.63
date	 2000.02.23.10.09.34;  author adurant;  state Exp;
branches ;
next	 1.62;

1.62
date	 2000.02.18.23.25.32;  author TJS;  state Exp;
branches ;
next	 1.61;

1.61
date	 2000.02.15.14.36.30;  author adurant;  state Exp;
branches ;
next	 1.60;

1.60
date	 2000.02.14.17.51.31;  author adurant;  state Exp;
branches ;
next	 1.59;

1.59
date	 2000.02.11.18.34.12;  author TJS;  state Exp;
branches ;
next	 1.58;

1.58
date	 2000.02.11.17.43.28;  author TJS;  state Exp;
branches ;
next	 1.57;

1.57
date	 2000.02.11.11.17.12;  author adurant;  state Exp;
branches ;
next	 1.56;

1.56
date	 2000.02.08.22.30.56;  author adurant;  state Exp;
branches ;
next	 1.55;

1.55
date	 2000.02.08.22.23.46;  author TJS;  state Exp;
branches ;
next	 1.54;

1.54
date	 2000.02.08.22.17.01;  author TJS;  state Exp;
branches ;
next	 1.53;

1.53
date	 2000.02.06.00.53.39;  author TJS;  state Exp;
branches ;
next	 1.52;

1.52
date	 2000.02.05.13.38.52;  author adurant;  state Exp;
branches ;
next	 1.51;

1.51
date	 2000.02.02.17.09.33;  author TJS;  state Exp;
branches ;
next	 1.50;

1.50
date	 2000.02.02.15.18.35;  author adurant;  state Exp;
branches ;
next	 1.49;

1.49
date	 2000.01.30.21.00.19;  author TJS;  state Exp;
branches ;
next	 1.48;

1.48
date	 2000.01.30.19.28.39;  author TJS;  state Exp;
branches ;
next	 1.47;

1.47
date	 2000.01.28.18.35.45;  author TJS;  state Exp;
branches ;
next	 1.46;

1.46
date	 2000.01.28.00.32.51;  author TJS;  state Exp;
branches ;
next	 1.45;

1.45
date	 2000.01.24.23.18.23;  author TJS;  state Exp;
branches ;
next	 1.44;

1.44
date	 2000.01.23.21.26.19;  author TJS;  state Exp;
branches ;
next	 1.43;

1.43
date	 2000.01.22.19.09.56;  author TJS;  state Exp;
branches ;
next	 1.42;

1.42
date	 2000.01.22.16.50.32;  author TJS;  state Exp;
branches ;
next	 1.41;

1.41
date	 2000.01.21.22.04.17;  author TJS;  state Exp;
branches ;
next	 1.40;

1.40
date	 2000.01.21.18.10.00;  author TJS;  state Exp;
branches ;
next	 1.39;

1.39
date	 2000.01.21.15.20.23;  author TJS;  state Exp;
branches ;
next	 1.38;

1.38
date	 2000.01.21.14.44.05;  author TJS;  state Exp;
branches ;
next	 1.37;

1.37
date	 2000.01.20.22.57.35;  author TJS;  state Exp;
branches ;
next	 1.36;

1.36
date	 2000.01.20.11.24.28;  author TJS;  state Exp;
branches ;
next	 1.35;

1.35
date	 2000.01.20.11.08.23;  author adurant;  state Exp;
branches ;
next	 1.34;

1.34
date	 2000.01.17.19.01.22;  author TJS;  state Exp;
branches ;
next	 1.33;

1.33
date	 2000.01.10.12.24.02;  author TJS;  state Exp;
branches ;
next	 1.32;

1.32
date	 2000.01.10.12.01.40;  author TJS;  state Exp;
branches ;
next	 1.31;

1.31
date	 2000.01.06.10.50.17;  author TJS;  state Exp;
branches ;
next	 1.30;

1.30
date	 2000.01.05.14.08.08;  author TJS;  state Exp;
branches ;
next	 1.29;

1.29
date	 1999.12.30.14.56.03;  author TJS;  state Exp;
branches ;
next	 1.28;

1.28
date	 1999.12.26.15.55.44;  author TJS;  state Exp;
branches ;
next	 1.27;

1.27
date	 1999.12.17.15.55.02;  author PATMAC;  state Exp;
branches ;
next	 1.26;

1.26
date	 1999.12.16.20.01.34;  author TJS;  state Exp;
branches ;
next	 1.25;

1.25
date	 1999.12.16.11.17.44;  author adurant;  state Exp;
branches ;
next	 1.24;

1.24
date	 1999.12.10.14.42.43;  author PATMAC;  state Exp;
branches ;
next	 1.23;

1.23
date	 1999.12.07.20.12.36;  author adurant;  state Exp;
branches ;
next	 1.22;

1.22
date	 1999.12.02.15.44.44;  author TJS;  state Exp;
branches ;
next	 1.21;

1.21
date	 1999.11.24.18.05.25;  author adurant;  state Exp;
branches ;
next	 1.20;

1.20
date	 1999.11.09.13.10.24;  author adurant;  state Exp;
branches ;
next	 1.19;

1.19
date	 1999.11.08.11.03.23;  author TJS;  state Exp;
branches ;
next	 1.18;

1.18
date	 1999.11.07.14.41.33;  author adurant;  state Exp;
branches ;
next	 1.17;

1.17
date	 1999.10.27.15.04.45;  author adurant;  state Exp;
branches ;
next	 1.16;

1.16
date	 1999.10.11.15.02.32;  author TJS;  state Exp;
branches ;
next	 1.15;

1.15
date	 1999.10.06.11.42.51;  author TJS;  state Exp;
branches ;
next	 1.14;

1.14
date	 1999.10.05.15.47.49;  author TJS;  state Exp;
branches ;
next	 1.13;

1.13
date	 1999.10.04.17.19.54;  author TJS;  state Exp;
branches ;
next	 1.12;

1.12
date	 1999.09.27.16.59.20;  author TJS;  state Exp;
branches ;
next	 1.11;

1.11
date	 1999.09.27.14.38.05;  author TJS;  state Exp;
branches ;
next	 1.10;

1.10
date	 1999.09.27.13.36.34;  author TJS;  state Exp;
branches ;
next	 1.9;

1.9
date	 1999.08.03.20.18.42;  author rsmith;  state Exp;
branches ;
next	 1.8;

1.8
date	 1999.07.31.12.33.22;  author TJS;  state Exp;
branches ;
next	 1.7;

1.7
date	 1999.07.22.09.12.02;  author TJS;  state Exp;
branches ;
next	 1.6;

1.6
date	 1999.07.16.14.47.31;  author TJS;  state Exp;
branches ;
next	 1.5;

1.5
date	 1999.07.16.09.20.33;  author TJS;  state Exp;
branches ;
next	 1.4;

1.4
date	 1999.07.15.15.59.12;  author TJS;  state Exp;
branches ;
next	 1.3;

1.3
date	 1999.07.06.14.28.31;  author TJS;  state Exp;
branches ;
next	 1.2;

1.2
date	 1999.07.05.15.08.25;  author TJS;  state Exp;
branches ;
next	 1.1;

1.1
date	 1999.07.05.15.07.22;  author TJS;  state Exp;
branches ;
next	 ;


desc
@Generic object behaviors, forked off version 1.204 from the Thief 1
tree.
@


1.76
log
@Map supplement cannot decrease map_max_page
@
text
@///////////////////////////////////////////////////////////////////////////
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.75 1970/01/01 00:00:00 adurant Exp $
//

#include "frobscrt.h"
#include "invtype.h"
#include "prjctile.h"
#include "animlgte.h"
#include "drscrpt.h"
#include "tweqflgs.h"
#include "aitype.h"
#include "aiscrt.h" // for alertness levels
#include "rendprop.h" // for render types
#include "dmgprop.h" // for slay results
#include "ambbase.h" // for ambient hack flags
#include "tfint.h" // for trap flags
#include "drkstats.h"

#include <stdio.h> // for sprintf, because damn, why not. 

#include "evidence.scr"
#include "traps.scr"
#include "gizmo.scr"
#include "ai.scr"

/* GEN.SCR
  This file contains "generic" object behavior scripts of various sorts.
  This is meant to include the default behaviors of certain object types,
  which corresponds to scripts set at the archetype level, in the game
  system.

  Usually, this includes two main classes of behaviors for each object
  type:
     * Interpretation of "Frob" events, excluding those behaviors which
       can be encoded in the object's FrobInfo property, such as being
       picked up or destroyed.
     * Type-dependent interpretation of "TurnOn" and "TurnOff" events,
       for "trap/trigger" scripting purposes.

  Types of behaviors found herein include:
     * Doors opening and closing
     * Keys unlocking lockboxes
     * Books showing contents when frobbed
     * Torches turning on and off in response to A/R stimuli
     * Weapons equipping themselves when selected as current inventory item.

*/




BEGIN_SCRIPT(Legible, RootScript)

METHODS:
   METHOD void ShowText()
   {
      if(Property.Possessed(self,"book"))
      {
         string bookname=Property.Get(self,"book");

         // we are so wacky.  We will code the possibility of qvar-dependent
         // books straight into the core legible script.
         if(Property.Possessed(self,"TrapQVar"))
         {
            string qvar=Property.Get(self,"TrapQVar");
            integer index=Quest.Get(qvar);
            // use sprintf to adhere to usual naming convention for books.
            char buf[64];

            sprintf(buf,"%s%02d",(const char*)bookname,index);
            bookname=string(buf);
         }

         if(Property.Possessed(self,"bookart"))
         {
            string bookart=Property.Get(self,"bookart");

            DarkUI.ReadBook(bookname,bookart);
         }
         else
         {
            bookname=string("..\\Books\\")+bookname;
            string popup=Data.GetString(bookname,"Page_0");
            DarkUI.TextMessage(popup);
         }
      }
   }
END_SCRIPT(Legible)

BEGIN_SCRIPT(StdBook,Legible)

MESSAGES:
  OnFrobWorldEnd()
  {
     ShowText();
     DefaultOnFrobWorldEnd();
  }
END_SCRIPT(StdBook)


BEGIN_SCRIPT(StdScroll,Legible)

MESSAGES:
  OnFrobInvEnd()
  {
     ShowText();
     DefaultOnFrobInvEnd();
  }
END_SCRIPT(StdScroll)


// Script: MapSupplement
/* When used, changes your MAP_MAX_PAGE quest variable
   to the page on the object's Automap property, then
   brings up your automap, then self-destructs since you
   have perfectly good other ways of bringing up your
   automap.

   Note that the self-destruct is handled by the object's
   FrobInfo property, though.
*/
BEGIN_SCRIPT(MapSupplement, RootScript)
MESSAGES:
   OnFrobInvEnd()
   {
      integer oldmax=Quest.Get("map_max_page");

      if(Property.Possessed(self,"Automap"))
      {
         integer newmax=Property.Get(self,"Automap","Page");

         if(newmax>oldmax)
            Quest.Set("map_max_page",newmax);
      }
      Debug.Command("automap");
      DefaultOnFrobInvEnd();
   }
END_SCRIPT(MapSupplement)


/* Musical instruments: make a sound (on yourself) if world frobbed
   or inv frobbed.  FrobInfo handles whether sound should be made,
   since nobody's forcing us to send frobs to scripts.
   */
BEGIN_SCRIPT(Instrument, RootScript)
   MESSAGES:

   OnFrobWorldEnd()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,message.Frobber,kEnvSoundAtObjLoc);
      DefaultOnFrobWorldEnd();
   }
   OnFrobInvEnd()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,message.Frobber,kEnvSoundAtObjLoc);
      DefaultOnFrobInvEnd();
   }

END_SCRIPT(Instrument)


/* Goofy food script.  In addition to destroying the item
   (as specified in its FrobInfo property) play a sound.
   */
BEGIN_SCRIPT(EatFood,RootScript)

  MESSAGES:

  OnFrobInvEnd()
  {
     boolean is_player = (object(message.Frobber) == object("Player")); 
     eEnvSoundLoc loc = is_player ? kEnvSoundAmbient : kEnvSoundAtObjLoc;
     // move the object to the frobber
     vector zeroes(0,0,0); 
     Object.Teleport(self,zeroes,zeroes,message.Frobber); 

     // Now play the activate event 
     Sound.PlayEnvSchema(self,"Event Activate",self,message.Frobber,loc);
        
     // Note: the food item is destroyed because of its FrobInfo property
     // so we don't have to do that here.
     DefaultOnFrobInvEnd();
  }

END_SCRIPT(EatFood)

/* For healing potions: when I am frobbed, make an unreffed clone of 
   myself and put it in A/R contact with the frobber.
   */
BEGIN_SCRIPT(CloneContactFrob, RootScript)
MESSAGES:
   OnFrobInvEnd()
   {
      object newobj=Object.BeginCreate(self);
      Property.Set(newobj,"HasRefs",FALSE);
      Object.EndCreate(newobj);
      ActReact.BeginContact(newobj,message.Frobber);
      DefaultOnFrobInvEnd();
   }
END_SCRIPT(CloneContactFrob)

/* Similar to the above: when I take damage from VenomStim,
   clone the weapon responsible and put me in contact with it,
   thus causing continuing damage.
   */
BEGIN_SCRIPT(CloneContactDmg, RootScript)
MESSAGES:
   OnDamage()
   {
      object stim=message.kind;
      object source=message.culprit;

      if(stim==Object.Named("VenomStim"))
      {
         object newobj=Object.BeginCreate(source);
         Property.Set(newobj,"HasRefs",FALSE);
         Object.EndCreate(newobj);
         ActReact.BeginContact(newobj,self);
      }
      DefaultOnDamage();
   }
END_SCRIPT(CloneContactDmg)


// For object which is slain when frobbed
BEGIN_SCRIPT(FrobSlay, RootScript)
MESSAGES:
   OnFrobWorldEnd()
   {
      Damage.Slay(self,message.Frobber);
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(FrobSlay)

// Base script for animating lights: knows how to turn them on and off
// Objects with special effects associated with these events should
// override the TurnOn and TurnOff methods

// If the anim light has a TweqFlicker property, then the light will
// respond to TurnOn messages by starting the TweqFlicker and going
// into "flicker between min and max" mode.  When the TweqFlicker
// finishes, _then_ it will turn on.

BEGIN_SCRIPT(AnimLight,RootScript)

   METHODS:

      METHOD void InitModes()
      {
         integer mode, onmode, offmode;

         if(Property.Possessed(self,"AnimLight"))
            mode=Property.Get(self,"AnimLight","Mode");
         else
            return; // Bad, but nothing we can do.

         if(mode==ANIM_LIGHT_MODE_MINIMUM)
            offmode=mode;
         else if(mode==ANIM_LIGHT_MODE_SMOOTH_BRIGHTEN ||
                 mode==ANIM_LIGHT_MODE_SMOOTH_DIM)
            offmode=ANIM_LIGHT_MODE_SMOOTH_DIM;
         else
            offmode=ANIM_LIGHT_MODE_EXTINGUISH;

         if(mode!=offmode)
            onmode=mode;
         else
         {
            if(offmode==ANIM_LIGHT_MODE_SMOOTH_DIM)
               onmode=ANIM_LIGHT_MODE_SMOOTH_BRIGHTEN;
            else
               onmode=ANIM_LIGHT_MODE_MAXIMUM;
         }

         SetData("OnLiteMode",onmode);
         SetData("OffLiteMode",offmode);
      }
         
      // Turn our ambienthack sound (if present) on or off
      METHOD void AmbientHack(boolean on)
      {
         if(Property.Possessed(self,"AmbientHacked"))
         {
            integer flags=Property.Get(self,"AmbientHacked","Flags");

            if(!on)
               flags|=AMBFLG_S_TURNEDOFF;
            else
               flags&=(~AMBFLG_S_TURNEDOFF);
            Property.Set(self,"AmbientHacked","Flags",flags);
         }
      }
      METHOD boolean IsLightOn()
      {
         integer mode;

         if(Property.Possessed(self,"AnimLight"))
            mode=Property.Get(self,"AnimLight","Mode");
         else
            return FALSE;

         if(!IsDataSet("OnLiteMode"))
            InitModes();

         return mode==integer(GetData("OnLiteMode"));
      }
      METHOD void ChangeMode(boolean on)
      {
         integer newmode;
         string onoffmsg=on?"TurnOn":"TurnOff";
         string modedata=on?"OnLiteMode":"OffLiteMode";

         Link.BroadcastOnAllLinks(self,onoffmsg,"~ParticleAttachement");
         
         if(Property.Possessed(self,"SelfIllum"))
            Property.Set(self,"SelfIllum",on?1.0:0);

         AmbientHack(on);

         Link.BroadcastOnAllLinks(self,onoffmsg,"ControlDevice",NULL);

         if(!Property.Possessed(self,"AnimLight"))
            return; // nothing we can do.

         if(!IsDataSet(modedata))
            InitModes();

         newmode=GetData(modedata);
         Light.SetMode(self,newmode);
      }
      METHOD void TurnOn()
      {
         ChangeMode(TRUE);
      }
      METHOD void TurnOff()
      {
         ChangeMode(FALSE);
      }
      METHOD void Toggle()
      {
         integer mode;
         if(!Property.Possessed(self,"AnimLight")) return;

         if(!IsDataSet("OnLiteMode") || !IsDataSet("OffLiteMode"))
            InitModes();

         mode=Property.Get(self,"AnimLight","Mode");
         if(mode==integer(GetData("OnLiteMode")))
            TurnOff();
         else if(mode==integer(GetData("OffLiteMode")))
            TurnOn();
      }

   MESSAGES:
      // Initializations to force particle and self-illum state to be
      // consistent with light "on" state.  Safe for save/load.
      OnSim()
      {
         if(message.starting)
            InitModes();
         DefaultOnSim();
      }
      OnBeginScript()
      {
         // This should just synch particles, tweqs, self illum, and such to
         // the current state of the AnimLight property.
         ChangeMode(IsLightOn());
         DefaultOnBeginScript();
      }
      OnTweqComplete()
      {
         if(message.Type==kTweqTypeFlicker)
         {
            TurnOn();
         }
         DefaultOnTweqComplete();
      }
      OnSlain()
      {
         // Anim Lights need to stick around just long enough to turn off
         // when slain.  So...
         TurnOff();
         SetOneShotTimer(self,"ReallySlay",0.1);
      
         DefaultOnSlain();
      }
      OnTimer()
      {
         if(message.name=="ReallySlay")
         {
            // Destruction of anim lights not safe across save/load, apparently
            // Object.Destroy(self);
            Property.Set(self,"HasRefs",FALSE);
        }
         DefaultOnTimer();
      }
      OnMessage()
      {
         if(MessageIs("TurnOn"))
         {
            if(Property.Possessed(self,"StTweqBlink"))
            {
               ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoActivate);
               Light.SetMode(self,ANIM_LIGHT_MODE_FLICKER);
            }
            else
               TurnOn();
         }
         else if(MessageIs("TurnOff"))
         {
            if(Property.Possessed(self,"StTweqBlink"))
            {
               ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoHalt);
               Property.Set(self,"StTweqBlink","Cur Time",0);
            }
            TurnOff();
         }
         else if(MessageIs("Toggle"))
            Toggle();
        DefaultOnMessage();
      }

END_SCRIPT(AnimLight)


/* Manages adding and removing the A/R heat source on flames. */
BEGIN_SCRIPT(DoFlameSource, RootScript)
MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         Object.AddMetaProperty(self,"FlameHeatSource");
      }
      DefaultOnSim();
   }
   OnSlain()
   {
      Object.RemoveMetaProperty(self,"FlameHeatSource");
      DefaultOnSlain();
   }
END_SCRIPT(DoFlameSource)


/* Script for any light that can be extinguished with water and gas, or
   lit with fire.  Assumes that the model is animating via a TweqModels.

   We commit the following gruesome hack to avoid hard-coding in the model
   to swap to when the light is extinguished:  since TweqModels animates until
   the first empty entry of its Tweq Config model list, we count on this and
   support no more than 4 models in the animation, when actually there are
   spaces for six in the property.  The sixth is the "dead" version of the
   model, and the fifth is left empty as a separator, so the normal animation
   does not include the "dead" version.

 */

BEGIN_SCRIPT(Extinguishable, AnimLight)

   METHODS:
      METHOD void ChangeMode(boolean on)
      {
         // turn on/off our TweqModels animation
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeModels,
                        on?kTweqDoActivate:kTweqDoHalt);
         if(!on)
         {
            string deadmodel="Newt01"; // default from Thief1 standard torches.

            // change our model
            if(Property.Possessed(self,"CfgTweqModels"))
            {
               string propmodel=Property.Get(self,"CfgTweqModels","Model 5");
               if(propmodel!=string(""))
                  deadmodel=propmodel;
            }
            Property.Set(self,"ModelName",(const char*)deadmodel);
         }

	 if ((Property.Possessed(self,"SuspObj")) &&
             (IsLightOn() != on)) //make sure we are changing states
         {
	   //I tried to do something clever here with negating the
	   //gotten data in a set directly, but it failed.  So I do this.
           //easier to read anyway.
           boolean wassusp = Property.Get(self,"SuspObj","Is Suspicious");  
           if (wassusp)
             Property.Set(self,"SuspObj","Is Suspicious",FALSE);
           else
             Property.Set(self,"SuspObj","Is Suspicious",TRUE);
           wassusp = Property.Get(self,"SuspObj","Is Suspicious");
         }

#ifdef TORCH_HEAT_SOURCE
         // Extinguishable items are also assumed to be touch sources of heat...
         if(on)
         {
            if(!Object.HasMetaProperty(self,"TouchHeatSource"))
               Object.AddMetaProperty(self,"TouchHeatSource");
         }
         else
            Object.RemoveMetaProperty(self,"TouchHeatSource");
#endif

         Base::ChangeMode(on);
      }

   MESSAGES:
      OnBeginScript()
      {
         ActReact.SubscribeToStimulus(self,"WaterStim");
         ActReact.SubscribeToStimulus(self,"FireStim");
         ActReact.SubscribeToStimulus(self,"KOGas");
         DefaultOnBeginScript();
      }
      OnEndScript()
      {
         ActReact.UnsubscribeToStimulus(self,"KOGas");
         ActReact.UnsubscribeToStimulus(self,"FireStim");
         ActReact.UnsubscribeToStimulus(self,"WaterStim");
         DefaultOnEndScript();
      }
      OnStimulus(KOGas)
      {
         TurnOff();
      }
      OnStimulus(WaterStim)
      {
         TurnOff();
      }
      OnStimulus(FireStim)
      {
         TurnOn();
      }

  // This will allow us to get the stimulus messages we're asking for
  SCRIPT_BEGIN_MESSAGE_MAP()
    STIMULUS_MESSAGE_MAP_ENTRY(KOGas)
    STIMULUS_MESSAGE_MAP_ENTRY(WaterStim)
    STIMULUS_MESSAGE_MAP_ENTRY(FireStim)
  SCRIPT_END_MESSAGE_MAP()

END_SCRIPT(Extinguishable)


/* Gaslights (we claim) can be turned on with a frob, but cannot be frobbed off */
BEGIN_SCRIPT(GasLight, Extinguishable)
METHODS:
   METHOD void TurnOn()
   {
      if(!Object.HasMetaProperty(self,"FrobInert"))
         Object.AddMetaProperty(self,"FrobInert");
      Base::TurnOn();
   }
   METHOD void TurnOff()
   {
      Object.RemoveMetaProperty(self,"FrobInert");
      Base::TurnOff();
   }
   METHOD void InitModes()
   {
      Base::InitModes();
      if(IsLightOn() && !Object.HasMetaProperty(self,"FrobInert"))
         Object.AddMetaProperty(self,"FrobInert");
   }

MESSAGES:
   OnFrobWorldEnd()
   {
      TurnOn();
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(GasLight)


// fairly generic script to play sounds upon receipt of
// TurnOn and TurnOff messages, presumably corresponding
// to other scripted actions.

// If a "Script Timing" property is present then it indicates
// flags about the sound sequencing:
// Treat the property as 0 if not present.

enum seqflags
{
   NoTwiceOn=0x1,
   RevThenLoop=0x2,
};


BEGIN_SCRIPT(OnOffSounds, RootScript)
States
{
   Off=0,
   RevOn=1,
   On=2,
   RevOff=3
};
METHODS:
   METHOD void NextSound()
   {
      integer state=GetState();
      integer flags=0;

      if(Property.Possessed(self,"scriptTiming"))
         flags=Property.Get(self,"scriptTiming");

      if(state==RevOn)
      {
         if(flags & seqflags(RevThenLoop))
         {
            // Play my "I am active" loop.
            Sound.PlayEnvSchema(self,"Event ActiveLoop",self);
         }
         SetState(On);
      }
      else if(state==RevOff)
      {
         SetState(Off);
      }
   }

MESSAGES:
   OnBeginScript()
   {
      if(!IsDataSet("State"))
         SetState(Off);
      DefaultOnBeginScript();
   }
   OnSchemaDone()
   {
      NextSound();
   }
   OnMessage()
   {
      integer flags=0;
      boolean success=TRUE;
      integer state=GetState();

      if(Property.Possessed(self,"scriptTiming"))
         flags=Property.Get(self,"scriptTiming");

      if(MessageIs("TurnOn"))
      {
         if(flags & (seqflags(RevThenLoop)|seqflags(NoTwiceOn)))
         {
            if(!(state==RevOn || state==On))
            {
               Sound.HaltSchema(self);
               success=Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
               SetState(RevOn);

               // If failed to play rev-up sound, proceed straight to loop
               if(!success)
                  NextSound();
            }
         }
         else
         {
            Sound.HaltSchema(self);
            success=Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
         }
      }
      else if(MessageIs("TurnOff"))
      {
         if(flags & (seqflags(RevThenLoop)|seqflags(NoTwiceOn)))
         {
            if(!(state==RevOff || state==Off))
            {
               Sound.HaltSchema(self);
               success=Sound.PlayEnvSchema(self,"Event Deactivate",self,NULL,kEnvSoundAtObjLoc);
               SetState(RevOff);
            }
         }
         else
         {
            Sound.HaltSchema(self);
            success=Sound.PlayEnvSchema(self,"Event Deactivate",self,NULL,kEnvSoundAtObjLoc);
         }
      }
      if(!success)
      {
         Debug.MPrint("Sorrow! Object ",self," failing to play OnOff sounds.");
      }
      DefaultOnMessage();            
   }

END_SCRIPT(OnOffSounds)

////////////////////////////////////////////////
// Activate/deactivate AmbientHacked

BEGIN_SCRIPT(ActivateAmbient, RootScript)

MESSAGES:
 
   OnMessage()
   {
      if (MessageIs("TurnOn"))
      {
         if (Property.Possessed(self,"AmbientHacked"))
         {
            integer flags=Property.Get(self,"AmbientHacked","Flags");

            flags &= ~AMBFLG_S_TURNEDOFF;
            Property.Set(self,"AmbientHacked","Flags",flags);
         }
      }

      if (MessageIs("TurnOff"))
      {
         if (Property.Possessed(self,"AmbientHacked"))
         {
            integer flags=Property.Get(self,"AmbientHacked","Flags");

            flags |= AMBFLG_S_TURNEDOFF;
            Property.Set(self,"AmbientHacked","Flags",flags);
         }
      }
   }

END_SCRIPT(ActivateAmbient)

// As above, this will play sounds on receipt of
// TurnOn message.  This is more suitable to single cases,
// whereas OnOffSounds is more suited to by-type cases.
BEGIN_SCRIPT(DescribeSounds, RootScript)
METHODS:
   METHOD void PlayMe(object schem)
   {
      Sound.PlaySchema(self,schem,self);
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         linkset sounds=Link.GetAll("SoundDescription",self);

         while(sounds.AnyLinksLeft())
         {
            PlayMe(sounds.Link().To());
            sounds.NextLink();
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(DescribeSounds)

// Like DescribeSounds, but plays sounds "ambient" (non-localized)
BEGIN_SCRIPT(AmbientSounds, DescribeSounds)
METHODS:
   METHOD void PlayMe(object schem)
   {
      Sound.PlaySchemaAmbient(self,schem);
   }
END_SCRIPT(AmbientSounds)


BEGIN_SCRIPT(VOSounds, DescribeSounds)
METHODS:
   METHOD void PlayMe(object schem)
   {
      Sound.PlayVoiceOver(self,schem);
   }
END_SCRIPT(VOSounds)


// situations for returning camera to player
// this script should be attached to players.
BEGIN_SCRIPT(CamReturn, RootScript)

MESSAGES:
    OnDamage()
    {
       if(message.damage>0)
          Camera.ForceCameraReturn();
       DefaultOnDamage();
    }
END_SCRIPT(CamReturn);

BEGIN_SCRIPT(CamGrenade, Physics)

METHODS:

   METHOD float GetMagSq(vector whichvec)
   {
     return ((whichvec.x * whichvec.x) + (whichvec.y * whichvec.y) +
             (whichvec.z * whichvec.z));
   }

   METHOD BOOL PassVelCheck()
   {
      vector myvel;
      Physics.GetVelocity(self,myvel);
      if (GetMagSq(myvel)<4)
	return TRUE;
      else
	return FALSE;
   }

   METHOD void Activate()
   {
      if (Link.AnyExist("~Contains",self))
      {
         SetData("AmContained",1);
         return; //this really should already be handled, but lets be safe
      }
      else
         SetData("AmContained",0);
      // So, who ever said I was in motion because the player threw me, anyway?
      // Need to check that.
      if(Link.AnyExist("~CulpableFor",self))
      {
         if(Object.InheritsFrom(Link.GetOne("~CulpableFor",self).To(),
                                "Avatar"))
            Camera.DynamicAttach(self);
      }
      // HACK: ok, so this sort of breaks the meaning of "culpable for",
      // but really I don't care that much about player culpability here,
      // and it fixes a nasty save/load bug. 
      while (Link.AnyExist("~CulpableFor",self))
        Link.Destroy(Link.GetOne("~CulpableFor",self));
   }

MESSAGES:

    OnBeginScript()
    {
       if (Link.AnyExist("~Contains",self)) //am I contained?
  	 SetData("AmContained",1);
       else
	 SetData("AmContained",0);
       //should handle remove from stack case.
       //Activate makes sure someone is culpable.
       if (!(integer)GetData("AmContained"))
          SetOneShotTimer(self,"velcheck",1.0);
       Physics.SubscribeMsg(self, kFellAsleepMsg);
       DefaultOnBeginScript();
    }
    OnEndScript()
    {
       Physics.UnsubscribeMsg(self, kFellAsleepMsg);
       DefaultOnEndScript();
    }
	
    OnPhysFellAsleep()
    {
       if ((integer)GetData("AmContained")==0)
          Activate();
       DefaultOnPhysFellAsleep();
    }

    OnContained()
    {
      if (message.event==kContainRemove)
	SetData("AmContained",0);
      else
        SetData("AmContained",1);
      if(message.event==kContainRemove &&
         Object.InheritsFrom(message.container,"Avatar"))
      {
	 SetOneShotTimer(self,"velcheck",1.0);	 
      }
      DefaultOnContained();
    }

    OnTimer()
    {
      if (message.name == "velcheck")
	if (!(integer)GetData("AmContained"))
	  if (PassVelCheck())
	    Activate();
          else
            SetOneShotTimer(self,"velcheck",1.0); //try again
      DefaultOnTimer();
    }
    

    OnSlain()
    {
       //if camera still attached to me, return.
       Camera.CameraReturn(self);
       DefaultOnSlain();
    }
	
    OnDestroy()
    {
       Camera.CameraReturn(self);
       //I'm irked that this isn't DefaultOnDestroy
       //
       // Me too.
       BaseOnDestroy();
    }

END_SCRIPT(CamGrenade);

BEGIN_SCRIPT(Mine, Physics)

METHODS:
   // What object type am I when I'm armed (@@HACK!)
   METHOD object ArmType()
   {
      return(object("ActiveMine"));
   }

   METHOD void Arm()
   {
      // @@TODO: Would prefer to determine what we transform into some
      // other way than by overloading this method.
      object newmine=Object.Create(ArmType());
      vector z=vector(0,0,0);

      Object.Teleport(newmine,z,z,self);

      // Just becaue it's a different object didn't mean it isn't
      // you who threw it.  Sorta.
      // This is important for assigning blame for kills, with
      // victory conditions and such.
      if(Link.AnyExist("~CulpableFor",self))
         Link.Create("~CulpableFor",newmine,Link.GetOne("~CulpableFor",self).To());
      Object.Destroy(self);
   }

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kFellAsleepMsg);
      if(!IsDataSet("Arming"))
         SetData("Arming",FALSE);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kFellAsleepMsg);
      DefaultOnEndScript();
   }
   // when we come to rest, destroy ourselves and create the
   // object type which represents the active mine.
   // Only do this is something is culpable for us, so objects
   // placed in levels and settling to rest don't arm...
   OnPhysFellAsleep()
   {
      boolean arming = GetData("Arming");
      if ((Link.AnyExist("~CulpableFor",self)) && (!arming))
      {
         // Start playing our arming sound.  When we're done with the
         // sound, become Live.
         boolean played=Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);

         // if failed to play schema, arm right away.
         if(!played) Arm();
         else
         {
            // Failsafe to arm in case schema doesn't complete
            timer_handle armtimer=SetOneShotTimer(self,"Arm",6.0);

            SetData("Arming",TRUE);
            SetData("ArmTimer",armtimer);
         }
      }
      DefaultOnPhysFellAsleep();
   }
   OnSchemaDone()
   {
      // if done playing arming sound, become live
      // @@TODO: would rather not code this schema name in here,
      // especially when we've gone to all the trouble to use envsound and all.
      if(message.name=="mine_arming")
      {
         boolean arming=GetData("Arming");
         if(arming) Arm();
      }
      DefaultOnSchemaDone();
   }
   OnTimer()
   {
      if(message.name=="Arm")
         Arm();
      DefaultOnTimer();
   }
   OnFrobWorldEnd()
   {
      boolean arming=GetData("Arming");

      SetData("Arming",FALSE);
      Sound.HaltSchema(self);
      if(arming && IsDataSet("ArmTimer"))
      {
         timer_handle armtimer=GetData("ArmTimer");
         KillTimer(armtimer);
         ClearData("ArmTimer");
      }
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(Mine)


// Just like a regular mine, only it turns into a different object when active.
BEGIN_SCRIPT(GasMine, Mine)

METHODS:
   METHOD object ArmType()
   {
      return(object("ActiveGasMine"));
   }
END_SCRIPT(GasMine)



BEGIN_SCRIPT(FlashMine, Mine)
METHODS:
   METHOD object ArmType()
   {
      return(object("ActiveFlashMine"));
   }
END_SCRIPT(FlashMine)

/* When active (armed) the mine detonates in response to collisions,
   or when triggered by associated AR ping.  
*/
BEGIN_SCRIPT(ActiveMine,Physics)

   // What object type am I when I'm disarmed (@@HACK!)
   METHOD object DisarmType()
   {
      return(object("Mine"));
   }

   METHOD void Disarm()
   {
      // @@TODO: Would prefer to determine what we transform into some
      // other way than by overloading this method.
      object newmine=Object.Create(DisarmType());
      vector z=vector(0,0,0);

      Object.Teleport(newmine,z,z,self);

      // unlike Arm, we lose the culpability links here.  It's as if the
      // mine were just laying here.  It won't arm and the player isn't
      // treated anymore as the one who threw it.
      Object.Destroy(self);
   }

MESSAGES:
   OnBeginScript()
   {
      if (!IsDataSet("MineMode"))
        SetData("MineMode",0);
      Physics.SubscribeMsg(self, kFellAsleepMsg);
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self,kCollisionMsg);
      Physics.UnsubscribeMsg(self,kFellAsleepMsg);
      DefaultOnEndScript();
   }
   OnPhysFellAsleep()
   {
      if ((integer)GetData("MineMode")==0) 
      {
         SetData("MineMode",1);
         if(!Object.HasMetaProperty(self,"MineSensePing"))
            Object.AddMetaProperty(self,"MineSensePing");
      }
      DefaultOnPhysFellAsleep();
   }
   OnPhysCollision()
   {
      if ((integer)GetData("MineMode")==1)
      {
         //really, a mine shouldn't trigger itself...  just bad form.
         object WhatHitMe = message.collObj;
         bool   fakeout = FALSE;
         if (Object.Exists(WhatHitMe))
         {
            vector selfvel(0,0,0);
            vector hitmevel(0,0,0);
            if (Physics.HasPhysics(self))
               Physics.GetVelocity(self,selfvel);
            if (Physics.HasPhysics(WhatHitMe))
               Physics.GetVelocity(WhatHitMe,hitmevel);
            float selfmag = selfvel.Magnitude();
            float hitmemag = hitmevel.Magnitude();
            //make sure that I don't trigger myself, and make sure that
            //at least one of us is actually moving and this isn't some 
            //wierd spoof collision...
//            if ((selfvel == vector(0,0,0)) && (hitmevel == vector(0,0,0)))
            //ignore low velocity collisions.
            Debug.MPrint("Active mine collision, selfmag: ",selfmag," and hitmemag: ",hitmemag);
            if ((selfmag < 10) && (hitmemag < 10))
               fakeout = TRUE;
         }
         else
         {
            vector selfvel(0,0,0);
            if (Physics.HasPhysics(self))
               Physics.GetVelocity(self,selfvel);
            float selfmag = selfvel.Magnitude();
            Debug.MPrint("Active mine collision.  Selfmag: ",selfmag);
            if (selfmag < 10)
               fakeout = TRUE;
         }
         if (!fakeout)
            Reply(kPM_Slay);
      }
      DefaultOnPhysCollision();
   }
   OnPickStateChange()
   {
      if (message.currentstate == 7)
      {
         Debug.MPrint("You've set off the mine! ",self," is going to blow.");
         Damage.Slay(self,self);
      }
      if (message.currentstate == 8)
      {
         Debug.MPrint("Mine disarmed.\n");
         Disarm();
      }
      DefaultOnPickStateChange();
   }

END_SCRIPT(ActiveMine);

// Just like a regular mine, only it turns into a different object when active.
BEGIN_SCRIPT(ActiveGasMine, ActiveMine)

METHODS:
   METHOD object DisarmType()
   {
      return(object("GasMine"));
   }
END_SCRIPT(ActiveGasMine)


BEGIN_SCRIPT(ActiveFlashMine, ActiveMine)
METHODS:
   METHOD object DisarmType()
   {
      return(object("FlashMine"));
   }
MESSAGES:
   OnSlain()
   {
      DrkPowerups.TriggerWorldFlash(self);
      DefaultOnSlain();
   }
END_SCRIPT(ActiveFlashMine)


// Script: MossLump
/* When the moss lump falls asleep, create a moss launcher */
BEGIN_SCRIPT(MossLump, Physics)
MESSAGES:

   OnBeginScript()
   {
     if (!IsDataSet("HaveMossed"))
       SetData("HaveMossed",0);
     Physics.SubscribeMsg(self, kFellAsleepMsg);
     DefaultOnBeginScript();
   }

   OnEndScript()
   {
     Physics.UnsubscribeMsg(self, kFellAsleepMsg);
     DefaultOnEndScript();
   }

   // when we come to rest, destroy ourselves and create the launcher
   // Better count on moss lumps only being created as part of the moss
   // arrow firing sequence, since we can't do the Firer-link check we
   // do for mines.
   OnPhysFellAsleep()
   {
      if ((integer)GetData("HaveMossed")==0)
      {
        SetData("HaveMossed",1);
        object launcher=Object.Create("Mosslauncher");
        Object.Teleport(launcher,vector(0,0,0),vector(0,0,0),self);

        // Our own tweq emit property determines what the launcher will
        // launch.  Difference is, we turn its tweq _on_.
        Property.CopyFrom(launcher,"CfgTweqEmit",self);
        Property.CopyFrom(launcher,"StTweqEmit",self);
        ActReact.React("tweq_control",1.0,launcher,0,kTweqTypeEmitter,kTweqDoActivate); 
        Property.Set(self,"PhysType","Remove On Sleep",TRUE);
	Physics.SetVelocity(self,vector(0,0,-2)); //try to resleep me;
	DefaultOnPhysFellAsleep();
      }
   }
  
   OnTimer()
   {
      if (message.name == "ReSleepMe")
	{
          Object.Teleport(self,vector(0,0,0.1),vector(0,0,0),self); //hack to sleep it again.
	}
      DefaultOnTimer();
   }

END_SCRIPT(MossLump)


// Script: MossSpore
/* Spores want to corpify only if they land on a fairly flat surface. */
BEGIN_SCRIPT(MossSpore,Physics)
MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }
   OnPhysCollision()
   {
      vector normal=message.collNormal;
      // Dot product of normal with unit vertical vector
      // is just its compnent in the z direction.  Such
      // normals are unit vectors.
      if(normal.z<0.707) // incline vs. 45 degrees?
      {
         // Don't corpsify; hit wall or ground not level
         Property.Set(self,"SlayResult",kSlayDestroy);         
      }
      Reply(kPM_Slay);
      DefaultOnPhysCollision();
   }
END_SCRIPT(MossSpore)



// Crystals, when frobbed, create the appropriate number of the
// appropriate type of arrow and stuff them in your inventory.
// The number is determined from the StackCount property of the
// crystal itself.  The type of arrow is currently determined by
// a total hack.  I'd write it a bit more elegantly but I expect
// to rip it out shortly anyway.  @@TODO: Change this.  (Har har.
// goes to show you how many of these sorts of things get
// changed, ever.)
BEGIN_SCRIPT(Crystal, RootScript)

METHODS:
   METHOD object ArrowType()
   {
     if(Object.InheritsFrom(self,"EarthCrystal"))
       return object("EarthArrow");
     else if(Object.InheritsFrom(self,"WaterCrystal"))
       return object("water");
     else if(Object.InheritsFrom(self,"FireCrystal"))
       return object("firearr");
     else if(Object.InheritsFrom(self,"AirCrystal"))
       return object("GasArrow");
     else
       return self;
   }
   METHOD void StuffAmmo(object container)
   {
     object newobj=Object.Create(ArrowType());
     integer count=1;

     if(Property.Possessed(self,"StackCount"))
       count=Property.Get(self,"StackCount");
     Property.Set(newobj,"StackCount",count);

     Container.Add(newobj,container);
   } 

MESSAGES:

   OnContained()
   {
      if(message.event!=kContainRemove &&
         object(message.container)==Object.Named("Player"))
      {
         StuffAmmo(message.container);
         Object.Destroy(self);
      }
      DefaultOnContained();
   }
   OnFrobWorldEnd()
   {
      StuffAmmo(message.Frobber);
      // frob property takes care of destroying the crystal.
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(Crystal)


BEGIN_SCRIPT(Sanctifier, RootScript)

METHODS:

   METHOD object GetArrowInInv()
   {
      linkset invent=Link.GetAll("Contains",self);

      for(; invent.AnyLinksLeft(); invent.NextLink())
      {
         object inv_item=invent.Link().To();

         if(Object.InheritsFrom(inv_item,Object.Named("water")))
            return inv_item; 
      }
      return 0; 
   }
   METHOD integer GetTimeLeft()
   {
      return GetData("Ticks"); 
   }
   METHOD void Tick()
   {
      integer ticks = GetTimeLeft(); 
      if (ticks > 0)
      {
         SetOneShotTimer(self,"Defile",1.0);
         //
         // Here's where we format ticks as a string, and set the water
         // arrow object name to it. 
         //

         // This is NOT FAST :)
         object arrow = GetArrowInInv(); 

         // blast the old name
         Property.Remove(arrow,"GameName"); 
         // look it up, so we get the archetypical name
         string name = Data.GetObjString(arrow,"objnames"); 

         // MAHK 9/6.  I'm too cool for string concatenation.  
         // behold my sprintf.  Don't try this at home, designers.  
         // Unless, of course, you really want to. 

         char buf[64]; 
         sprintf(buf,"@@hack: \"%s %d:%02d\"",(const char*)name,ticks/60,ticks%60); 

         Property.Set(arrow,"GameName",buf); 

         ticks --; 
         SetTimeLeft(ticks); 
      }
      else
         Sanctify(FALSE); 
   }


   METHOD void SetTimeLeft(integer ticks)
   {
      SetData("Ticks",ticks); 
   }

   // if sanctify TRUE, turn water arrows into holy water arrows.
   // if false, do the reverse.
   METHOD void Sanctify(boolean sanctify)
   {
      object inv_item = GetArrowInInv();
      object holiness = Object.Named("ArrowIsHoly");

      if(inv_item==object(0)) return;

      if(sanctify)
      {
         if(!Object.HasMetaProperty(inv_item,holiness))
            Object.AddMetaProperty(inv_item,holiness);
         // aaaand, select the water arrows
         Debug.Command("inv_select water");
      }
      else
      {
         Object.RemoveMetaProperty(inv_item,holiness);
         // and revert to archetypal inv name
         Property.Remove(inv_item,"GameName");
      }
   }

MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         SetData("Sanctity",0);
         SetTimeLeft(0);
      } 
      DefaultOnSim();
   }

   OnMessage()
   {
      if(MessageIs("Sanctify"))
      {
         Sanctify(TRUE);
         boolean start = GetTimeLeft() <= 0; 
         SetTimeLeft(30); 
         if (start)
            Tick(); 
      }
      DefaultOnMessage();
   }

   OnTimer()
   {
      if(message.name=="Defile")
         Tick(); 
      DefaultOnTimer();
   }

END_SCRIPT(Sanctifier)


BEGIN_SCRIPT(HolyFont, RootScript)

MESSAGES:
   OnFrobWorldEnd()
   {
      PostMessage(message.Frobber,"Sanctify");
      Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(HolyFont)



BEGIN_SCRIPT(HolyH2O,EatFood)

MESSAGES:

   OnFrobInvEnd()
   {
      linkset invent=Link.GetAll("Contains",message.Frobber);
      boolean haswater=FALSE;

      while(!haswater && invent.AnyLinksLeft())
      {
         if(Object.InheritsFrom(invent.Link().To(),Object.Named("water")))
            haswater=TRUE;
         invent.NextLink();
      }
      if(haswater)
         PostMessage(message.Frobber,"Sanctify");
      else
         Reply(0);
      DefaultOnFrobInvEnd();
   }

END_SCRIPT(HolyH2O)


BEGIN_SCRIPT(AirPotion,EatFood)

MESSAGES:

  OnFrobInvEnd()
  {
     object imbiber=message.Frobber;

     if(Property.Possessed(imbiber,"BreathConfig"))
     {
        integer max=Property.Get(imbiber,"BreathConfig","Max Air (ms)");
        Property.Set(imbiber,"AirSupply",max);
     }
     DefaultOnFrobInvEnd();
  }

END_SCRIPT(AirPotion)


BEGIN_SCRIPT(TimedPotion,EatFood)
METHODS:
  METHOD object Subject()
  {
     if(Link.AnyExist("~ScriptParams",self))
        return(Link.GetOne("~ScriptParams",self).To());
     return NULL;
  }
  METHOD object GetHandler(object imbiber)
  {
     object handler=NULL;
     string ctype="";

     if(Property.Possessed(self,"CombineType"))
        ctype=Property.Get(self,"CombineType");

     if(imbiber!=object(NULL))
     {
        // Not necessarily links to potions, but we'll check link data to verify
        linkset potions=Link.GetAll("ScriptParams",imbiber);

        while(potions.AnyLinksLeft())
        {
           link potlink=potions.Link();
           object pot=potlink.To();
           // Hmm. Questionable.  Detect same sort of potion by checking combine type.
           if(string(potlink.GetData())=="Potion" &&
              Property.Possessed(pot,"CombineType") &&
              ctype==Property.Get(pot,"CombineType"))
              handler=pot;
           
           potions.NextLink();
        }
     }

     if(handler==object(NULL))
     {
        // the handler is a clone of ourselves to gurantee it has the same scripts
        handler=Object.BeginCreate(self);
        link newlink=Link.Create("ScriptParams",imbiber,handler);

        newlink.SetData("Potion");
        Property.Set(handler,"HasRefs",FALSE);
        Object.EndCreate(handler);
        // Debug.MPrint("No handler for potion type matching combine ",ctype,".  Creating handler ",handler);
     }
     //else
     //   Debug.MPrint("Found handler ",handler," for potion matching combine ",ctype);

     return handler;
  }
  METHOD void PotionEffect(object imbiber, boolean start)
  {
     return;
  }
MESSAGES:
  OnBeginScript()
  {
     if(Link.AnyExist("~Contains",self))
     {
        object container=Link.GetOne("~Contains",self).To();
        Debug.MPrint(self," contained by ",container);
        if(Property.Possessed(container,"AI"))
        {
           if(!Object.HasMetaProperty(container,"M-QuaffHeal"))
              Object.AddMetaProperty(container,"M-QuaffHeal");
        }
     }
     DefaultOnBeginScript();
  }
  OnFrobInvEnd()
  {
     PostMessage(GetHandler(message.Frobber),"StartPotion");
     DefaultOnFrobInvEnd();
  }
  OnMessage()
  {
     if(MessageIs("StartPotion"))
     {
        integer timeout=8600; // arbitrary default, compatible with old speed potions
        timer_handle potiontimer;

        // If we're already waiting on a timeout, kill the old one and refresh.
        if(IsDataSet("PotionTimer"))
        {
           // Debug.MPrint(self," resetting pre-existing timer.");
           potiontimer=GetData("PotionTimer");
           KillTimer(potiontimer);
        }
        if(Property.Possessed(self,"ScriptTiming"))
           timeout=Property.Get(self,"ScriptTiming");
        timeout=timeout-1000; // to give time for deactivation sound
        if(timeout<0) timeout=0;

        PotionEffect(Subject(),TRUE);
        // Debug.MPrint(self," setting timer for timeout of ",float(timeout)/1000.0);
        potiontimer=SetOneShotTimer(self,"PreEndPotion",float(timeout)/1000.0);
        SetData("PotionTimer",potiontimer);
     }
     DefaultOnMessage();
  }
  OnTimer()
  {
     // Debug.MPrint(self," got timer message, ",message.name);
     if(message.name=="EndPotion")
     {
        // Debug.MPrint("Got endpotion message.");
        PotionEffect(Subject(),FALSE);
        ClearData("PotionTimer");
        Object.Destroy(self);
     }
     else if(message.name=="PreEndPotion")
     {
        timer_handle potiontimer=SetOneShotTimer(self,"EndPotion",1.0);
        object imbiber=Subject();
        boolean is_player = (imbiber == object("Player")); 
        eEnvSoundLoc loc = is_player ? kEnvSoundAmbient : kEnvSoundAtObjLoc;

        SetData("PotionTimer",potiontimer);
        Sound.PlayEnvSchema(self,"Event Deactivate",self,imbiber,loc);
     }
     DefaultOnTimer();
  }
END_SCRIPT(TimedPotion)


/* Potion's effect is to increase movement speed by 75%.
   Only supported for player-character imbiber.
   */
BEGIN_SCRIPT(SpeedPotion,TimedPotion)
METHODS:
   METHOD void PotionEffect(object imbiber, boolean start)
   {
      if(!Object.InheritsFrom(imbiber,Object.Named("Avatar")))
         return;
      if(start)
         DrkInv.AddSpeedControl("Speedy", 1.75,1.25);
      else
         DrkInv.RemoveSpeedControl("Speedy");
   }
END_SCRIPT(SpeedPotion)


/* Potion's effect is to reduce gravity on the imbiber to 50%.
   Also reduces movement speed by 50%, keeping jump distance about
   the same.  Only supported for player-character imbiber.
   */
BEGIN_SCRIPT(LoGravPotion,TimedPotion)
METHODS:
   METHOD void PotionEffect(object imbiber, boolean start)
   {
      if(!Object.InheritsFrom(imbiber,Object.Named("Avatar")))
         return;
      if(start)
      {
         vector vel;

         // Arrest downward velocity by 50%.  If you'd been at 50%
         // gravity all along, you'd actually only be at 30% less
         // velocity at the same depth (a factory of 1/root(2)).
         // This will then tend to encourage use of the potion in
         // mid-fall, which sounds like fun. -TJS
         Physics.GetVelocity(imbiber,vel);
         if(vel.z<0) vel.z/=2;
         Physics.SetVelocity(imbiber,vel);

         DrkInv.AddSpeedControl("LoGrav",0.5,1.0);
         Physics.SetGravity(imbiber,0.50);
      }
      else
      {
         Physics.SetGravity(imbiber,1.00);
         DrkInv.RemoveSpeedControl("LoGrav");
      }
   }
END_SCRIPT(LoGravPotion)

/* Potion manhandles player's visibility property, and postdates it
   so it doesn't get recalculated from the environment while potion
   is active.  We also add a metaproperty to the player to handle
   script events.  That metaproperty handles some of the actual 
   consequences of visibility and invisibility, since even while under
   an invisibility potion other factors can make the player visible
   (such as holding a flare).
   */
BEGIN_SCRIPT(InvisiPotion, TimedPotion)
METHODS:
   METHOD void PotionEffect(object imbiber, boolean start)
   {
      object invis=object("M-Invisible");
      if(!Object.InheritsFrom(imbiber,Object.Named("Avatar")))
         return;
      if(start)
      {
         // note that this will need to be converted to milliseconds for the property
         float time=GetTime();
         integer timeout=8600;

         if(Property.Possessed(self,"ScriptTiming"))
            timeout=Property.Get(self,"ScriptTiming");

         if(!Object.HasMetaProperty(imbiber,invis))
            Object.AddMetaProperty(imbiber,invis);
         // Postdate the property so as to disable updates
         Property.Set(imbiber,"AI_Visibility","Last update time",
                      integer(time*1000)+timeout);

         // Actually handles the transition in visibility
         SendMessage(imbiber,"Invisible");

         // Note that this is a renderer property.  It thus depends on whether
         // we're under the influence of the potion, not overriding visibility
         // factors such as the flare.
         Property.Set(imbiber,"INVISIBLE",-1);
      }
      else
      {
         float time=GetTime();

         Property.Set(imbiber,"INVISIBLE",0);

         SendMessage(imbiber,"Visible");
         Object.RemoveMetaProperty(imbiber,invis);
         // Just to make sure, enable updates again.
         Property.Set(imbiber,"AI_Visibility","Last update time",
                      integer(time*1000));
      }
   }
END_SCRIPT(InvisiPotion)

/* Script which goes on the player while under the influence of 
   invisibility potion.  Handles potion start and end, and visibility
   start end end due to flare manipulation.
   */
BEGIN_SCRIPT(Invisible,RootScript)
MESSAGES:
   // @@TODO: Handle container messages and such, for evidence.
   OnMessage()
   {
      if(MessageIs("Invisible"))
      {
         linkkind kind("~AIAttack");

         Property.Set(self,"AI_Visibility","Level",0);
         Property.Set(self,"AI_Visibility","Light rating",0);
         Property.Set(self,"AI_Visibility","Movement rating",0);
         Property.Set(self,"AI_Visibility","Exposure rating",0);

         // break all AI attack links explicitly, as per System Shock
         // psi invisibility script.
         if (Link.AnyExist(kind, self))
         {
            linkset myLinks = Link.GetAll(kind, self);
            link currLink = myLinks.Link();
            while (myLinks.AnyLinksLeft())
            {
               currLink = myLinks.Link();
               Link.Destroy(currLink);
               myLinks.NextLink();
            }
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(Invisible)


BEGIN_SCRIPT (Arrow, RootScript)

METHODS:
   METHOD void UnEquipMe()
   {
      Bow.UnEquip();
      DrkInv.RemoveSpeedControl("BowDraw");
   }

MESSAGES:
   OnBeginScript()
   {
      if(!IsDataSet("Selected"))
         SetData("Selected",FALSE);
      DefaultOnBeginScript();
   }
   OnFrobInvBegin()           
   {
      if (message.Abort)
      {
         Bow.AbortAttack();
         DrkInv.RemoveSpeedControl("BowDraw");
      }
      else
      {  
         Bow.StartAttack();
         DrkInv.AddSpeedControl("BowDraw",0.75,1.0);
      }
      DefaultOnFrobInvBegin();
   }
   OnFrobInvEnd()
   {
      BOOL retval = Bow.FinishAttack();
      DrkInv.RemoveSpeedControl("BowDraw");
      Reply(retval);
      DefaultOnFrobInvEnd();
   }

   OnInvSelect()
   {
      SetData("Selected",TRUE);
      Bow.SetArrow(self);
      Bow.Equip();
      DefaultOnInvSelect();
   }

   OnInvDeSelect()
   {
      SetData("Selected",FALSE);
      UnEquipMe();
      DefaultOnInvDeSelect();
   }

   OnDestroy()
   {
      if(boolean(GetData("Selected")))
         UnEquipMe(); 
   }

END_SCRIPT(Arrow)


BEGIN_SCRIPT(LootSounds, RootScript)
MESSAGES:
   OnContained()
   {
      if(message.event!=kContainRemove &&
         object(message.container)==Object.Named("Player") &&
         GetTime()>0.1)
      {
         object schem;

         if(Object.InheritsFrom(self,"IsLoot"))
            schem=Object.Named("pickup_loot");
         else
            schem=Object.Named("pickup_power");

         if(schem!=object(0)) Sound.PlaySchemaAmbient(self,schem);
      }
      DefaultOnContained();
   }
END_SCRIPT(LootSounds)


BEGIN_SCRIPT(OutDamnSpot, RootScript)

MESSAGES:
   OnSlain()
   {
      DrkPowerups.CleanseBlood(self,5.0);
      DefaultOnSlain();
   }

END_SCRIPT(OutDamnSpot)




// Starts the noisemaker schema when the arrow collides.
// Stops it again (if necessary) if it's picked up.
BEGIN_SCRIPT(PlayNoisemaker, Physics)

METHODS:

   METHOD void TurnOffSound()
   {
      Sound.HaltSchema(self);
      ClearData("Playing");
   }

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      TurnOffSound();
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   OnPhysCollision()
   {
      // @@TODO: should probably be an activate envschema on
      // the arrow, but don't know if we can do that and have it
      // still track the arrow...
      if(!IsDataSet("Playing"))
      {
	 object noiseschem = Object.Named("noisemaker");
	 char buf[64];
	 sprintf(buf,"noisemaker%d",self);	
	 Property.Set(noiseschem,"AI_SndType","Signal",(const char*)buf);
         Sound.PlaySchema(self,"noisemaker",self);
         SetData("Playing",NULL);
      }
      DefaultOnPhysCollision();
   }
   OnPhysMadeNonPhysical()
   {
      // either we've been picked up, or come to rest in the world
      // turn off our special emit effect, if any
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeEmitter,kTweqDoHalt);
      DefaultOnPhysMadeNonPhysical();
   }
   OnContainer()
   {
      if(message.containee==self)
         TurnOffSound();
      DefaultOnContainer();
   }

END_SCRIPT(PlayNoisemaker)



/* Script which causes arrows and such to stick in wood.
   The "ScriptTiming" property is used for the chance of
   actually sticking, so not _all_ arrows will stick
   (avoiding the whole pincushion nature of it all).
   */
BEGIN_SCRIPT(CollisionStick, Physics)

METHODS:

   // Considering only the type of surface, can I attach?
   // This is the method you'd override to make distinctions
   // between target surface types, as with the vine arrow.
   METHOD boolean CanAttachToSurface(object targ)
   {
      integer surf=0, me=0;

      if(Property.Possessed(targ,"CanAttach"))
         surf=Property.Get(targ,"CanAttach");
      if(Property.Possessed(self,"CanAttach"))
         me=Property.Get(self,"CanAttach");

      return(boolean(me&surf));
   }

   METHOD boolean CanAttachTo(object targ)
   {
      if(targ==object(0)) return FALSE;
      if(!CanAttachToSurface(targ)) return FALSE;
      if(Object.InheritsFrom(targ,"Texture"))
         return TRUE;
      // Objects which are not textures ought to be
      // immobile, or we can't attach.
      if(!Property.Possessed(targ,"Immobile") ||
         !boolean(Property.Get(targ,"Immobile")))
         return FALSE;
      // Even if "immobile", the object might be a door
      // set to "immobile" because we'd like it to block
      // lights.  So, check for doors explicitly.
      if(Property.Possessed(targ,"RotDoor") ||
         Property.Possessed(targ,"TransDoor") ||
         Property.Possessed(targ,"MovingTerrain"))
         return FALSE;
      return TRUE;
   }

   METHOD real LifeSpan()
   {
      // by default, don't time out
      real limit=-1.0;
      if(Property.Possessed(self,"ScriptTiming"))
         limit=Property.Get(self,"ScriptTiming");
      // Anything shot by the player lasts much longer
      if(Link.AnyExist("CulpableFor",Object.Named("Player"),self))
         limit*=5.0;
      return limit;
   }

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }
   OnPhysCollision()
   {
      object WhatIHit=message.collObj;
      boolean attach=CanAttachTo(WhatIHit);

      if(attach)
      {
         real limit=LifeSpan();
         if(limit>0.0)
         {
            timer_handle timeout=SetOneShotTimer(self,"Tick",limit);
            SetData("timeout",timeout);
         }
         if(!Property.Possessed(self,"StackCount"))
         {
            Property.Add(self,"StackCount");
            Property.Set(self,"StackCount",1);
         }
      }
      Reply(attach?kPM_NonPhys:kPM_Slay);
   }
   OnTimer()
   {
      if(message.name=="Tick")
      {
         if(!Object.RenderedThisFrame(self))
         {
            Object.Destroy(self);
         }
         else
         {
            timer_handle new_timeout;
            new_timeout=SetOneShotTimer(self,"Tick",10.0);
            SetData("timeout",new_timeout);
         }
      }
      DefaultOnTimer();
   }
   OnContained()
   {
      if(message.event==kContainAdd && IsDataSet("timeout"))
      {
         timer_handle timeout=GetData("timeout");
         KillTimer(timeout);
         ClearData("timeout");
      }
      DefaultOnContained();
   }
END_SCRIPT(CollisionStick)

// script for rope arrows, to be used _in addition to_ the usual "Arrow" script.
// this script is only responsible for the rope-deploying behavior.
BEGIN_SCRIPT(DeployRope, CollisionStick)
METHODS:
   METHOD object ProduceRope()
   {
      return(Object.BeginCreate("RopeArrowRope"));
   }
   METHOD object ProduceJoint()
   {
      return(object(0));
   }
             
MESSAGES:

   OnPhysCollision()
   {
      object WhatIHit=message.collObj;

      if(CanAttachTo(WhatIHit))
      {
         object MyRope=ProduceRope();

         Link.Create("Owns",self,MyRope);
         Object.Teleport(MyRope,vector(-1.0,0,0),vector(0,0,0),self);

         Property.Set(MyRope,"SuspObj","Is Suspicious",TRUE);
         //don't set type.	 
         Property.Set(MyRope,"SuspObj","Minimum Light Level",0.15);

         Object.EndCreate(MyRope);
         
         object Joint=ProduceJoint();

         if(Joint!=object(0))
         {
            Link.Create("Owns",self,Joint);
            Object.Teleport(Joint,vector(-0.33,0,0),vector(0,0,0),self);
            Object.EndCreate(Joint);
         }
      }
      DefaultOnPhysCollision();
   }
   OnFrobWorldEnd()
   {
      // if rope arrow is picked up, destroy the rope it deployed
      // (also vine clump for vine arrows)
      if(Link.AnyExist("Owns",self))
      {
         linkset ownlinks=Link.GetAll("Owns",self);
         while(ownlinks.AnyLinksLeft())
         {
            object attachment=ownlinks.Link().To();
            Damage.Slay(attachment,self);
            ownlinks.NextLink();
         }
      }
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(DeployRope)


// Different script for vine arrow is kinda dumb, but expedient.
BEGIN_SCRIPT(DeployVine, DeployRope)
METHODS:
   METHOD object ProduceRope()
   {
      return(Object.BeginCreate("VineArrowVine"));
   }
   METHOD object ProduceJoint()
   {
      object clumparch=object("VineClump");
      if(Object.Exists(clumparch))
      {
         return(Object.BeginCreate(clumparch));
      }
      return object(0);
   }
END_SCRIPT(DeployVine)


BEGIN_SCRIPT(RopeFX, RootScript)

MESSAGES:
   OnFrobWorldEnd()
   {
      // if rope is frobbed, stuff arrow into frobber's inventory
      // (rope is slain here instead of destroyed by virtue of its
      // frob properties so as to get the OnSlain SFX below.)
      if(Link.AnyExist("~Owns",self))
      {
         object arrow=Link.GetOne("~Owns",self).To();
         Container.Add(arrow,message.Frobber);
         Damage.Slay(self,message.Frobber);
      }
      DefaultOnFrobWorldEnd();
   }
   OnSlain()
   {
      object FX;
      integer len=0, particles=0;
      vector lenvec=vector(0,0,0);

      // hack
      if(Property.Possessed(self,"ModelName") &&
         string(Property.Get(self,"ModelName"))=="ropevine")
         FX=Object.BeginCreate("ExVine");
      else
         FX=Object.BeginCreate("ExRope");

      if(Property.Possessed(self,"PhysRope"))
         len=Property.Get(self,"PhysRope","Length");
      else
         Debug.MPrint("Dang!  No rope anymore already.");

      // Treat #particles on archetype as #particles per foot
      if(Property.Possessed(FX,"ParticleGroup"))
         particles=Property.Get(FX,"ParticleGroup","number of particles");      

      lenvec.z=-len;

      Property.Set(FX,"ParticleGroup","number of particles",particles*len);

      Property.Set(FX,"PGLaunchInfo","Box Min",lenvec);
      Object.EndCreate(FX);
      Object.Teleport(FX,Object.Position(self),vector(0,0,0));
      DefaultOnSlain();
   }
END_SCRIPT(RopeFX)

BEGIN_SCRIPT (Sword, RootScript)

MESSAGES:
   OnFrobInvBegin()           
   {
      if (message.Abort)
         Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      else
         Weapon.StartAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobInvBegin();
   }

   OnFrobInvEnd()
   {
      Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobInvEnd();
   }

   // Note: without FrobTool message handlers, the sword
   // won't swing if you have a tool target selected, because
   // that's a tool frob.  It must treat tool frobs just like
   // inv frobs.
   OnFrobToolBegin()           
   {
      Weapon.StartAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobToolBegin();
   }
   OnFrobToolEnd()
   {
      Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobToolEnd();
   }

   OnInvSelect()
   {
      Weapon.Equip(self,kDWT_Sword);
      DrkInv.AddSpeedControl("SwordEquip", 0.75,0.8);
      DefaultOnInvSelect();
   }

   OnInvDeSelect()
   {
      Weapon.UnEquip(self);
      DrkInv.RemoveSpeedControl("SwordEquip");
      DefaultOnInvDeSelect();
   }

END_SCRIPT(Sword)

BEGIN_SCRIPT (BlackJack, RootScript)

MESSAGES:
   OnFrobInvBegin()           
   {  
      if (message.Abort)
         Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      else
         Weapon.StartAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobInvBegin();
   }

   OnFrobInvEnd()
   {
      Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobInvEnd();
   }

   // Note: without FrobTool message handlers, the sword
   // won't swing if you have a tool target selected, because
   // that's a tool frob.  It must treat tool frobs just like
   // inv frobs.
   OnFrobToolBegin()           
   {
      Weapon.StartAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobToolBegin();
   }
   OnFrobToolEnd()
   {
      Weapon.FinishAttack(message.Frobber, message.SrcObjId);
      DefaultOnFrobToolEnd();
   }

   OnInvSelect()
   {
      Weapon.Equip(self,kDWT_BlackJack);
      DefaultOnInvSelect();
   }

   OnInvDeSelect()
   {
      Weapon.UnEquip(self);
      DefaultOnInvDeSelect();
   }

END_SCRIPT(BlackJack)

BEGIN_SCRIPT(AttackActivate, Attack)

METHODS:
   METHOD integer GetWeap()
   {
      if(!IsDataSet("weapon"))
         return 0;
      else
         return GetData("weapon");
   }
   METHOD void SetWeap(integer weap)
   {
      integer weapset;
      // set weapon data only if not already set, or if somehow set to a
      // positive value which for some reason is not a valid object.
      if(!IsDataSet("weapon") ||
         ((weapset=GetData("weapon"))>0 && !Object.Exists(weapset)))
         SetData("weapon",weap);
   }

MESSAGES:

   // if no weapon, must be ranged, so send message to self
   // otherwise send messages to the weapon

   OnStartWindup()
   {
      // Debug.MPrint(self," StartWindup weapon ",message.weapon);
      integer weapon;
      SetWeap(message.weapon);
      weapon=GetWeap();
      if (weapon<=0)
         Link.BroadcastOnAllLinks(self,"TurnOn","~ParticleAttachement");
      else
         SendMessage(weapon, "TurnOn");
   }

   OnStartAttack()
   {
      // Debug.MPrint(self," StartAttack weapon ",message.weapon);
      integer weapon;
      SetWeap(message.weapon);
      weapon=GetWeap();
      if (weapon<=0)
         Link.BroadcastOnAllLinks(self,"TurnOn","~ParticleAttachement");
      else
         SendMessage(weapon, "TurnOn");
   }

   OnEndAttack()
   {
      integer weapon=GetWeap();
      // Debug.MPrint(self," EndAttack weapon ",message.weapon);
      if (weapon<=0)
         Link.BroadcastOnAllLinks(self,"TurnOff","~ParticleAttachement");
      else
         SendMessage(weapon, "TurnOff");
   }

   // @@TODO: Should also turn off when AI mode goes to dead, to handle KO's
   OnSlain()
   {
      integer weapon=GetWeap();
      // Debug.MPrint(self," EndAttack weapon ",message.weapon);
      if (weapon<=0)
         Link.BroadcastOnAllLinks(self,"TurnOff","~ParticleAttachement");
      else
         SendMessage(weapon, "TurnOff");
      
      DefaultOnSlain();
   }

   OnMessage()
   {
      if (MessageIs("AbortAttack"))
      {
         integer weapon=GetWeap();

         if (weapon<=0)
            Link.BroadcastOnAllLinks(self,"TurnOff","~ParticleAttachement");
         else
            SendMessage(weapon, "TurnOff");
      }      
      DefaultOnMessage();
   }

END_SCRIPT(AttackActivate)

BEGIN_SCRIPT(StickyWebs, Physics)

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }
   OnPhysCollision()
   {
      object WhatIHit=message.collObj;

      if(WhatIHit==Object.Named("Player"))
      {
         object new_obj=Object.Create("JunkWebs");
         Container.Add(new_obj,WhatIHit);
      }
      // @@TODO: Else, would like to at least stun the victim
      Reply(kPM_Slay);
   }

END_SCRIPT(StickyWebs)


BEGIN_SCRIPT(JunkWebs, RootScript)

METHODS:
   // movement speed allowable when webbed depends on stack count.
   METHOD float MoveFromStackCount()
   {
      integer count;
      float moveratio=1.0;
      const float BEST_MOVE_WEBBED=0.8;
      const float WEBS_TO_STICK=20.0;

      if(!Property.Possessed(self,"StackCount"))
         return 0.0;
      count=Property.Get(self,"StackCount");
      moveratio=BEST_MOVE_WEBBED*(1.0-float(count)/WEBS_TO_STICK);
      return((moveratio<0.0)?0.0:moveratio);
   }      

MESSAGES:
   OnFrobInvEnd()
   {
      float moveratio=MoveFromStackCount();
      if(Property.Possessed(self,"StackCount") &&
         integer(Property.Get(self,"StackCount"))>1)
      {
         Object.AddMetaProperty(self,"FrobInert");
         SetOneShotTimer(self,"CanFrob",0.5);
         DrkInv.AddSpeedControl("Webs", moveratio,moveratio);
      }
      else
      {
         DrkInv.RemoveSpeedControl("Webs");
      }
      DefaultOnFrobInvEnd();
   }
   OnTimer()
   {
      if(message.name=="CanFrob")
      {
         Object.RemoveMetaProperty(self,"FrobInert");
      }
      DefaultOnTimer();
   }
   OnContained()
   {
      if(message.event!=kContainRemove &&
         object(message.container)==Object.Named("Player"))
      {
         float moveratio=MoveFromStackCount();

         DrkInv.AddSpeedControl("Webs", moveratio,moveratio);
      }
      DefaultOnContained();
   }

END_SCRIPT(JunkWebs)


// Lockpick script handles setting the player hand art and
// starting and stopping the pick attempt.
BEGIN_SCRIPT(LockPick, RootScript)

MESSAGES:

   OnInvSelect()
   {
      PickLock.Ready("Player",self);
      DefaultOnInvSelect();
   }

   OnInvDeSelect()
   {
      PickLock.FinishPicking(self);
      PickLock.UnReady("Player",self);
      DefaultOnInvDeSelect();
   }

   OnFrobToolBegin()
   {
      if (message.Abort)
         PickLock.FinishPicking(message.SrcObjId);  
      else
         PickLock.StartPicking(message.Frobber,message.SrcObjId,message.DstObjId);
      DefaultOnFrobToolBegin();
   }

   OnFrobToolEnd()
   {
      PickLock.FinishPicking(message.SrcObjId);
      DefaultOnFrobToolEnd();
   }

END_SCRIPT(LockPick)



/* Can't believe we didn't have this already.  Object just makes a sound
   when frobbed.
   */
BEGIN_SCRIPT(FrobSounds, RootScript)
   OnFrobWorldEnd()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(FrobSounds)

/* Using a flare (unlit) in your inventory causes it to produce a lit
   flare (a new junk object, separate from your stack of unlit flares)
   */
BEGIN_SCRIPT(LightFlare, RootScript)
MESSAGES:
   OnFrobInvEnd()
   {
      object litflare=Object.Create("LitFlare");
      Link.Create("Contains",message.Frobber,litflare);
      DefaultOnFrobInvEnd();
   }
END_SCRIPT(LightFlare)

/* Flares need to make their bearer a dynamic light when in inventory.
   This behavior relies on the assumption no creature who could have the
   flare would _ordinarily_ be a dynamic light.  It takes the liberty
   of adding and removing the relevant property, which has to be
   instantiated for what one presumes are performance reasons.
   It also relies on the flare being junk to guarantee that only one
   flare can be in inventory at a time.
*/
BEGIN_SCRIPT(IllumeBearer, RootScript)

METHODS:
   METHOD void Illume(boolean on, object container)
   {
      /* Add or remove properties on my bearer, as appropriate */
      if(!on)
      {
         Property.Remove(container,"SelfLit");
         Property.Remove(container,"LightColor");

         // Note that this only gets handled if bearer is under influence
         // of invisibility potion.
         SendMessage(container,"Invisible");
      }
      else
      {
         if(Property.Possessed(self,"SelfLit"))
         {
            integer light=Property.Get(self,"SelfLit");

            Property.CopyFrom(container,"SelfLit",self);
            if(Property.Possessed(self,"LightColor"))
               Property.CopyFrom(container,"LightColor",self);

            // Invisible bearer needs new visibility property values.
            if(Object.HasMetaProperty(container,"M-Invisible"))
            {
               Property.Set(container,"AI_Visibility","Level",light);
               Property.Set(container,"AI_Visibility","Light rating",light);
               SendMessage(container,"Visible");
            }
         }
      }  
   }

MESSAGES:
   OnContained()
   {
      Illume(message.event!=kContainRemove,message.container);
      DefaultOnContained();
   }
   OnSlain()
   {
      if(Link.AnyExist("~Contains",self))
      {
         object container=Link.GetOne("~Contains",self).To();
         Illume(FALSE,container);
      }
      DefaultOnSlain();
   }
END_SCRIPT(IllumeBearer)


/* CONTAINER
   This is a container which yields its contents into the frobber's
   inventory when frobbed.  Containers may want to do additional
   things when frobbed (like a chest whose lid swings open)
   but that isn't being dealt with here.
   */
BEGIN_SCRIPT(Container, RootScript)

METHODS:

   METHOD void ContainerReport(integer WarnLevel)
   {
      integer contcount=0;
      linkset contents=Link.GetAll("Contains",self);

      while(contents.AnyLinksLeft())
      {
         if(WarnLevel<2)
         {
            Debug.MPrint("Container ",self,"->",contents.Link().To());
         }
         contcount++;
         contents.NextLink();
      }
      if(WarnLevel>=2 && contcount>1)
      {
         Debug.MPrint("Container ",self," contains ",contcount,">1 items.");
      }
      // @@TODO: Report on containers with nonzero joint positions (except for lock joint, if any)
      // and more than zero contents.
   }      

MESSAGES:
   OnTweqComplete()
   {
      if(message.Type!=kTweqTypeLock)
      {
         // for purposes of generating sound effects, treat the container lid
         // as semantically equivalent to a door.  Reinterpret tweq actions
         // appropriately.

         // halt previous sound effect, if any
         Sound.HaltSchema(self);

         // not the lock; must be the lid
         if(message.Dir==kTweqDirForward)
         {
            // finished opening
            Sound.PlayEnvSchema(self,"Event StateChange, OpenState Open, OldOpenState Opening",self,NULL,kEnvSoundAtObjLoc);
         }
         else
            Sound.PlayEnvSchema(self,"Event StateChange, OpenState Closed, OldOpenState Closing",self,NULL,kEnvSoundAtObjLoc);
      }
   }
   OnFrobWorldEnd()
   {
      boolean playerfrob=(object(message.Frobber)==object("Player"));
      boolean locked=Locked.IsLocked(self);
      
      if(playerfrob && DarkGame.ConfigIsDefined("LockCheat"))
         locked=FALSE;

      if(locked)
      {
         Sound.PlayEnvSchema(self,"Event Reject, Operation OpenDoor",self,NULL,kEnvSoundAtObjLoc);
      }
      else
      {
         boolean wasmoving=FALSE;

         // trigger any effects of searching container
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);

         if(Property.Possessed(self,"StTweqJoints"))
         {
            wasmoving=(Property.Get(self,"StTweqJoints","AnimS")&TWEQ_AS_ONOFF);
         }

         // Animate tweqjoints for container opening/closing, if any.
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoActivate);

         // Sound effect for lid.  We know after .React call that our tweq ought to
         // be in motion, so which direction is it going?  Forward is opening.
         if(Property.Possessed(self,"StTweqJoints"))
         {
            // halt whatever schema we might previously have been playing
            Sound.HaltSchema(self);

            if(Property.Get(self,"StTweqJoints","AnimS")&TWEQ_AS_REVERSE)
            {
               // closing
               if(!wasmoving)
                  Sound.PlayEnvSchema(self,"Event StateChange, OpenState Closing, OldOpenState Open",self,NULL,kEnvSoundAtObjLoc);
               else
                  Sound.PlayEnvSchema(self,"Event StateChange, OpenState Closing, OldOpenState Opening",self,NULL,kEnvSoundAtObjLoc);
            }
            else
               // opening
               if(!wasmoving)
                  Sound.PlayEnvSchema(self,"Event StateChange, OpenState Opening, OldOpenState Closed",self,NULL,kEnvSoundAtObjLoc);
               else
                  Sound.PlayEnvSchema(self,"Event StateChange, OpenState Opening, OldOpenState Closing",self,NULL,kEnvSoundAtObjLoc);
         }

         // note that we make no effort to ensure that contents are only delivered when
         // container tweqs _open_.
         // we assume this is okay because there's no way to put anything _into_ 
         // a container, and we assume that nobody will set up an open-jointed
         // container with stuff in it.
         Container.MoveAllContents(self,message.Frobber);
      }
   }
   OnReportMessage()
   {
      ContainerReport(message.WarnLevel);
      DefaultOnReportMessage();
   }
   
END_SCRIPT(Container)   



// Script: LoadoutBox
// For collections of objects which appear as aggregates in the loadout screen.
// The loadout object is a container which automatically dumps its contents
// to _its_ container upon sim start.

BEGIN_SCRIPT (LoadoutBox, RootScript)

METHODS:
   METHOD object Beneficiary()
   {
      if(Link.AnyExist("~Contains",self))
         return Link.GetOne("~Contains",self).To();
      return object(0);
   }
   // Overload if you want to apply further criterea to which objects
   // should be bestowed.
   METHOD boolean Clear(object obj)
   {
      return TRUE;
   }
   METHOD void CleanUp()
   {
      Object.Destroy(self);
   }
   METHOD void Unload()
   {
      object MyContainer=Beneficiary();
      linkset MyContents=Link.GetAll("Contains",self);
      
      if(MyContainer==object(0))
         return;

      if(Link.AnyExist("Contains",self))
      {
         linkset MyContents=Link.GetAll("Contains",self);
         
         while(MyContents.AnyLinksLeft())
         {
            object Goodies=MyContents.Link().To();
            
            Container.Remove(Goodies);
            Container.Add(Goodies,MyContainer);

            Debug.MPrint(self," adding ",Goodies," to ",MyContainer);

            Clear(Goodies);

            MyContents.NextLink();
         }
      }
      CleanUp();
   }
MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         Unload();
      }
      DefaultOnSim();
   }

END_SCRIPT (LoadoutBox)

// Script: LoadoutCache
// For objects which don't want to appear as in the loadout screen, but
// nevertheless start in the player's inventory.  Put them in a container
// with this script.
BEGIN_SCRIPT(LoadoutCache, LoadoutBox)
METHODS:
   METHOD object Beneficiary()
   {
      object retval=Base::Beneficiary();

      if(retval==object(0))
         retval=Object.Named("Player");
      if(retval==object(0))
      {
         // No player?  What about a player factory?
         object playarch=Object.Named("Garrett");
         if(playarch==object(0)) return retval; // No good

         if(Link.AnyExist("~PlayerFactory",playarch))
            retval=Link.GetOne("~PlayerFactory",playarch).To();
      }
      return retval;
   }
END_SCRIPT(LoadoutCache)



// script for particle groups, so they can respond to
// state changes in their associated object, which will
// send messages notifying the group.
BEGIN_SCRIPT(StdParticleGroup, RootScript)

   // @@TODO: If group is of motion type "attached to object,"
   // but is lacking an attechement (sic) link, then complain
   // in report function.  This functionality should probably
   // be the particle module's responsibility, not scripts'.

MESSAGES:

   OnMessage()
   {
      if(MessageIs("Die"))
      {
         Object.Destroy(self);
      }
      else if(MessageIs("TurnOn"))
      {
         PGroup.SetActive(self, TRUE);
      }
      else if(MessageIs("TurnOff"))
      {
         PGroup.SetActive(self, FALSE);
      }
      DefaultOnMessage();
   }

END_SCRIPT(StdParticleGroup)




BEGIN_SCRIPT(FlashBomb, Physics)

METHODS:

MESSAGES:

   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }

   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      //      Debug.MPrint("unsubscribe for ", self, " ", message.message);
      DefaultOnEndScript();
   }

   OnPhysCollision()
   {
      DrkPowerups.TriggerWorldFlash(self);
      Reply(kPM_Slay);
   }

END_SCRIPT(FlashBomb)

/* For use in test levels without a full victory conditions script,
   so Garrett will get the appropriate difficulty metaprops.
   */
BEGIN_SCRIPT(DiffSpoof, RootScript)
MESSAGES:
   OnBeginScript()
   {
      if(!Object.InheritsFrom(self,Object.Named("M-GarrettDiffSettings")))
      {
         // For non-existent or invalid difficulty quest var, treat as Normal.
         // This will result naturally from quest var default to 0.
         integer diff=Quest.Get("difficulty");
         object diffsettings=Object.Named("M-GarrettDiffNormal");

         if(diff==1)
            diffsettings=Object.Named("M-GarrettDiffHard");
         else if(diff==2)
            diffsettings=Object.Named("M-GarrettDiffExpert");
         Object.AddMetaProperty(self,diffsettings);

         Property.Add(self,"AirSupply");
      }
   }
END_SCRIPT(DiffSpoof)


BEGIN_SCRIPT(JAccuse, RootScript)

   OnSlain()
   {
      object slayer=message.culprit;
      object player=Object.Named("Player");
      boolean accuse=FALSE;

      Debug.MPrint(self," dying.  Culprit is ",slayer);

      /* First off, if the player is culpable for me, then he has carried
         my carcass somewhere, in this case clearly somewhere that turned
         out to be dangerous.  So, this clause allows us to blame you for
         dropping unconscious guys in water or lava or off cliffs and such.
         */
      if(Link.AnyExist("CulpableFor",player,self))
         accuse=TRUE;

      /* Okay, the "culprit" of the slaying is pretty literal,
         e.g. the actual sword, arrow, or whatever that did the damage.
         To hold the player responsible, the object might be Weapon
         or Firer linked to him.
      */
      if(slayer==player ||
         (slayer!=object(0) && Link.AnyExist("CulpableFor",player,slayer)))
         accuse=TRUE;

      if(accuse)
      {
         // Debug.MPrint(self," accusing the player of killing it.");
         PostMessage(player,"J'Accuse");
      }

      DefaultOnSlain();
   }

END_SCRIPT(JAccuse)



/* LUGGED
   For any especially heavy-seeming object (e.g. corpses, boulders).
   When the player picks such a thing up, there's a sound effect and
   he is slowed.
   */
BEGIN_SCRIPT(Lugged, RootScript)
   OnContained()
   {
      if(Object.InheritsFrom(message.container,"Avatar"))
      {
         if(message.event==kContainAdd)
         {
            Sound.PlaySchemaAmbient(self,"garlift");
            DrkInv.AddSpeedControl("CorpseCarry", 0.6,0.9);
         }
         else if(message.event==kContainRemove)
         {
            Sound.PlaySchemaAmbient(self,"gardrop");
            DrkInv.RemoveSpeedControl("CorpseCarry");
         }
      }
      DefaultOnContained();
   }

END_SCRIPT(Lugged)


/* Hidden object with this script on it counts as found when slain.
   Intended primarily for banners, which are marked hidden to indicate
   that there is something hidden _behind_ them.
   */
BEGIN_SCRIPT(SlayFind, RootScript)
MESSAGES:
   OnSlain()
   {
      DarkGame.FoundObject(self);
      DefaultOnSlain();
   }
END_SCRIPT(SlayFind)


/* Hidden object with this script on it counts as found when frobbed.
   Intended primarily for inventory objects.  Note this doesn't work
   if the object is in a container, but it's not clear how it could
   be meaningfully considered "hidden" in that case anyway.
   */
BEGIN_SCRIPT(FrobFind, RootScript)
MESSAGES:
   OnFrobWorldEnd()
   {
      DarkGame.FoundObject(self);
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(FrobFind)


/* Maintains A/R script contact with object when in physics contact */
BEGIN_SCRIPT(PhysARContact, Physics)
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kContactMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kContactMsg);
      DefaultOnEndScript();
   }
   OnPhysContactCreate()
   {
      // Just in case we get multiples of this message, we don't
      // want to in any sense have more than one A/R contact...
      ActReact.EndContact(self,message.contactObj);
      ActReact.BeginContact(self,message.contactObj);
      DefaultOnPhysContactCreate();
   }
   OnPhysContactDestroy()
   {
      ActReact.EndContact(self,message.contactObj);
      DefaultOnPhysContactDestroy();
   }

END_SCRIPT(PhysARContact)


// Script:              LastMissionsLoot

// Stuffs the loot value of this object with the value in the
// total_loot quest var (last mission's loot total, normally)
// before the loadout where that value gets zorched.

// Useful here for several missions with no store (Ambush, Blood, Kidnap)

BEGIN_SCRIPT(LastMissionLoot, RootScript)
MESSAGES:
// This happens before loadout, so is a convenient place to hook this.
// We don't actually care what difficulty level we're on.
OnDifficulty()
{
   integer loot=Quest.Get("total_loot");

   Debug.MPrint("Total loot ",loot);

   if(loot==0)
   {
      Object.Destroy(self);
   }
   else
   {
      Property.Set(self,"Loot","Gold",loot);
      Property.Set(self,"Loot","Gems",0);
      Property.Set(self,"Loot","Art",0);
      DefaultOnDifficulty();
   }
}

END_SCRIPT(LastMissionLoot)

BEGIN_SCRIPT(SecretSounds, RootScript)


METHODS:
  
  METHOD void FoundASecret()
  {
     if ((DarkGame.BindingGetFloat("goal_notify")!=0.0))
     {
        object schem=Object.Named("new_obj");
        string popup=Data.GetString("PlayHint.str","FoundSecret");
        if (popup!="") 
           DarkUI.TextMessage(popup);
        if (schem!=object(NULL)) 
           Sound.PlaySchemaAmbient(self,schem); 
     }
  }


MESSAGES:

  OnBeginScript()
  {
     if (!IsDataSet("PopTimer"))
        SetData("PopTimer",0);
     Quest.SubscribeMsg(self,kDarkStatSecrets);
     if (!IsDataSet("SecretsFound"))
        SetData("SecretsFound",Quest.Get(kDarkStatSecrets));
     DefaultOnBeginScript();
  }
  
  OnEndScript()
  {
     Quest.UnsubscribeMsg(self,kDarkStatSecrets);
     DefaultOnEndScript();
  }

  OnMessage()
  {
     if (MessageIs("Popup"))
     {
        SetData("PopTimer",1);
        SetOneShotTimer(self,"poptiming",3.0);
     }
     DefaultOnMessage();
  }

  OnTimer()
  {
     if (message.name == "poptiming")
     {
        SetData("PopTimer",0);
     }
     if (message.name == "DoSecret")
     {
        if ((integer)GetData("PopTimer")==0)
           FoundASecret();
        //else give up
     }
     DefaultOnTimer();
  }

  OnQuestChange()
  {
     if (stricmp(message.m_pName,kDarkStatSecrets)==0) //make sure was secrets
        if (Quest.Get(kDarkStatSecrets)>(integer)GetData("SecretsFound"))
        {
           if ((integer)GetData("PopTimer")==0)
              SetOneShotTimer("DoSecret",0.2); 
           else
              SetOneShotTimer("DoSecret",3.0);
           SetData("SecretsFound",Quest.Get(kDarkStatSecrets));
        }
     DefaultOnQuestChange();
  }

END_SCRIPT(SecretSounds)


BEGIN_SCRIPT(PlayerCheatScript, RootScript)

METHODS:

   METHOD void Catch(string whatdata)
   {
      if ((integer)GetData(whatdata)==0)
         return;
      Debug.MPrint(self," is Garrett, getting caught");
      integer i;
      for (i=0;i<20;i++)
      {
         if (Quest.Get(GoalVisibleVarName(i)))
            Quest.Set(GoalStateVarName(i),kGoalFailed);
      }
   }

MESSAGES:
  
   OnBeginScript()
   {
      if (!IsDataSet("FailOnKill"))
      {
         if (DarkGame.ConfigIsDefined("FailOnKill"))
            SetData("FailOnKill",1);
         else
            SetData("FailOnKill",0);       
         if ((integer)GetData("FailOnKill")==1)
            Debug.MPrint("Garrett(",self,") should not kill.\n");
      }
      DefaultOnBeginScript();
   }

   OnMessage()
   {
      if (MessageIs("J'Accuse"))
         Catch("FailOnKill");
      DefaultOnMessage();
   }

END_SCRIPT(PlayerCheatScript)



@


1.75
log
@PlayerCheatScript
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.74 1970/01/01 00:00:00 adurant Exp $
d126 2
d132 2
a133 1
         Quest.Set("map_max_page",newmax);
@


1.74
log
@ActiveMines now require that at least one participant in the collision
have a velocity magnitude >=10.  This helps prevent mines from chain
reacting quite so easily.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.73 1970/01/01 00:00:00 adurant Exp $
d3077 45
@


1.73
log
@camera stuff
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.72 1970/01/01 00:00:00 adurant Exp $
d1083 2
d1088 4
a1091 1
            if ((selfvel == vector(0,0,0)) && (hitmevel == vector(0,0,0)))
d1093 11
a1103 1
         } 
@


1.72
log
@AttackActivate listens to AbortAttack message (sent in ai.scr from
CleanUpAttack)
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.71 1970/01/01 00:00:00 adurant Exp $
d802 7
d847 2
a848 1
       Activate();
d857 1
a857 1
        SetData("Amcontained",1);
@


1.71
log
@Camera grenades that are part of a stack (and not the last one) now work
properly when thrown against doors
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.70 1970/01/01 00:00:00 adurant Exp $
d2292 14
a2306 1

@


1.70
log
@secrets and objectives get along better
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.69 1970/01/01 00:00:00 adurant Exp $
d792 2
a793 2
	vector myvel;
        Physics.GetVelocity(self,myvel);
d825 4
d851 1
a851 1
         object(message.container)==Object.Named("Player"))
@


1.69
log
@SecretSounds
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.68 1970/01/01 00:00:00 adurant Exp $
d2983 2
d2997 25
d3027 4
a3030 1
           FoundASecret(); 
@


1.68
log
@set ropes to 0.15 min susp light level
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.67 1970/01/01 00:00:00 TJS Exp $
d17 1
d2959 49
@


1.67
log
@Added vine arrow vine clump effect.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.66 1970/01/01 00:00:00 TJS Exp $
d2016 1
@


1.66
log
@Added LastMissionLoot from Thief 1.
@
text
@d1 2
a2 2
////////////////////////////////////////////////////////////////////////////
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.65 1970/01/01 00:00:00 adurant Exp $
d1996 4
d2014 2
a2015 2
	 Property.Set(MyRope,"SuspObj","Is Suspicious",TRUE);
	 //don't set type.	 
d2018 9
d2033 1
d2036 7
a2042 2
         object rope=Link.GetOne("Owns",self).To();
         Damage.Slay(rope,self);
d2056 9
@


1.65
log
@fixed subscription bug in mines.  my fault originally.
now they subscribe unsubscribe correctly
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.64 1970/01/01 00:00:00 TJS Exp $
d2895 34
@


1.64
log
@Stop particles in AttackActivate in OnSlain handler.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.63 1970/01/01 00:00:00 adurant Exp $
d1033 2
a1034 6
      //so now we wait for the active mine to first come to rest... THEN
      //we subscribe to collision.  The only case I can think of where
      //this could be a problem is if the mine comes to rest initially
      //(and therefore starts activating), then starts falling while
      //activating, the mine won't explode when it hits the ground, it
      //will just sit there and be active.  But that seems ok.
d1036 1
a1036 1
//      Physics.SubscribeMsg(self, kCollisionMsg);
d1041 2
a1042 9
      //possible to endscript without having subscribed to these... so we
      //are trying to unsubscribe when not subscribed.  But that's just a 
      //warning, and can't tell how to check subscription.  AMSD<-the guy
      //to blame here. :)
      //since it's highly unlikely that we will NOT have fallen asleep by end
      //script...  it might be better to not bother unsubscribing to 
      //fall asleep.  But leaving a subscription open seems bad.
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      Physics.UnsubscribeMsg(self, kFellAsleepMsg);
d1046 7
a1052 5
	{
      Physics.SubscribeMsg(self, kCollisionMsg);   
      Physics.UnsubscribeMsg(self, kFellAsleepMsg);
      if(!Object.HasMetaProperty(self,"MineSensePing"))
         Object.AddMetaProperty(self,"MineSensePing");
d1054 1
a1054 1
	}
d1057 22
a1078 19
      //really, a mine shouldn't trigger itself...  just bad form.
      object WhatHitMe = message.collObj;
      bool   fakeout = FALSE;
      if (Object.Exists(WhatHitMe))
      {
         vector selfvel(0,0,0);
         vector hitmevel(0,0,0);
         if (Physics.HasPhysics(self))
            Physics.GetVelocity(self,selfvel);
         if (Physics.HasPhysics(WhatHitMe))
            Physics.GetVelocity(WhatHitMe,hitmevel);
         //make sure that I don't trigger myself, and make sure that
         //at least one of us is actually moving and this isn't some 
         //wierd spoof collision...
         if ((selfvel == vector(0,0,0)) && (hitmevel == vector(0,0,0)))
            fakeout = TRUE;
      } 
      if (!fakeout)
         Reply(kPM_Slay);
@


1.63
log
@camera works on moving terrain
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.62 1970/01/01 00:00:00 TJS Exp $
d2249 13
@


1.62
log
@Torches no longer burn you.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.61 1970/01/01 00:00:00 adurant Exp $
d782 17
d820 4
d838 26
@


1.61
log
@Moss lumps fixed again so that they will fall if crates under them are
moved.  Ugh.  
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.60 1970/01/01 00:00:00 adurant Exp $
d490 1
d499 2
@


1.60
log
@Moss lumps now listen for onsleep rather than on non physical.  Gamfile
changed to match.  Fixes a very nasty save/load bug.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.59 1970/01/01 00:00:00 TJS Exp $
a1084 1

d1087 2
d1105 15
a1119 10
      object launcher=Object.Create("Mosslauncher");
      Object.Teleport(launcher,vector(0,0,0),vector(0,0,0),self);

      // Our own tweq emit property determines what the launcher will
      // launch.  Difference is, we turn its tweq _on_.
      Property.CopyFrom(launcher,"CfgTweqEmit",self);
      Property.CopyFrom(launcher,"StTweqEmit",self);
      ActReact.React("tweq_control",1.0,launcher,0,kTweqTypeEmitter,kTweqDoActivate); 
      SetOneShotTimer(self,"KillMyPhys",0.1);
      DefaultOnPhysFellAsleep();
d1124 1
a1124 1
      if (message.name == "KillMyPhys")
d1126 1
a1126 1
	  Property.Remove(self,"PhysType");
@


1.59
log
@Reworked proximity detection on mines, since the problem of creatures
starting inside the triggering OBB was proving to be intractable.
Now mines send out and recieve "Ping" stimuli, which creatures and
Avatars know how to reflect.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.58 1970/01/01 00:00:00 TJS Exp $
d1084 14
d1102 1
a1102 1
   OnPhysMadeNonPhysical()
d1111 13
a1123 1
      ActReact.React("tweq_control",1.0,launcher,0,kTweqTypeEmitter,kTweqDoActivate);
a1124 2
      DefaultOnPhysMadeNonPhysical();
   }
@


1.58
log
@Mines don't create a new bounds trigger every time we go in and out
of sim and they fall asleep again (e.g. after loading a game!)
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.57 1970/01/01 00:00:00 adurant Exp $
d955 1
a955 2
   or when triggered by associated bounds trigger.  When slain, also
   clean up bounds trigger.
a958 10
   METHOD void CleanUpBounds()
   {
      linkset triggers=Link.GetAll("~ControlDevice",self);
      for(;triggers.AnyLinksLeft();triggers.NextLink())
      {
         Debug.MPrint("Slaying mine ",self,", deleting bounds ",triggers.Link().To());
         Object.Destroy(triggers.Link().To());
      }
   }

a976 2

      CleanUpBounds();
d1010 2
a1011 11
      if(!Link.AnyExist("~ControlDevice",self))
      {
         //now we subscribe to collision and unsubscribe to sleep so that
         //this doesn't trigger again.
         vector z = vector(0,0,0);
         vector pos = Object.Position(self);
         object bounds=Object.Create("MineBounds");

         Object.Teleport(bounds,pos,z);
         Link.Create("ControlDevice",bounds,self);   
      }
d1030 1
a1030 2
         if ((Link.AnyExist("ControlDevice",self,WhatHitMe)) ||
             ( (selfvel == vector(0,0,0)) && (hitmevel == vector(0,0,0))))
a1040 1
         PostMessage(self,"TurnOn");
d1042 1
a1049 11
   }
   OnMessage()
   {
      if(MessageIs("TurnOn"))
         Damage.Slay(self,self);
      DefaultOnMessage();
   }
   OnSlain()
   {
      CleanUpBounds();
      DefaultOnSlain();
@


1.57
log
@ropes now become suspicious (hierarchy problem)
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.56 1970/01/01 00:00:00 adurant Exp $
d965 1
a965 1
	 Debug.MPrint("Slaying mine ",self,", deleting bounds ",triggers.Link().To());
d1021 14
a1034 8
	  //now we subscribe to collision and unsubscribe to sleep so that
	  //this doesn't trigger again.
	  Physics.SubscribeMsg(self, kCollisionMsg);   
	  Physics.UnsubscribeMsg(self, kFellAsleepMsg);
	  vector z = vector(0,0,0);
	  object bounds=Object.Create("MineBounds");
          Object.Teleport(bounds,z,z,self);
          Link.Create("ControlDevice",bounds,self);      
d1042 4
a1045 4
	{
	  vector selfvel(0,0,0);
	  vector hitmevel(0,0,0);
	  if (Physics.HasPhysics(self))
d1047 9
a1055 9
	  if (Physics.HasPhysics(WhatHitMe))
	    Physics.GetVelocity(WhatHitMe,hitmevel);
	  //make sure that I don't trigger myself, and make sure that
	  //at least one of us is actually moving and this isn't some 
	  //wierd spoof collision...
	  if ((Link.AnyExist("ControlDevice",self,WhatHitMe)) ||
	      ( (selfvel == vector(0,0,0)) && (hitmevel == vector(0,0,0))))
	    fakeout = TRUE;
	} 
d1057 1
a1057 1
        Reply(kPM_Slay);
d1063 4
a1066 4
	{
	   PostMessage(self,"TurnOn");
	   Debug.MPrint("You've set off the mine! ",self," is going to blow.");
	}
d1068 4
a1071 4
	{
	   Debug.MPrint("Mine disarmed.\n");
	   Disarm();
	}
a1111 1

@


1.56
log
@Extinguishable lights toggle suspicious properties properl
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.55 1970/01/01 00:00:00 TJS Exp $
d1964 4
@


1.55
log
@Took out obselete vine arrow stuff.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.54 1970/01/01 00:00:00 TJS Exp $
d475 15
@


1.54
log
@Rope/Vine arrows check various fields of CanAttach property instead
of treating it as a boolean.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.53 1970/01/01 00:00:00 TJS Exp $
a1972 19
   }
   METHOD boolean CanAttachToSurface(object targ)
   {
      // If a rope arrow could attach, so can a vine arrow.
      if(Base::CanAttachToSurface(targ))
         return TRUE;
      // _really_ dumb, and not even right.
      // if(Object.InheritsFrom(targ,"MatMetal"))
      //   return TRUE;

      // This won't work, since we can't get Pore Size this way (probably since
      // it's not in the default sDesc fields?). -TJS
      if(Physics.IsOBB(targ) &&
         Property.Possessed(targ,"PhysAttr") &&
         float(Property.Get(targ,"PhysAttr","Pore Size")) > 0.0)
      {
         return TRUE;
      }
      return FALSE;
@


1.53
log
@Potions automatically add M-QuaffHeal to container if contained by AI.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.52 1970/01/01 00:00:00 adurant Exp $
d1824 8
a1831 4
      if(!(Property.Possessed(targ,"CanAttach")
           && boolean(Property.Get(targ,"CanAttach"))))
         return FALSE;
      return TRUE;
@


1.52
log
@Kill culpable links on camera when it activates.  HACK
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.51 1970/01/01 00:00:00 TJS Exp $
d1442 14
@



1.51
log
@Set up extinguishable objects to be contact sources of heat when lit.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.50 1970/01/01 00:00:00 adurant Exp $
d774 5
@



1.50
log
@Noisemakers add their object id to the end of their signal
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.49 1970/01/01 00:00:00 TJS Exp $
d475 8
d2786 28
@



1.49
log
@Moss launchers can launch different sorts of things.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.47 1970/01/01 00:00:00 TJS Exp $
d1756 4
@



1.48
log
@Added flash mines.
Eliminated FireElemSparx
@
text
@d1093 7
a1099 2
      // make me the "firer" of the lancher, helps with culpability
      //      Link.Create("firer",launcher,self); 
@



1.47
log
@Added Instrument script.
Pulled WhistleCall script out into miss1.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.46 1970/01/01 00:00:00 TJS Exp $
d917 9
d1064 17
a2616 42


// Behaviors of the fire elemental's particle group to reflect
// AI state and such.
BEGIN_SCRIPT(FireElemSparx, StdParticleGroup)

METHODS:

   METHOD void SetColorToMood(int alertness)
   {
      static const int alert_red[] = {185, 187, 187, 122};
      // @@TODO: In the future, when particle color is really
      // RGB instead of a palette index in "red," do the obvious.

      if((alertness<0)||(alertness>=(sizeof(alert_red)/sizeof(alert_red[0]))))
      {
         Debug.MPrint("Heeey! Invalid alertness ",alertness,
                      " in method SetColorToMood.");
         return;
      }
      Property.Set(self,"ParticleGroup","red",alert_red[alertness]);
   }


MESSAGES:

   OnMessage()
   {
      if(Property.Possessed(self,"ParticleGroup"))
      {
         // Hack hack
         if(MessageIs("Mood0")||MessageIs("Mood1")||MessageIs("Mood2")||
            MessageIs("Mood3"))
         {
            SetColorToMood(message.message[4]-'0');
         }
      }
      DefaultOnMessage();
   }

END_SCRIPT(FireElemSparx)

@



1.46
log
@Potions play a Deactivate sound one second before running out.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.45 1970/01/01 00:00:00 TJS Exp $
d137 21
a2271 48


BEGIN_SCRIPT(WhistleCall, RootScript)

METHODS:

boolean WithinRange(object target, integer sigdistance)
   {
	vector mypos = Object.Position(self);
	vector targpos = Object.Position(target);
//do ugly nasty distance calculation.
	if (( ((mypos.z - targpos.z) * (mypos.z - targpos.z)) +
	      ((mypos.y - targpos.y) * (mypos.y - targpos.y)) + 
	      ((mypos.x - targpos.x) * (mypos.x - targpos.x)) ) <
	      (sigdistance * sigdistance))
	    return TRUE;
	else
	    return FALSE;
   }


MESSAGES:
   OnFrobInvEnd()
   {
	object signaltarget;
	integer distancetotarget;
	if(Link.AnyExist("ScriptParams",self))
	    {
		linkset allparamlinks = Link.GetAll("ScriptParams",self);
		while (allparamlinks.AnyLinksLeft())
		{
		    link currentparamlink = allparamlinks.Link();
		    integer sigdistance = (integer)currentparamlink.GetData();
		    object target = (object)currentparamlink.To();
		    Debug.MPrint("Attempting to signal ",target);
		    if (WithinRange(target,sigdistance))
			AI.Signal(target,"WhistleBlown");
		    else
			Debug.MPrint("Out of range");
		    allparamlinks.NextLink();
		}
	    }
	else
	   Debug.MPrint("No script param links found!");
	DefaultOnFrobInvEnd();
   }

END_SCRIPT(WhistleCall);
@



1.45
log
@Simpler remote camera script, should fix some bugs.
Heck, might even introduce some new ones.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.44 1970/01/01 00:00:00 TJS Exp $
d1398 3
d1403 1
a1403 1
        potiontimer=SetOneShotTimer(self,"EndPotion",float(timeout)/1000.0);
d1415 1
d1417 10
@



1.44
log
@Pulled out creature-specific scripts to ai.scr
Pulled out conveyer belt to gizmo.scr
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.43 1970/01/01 00:00:00 TJS Exp $
a736 4
      //will be back when player throws it again
      Physics.UnsubscribeMsg(self, kFellAsleepMsg);
      // Physics.UnsubscribeMsg(self, kContactMsg);

d739 1
a739 2
      if(IsDataSet("Armed") && boolean(GetData("Armed")) &&
         Link.AnyExist("~CulpableFor",self))
a744 1
      SetData("Armed",FALSE);
d751 1
a751 7
       if(!IsDataSet("Armed"))
          SetData("Armed",FALSE);
       else if(boolean(GetData("Armed")))
       {
          // Physics.SubscribeMsg(self, kContactMsg);
          Physics.SubscribeMsg(self, kFellAsleepMsg);
       }
a755 1
       // Physics.UnsubscribeMsg(self, kContactMsg);
a759 6
    OnFrobWorldEnd()
    {	
       //he picked me up, subscribe again
       DefaultOnFrobWorldEnd();
    }
	
a780 14

    OnContained()
    {
       if(message.event==kContainRemove &&
          Object.InheritsFrom(message.container,"Avatar"))
       {
          // Player just threw/dropped us
          // Physics.SubscribeMsg(self, kContactMsg);
          Physics.SubscribeMsg(self, kFellAsleepMsg);
          SetData("Armed",TRUE);
       }
       DefaultOnContained();
    }

@



1.43
log
@Vine arrows produce distinctive ropes.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.42 1970/01/01 00:00:00 TJS Exp $
d23 1
a2638 7
/* CREATURE SCRIPTS
   Fire Elementals
   Undead vs. Holy Water
   camera and turret stuff goes under traps
 */


a2679 308
// Script behaviors common to elementals, such
// as changing size based on hit points.
BEGIN_SCRIPT(Elemental, AI)

METHODS:

   METHOD void NotifyParticleGroups(string mess)
   {
      Link.BroadcastOnAllLinks(self,mess,"~ParticleAttachement");
   }

MESSAGES:

   OnDamage()
   {
      // @@TODO: Change scale smoothly, using tweq?
      const float MIN_ELEMENTAL_SCALE=0.375;
      vector newprop;
      float newsc;

      if(Property.Possessed(self,"HitPoints") &&
         Property.Possessed(self,"MAX_HP"))
      {
         int max=Property.Get(self,"MAX_HP");

         if(max==0) return; // whaddaya gonna do?
         newsc=Property.Get(self,"HitPoints");

         // even at negative hit points, don't scale to less than MIN
         if(newsc<0) newsc=0;

         newsc/=max;
         newsc=MIN_ELEMENTAL_SCALE+((1.0-MIN_ELEMENTAL_SCALE)*newsc);
         newprop.x=newprop.y=newprop.z=newsc;
         Property.Set(self,"Scale",newprop);
      }
      else
         Debug.MPrint(self," got damage message without HP properties!");;
   }

   // if we have any particle groups associated with us,
   // we'll want to shut them down.
   OnSlain()
   {
      // set our tweqscale so that we shrink away
      const float TIME_TO_SHRINK=10.0;
      vector rates, tmpvec, scale=vector(1.0,1.0,1.0);

      if(Property.Possessed(self,"StTweqScale"))
      {
         if(Property.Possessed(self,"Scale"))
            scale=Property.Get(self,"Scale");

         Property.Add(self,"CfgTweqScale");

         rates.x=-scale.x/TIME_TO_SHRINK;
         rates.y=-scale.y/TIME_TO_SHRINK;
         rates.z=-scale.z/TIME_TO_SHRINK;

         // why, oh why, didn't we write this the other way?
         tmpvec=Property.Get(self,"CfgTweqScale","x rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.y=0;
         tmpvec.z=scale.x;
         Property.Set(self,"CfgTweqScale","x rate-low-high",tmpvec);
         tmpvec=Property.Get(self,"CfgTweqScale","y rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.z=scale.y;
         Property.Set(self,"CfgTweqScale","y rate-low-high",tmpvec);
         tmpvec=Property.Get(self,"CfgTweqScale","z rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.z=scale.z;
         Property.Set(self,"CfgTweqScale","z rate-low-high",tmpvec);

         ActReact.React("tweq_control",1.0,self,0, kTweqTypeAll, kTweqDoActivate); 
      }
      Sound.HaltSpeech(self);

      DefaultOnSlain();
   }

END_SCRIPT(Elemental)

// Special effects associated with fire elemental AI
BEGIN_SCRIPT(FireElement,Elemental)

MESSAGES:

   OnDamage()
   {
      integer hp=Property.Get(self,"HitPoints");

      if (message.damage>0 && hp>=0)
      {
         object spang;
         object spang_arch;

         // @@TODO: You'd really like this to be done through the
         // blood splatter system.
  
         if(object(message.kind)==object("WaterStim"))
         {
            spang_arch=Object.Named("SteamPuff");
         }
         else
            spang_arch=Object.Named("FElemHit");

         if(Object.InheritsFrom(object(message.culprit),spang_arch))
         {
            Debug.MPrint("Pelligro! Heading off potential chain reaction of spang from ",self);
            spang_arch=object(0);
         }

         if(spang_arch!=object(0))
         {
            spang=Object.Create(spang_arch);
            Object.Teleport(spang,vector(0.0,0.0,0.0),vector(0.0,0.0,0.0),self);
         }
      }
      DefaultOnDamage();
   }
   OnAlertness()
   {
      // @@TODO: This calculation is of course riddled
      // with magic numbers which should be dealth with.
      
      // I still like an interpolation from like .4-1.0 or so,
      // but .4 is obviously not very flashy, so let's jack
      // this up a little bit at least for E3.
      float litelvl=.6+((.4/3.0)*message.level);
      
      float alpha=.3+(.2*message.level);
      int selflit=25+25*message.level;
      static const string moods[]={"Mood0","Mood1","Mood2","Mood3"};
      
      if(message.level<0 || message.level>=(sizeof(moods)/sizeof(moods[0])))
      {
         Debug.MPrint("Invalid alertness in obj ",self," script!");
         return;
      }

      if(message.level<2)
      {
         // Turn off heat source
         Object.RemoveMetaProperty(self,Object.Named("BigHeatSource"));
      }
      else
      {
         object metaprop=Object.Named("BigHeatSource");
         // Turn on heat source
         if(!Object.HasMetaProperty(self,metaprop))
         {
            Object.AddMetaProperty(self,metaprop);
         }
      }
      
      if(litelvl>1.0)
         litelvl=1.0;
      Property.Set(self,"ExtraLight","Amount (-1..1)",litelvl);
      Property.Set(self,"RenderAlpha",alpha);
      Property.Set(self,"SelfLit",selflit);
      
      NotifyParticleGroups(moods[message.level]);
   }
/* Screw this.  Replace it with CorpsePart
   OnSlain()
   {
      object puff=Object.Create("SmokePuff");
      Object.Teleport(puff,vector(0.0,0.0,0.0),vector(0.0,0.0,0.0),self);
      DefaultOnSlain();
   }
*/

END_SCRIPT(FireElement)

/* Causes damage done by "HolyStim" (holy water) stimulus to affect
   zombies permanently, while other types of damage will just put the
   zombie down for a limited period of time.
   */
BEGIN_SCRIPT(ZombieRegen, Physics)

METHODS:
   METHOD void Resurrect()
   {
      Object.RemoveMetaProperty(self,"M-ZombiePossum");
      Link.DestroyMany("AIWatchObj",self,self);
   }

MESSAGES:

   // Zombies should get up if you actually bump into them.
   // in fact, it quite causes problems if they don't.
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   // Problem: will this resurrect the zombie as soon as it dies,
   // due to hitting the player's sword?  Probably ok.
   OnPhysCollision()
   {
      object WhatIHit=message.collObj;

      if(WhatIHit!=object("Player"))
         return;
      // Debug.MPrint("Resurrecting ",self," due to collision with ",WhatIHit);
      Resurrect();
   }

   /* Zombies have a NULL slay result, so we can catch the slain event 
      here and decide what to do.  If we _really_ want to slay them, we
      can always resurrect them, set their slay result to terminate, and
      slay them all over again.
   */
   OnSlain()
   {
      integer slay=Property.Get(self,"SlayResult");

      // Debug.MPrint(self," slain.");
      Property.Remove(self,"AI_IdleOrgn");
      if(Property.Possessed(self,"MAX_HP"))
      {
         integer max=Property.Get(self,"MAX_HP");
         if(max<=0)
         {
            // set me up to explode
            object parts=Object.Named("M-ZombieParts");
            if(Object.InheritsFrom(self,Object.Named("HammerZombie")))
               parts=Object.Named("M-HamZombieParts");
            Object.AddMetaProperty(self,parts);
            Property.Set(self,"SlayResult",kSlayNormal);
            Sound.HaltSpeech(self);
            // Debug.MPrint(self," Really Dead");
         }
         else if(slay!=kSlayNormal)
         {
            boolean possum=GetData("Possum");

            Damage.Resurrect(self);
            if(!possum)
            {
               AI.Signal(self,"Possum");
               // Debug.MPrint(self," Playing Possum");
            }
         }
      }
   }

   OnDamage()
   {
      integer damage=message.damage;
      integer max, hp=Property.Get(self,"HitPoints");
      object stim=message.kind;
      object culprit=message.culprit;
      real permanent=0.0;
      
      if(culprit!=object(0) && Link.AnyExist("~CulpableFor",culprit))
         culprit=Link.GetOne("~CulpableFor",culprit).To();

      if(stim==object("HolyStim") ||
         stim==object("FireStim"))
         permanent=1.0;
      else if(stim==object("LightBright"))
         permanent=0.5;

      if(culprit!=object(0) &&
         Object.InheritsFrom(culprit,"Hammerite"))
         permanent=1.0;
       
      if(Property.Possessed(self,"MAX_HP"))
      {
         max=Property.Get(self,"MAX_HP");
         max-=(damage*permanent);
         Property.Set(self,"MAX_HP",max);
      }

      // Okay, the only way we're going to get damaged by WaterStim
      // is drowning.  If we drown, best to just lie down and stop
      // embarrassing us.
      if(stim==object("WaterStim") && hp<=0)
      {
         Property.Set(self,"SlayResult",kSlayNormal);
      }
      DefaultOnDamage();
   }
   OnMessage()
   {
      if(MessageIs("Resurrect"))
      {
         // Debug.MPrint("Resurrecting ",self," due to message request.");
         Resurrect();
      }
      if(MessageIs("Possum?"))
      {
         // pseudoscript wanting to know if it should add the possum
         // metaproperty/link.  Don't do it if they're already there.
         Reply(!Object.HasMetaProperty(self,"M-ZombiePossum"));
      }
      DefaultOnMessage();
   }
END_SCRIPT(ZombieRegen)
      
a2774 102
BEGIN_SCRIPT(CorpseFrobHack, AI)

METHODS:
   METHOD void MakeFrobbable(boolean frobbable)
   {
      // Debug.MPrint("Call ",self," MakeFrobbable, ",frobbable);
      if(frobbable)
         Object.RemoveMetaProperty(self,"FrobInert");
      else if(!Object.HasMetaProperty(self,"FrobInert"))
         Object.AddMetaProperty(self,"FrobInert");

      // Frobbable creatures are not responsible for their own actions or safety.
      Property.Set(self,"Culpable",!frobbable);
   }


   METHOD void CheckFrobbable()
   {
      if(Property.Possessed(self,"AI"))
      {
         string set=Property.Get(self,"AI","Behavior Set");
      
         if(set=="null")
            MakeFrobbable(TRUE);
         else if(Property.Possessed(self,"AI_Mode"))
         {
            integer mode=Property.Get(self,"AI_Mode");

            MakeFrobbable(mode==kAIM_Dead);
         }
         else
            MakeFrobbable(FALSE); // Can't tell AI mode; no frob
      }
      else
         MakeFrobbable(TRUE); // No AI, assume it's okay
   }

   METHOD object GetCarriedObj(object myself)
   {
       object candidate = myself;
       linkset contlinks = Link.GetAll("Contains",myself);
       while (contlinks.AnyLinksLeft())
       {
           link curlink = contlinks.Link();
           if ((integer)curlink.GetData() < 0)  //external carry
               candidate = curlink.To();
           contlinks.NextLink();
       }
       return candidate;       
   }

MESSAGES:
   OnBeginScript()
   {
      CheckFrobbable();
      DefaultOnBeginScript();
   }


   OnAIModeChange()
   {
      if (message.mode == kAIM_Dead)
      {
         MakeFrobbable(TRUE); 
      }
      else if (message.previous_mode == kAIM_Dead)
         MakeFrobbable(FALSE); 
      
      // Otherwise, stay how you were 
         
      DefaultOnAIModeChange(); 
   }

   OnFrobWorldEnd()
   {
      if (DarkGame.BindingGetFloat("auto_search") != 0.0)
      {
         Debug.MPrint("Performing Loot And Lug");
         object carriedobj = GetCarriedObj(self);
         if (carriedobj != object(self))
         {
            Container.Add(carriedobj,message.Frobber);
            Reply(FALSE);
         }       
      }
      DefaultOnFrobWorldEnd();
   }

   OnSlain()
   {
      // we're no longer knocked out.
      object ko = object("M-KnockedOut"); 
      if (ko != object(0))
//next line was causing a hang
//         while (Object.HasMetaProperty(self,ko))
            Object.RemoveMetaProperty(self,ko); 
      // de-physicalize
      if (Property.Possessed(self,"PhysType"))
         Property.Set(self,"PhysType","Remove On Sleep",TRUE); 
      DefaultOnSlain(); 
   }

a2775 3
END_SCRIPT(CorpseFrobHack)


a2802 441
BEGIN_SCRIPT(Corpsed, Physics)
MESSAGES:
   OnContained()
   {
      if(Object.InheritsFrom(message.container,"Avatar"))
      {
         if(message.event==kContainAdd)
         {
            PlayerLimbs.Equip(self);
            Property.Set(self, "NonPhysCreature", FALSE);
         }
         else if(message.event==kContainRemove)
         {
            // If not unconscious, de-physicalize on sleep
            if (!Object.InheritsFrom(self,"M-KnockedOut"))
            {
               if (Property.Possessed(self,"PhysType"))
                  Property.Set(self,"PhysType","Remove On Sleep",TRUE); 
            }
            PlayerLimbs.UnEquip(self);
         }
      }
      DefaultOnContained();
   }

// This is re-physicalization code if the body throw code is set up to
// auto-remove on sleep. 
#ifdef RE_PHYSICALIZE
   OnPhysMadeNonPhysical()
   {
      if (Object.InheritsFrom(self,"M-KnockedOut"))
         PostMessage(self,"ReFiz"); 
      DefaultOnPhysMadeNonPhysical(); 
   }

   OnMessage()
   {
      if (MessageIs("ReFiz"))
      {
         // re-add physics
         Property.Remove(self,"PhysType"); 
         Property.Add(self,"PhysType"); 
         Property.Set(self,"PhysType","Remove On Sleep",FALSE); 
      }
   } 

#endif // RE_PHYSICALIZE

END_SCRIPT(Corpsed)



/* This "window shade" is responsible for retexturing in its locality
   to represent an interior light turning on or off, or to represent the
   window itself being broken.  Also handles lighting changes.
*/
BEGIN_SCRIPT(WindowShade, AnimLight)

States
{
   LightOn,
   LightOff,
   WindowBroken
};

METHODS:
  METHOD string StateTexture(integer state)
  {
     string propname;

     if(state==LightOn)
        propname="TerrRepOn";
     else if(state==LightOff)
        propname="TerrRepOff";
     else if(state==WindowBroken)
        propname="TerrRepDestroy";
     else
     {
        Debug.MPrint("Invalid state passed to StateTexture by object ",self);
        return "";
     }
     if(!Property.Possessed(self,propname))
     {
        Debug.MPrint("Object ",self," missing desired property ",propname);
        return "";
     }
     return(Property.Get(self,propname));
  }
  
  METHOD void GoToState(integer state)
  {
     if(StateIs((integer)state) || StateIs((integer)WindowBroken)) return;

     AnimTexture.ChangeTexture(self,NULL,StateTexture(GetState()),
                                    NULL,StateTexture(state));
     SetState(state);
     if(StateIs((integer)LightOn))
        TurnOn();
     else
        TurnOff();
  }

  METHOD void HandleMessage(string message)
  {
     if(message==string("TurnOn"))
        GoToState(LightOn);
     else if(message==string("TurnOff"))
        GoToState(LightOff);
  }

MESSAGES:

  OnBeginScript()
  {
     // Discern starting state from light mode
     boolean on=IsLightOn();
     SetState(on?LightOn:LightOff);
     // Note that it's the designer's responsibility for the level to actually be textured
     // to match the light state.  We literally have no other possible way of knowing.
     SetData("StartState",GetState());
     DefaultOnBeginScript();
  }
  OnEndScript()
  {
     /* Hey, this crashes.  So, don't do this until it doesn't crash.
     AnimTexture.ChangeTexture(self,NULL,StateTexture(GetState()),
                                    NULL,StateTexture(GetData("StartState")));
     */
     DefaultOnEndScript();
  }
  OnSlain()
  {
     GoToState(WindowBroken);
     DefaultOnSlain();
  }
  OnMessage()
  {
     if(!StateIs((integer)WindowBroken))
     {
        HandleMessage(message.message);
     }
     DefaultOnMessage();
  }

END_SCRIPT(WindowShade)


BEGIN_SCRIPT(ControlWindowShade, WindowShade)

METHODS:
  // return a number from 0 to 1, which is (stochastically) the
  // the proportion of my time I spend in the "on" state.
  METHOD float OnWeight()
  {
     integer percent_on=50;

     if(Property.Possessed(self,"scriptTiming"))
        percent_on=Property.Get(self,"scriptTiming");

     return(percent_on/100.0);
  }

MESSAGES:
  OnSim()
  {
     if(message.starting)
     {
        float dont_all_go_at_once=15.0*Data.RandFlt0to1();

        SetOneShotTimer(self,"Randomize",dont_all_go_at_once);
     }
     DefaultOnSim();
  }
  OnTimer()
  {
     if(message.name=="Randomize")
     {
        if(!StateIs((integer)WindowBroken))
        {
           float roll=Data.RandFlt0to1();
           // re-roll every 10 seconds, + or - 5 seconds.
           float nextroll=10.0+Data.RandFltNeg1to1()*5.0;

           if(roll<OnWeight())
              GoToState(LightOn);
           else
              GoToState(LightOff);
        
           SetOneShotTimer(self,"Randomize",nextroll);
        }
     }
     DefaultOnTimer();
  }

END_SCRIPT(ControlWindowShade)


/* Needs a lot of help, with respect to blocking AI sight and vision and such. */
BEGIN_SCRIPT(CollapseFloor,PressurePlate)
MESSAGES:
   OnPressurePlateActive()
   {
      Damage.Slay(self,self);
   }

END_SCRIPT(CollapseFloor)



/* Cameras send a "TurnOn" when they reach high alertness,
   and a "TurnOff" when they stand down from high alertness.
   They also animate their models to reflect alertness,
   and when slain.  The TweqModels config property is used to
   parametrize the models used (so, cameras which use TweqModels
   animation are not supported).  Model number 0 is used for the
   dead camera, while 1 and up are used for alertness levels.
   */
BEGIN_SCRIPT(CameraAlert, AI)
METHODS:
   METHOD void SetTweqModel(integer tweqmod)
   {
      string model=Property.Get(self,"ModelName");

      if(Property.Possessed(self,"CfgTweqModels"))
         model=Property.Get(self,"CfgTweqModels",
                            string("Model ")+string(tweqmod));

      Property.Set(self,"ModelName",(const char*)model);
   }
MESSAGES:
   OnAlertness()
   {
      if(message.level==kHighAlert)
      {
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
      else if(message.oldLevel==kHighAlert)
      {
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      }
      if(!Object.HasMetaProperty(self,"M-AI-Stasis"))
         SetTweqModel(message.level+1);

      DefaultOnAlertness();
   }
   /* Note that if a camera is slain while at Alertness 3, it can
      never send the all-clear "TurnOff".  This is intentional. */
   OnSlain()
   {
      SetTweqModel(0);
      DefaultOnSlain();
   }
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         if(Object.HasMetaProperty(self,"M-AI-Stasis"))
         {
            SetTweqModel(1); // as per 0 alertness, since we know we're alert-capped
            Object.RemoveMetaProperty(self,"M-AI-Stasis");
         }
      }
      else if(MessageIs("TurnOff"))
      {
         if(!Object.HasMetaProperty(self,"M-AI-Stasis"))
            Object.AddMetaProperty(self,"M-AI-Stasis");
         SetTweqModel(5);
      }
      DefaultOnMessage();
   }

END_SCRIPT(CameraAlert)


/* QuaffHeal:
Prompt AI to use a healing potion, if he has one and has lost
hit points.
*/
BEGIN_SCRIPT(QuaffHeal, AI)
METHODS:
   METHOD object MyPotion()
   {
      boolean gotpotion=FALSE;
      object potion, item;
      linkset inventlinks=Link.GetAll("Contains",self);
      object healing=Object.Named("HealingPotion");
      
      for(;!gotpotion && inventlinks.AnyLinksLeft();inventlinks.NextLink())
      {
         item=inventlinks.Link().To();
         if(Object.InheritsFrom(item,healing))
         {
            gotpotion=TRUE;
            potion=item;
         }
      }
      if(gotpotion)
         return potion;
      else
         return object(0);
   }
MESSAGES:
   OnAlertness()
   {
      if(Property.Possessed(self,"AI_Mode") &&
         integer(Property.Get(self,"AI_Mode"))!=kAIM_Dead &&
         message.level!=kAIAL_High && 
         Property.Possessed(self,"HitPoints") &&
         Property.Possessed(self,"MAX_HP"))
      {
         integer hp=Property.Get(self,"HitPoints");
         integer max=Property.Get(self,"MAX_HP");

         if(hp<max)
         {
            object potion=MyPotion();
            if(potion!=object(0))
            {
               // Play drinking motion?
               SetData("Drinking",TRUE);
               Puppet.PlayMotion(self,"BH214113");
            }
         }
      }
      DefaultOnAlertness();
   }
   OnMotionEnd()
   {
      if(message.MotionName=="BH214113" && IsDataSet("Drinking"))
      {
         object potion=MyPotion();
         if(potion!=object(0)) FrobObj(potion,kHighPriorityAction);
         ClearData("Drinking");
      }
      DefaultOnMotionEnd();
   }
END_SCRIPT(QuaffHeal)



/* WorkerRobot:

  Upon receiving "DoISearch?" msg, it returns F if the robot already has either of
  the metaprops "M-WorkBot-Searching" or "M-WorkBot-CameraOut" or T otherwise.
  When prompted by msg "DoSearch" from AlertResponse pseudoscript, the robot
  gives itself the "M-WorkBot-Searching" metaprop and plays searching motions
  (defined by GetSearchMotion()) for GetSearchDuration() seconds.
  If the robot achieves high alertness, it removes the searching metaprop.
  If the robot ramps down to low alertness, it prompts the SignalResponse
  pseudoscript to put the robots camera away.

*/
BEGIN_SCRIPT (WorkerRobot, AI)

METHODS:
void DoSearch ()
{
	while (!Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
		Object.AddMetaProperty(self,Object.Named("M-WorkBot-Searching"));

	AI.SetScriptFlags(self, kMotionOff);  // disallow new motions
	Puppet.PlayMotion(self,GetSearchMotion());
	SetOneShotTimer("DoneSearching",GetSearchDuration());
}
void StopSearching ()
{
	AI.SetScriptFlags(self, 0x00); 		// Allow new motions again 

	while (Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
		Object.RemoveMetaProperty(self,Object.Named("M-WorkBot-Searching"));
}
string GetSearchMotion ()
{
	return "BH111210";  // turn 90 deg to left
}
float GetSearchDuration ()
{
	return 15.0;
}

MESSAGES:
OnMessage()
{
	if (MessageIs("DoISearch?"))
	{
		// reply F if I have either of these metaprops and T otherwise
		Reply (	!(	(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) ||
					(Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))	)	);
	}
	else if (MessageIs("DoSearch"))
	{
		DoSearch();
	}
	DefaultOnMessage();
}
OnMotionEnd()
{
	if (	(message.MotionName == GetSearchMotion()) && 
			(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) )
	{
		SetOneShotTimer ("TurnNow",1.0);
	}
	DefaultOnMotionEnd();
}
OnTimer()
{
	if (	(message.name == "DoneSearching") && 
			(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) )
	{
		StopSearching ();
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		{
			AI.Signal(self, "PutCameraAway");
		}
	}
	else if (message.name == "TurnNow")
	{
		Puppet.PlayMotion(self,GetSearchMotion());
	}
	DefaultOnTimer();
}
OnAlertness()
{
	if (message.level == kHighAlert)
	{
		StopSearching();
	}
	else if ( (message.level == kLowAlert) && (message.oldLevel > kLowAlert) )
	{
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		{
			AI.Signal(self, "PutCameraAway");
		}
	}
	DefaultOnAlertness();
}

END_SCRIPT (WorkerRobot)



a2829 76


#define degreesPerRadian 57.295779513
/*
 * Conveyor belt script
 * @@TODO: This should probably be in gizmo.scr, guys.
 */
BEGIN_SCRIPT(ConveyorBelt, Physics)

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kContactMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kContactMsg);
      DefaultOnEndScript();
   }

   // when an object contacts us, set their velocity to that of conveyor belt
   OnPhysContactCreate()
   {
      vector convVel;
      vector convFacing;
      float speed;
      object WhatTouchedMe = message.contactObj;

      if ( Object.Exists(WhatTouchedMe) ) {
         if ( Physics.HasPhysics(WhatTouchedMe) ) {
            convFacing = Object.Facing( self );
            // hack - use the x component of the conveyor belt velocity as the
            //    speed of the belt itself
            if ( Property.Possessed( self, "ConveyorVel" ) ) {
               convVel = Property.Get( self, "ConveyorVel" );
               speed = convVel.x;
            } else {
               speed = 5.0;  // default conveyor belt speed
            }
            // only pay attention to belt rotation around z axis (for now)
            convVel.x = speed * cos( convFacing.z / degreesPerRadian );
            convVel.y = speed * sin( convFacing.z / degreesPerRadian );
            convVel.z = 0.0;
            if ( WhatTouchedMe == Object.Named("Player") ) {
               // object is an AI, or the player
               Property.Set( WhatTouchedMe, "ConveyorVel", convVel);
            } else {
               // inanimate objects
               Physics.ControlVelocity( WhatTouchedMe, convVel );
            }
         }
      }
      DefaultOnPhysContactCreate();
   }

   // when an object breaks contact with us, set obj velocity to 0
   OnPhysContactDestroy()
   {
      object WhatTouchedMe = message.contactObj;

      if ( Object.Exists(WhatTouchedMe) ) {
         if ( Physics.HasPhysics(WhatTouchedMe) ) {
            if ( WhatTouchedMe == Object.Named("Player") ) {
               // object is an AI, or the player 
               Property.Remove( WhatTouchedMe, "ConveyorVel" );
            } else {
               // inanimate objects
               Physics.StopControlVelocity( WhatTouchedMe );
            }
         }
      }
      DefaultOnPhysContactDestroy();
   }
END_SCRIPT(ConveyorBelt)

@



1.42
log
@More reworking of loadout boxes.  Still not right.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.41 1970/01/01 00:00:00 TJS Exp $
d1862 6
a1867 1

d1876 1
a1876 1
         object MyRope=Object.BeginCreate("RopeArrowRope");
d1901 4
d1945 1
a1945 1
      object FX=Object.BeginCreate("ExRope");
d1948 7
@



1.41
log
@No Burricks, no Burplauncher.
@
text
@d1 2
a2 2
/////////////////////////////////////////////////////////////////////////////
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.40 1970/01/01 00:00:00 TJS Exp $
d2513 1
a2513 1
   // Override if you want to apply further criterea to which objects
d2515 1
a2515 1
   METHOD boolean Cleared(object obj)
d2519 5
a2523 2
MESSAGES:
   OnBeginScript()
d2527 3
d2531 1
a2531 1
      if(MyContainer!=object(0) && Link.AnyExist("Contains",self))
d2538 3
d2542 4
a2545 5
            if(Cleared(Goodies))
            {
               Container.Remove(Goodies);
               Container.Add(Goodies,MyContainer);
            }
d2548 9
a2556 13
         // Probably safer to remove the undistributed contents of the container
         // after the intial pass.  Lord knows how safe destrying objects is
         // during that initial link iteration when Cleared() could be having
         // arbitrary other side-effects.  -TJS
         if(Link.AnyExist("Contains",self))
         {
            MyContents=Link.GetAll("Contains",self);
            while(MyContents.AnyLinksLeft())
            {
               Object.Destroy(MyContents.Link().To());
               MyContents.NextLink();
            }
         }
d2558 1
a2558 2
      Object.Destroy(self);
      DefaultOnBeginScript();
d2571 4
a2574 1
      object retval=Object.Named("Player");
@



1.40
log
@Torches that start off should initialize their tweq models correctly.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.39 1970/01/01 00:00:00 TJS Exp $
a716 20


BEGIN_SCRIPT(Burplauncher, RootScript)

MESSAGES:
   // we want all objects in the burp fan to time out simultaneously.
   OnSlain()
   {
      linkset firedset=Link.GetAll("~Firer",self);

      while(firedset.AnyLinksLeft())
      {
         object fired=firedset.Link().To();

         Damage.Slay(fired,self);
         firedset.NextLink();
      }
      DefaultOnSlain();
   }
END_SCRIPT(Burplauncher)
@



1.39
log
@Check Exists before doing AnyLinksLeft in LoadoutBox.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.38 1970/01/01 00:00:00 TJS Exp $
d339 3
a341 7
         if(!IsLightOn())
         {
            Link.BroadcastOnAllLinks(self,"TurnOff","~ParticleAttachement");
            if(Property.Possessed(self,"SelfIllum"))
               Property.Set(self,"SelfIllum",0.0);
            AmbientHack(FALSE);
         }
d435 1
a435 1
      METHOD void TurnOn()
d437 6
a442 8
         // turn on our TweqModels animation
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeModels,kTweqDoActivate);
         // Turn on our light
         Base::TurnOn();
      }
      METHOD void TurnOff()
      {
         string deadmodel="Newt01"; // default from Thief1 standard torches.
d444 8
a451 8
         // turn off our TweqModels animation
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeModels,kTweqDoHalt);
         // change our model
         if(Property.Possessed(self,"CfgTweqModels"))
         {
            string propmodel=Property.Get(self,"CfgTweqModels","Model 5");
            if(propmodel!=string(""))
               deadmodel=propmodel;
d453 2
a454 4

         Property.Set(self,"ModelName",(const char*)deadmodel);
         Base::TurnOff();
      } 
@



1.38
log
@Set up basic vine arrow script structure.
Loadout Boxes should be somewhat safer now.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.37 1970/01/01 00:00:00 TJS Exp $
d1150 3
a1152 1
// to rip it out shortly anyway.  @@TODO: Change this.
d2553 1
a2553 1
      if(MyContainer!=object(0))
d2555 2
d2572 1
a2572 2
         MyContents=Link.GetAll("Contains",self);
         while(MyContents.AnyLinksLeft())
d2574 6
a2579 2
            Object.Destroy(MyContents.Link().To());
            MyContents.NextLink();
a2581 2
      else
         Debug.MPrint("Sorrow: invalid beneficiary of object ",self);
@



1.37
log
@Backed out changes to loadout boxes.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.36 1970/01/01 00:00:00 TJS Exp $
d1714 57
d1780 4
a1783 1
   METHOD boolean CanAttachTo(object targ)
a1784 1
      if(targ==object(0)) return FALSE;
d1788 7
a1884 55

// Starts the noisemaker schema when the arrow collides.
// Stops it again (if necessary) if it's picked up.
BEGIN_SCRIPT(PlayNoisemaker, Physics)

METHODS:

   METHOD void TurnOffSound()
   {
      Sound.HaltSchema(self);
      ClearData("Playing");
   }

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      TurnOffSound();
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   OnPhysCollision()
   {
      // @@TODO: should probably be an activate envschema on
      // the arrow, but don't know if we can do that and have it
      // still track the arrow...
      if(!IsDataSet("Playing"))
      {
         Sound.PlaySchema(self,"noisemaker",self);
         SetData("Playing",NULL);
      }
      DefaultOnPhysCollision();
   }
   OnPhysMadeNonPhysical()
   {
      // either we've been picked up, or come to rest in the world
      // turn off our special emit effect, if any
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeEmitter,kTweqDoHalt);
      DefaultOnPhysMadeNonPhysical();
   }
   OnContainer()
   {
      if(message.containee==self)
         TurnOffSound();
      DefaultOnContainer();
   }

END_SCRIPT(PlayNoisemaker)


d1919 25
d2562 10
a2571 2
            else
               Object.Destroy(Goodies);
@



1.36
log
@Oops.  That's End, not Begin, folks.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.35 1970/01/01 00:00:00 adurant Exp $
d2526 2
d2533 1
@



1.35
log
@CorpseFrobHack modified to support AutoSearch
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.34 1970/01/01 00:00:00 TJS Exp $
d3118 11
a3128 11
       if (DarkGame.BindingGetFloat("auto_search") != 0.0)
       {
           Debug.MPrint("Performing Loot And Lug");
           object carriedobj = GetCarriedObj(self);
	   if (carriedobj != object(self))
	   {
	       Container.Add(carriedobj,message.Frobber);
	       Reply(FALSE);
           }       
       }
       DefaultOnFrobWorldBegin();
@



1.34
log
@Added Clear method to LoadoutBox.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.33 1970/01/01 00:00:00 TJS Exp $
d3080 14
d3114 15
@



1.33
log
@Potion sets INVISIBILITY property on imbiber.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.31 1970/01/01 00:00:00 TJS Exp $
d2503 6
a2508 1

d2521 5
a2525 2
            Container.Remove(Goodies);
            Container.Add(Goodies,MyContainer);
a2530 1
      Object.Destroy(self);
@



1.32
log
@Added invisibility potion scripts.
Pulled out illumination behavior in IllumeBearer script into a method
to make it easier to handle player invisibility special case for flares.
So handled.
@
text
@d1560 5
d1570 2
d1613 1
@



1.31
log
@Added GasLight script.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.30 1970/01/01 00:00:00 TJS Exp $
d1528 80
d2307 2
a2308 2
MESSAGES:
   OnContained()
d2310 5
a2314 1
      object container=message.container;
d2316 5
a2320 1
      if(Property.Possessed(self,"SelfLit"))
d2322 1
a2322 2
         /* Add or remove this property on my bearer, as appropriate */
         if(message.event==kContainRemove)
d2324 2
a2325 5
            Property.Remove(container,"SelfLit");
            Property.Remove(container,"LightColor");
         }
         else
         {
d2329 8
d2338 7
a2344 1
      }
d2352 1
a2352 2
         Property.Remove(container,"SelfLit");
         Property.Remove(container,"LightColor");
@



1.30
log
@Questvar-dependent books and scrolls.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.29 1999/12/30 14:56:03 TJS Exp $
d500 30
@



1.29
log
@Don't force remote camera return when player is healed.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.28 1999/12/26 15:55:44 TJS Exp $
d16 1
d58 14
@



1.28
log
@Changed cam grenade activation into its own method.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.27 1999/12/17 15:55:02 PATMAC Exp $
d708 3
a710 2
	Camera.ForceCameraReturn();
	DefaultOnDamage();
@



1.27
log
@Use ConveyorVel property for conveyor belt speed, make conveyor
belt work for the player
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.26 1999/12/16 20:01:34 TJS Exp $
d715 19
d735 1
d738 7
a744 2
       if(!IsDataSet("Armed")) SetData("Armed",FALSE);
       Physics.SubscribeMsg(self, kFellAsleepMsg);
d749 1
a756 1
       Physics.SubscribeMsg(self, kFellAsleepMsg);
d762 1
a762 13
       //will be back when player throws it again
       Physics.UnsubscribeMsg(self, kFellAsleepMsg);

       // So, who ever said I was in motion because the player threw me, anyway?
       // Need to check that.
       if(IsDataSet("Armed") && boolean(GetData("Armed")) &&
          Link.AnyExist("~CulpableFor",self))
       {
          if(Object.InheritsFrom(Link.GetOne("~CulpableFor",self).To(),
                                 "Avatar"))
             Camera.DynamicAttach(self);
       }
       SetData("Armed",FALSE);
d777 2
d788 2
d3462 1
@



1.26
log
@Set up separate "Lugged" scripts for objects that burden the player
in inventory.
Set camera remotes to actually check that the player threw them before
grabbing his camera.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.25 1999/12/16 11:17:44 adurant Exp $
d3460 1
a3460 1
   // when an object contacts us, set their velocity to ???
d3471 8
a3478 1
            speed = 5.0;   // replace this with property
d3483 7
a3489 3
            //Debug.MPrint("move obj ", WhatTouchedMe, " ", convVel.x, ",", convVel.y, ",", convVel.z);
            //Debug.MPrint("facing obj ", WhatTouchedMe, " ", convFacing.x, ",", convFacing.y, ",", convFacing.z);
            Physics.ControlVelocity( WhatTouchedMe, convVel );
d3499 1
d3502 7
a3508 1
            Physics.StopControlVelocity( WhatTouchedMe );
@



1.25
log
@CamReturn and CamGrenade.  note that these scripts won't run under
dromed 1.11 or below.  but having them in the osm doesn't hurt if you
aren't trying to run them.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.24 1999/12/10 14:42:43 PATMAC Exp $
d717 5
a721 4
	{
	    Physics.SubscribeMsg(self, kFellAsleepMsg);
	    DefaultOnBeginScript();
	}
d723 4
a726 4
	{
	    Physics.UnsubscribeMsg(self, kFellAsleepMsg);
	    DefaultOnEndScript();
	}
d729 5
a733 5
	{	
	    //he picked me up, subscribe again
	    Physics.SubscribeMsg(self, kFellAsleepMsg);
	    DefaultOnFrobWorldEnd();
	}
d736 16
a751 6
	{
	    //will be back when player throws it again
	    Physics.UnsubscribeMsg(self, kFellAsleepMsg);
	    Camera.DynamicAttach(self);
	    DefaultOnPhysFellAsleep();
	}
d754 5
a758 5
	{
	    //if camera still attached to me, return.
	    Camera.CameraReturn(self);
	    DefaultOnSlain();
	}
d761 18
a778 5
	{
	    Camera.CameraReturn(self);
	//I'm irked that this isn't DefaultOnDestroy
	    BaseOnDestroy();
	}
d2945 27
d2976 1
a2976 1
      if(object(message.container)==Object.Named("Player"))
a2979 2
            Sound.PlaySchemaAmbient(self,"garlift");
            DrkInv.AddSpeedControl("CorpseCarry", 0.6,0.9);
a2984 2
            Sound.PlaySchemaAmbient(self,"gardrop");
            DrkInv.RemoveSpeedControl("CorpseCarry");
a2990 1

a2991 1

@



1.24
log
@Add in preliminary version of conveyor belt script
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.23 1999/12/07 20:12:36 adurant Exp $
d701 55
@



1.23
log
@Mine disarming
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.22 1999/12/02 15:44:44 TJS Exp $
d3340 58
@



1.22
log
@Implemented LockCheat config for containers.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.21 1999/11/24 18:05:25 adurant Exp $
d819 34
d914 14
d936 1
a936 5
      linkset triggers=Link.GetAll("~ControlDevice",self);
      for(;triggers.AnyLinksLeft();triggers.NextLink())
      {
         Object.Destroy(triggers.Link().To());
      }
d942 2
d945 6
@



1.21
log
@Addied WhistleCall script.   Broadcasts down ScriptParam links if target
of link is within range (data set per link).  
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.20 1999/11/09 13:10:24 adurant Exp $
d2124 7
a2130 1
      if(Locked.IsLocked(self))
@



1.20
log
@Now doesn't create mine edge-triggered OBB (minebounds) until after
activemine goes to sleep.  Prevents separation of box and mine. 
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.19 1999/11/08 11:03:23 TJS Exp $
d1963 46
@



1.19
log
@Added SlayFind and FrobFind scripts.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.18 1999/11/07 14:41:33 adurant Exp $
a715 1
      object bounds=Object.Create("MineBounds");
a718 1
      Object.Teleport(bounds,z,z,self);
a725 1
      Link.Create("ControlDevice",bounds,newmine);      
d851 4
@



1.18
log
@Mines now work without location/rotation control(they don't fully arm
until they are at rest AND armed at the same time).  Also, they
don't play the "arming" sound again if they are already arming.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.17 1999/10/27 15:04:45 adurant Exp $
d3206 29
@



1.17
log
@Really fixed dropping body bug
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/RCS/gen.scr 1.16 1999/10/11 15:02:32 TJS Exp $
d751 2
a752 1
      if(Link.AnyExist("~CulpableFor",self))
d825 8
a832 1
      Physics.SubscribeMsg(self, kCollisionMsg);
d837 7
d845 1
d848 7
d857 20
a876 1
      Reply(kPM_Slay);
@



1.16
log
@Changed arrow scripts to use ScriptTiming property for setting
timeouts to clean up arrow.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.15 1999/10/06 11:42:51 TJS Exp $
d2706 2
a2707 1
         while (Object.HasMetaProperty(self,ko))
@



1.15
log
@Pulled out about 1/3 of file to new gizmo.scr
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.14 1999/10/05 15:47:49 TJS Exp $
a1399 2
      float stickchance=100.00;

d1418 1
a1418 4
      if(Property.Possessed(self,"scriptTiming"))
         stickchance=Property.Get(self,"scriptTiming");
      return ((Data.RandFlt0to1()*100.0)<=stickchance);

d1423 5
a1427 1
      real limit=30.0;
d1451 2
a1452 1
         if(!IsDataSet("DontTimeout"))
d1454 1
a1454 1
            timer_handle timeout=SetOneShotTimer(self,"Tick",LifeSpan());
d1476 1
a1476 1
            new_timeout=SetOneShotTimer(self,"Tick",30.0);
a1562 1
         SetData("DontTimeout",TRUE);
@



1.14
log
@Pulled out TurretAlert into traps.scr
Slow-fall potions arrest some of your downward velocity when used.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.13 1999/10/04 17:19:54 TJS Exp $
d21 1
a46 4
/* ====== StdDoor ======
script for basic door behavior.  The door opens, closes, or changes
direction of motion when frobbed, and can respond to "TurnOn" and
"TurnOff" messages by opening and closing (respectively).
a47 4
The standard frob response takes into account whether the door is locked.
The door will Open and Close in response to messages even if locked,
but will not respond to frobs if locked. Responsibility for locking
and unlocking falls on the lock boxes themselves.
a48 376
How TurnOn/TurnOff messages are delivered is intentionally left flexible:
the usual vector would presumably be from a controlling lever.

If a door should not open to frobs at all (e.g., in the case where the
door is strictly remote-controlled) there are two options.  Either the
door can simply be absent a "scripts" flag in its "FrobInfo" property
(or without a FrobInfo property at all) in which case it will of course
have absolutely no scripted Frob response.  The other option is to have
a special-purpose script for that door, though possibly one which
inherits from StdDoor but declines to chain up with DefaultOnFrobWorldEnd()

This script includes synchronizing behavior for double doors, indicated
by a ScriptParams link (in either direction) with the data "Double."
Such doors will attempt to open and close as a unit, and keep the same
lock state.

*/
BEGIN_SCRIPT(StdDoor,Door)

   METHODS:

      METHOD void PingDoubles(void)
      {
         Link.BroadcastOnAllLinks(self,"SynchUp","ScriptParams","Double");
         Link.BroadcastOnAllLinks(self,"SynchUp","~ScriptParams","Double");
      }

      METHOD integer TargState(integer state)
      {
         if(state==kDoorClosing) return kDoorClosed;
         if(state==kDoorOpening) return kDoorOpen;
         return state;
      }

      METHOD string StateChangeTags(integer Status, integer OldStatus)
      {
         static string StateTags[]={"Open","Closed","Opening","Closing","Halted"};
         string retval="Event StateChange, OpenState ";

         retval=retval+StateTags[Status]+string(", OldOpenState ")+StateTags[OldStatus];

         if(IsDataSet("PlayerFrob"))
         {
            retval=retval+", CreatureType Player";
         }
         // When I halt, open, or close, clear the player frob info
         if(Status!=kDoorClosing && Status!=kDoorOpening)
            ClearData("PlayerFrob");
         return retval;
      }         

MESSAGES:

    // Since we know we probably have our hands full with a key
    // when we unlock a door, and using the key and door are now
    // on the same mouse button, locking and unlocking a door
    // will also close and open it.  -TJS
    OnNowLocked()
    {
       PingDoubles();
       Door.CloseDoor(self);
       DefaultOnNowLocked();
    }
    OnNowUnlocked()
    {
       PingDoubles();
       Door.OpenDoor(self);
       DefaultOnNowUnlocked();
    }

    OnFrobWorldEnd()
    {
      if(Locked.IsLocked(self) && Door.GetDoorState(self)==kDoorClosed)
      {
         Sound.PlayEnvSchema(self,"Event Reject, Operation OpenDoor",self);
      }
      else
      {
         if(object(message.Frobber)==object("Player"))
         {
            SetData("PlayerFrob",0);
         }
         Door.ToggleDoor(self);
      }
      DefaultOnFrobWorldEnd();
    }
    OnDoorHalt()
    {
       Sound.PlayEnvSchema(self,StateChangeTags(message.ActionType,message.PrevActionType),self);
       DefaultOnDoorHalt();
    }
    OnDoorOpening()
    {
       PingDoubles();
       Sound.PlayEnvSchema(self,StateChangeTags(message.ActionType,message.PrevActionType),self);
       DefaultOnDoorOpening();
    }
    OnDoorClosing()
    {
       PingDoubles();
       Sound.PlayEnvSchema(self,StateChangeTags(message.ActionType,message.PrevActionType),self);
       DefaultOnDoorClosing();
    }
    OnDoorClose()
    {
       Sound.HaltSchema(self);
       Sound.PlayEnvSchema(self,StateChangeTags(message.ActionType,message.PrevActionType),self);
       DefaultOnDoorClose();
    }
    OnDoorOpen()
    {
       Sound.HaltSchema(self);
       Sound.PlayEnvSchema(self,StateChangeTags(message.ActionType,message.PrevActionType),self);
       DefaultOnDoorOpen();
    }
    OnSlain()
    {
       // Resurrect so that I can potentially be bashed open again.
       Damage.Resurrect(self);
       Property.Set(self,"HitPoints",1);

       /* Note that this doesn't deal with double doors
          at all.  We presume that for double doors to be
          locked, all of the synchronized doors will be
          locked.  Probably there will be a separate script
          with the sole responsibility of slaying all doors
          in the set when any of them is slain, if that's
          what you want.
          */
       linkset locks=Link.GetAll("Lock",self);

       while(locks.AnyLinksLeft())
       {
          Link.Destroy(locks.Link());
          locks.NextLink();
       }
       if(Property.Possessed(self,"Locked"))
       {
          // see how sneaky!  first we set to FALSE, so the TweqLock
          // listener knows.
          Property.Set(self,"Locked",FALSE);
          // but really, we don't want it around at all anymore.
          Property.Remove(self,"Locked");
       }
       if(Property.Possessed(self,"KeyDst"))
          Property.Remove(self,"KeyDst");

       Door.OpenDoor(self);
    }
    
    OnMessage()
    {
       // interpret TurnOn/TurnOff messages, in this case as Open/Close
       if(MessageIs("TurnOn") || MessageIs("Open"))
          Door.OpenDoor(self);
       else if(MessageIs("TurnOff") || MessageIs("Close"))
          Door.CloseDoor(self);
       // used by key script to let the door know of tool-frobs by the player
       // so we can treat them as direct frobs with respect to sound.  This
       // message better be strictly correlated with immediately subsequent
       // events causing changes in door state...
       else if(MessageIs("PlayerToolFrob"))
       {
          SetData("PlayerFrob",0);
       }
       else if(MessageIs("SynchUp"))
       {
          // @@TODO: Work out what to do about PlayerFrob data in this case.
          object otherdoor=message.from;
          integer othertargstate=TargState(Door.GetDoorState(otherdoor));
          integer mytargstate=TargState(Door.GetDoorState(self));

          if(mytargstate!=othertargstate)
          {
             if(othertargstate==kDoorClosed)
                Door.CloseDoor(self);
             else
                Door.OpenDoor(self);
          }
          // @@TODO: Address lock states. Currently causing hang in Thief Gold
          // if(Property.Possessed(otherdoor,"Locked"))
          //    Property.CopyFrom(self,"Locked",otherdoor);
       }
    }

END_SCRIPT(StdDoor)


BEGIN_SCRIPT(ToggleDoor, StdDoor)

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn")||MessageIs("TurnOff"))
         Door.ToggleDoor(self);
      else
         DefaultOnMessage();
   }
END_SCRIPT(ToggleDoor)


/* Key which knows how to lock and unlock an object, if and only 
   if it matches that object's RegionID and either has its Master
   bit set or matches the object's LockID.  Mind you, all of that
   is adjudicated by the Key service.
*/
BEGIN_SCRIPT(StdKey,RootScript)

   METHODS: 
     METHOD boolean IsDoor(object obj)
     {
       return(Property.Possessed(obj,"RotDoor") ||
              Property.Possessed(obj,"TransDoor"));
     }
   MESSAGES:
     // Keys of the same KeySrc value combine in inventory.
     // we do this thusly: if a key without a Combine Type (as is the default)
     // comes into the player's inventory, we cook the KeySrc into a string
     // which gets slammed into its CombineType.  Then the object is punched
     // back into inventory so as to combine.  Lets go:
     OnContained()
     {
        if(message.event==kContainAdd &&
           object(message.container)==Object.Named("Player"))
        {
           object schem=Object.Named("pickup_key");

           // all keys coming into player inv must have stack count 
           // so it'll be clear when they combine.
           if(!Property.Possessed(self,"StackCount"))
              Property.Set(self,"StackCount",1);

           if(!Property.Possessed(self,"CombineType") &&
              Property.Possessed(self,"KeySrc"))
           {
              string combine="key";
              boolean master=Property.Get(self,"KeySrc","MasterBit");
              integer region=Property.Get(self,"KeySrc","RegionMask");
              integer id=Property.Get(self,"KeySrc","LockID");

              combine=combine+(master?"T":"F");
              combine=combine+string(region)+"i"+string(id);
              
   // Debug.MPrint("Setting combine type on ",self," to ",combine);
                                   
              Property.Set(self,"CombineType",(const char*)(combine));
              // Not clear if this is safe to do inside the OnContained handler...
              Container.Remove(self);
              Container.Add(self,Object.Named("Player"));
           }
           if(schem!=object(0))
              Sound.PlaySchemaAmbient(self,schem);
        }
        DefaultOnContained();
     }
     OnFrobToolEnd()
     {
        object targ=message.DstObjId;
        // we use kKeyUseCheck instead of (before) kKeyUseDefault because
        // we don't want to lock/unlock until we know whether the frob
        // will succeed, since we need to send PlayerFrob messages to
        // the affected door beforehand, so it can tag the sounds
        // appropriately.  Ick.
        boolean keyfit=Key.TryToUseKey(self,targ,kKeyUseCheck);
        boolean playerfrob=(object(message.Frobber)==object("Player"));
        boolean wasused=keyfit;

        if(keyfit)
        {
           if(playerfrob) SendMessage(targ,"PlayerToolFrob");
           Key.TryToUseKey(self,targ,kKeyUseDefault);
        }
        else
        {
           // okay, so the key doesn't fit whatever I'm trying to
           // use it on.  The least I can do, is if the thing I'm
           // trying to use it on is a door which has no lock,
           // to use the door.  But if it _has_ a lock, maybe I really
           // am trying to lock the lock, and the key just doesn't
           // fit.  Oi.  This is what happens when you try to read
           // the player's mind.

           // Not clear if we really need to check whether our targ
           // is a door.  Could the Door service be handing us this
           // information instead?
           if(IsDoor(targ) && !Property.Possessed(targ,"Locked")
              && !Locked.IsLocked(targ))
           {
              if(playerfrob) SendMessage(targ,"PlayerToolFrob");
              Door.ToggleDoor(targ);
              wasused=TRUE;
           }
           else
              SendMessage(targ,"Wrongkey");
        }
        Reply(wasused);
        DefaultOnFrobToolEnd();
     }

END_SCRIPT(StdKey)

/* Basic script for locking and unlocking objects.
   Responds to TurnOn and TurnOff messages by locking
   and unlocking, respectively.  This script can be used on
   an abstract object (Lock linked to some device) as
   part of a trap mechanism, or can be derived from for
   objects which want more concrete additional behaviors
   (such as lock boxes)
   */
BEGIN_SCRIPT(Lock, RootScript)

  MESSAGES:
      OnMessage()
      {
         // if Locked property is not present, take this to
         // represent a potentially- or previously-lockable
         // object which does not currently have a lock
         // (e.g., when a door is forced open, it loses its
         // locks).  So, do not add the property; do nothing.
         if(Property.Possessed(self,"Locked"))
            if(MessageIs("TurnOn") || MessageIs("Lock"))
            {
               Property.Set(self,"Locked",TRUE);
            }
            else if(MessageIs("TurnOff") || MessageIs("Unlock"))
            {
               Property.Set(self,"Locked",FALSE);
            }
         DefaultOnMessage();
      }

END_SCRIPT(Lock)

/* LockSounds
   Control logic for lock box objects, doors, chests, encoding
   the sounds they make to express their state changes.  Visible
   state changes are handled by the TweqLock property.
*/
BEGIN_SCRIPT(LockSounds,RootScript)
   METHODS:
      METHOD string CritterTag(string tagset)
      {
         if(IsDataSet("PlayerFrob"))
         {
            tagset+=", CreatureType Player";
            ClearData("PlayerFrob");
         }
         return tagset;
      }
   MESSAGES:
      OnNowLocked()
      {
         string tags="Event StateChange, LockState Locked";
         Sound.PlayEnvSchema(self,CritterTag(tags),self,NULL,kEnvSoundAtObjLoc);
         DefaultOnNowLocked();
      }
      OnNowUnlocked()
      {
         string tags="Event StateChange, LockState Unlocked";
         Sound.PlayEnvSchema(self,CritterTag(tags),self,NULL,kEnvSoundAtObjLoc);
         DefaultOnNowUnlocked();
      }
      OnMessage()
      {
        if(MessageIs("Wrongkey"))
        {
           Sound.PlayEnvSchema(self,"Event Reject, Operation KeyFit",self,NULL,kEnvSoundAtObjLoc);
        }
        else if(MessageIs("PlayerToolFrob"))
           SetData("PlayerFrob",0);
        DefaultOnMessage();
      }

END_SCRIPT(LockSounds)


a120 72

/* The roulette table can be frobbed to start the wheel spinning.
   The wheel slows down over time, eventually coming to a stop.
   It sends a TurnOn when it starts spinning and (just a guess as 
   to the right behavior) a TurnOff when it stops.
 */

const integer ROULETTE_FULL_SPEED=60;
const integer ROULETTE_TIME_TO_SLOW=9870;
const string sillyfieldname="    rate-low-high";

BEGIN_SCRIPT(Roulette,RootScript)

METHODS:
   METHOD void StopWheel()
   {
      Property.Set(self,"CfgTweqJoints",sillyfieldname,vector(0,0,360));
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoHalt);
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoHalt);
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
   }

   MESSAGES:
   OnTweqComplete()
   {
      if(message.Type==kTweqTypeFlicker &&
         message.Op==kTweqOpFrameEvent)
      {
         integer error=GetData("Error");
         integer rate=Property.Get(self,"CfgTweqBlink","Rate");
         integer delta=0;
         const string sillyfieldname="    rate-low-high";
         vector spin=Property.Get(self,"CfgTweqJoints",sillyfieldname);

         delta=error+(ROULETTE_FULL_SPEED*rate);
         error=delta%ROULETTE_TIME_TO_SLOW;
         delta=delta/ROULETTE_TIME_TO_SLOW;
         SetData("Error",error);

         spin.x-=delta;
         if(spin.x<0) spin.x=0;

         Property.Set(self,"CfgTweqJoints",sillyfieldname,spin);
         if(spin.x==0)
            StopWheel();
      }
      DefaultOnTweqComplete();
   }
   OnFrobWorldEnd()
   {
      // defining a constant so subtle differences in numbers of spaces don't
      // potentially loom over us. -TJS
      vector spin=Property.Get(self,"CfgTweqJoints",sillyfieldname);

      if(spin.x==0) // not spinning
      {
         Property.Set(self,"CfgTweqJoints",sillyfieldname,vector(60,0,360));
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoActivate);
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoActivate);
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
         SetData("Error",0);
      }
      else // spinning
      {
         StopWheel();
      }
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(Roulette)


a1908 428
//////////////////////////////////////////////////////////
///////  GENERIC LEVER SCRIPTS BELOW THIS POINT  /////////
//////////////////////////////////////////////////////////

// Note: until we demonstrate a compelling need for genericity
// here, only controllers which animate via TweqJoints will be
// supported.  If other tweqs need to be supported we should
// pursue better service-side utilities. -TJS
BEGIN_SCRIPT(StdController,Physics)

  METHODS:

     /* TODO: In the future (when we all drive electric cars)
        there should be a better way of detecting this. */
     METHOD boolean TweqAnimStateHasVal(object obj, int InputMask)
     {
        // InputMask should be all zeros except bit(s) being
        // queried for set to 1
        integer AnimS;

        if(!Property.Possessed(self,"StTweqJoints")) // No tweq!
        {
           Debug.MPrint(" *** Warning: Object ", obj, " has no TweqState properties (and is in script method TweqAnimStateHasValue).");
           return FALSE;
        }

        AnimS=Property.Get(obj,"StTweqJoints","AnimS");

        // return TRUE if the bit(s) is 1 in the bitfield, FALSE if not
        return ((AnimS & InputMask)!=0);
     }  // end of Method: TweqAnimStateHasVal

END_SCRIPT(StdController)

// script for object which turns on its tweq when it gets a 
// "TurnOn" message and turns off when it gets "TurnOff".
// To start and stop associated sound with environmental
// sound schema, just add the OnOffSounds script.
BEGIN_SCRIPT(TweqOnOff,StdController)

  MESSAGES:
     OnMessage()
     {
        integer TweqDo=kTweqDoActivate;
        boolean TweqMe=FALSE;

        if(MessageIs("GoForward"))
        {
           TweqMe=TRUE;
           TweqDo=kTweqDoForward;
        }
        else if(MessageIs("GoReverse"))
        {
           TweqMe=TRUE;
           TweqDo=kTweqDoReverse;
        }                
        else if (MessageIs("TurnOn"))
        {
           TweqMe=TRUE;
           TweqDo=kTweqDoActivate;
        }
        else if (MessageIs("TurnOff"))
        {
           TweqMe=TRUE;
           TweqDo=kTweqDoHalt;
        }

        if(TweqMe)
        {
           ActReact.React("tweq_control",1.0,self,0, kTweqTypeAll, TweqDo);
        }
     }

END_SCRIPT(TweqOnOff)


/*
Script for a two-state device which animates between
states using the Tweq system.  The actual tweq involved
is not specified, but detected by the script.  For
convenience, kTweqDirForward is used to refer to the 
state which is reached by the tweq acting in the "forward"
direction, and kTweqDirReverse refers to the state 
reached by acting in reverse.
*/
BEGIN_SCRIPT(StdTwoState,StdController)

METHODS:

     /* Return the state (kTweqDirForward or kTweqDirReverse
        which the device is either resting (if resting)
        in or moving towards (if moving). */
     METHOD integer TargetState(object obj)
     {
        // Device is in or towards forward position IFF it
        // is currently active and going forwards (of course)
        // or inactive and set to reverse.  That is, if its
        // ACTIVE bit (0x01) is not equal to its REVERSE
        // bit (0x02).
        if(TweqAnimStateHasVal(obj,0x01)!=TweqAnimStateHasVal(obj,0x02))
           return(kTweqDirForward);
        else
           return(kTweqDirReverse);
     }  // end of Method: TargetState

     METHOD string DirectionTags(integer dir)
     {
        if(dir==kTweqDirForward)
           return("Forward");
        else
           return("Reverse");
     }

     METHOD void PreTweqActivate (integer dir)
     {
        // this method should be defined by scripts that derive from this one
     }
     METHOD void PostTweqActivate (integer dir)
     {
        // this method should be defined by scripts that derive from this one
     }

     METHOD void TweqActivateNoSE()
     {
        if(!TweqAnimStateHasVal(self,0x01)) // 0x01==ON, so if anims are OFF
        {
           integer targ=TargetState(self);
           string tags="Event StateChange, DirectionState "+DirectionTags(targ);

           PreTweqActivate(targ);
           Sound.PlayEnvSchema(self,tags,self,NULL,kEnvSoundAtObjLoc);
        }
        
        // activate/reverse the motion of the lever
        ActReact.React("tweq_control",1.0,self,0, kTweqTypeJoints, kTweqDoDefault);
        Link.BroadcastOnAllLinks(self,"SynchUp","~FrobProxy");
     }  

     /*
       Like TweqActivateNoSE, but also causes side-effects on any other levers
       that want to toggle along with this one.  This is MOST of the time
       the desired behavior.  The exception is when the lever is toggling
       _as_ a side effect: then it doesn't want to chain side effects.
       */
     METHOD void TweqActivate()
     {
        TweqActivateNoSE();
        Link.BroadcastOnAllLinks(self,"ToggleNoSE","ScriptParams","SideEffect");
     }

     /* Sends the tweq device towards the specified state if it's
        not already there.  
     */
     METHOD void GoTowardsState(integer stateId)
     {
        if(TargetState(self)==stateId)
           return;
        else // get moving, then
           TweqActivate();

           // The TweqActivate call will take care of synching the frob proxies
     }  // end of Method: GoTowardsState

MESSAGES:
     OnMessage()
     {
        if (MessageIs("TurnOn") || MessageIs("GoForward"))
           GoTowardsState(kTweqDirForward);
        else if (MessageIs("TurnOff") || MessageIs("GoBackward"))
           GoTowardsState(kTweqDirReverse);
        else if (MessageIs("Toggle"))
           TweqActivate();
        else if (MessageIs("ToggleNoSE"))
        {
           // Toggling as a side effect of another lever toggling.
           // don't chain side effects.
           TweqActivateNoSE();
        }
        else if (MessageIs("Target?"))
           Reply(TargetState(self));
        else if (MessageIs("SynchUp"))
        {
           // synch up with another lever, for when multiple levers
           // are frob proxied to control a single two-state mechanism
           // and you want to keep all levers in the same animation
           // state.
           GoTowardsState(TargetState(message.from));
        }
        DefaultOnMessage();
     }
     OnTweqComplete()
     {
        if(message.Type==kTweqTypeJoints)
           PostTweqActivate(message.Dir);
        DefaultOnTweqComplete();
     }

END_SCRIPT(StdTwoState)

// This script activates the animation on a lever when it is frobbed,
// and calls the method Activate and passes in the message.Dir from the
// TweqComplete message.
// A lever that uses this script needs FrobWorld and Tweq properties on it.
BEGIN_SCRIPT(StdLever,StdTwoState)

  METHODS:
     METHOD void PostTweqActivate (integer dir)
     {
        // if you want to modify the basic behavior of broadcasting
        // TurnOn and TurnOff messages, you can derive from this
        // script and override the method.
        if (dir==kTweqDirReverse) 
           // the lever is going from down to up, send TurnOff
           Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
        else if (dir==kTweqDirForward)
           // the lever is going from up to down, send TurnOn
           Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
     }

  MESSAGES:
     OnFrobWorldEnd()
     {
       // If lever is locked, then it can't move in respone to frobs.
       // There must of course be some feedback to the frob, but unlike
       // in the door case this feedback won't be as natural with just
       // lock-rattling sounds and/or Garrett voice-overs.  So, we
       // assume that there's some external error-signalling mechanism,
       // like an alarm light.  This should be indicated by a (insert
       // link flavor here) link, which will direct a TurnOn message.
       if(Locked.IsLocked(self)) {
          Link.BroadcastOnAllLinks(self,"TurnOn","ScriptParams","ErrorOutput");
       }
       else {
          TweqActivate();
       }
       DefaultOnFrobWorldEnd();
     }

END_SCRIPT(StdLever)


/* Slight variation on the standard lever behavior in
   terms of triggering circumstances. 
   This script sends a "TurnOn" message when the attached object's
   tweq animation has ended in the forward direction; for the reverse
   direction, it sends a "TurnOff" message when the frob has ended.
   This behavior corresponds to a JumperSwitch in which the electric
   current is connected only when the switch is fully closed.
   */
BEGIN_SCRIPT(JumperSwitch,StdLever)

METHODS:

   METHOD void PreTweqActivate(integer dir)
   {
      //    This gets called just after the object is frobbed and before the
      // tweq animation starts.
      //    If the tweq is set to go in reverse, then last time the tweq went
      // forward and the JumperSwitch is currently engaged. We wish to shut
      // off the "electric current" now since the connection is about to be
      // broken.
      // @@TODO: Get rid of magic numbers.
      if (TweqAnimStateHasVal(self,0x02)) // 0x02 = REVERSE
      {
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      }
   }  // end of method PreTweqActivate

   METHOD void PostTweqActivate (int dir)
   {
      //    This gets called just after the tweq animation finishes.
      //   If the tweq is set to go in reverse, then it just got done
      // going forward and the JumperSwitch just got engaged.  We wish to
      // turn on the "electric current" now that the connection has been
      // established.
      if (TweqAnimStateHasVal(self,0x02)) // 0x02 = REVERSE
      {
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
   } // end of method PostTweqActivate

END_SCRIPT(JumperSwitch)


/* STANDARD GAUGE (no pun intended)

   Gauges are essentially levers with a twist.  They animate in response to
   turnon and turnoff messages, and can run Pre- and Post-TweqActivate methods
   when they reach their limits.  The difference is that some gauges also
   have some intermediate point in their animation which we want to be able
   to detect and respond to, as when the gauge enters the "danger zone."

   This is less a behavior that it's clear you'd really want on a particular
   gauge than a core infrastructure for implementing this kind of (potent,
   intricate) gauge.

   For right now, we're going to totally hack this.
*/

BEGIN_SCRIPT(StdGauge,StdLever)

METHODS:

States
{
   lowrangerising=0,
   redzonerising=1,
   falling=2
};
/* Stages are
   0 (rising from low to error point),
   1 (rising from error point to max),
   2 (falling)

   Gauge can have different tweq params for each stage.
   Overload this method to change.
   */
   METHOD vector TweqParams(integer stage)
   {
      return(vector(0,0,0));
   }

   // This method gets called as the gauge passes the designated error point.
   // overload as necessary.
   METHOD void MidTweqActivate()
   {
      return;
   }

   METHOD void StateChange(integer stage)
   {
      Property.Set(self,"CfgTweqJoints","    rate-low-high",TweqParams(stage));
      SetState(stage);
   }

MESSAGES:

   OnTweqComplete()
   {
      vector limits;

      if(!Property.Possessed(self, "CfgTweqJoints"))
         return;
      limits=Property.Get(self,"CfgTweqJoints","    rate-low-high");
      if(message.Dir==kTweqDirReverse) // joint returning to rest
      {
         StateChange(lowrangerising);
         DefaultOnTweqComplete();
      }
      else if(limits.z==TweqParams(redzonerising).z) // joint reached real upper limit
      {
         // as payback for the brutal tweqjoint hackery we do,
         // incorrect initial conditions for the guage's
         // tweqjoint extents can keep the MidTweqActivate from
         // ever being run.  So, we detect this case and issue a warning.

         if(!StateIs((int)redzonerising))
         {
            // Debug.MPrint("Hey!  Gauge ",self," has got no red zone!");
            MidTweqActivate();
         }

         StateChange(falling);
         DefaultOnTweqComplete();
      }
      else // joint reached error angle
      {
         StateChange(redzonerising);
         MidTweqActivate();
         // keep going to new upper range
         ActReact.React("tweq_control",1.0,self,0, kTweqTypeJoints, kTweqDoForward);
      }
   }
    
END_SCRIPT(StdGauge)  
      

/* STANDARD BUTTON
Standard button, when frobbed, sends a TurnOn message.
*/
BEGIN_SCRIPT(StdButton, StdController)

METHODS:
   METHOD void ButtonPush()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      // bounce the button
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoActivate);
   }
      
MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   OnPhysCollision()
   {
      // only pushed by collisions with your front face
      // @@TODO: Get rid of magic number.
      if(message.collSubmod==4)
      {
        // collisions with AI's don't push the button; they're
        // assumed to be controlling themselves a bit better than that.
        if(! (Object.InheritsFrom(message.collObj,"Avatar")
              || Object.InheritsFrom(message.collObj,"Creature")))
        {
          ButtonPush();
        }
      }
      DefaultOnPhysCollision();
   }
   OnFrobWorldEnd()
   {
      ButtonPush();
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(StdButton)



a1979 31
/*
  VICTROLA
  A Victrola simply plays a sound when frobbed.  We actually presume the
  victrola will have some sort of Tweq joint on it, so we script that to
  animate while the sound is playing.  If frobbed again, stop the old sound
  and start over.  Also, trigger across ControlDevice links when frobbed.
 */
BEGIN_SCRIPT(Victrola, RootScript)
MESSAGES:
   OnSchemaDone()
   {
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoHalt);
      DefaultOnSchemaDone();
   }
   OnFrobWorldEnd()
   {
      Sound.HaltSchema(self);
      if(Link.AnyExist("SoundDescription",self))
      {
         object schem=Link.GetOne("SoundDescription",self).To();
         Sound.PlaySchema(self,schem,self);
      }

      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      // bounce the button
      ActReact.React("tweq_control",1.0,self,0,kTweqTypeJoints,kTweqDoActivate);
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(Victrola)


a2159 300
/* STANDARD ELEVATOR
The basic "elevator" behavior will be to go between two states,
interpreting "Off" as the highest terrpt it can find and "On"
as the lowest.  This is a bit counterintuitive, but corresponds
to the action of a typical lever.

Obviously, this is only really supported if there
exactly two waypoints associated with the moving terrain object.
In truth, the code is easy to write for any cycle of
waypoints, but it's not like there's any point in setting things
up that way.

It's also possible to have a multi-stage elevator where each
waypoint on its path can "call" the elevator.  Thus, the elevator
can respond to calls by just going towards a specific waypoint.
*/
BEGIN_SCRIPT(StdElevator, RootScript)

METHODS:

   METHOD void SeekPoint(object dest)
   {
      if(dest==object(self)) return;
      if(Property.Possessed(self,"MovingTerrain"))
      {
         // Hack alert: different scripts know about the elevator
         // starting and stopping (woe, lamentation), so we just
         // message ourselves about these things happening so that
         // yet a third script can handle the sounds.
         {
            // At short distances, we may not go at all, and no sound
            // for tiny trips won't kill us, so check that.
            vector p1=Object.Position(self);
            vector p2=Object.Position(dest);
            real dist=(p1-p2).Magnitude();

            if(dist>0.5)
            {
               SendMessage(self,"Starting");
            }
         }
         
         if(Link.AnyExist("TPathNext",self))
         {
            link destlink = Link.GetOne("TPathNext",self);
            // if we're already going to the right place, 
            // don't munge the links, but do make sure we're active

            if(destlink.To()==dest)
            {
               Property.Set(self,"MovingTerrain","active",TRUE);
               return;
            }
            Property.Set(self,"MovingTerrain","active",FALSE);
            Link.Destroy(destlink);
         }
         // if it so happens that this gets set false twice, it won't hurt.
         Property.Set(self,"MovingTerrain","active",FALSE);
         Link.Create("TPathNext",self,dest);
         Property.Set(self,"MovingTerrain","active",TRUE);
         ActReact.React("tweq_control",1.0,self,0, kTweqTypeAll, kTweqDoActivate);
      }
   }

   // Find "the" next waypoint along the moving terrain route.
   // this assumes that no object has two outgoing TPath
   // links, which is the only supported case.  Behavior in
   // other cases is unspecified but should be non-disastrous.
   // This assumes Link.GetOne acts deterministically so two
   // calls to NextPoint from the same start do not go different
   // places. 
   METHOD object NextPoint(object curpt, linkkind linktype)
   {
      if(Link.AnyExist(linktype,curpt))
         return(Link.GetOne(linktype,curpt).To());
      else
         return curpt;
   }

   // find either the highest or lowest waypoint on the cycle associated
   // with myself.
   METHOD object FindPoint(bool highest)
   {
      int transform=1;
      object curpoint;

      // to find the lowest point, turn the world upside-down and find the highest.
      if(!highest) transform=-1;

      // what waypoint path am I on?
      if(Link.AnyExist("TPathNext",self))
         curpoint=Link.GetOne("TPathNext",self).To();
      else if(Link.AnyExist("TPathInit",self))
         curpoint=Link.GetOne("TPathInit",self).To();
      else {
         Debug.MPrint("Warning: elevator ",self," could not find path.");
         return(self);
      }

      // now, starting from initpoint, traverse TPath links and search
      // for the highest point.  detect both dead ends and cycles by
      // sending a scouting traversal ahead.  You'll either dead-end
      // and catch up to the scout, our cycle and be caught by it.
      {
         float hgt, max=transform*(Object.Position(curpoint).z);
         object highpoint=curpoint;
         object scoutpt=curpoint;

         do {
            // is current point higher than any found before?
            hgt=transform*(Object.Position(curpoint).z);
            if(hgt>max)
            {
               max=hgt;
               highpoint=curpoint;
            }

            curpoint=NextPoint(curpoint,"TPath");
            scoutpt=NextPoint(NextPoint(scoutpt,"TPath"),"TPath");

         } while (curpoint!=scoutpt);

         return(highpoint);   
      }
   }
         
MESSAGES:

   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         SeekPoint(FindPoint(FALSE));
      }
      else if(MessageIs("TurnOff"))
      {
         SeekPoint(FindPoint(TRUE));
      }
      else if(MessageIs("Call"))
      {
         SeekPoint(message.from);
      }
      DefaultOnMessage();
   }

END_SCRIPT(StdElevator)


/* Pretty self-explanatory.  A moving terriain object with
   this script will deactivate when it gets to waypoints.
   It must rely on some other agency (such as the StdElevator
   script) to start it up again if it is ever to do so.
   */
BEGIN_SCRIPT(StopAtWaypoints,MovingTerrain)

MESSAGES:
   OnMovingTerrainWaypoint()
   {
      // stop when you reach waypoints
      if(Property.Possessed(self,"MovingTerrain"))
      {
         // Debug.MPrint("Lo!  I, ",self,", have reached waypoint ",message.waypoint);
         Property.Set(self,"MovingTerrain","active",FALSE);
         ActReact.React("tweq_control",1.0,self,0, kTweqTypeAll, kTweqDoHalt);

         // Hack alert: different scripts know about the elevator
         // starting and stopping (woe, lamentation), so we just
         // message ourselves about these things happening so that
         // yet a third script can handle the sounds.
         SendMessage(self,"Stopping");
      }
      DefaultOnMovingTerrainWaypoint();
   }

END_SCRIPT(StopAtWaypoints)



// Script: StopHere
/* Put on a moving terrain waypoint to cause platforms
   reaching it to halt there.
   */
BEGIN_SCRIPT(StopHere,Waypoint)
MESSAGES:
   OnWaypointReached()
   {
      Property.Set(message.moving_terrain,"MovingTerrain","active",FALSE);
      DefaultOnWaypointReached();
   }
END_SCRIPT(StopHere)




BEGIN_SCRIPT(ElevatorSounds,RootScript)
MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         SetData("ElevLooping",FALSE);
      }
      DefaultOnSim();
   }
   OnMessage()
   {
      boolean looping=GetData("ElevLooping");

      if(MessageIs("Starting") && !looping)
      {
         Sound.PlayEnvSchema(self,"Event ActiveLoop",self);
         SetData("ElevLooping",TRUE);
      }
      else if(MessageIs("Stopping"))
      {
         Sound.HaltSchema(self);
         SetData("ElevLooping",FALSE);
         Sound.PlayEnvSchema(self,"Event Deactivate",self);
      }
      DefaultOnMessage();
   }
END_SCRIPT(ElevatorSounds)



/* STANDARD TERRAIN WAYPOINT
Terrain waypoints respond to TurnOn messages by calling their associated
moving terrain object.
*/
BEGIN_SCRIPT(StdTerrpoint, RootScript)

METHODS:

   // Find "the" next waypoint along the moving terrain route.
   // this assumes that no object has two outgoing TPath
   // links, which is the only supported case.  Behavior in
   // other cases is unspecified but should be non-disastrous.
   // This assumes Link.GetOne acts deterministically so two
   // calls to NextPoint from the same start do not go different
   // places. 

   METHOD object NextPoint(object curpt, linkkind linktype)
   {
      if(Link.AnyExist(linktype,curpt))
         return(Link.GetOne(linktype,curpt).To());
      else
         return curpt;
   }

   // This of course assumes that only one object links
   // to the current TPath, and that the current TPath
   // is non-branching (either a cycle or a sequence).  
   METHOD object MyTerrObj()
   {
      // this is a bit pesky.  scan the waypoints on my path
      // (assumed to be a simple cycle) to find the one my
      // terrain object actually currently knows about.
      object curpoint=self;
      object scoutpt=curpoint;
      linkkind linktypes[]={"TPath","~TPath"};
      linkkind linkdir=linktypes[0];
      int pass;

      // do one scan traversing forwards, one backwards, in case
      // we're not just on a simple cycle for some reason.
      for(pass=0;pass<2;pass++) {
         do {
            // found a terrain obj yet?
            if(Link.AnyExist("~TPathNext",curpoint))
               return(Link.GetOne("~TPathNext",curpoint).To());
            else if(Link.AnyExist("~TPathInit",curpoint))
               return(Link.GetOne("~TPathInit",curpoint).To());
            
            linkdir=linktypes[pass];

            curpoint=NextPoint(curpoint,linkdir);
            scoutpt=NextPoint(NextPoint(scoutpt,linkdir),linkdir);
         
         } while (curpoint!=scoutpt);
      }
      // if all else fails...
      return(self);
   }

MESSAGES:

   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         object MyTerr=MyTerrObj();
         if(MyTerr!=object(self))
            SendMessage(MyTerr,"Call");
      }
      DefaultOnMessage();
   }

END_SCRIPT(StdTerrpoint)


a2776 71

// the script for alarm gongs.  When rung, either by frobbing
// or impact, make appropriate activation sound so as to notify
// any AI's within earshot.
BEGIN_SCRIPT(Gong,StdController)

METHODS:

   METHOD void Ring()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
      /* @@TODO: In our perfect world, guys would just hear
         the sound and get the signal.  Sadly...
         Well, suffice to say that if you want a guy to  
         get the signal whether or not he really hears the
         gong, give him an "Owns" link to the gong.
         */
      {
         linkset owners=Link.GetAll("~Owns",self);
         while(owners.AnyLinksLeft())
         {
            object owner=owners.Link().To();
            AI.Signal(owner,"gong_ring");
            owners.NextLink();
         }
      }
   }

MESSAGES:
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }

   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   OnPhysCollision()
   {
      // Only collisions with broad faces of gong will ring it.
      // @@TODO: Kill magic numbers
      // @@TODO: If we get a jointed model and TweqWubWub, do so.
      if(message.collSubmod==1 || message.collSubmod==4)
      {
        // collisions with AI's don't ring the gong; they're
        // assumed to be controlling themselves a bit better than that.
        if(! (Object.InheritsFrom(message.collObj,"Avatar")
              || Object.InheritsFrom(message.collObj,"Creature")))
        {
          Ring();
        }
      }
      DefaultOnPhysCollision();
   }
   OnFrobWorldEnd()
   {
      Ring();
      DefaultOnFrobWorldEnd();
   }
   OnMessage()
   {
      if(MessageIs("TurnOn"))
         Ring();
   }

END_SCRIPT(Gong)

d2922 1
@



1.13
log
@Added DiffSpoof.
Rewrote SpeedPotion script to support a more generic notion
of a "TimedPotion" with on and off handlers.  Made SpeedPotion
an instance of TimedPotion.  Added new instance of TimedPotion,
LoGravPotion.  Any TimedPotion can now have its duration set
via the object's ScriptTiming property.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.12 1999/09/27 16:59:20 TJS Exp $
a15 1
#include "phprops.h" // for kCPT_ constants
d1724 11
d1736 1
a1736 1
         Property.Set(imbiber,"PhysAttr","Gravity %",50);
d1740 1
a1740 1
         Property.Set(imbiber,"PhysAttr","Gravity %",100);
a4280 40


/* Turrets' alertness is controlled by external sensors, such as cameras
   or other triggers.   When a turret gets a "TurnOn," it goes to high
   alertness and stays there.  When it gets a "TurnOff," it goes to low
   alertness and stays _there_.
   Turrets inherit from TrapRequirement so they can be on so long as
   _any_ of their sensors have sent them a TurnOn without a matching
   TurnOff.
*/
BEGIN_SCRIPT(TurretAlert, TrapRequirement)

METHODS:
   METHOD void ClampAlert(integer alert)
   {
      Property.Set(self,"AI_AlertCap","Min level",alert);
      Property.Set(self,"AI_AlertCap","Max level",alert);

      // Placeholder joint animation until we get real turret AI
      // Assumes we'll use the StdTwoState script for this.
      PostMessage(self,alert==kHighAlert?"GoForward":"GoBackward");
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         ClampAlert(kHighAlert);
         DefaultOnMessage();
      }
      else if(MessageIs("TurnOff"))
      {
         DefaultOnMessage();
         if(!Link.AnyExist("ScriptParams",self))
            ClampAlert(kNoAlert);
      }
   }

END_SCRIPT(TurretAlert)
@



1.12
log
@Pulled out all trap/trigger scripts into their own file.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.11 1999/09/27 14:38:05 TJS Exp $
d1598 3
a1600 3
BEGIN_SCRIPT(SpeedPotion,EatFood)
MESSAGES:
  OnFrobInvEnd()
d1602 8
a1609 1
     object imbiber=message.Frobber;
d1611 4
a1614 1
     if(Object.InheritsFrom(imbiber,Object.Named("Avatar")))
d1616 15
a1630 3
        if(!Object.HasMetaProperty(imbiber,Object.Named("M-SpeedyPlayer")))
           Object.AddMetaProperty(imbiber,Object.Named("M-SpeedyPlayer"));
        PostMessage(imbiber,"Speedy");
a1631 2
     DefaultOnFrobInvEnd();
  }
d1633 5
a1637 1
END_SCRIPT(SpeedPotion)
d1639 14
a1652 1
BEGIN_SCRIPT(SpeedyPlayer,RootScript)
d1654 5
d1661 1
a1661 1
     if(MessageIs("Speedy"))
d1663 16
a1678 4
        DrkInv.AddSpeedControl("Speedy", 1.75,1.25);
        if(!IsDataSet("Timeout"))
           SetOneShotTimer(self,"Pokey",1.0);
        SetData("Timeout",GetTime()+8.6);
d1684 2
a1685 1
     if(message.name=="Pokey")
d1687 3
a1689 10
        real timeout=0.0;
        if(IsDataSet("Timeout")) timeout=GetData("Timeout");
        if(GetTime()>=timeout)
        {
           Object.RemoveMetaProperty(self,"M-SpeedyPlayer");
           DrkInv.RemoveSpeedControl("Speedy");
           ClearData("Timeout");
        }
        else
           SetOneShotTimer(self,"Pokey",1.0);
d1693 1
a1693 1
END_SCRIPT(SpeedyPlayer)
d1696 42
d3781 25
@



1.11
log
@Added TrigContained, TrigWorldFrob, TrigInvFrob, TrigBrainDead,
StopHere, RouletteWheel, and FrobSounds scripts.
Quest variable traps/triggers should now treat non-existent quest
variables correctly (i.e. as if zero).
Relay behavior removed from TweqOnOff.  If you want the behavior,
you can always put the TrapRelay script on separately.
TrapRelay, TrapInverter, and TrapOnFilter no longer relay messages
coming from themselves, thus preventing the most trivial case of
undesirable cycles.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.10 1999/09/27 13:36:34 TJS Exp $
d21 1
a22 4
/* @@TODO: Break this bad boy up into individual files, one for traps,
   one for standard AI, and such.
*/

a256 17
BEGIN_SCRIPT(TrigDoorOpen, Door)
MESSAGES:
    OnDoorOpening()
    {
       if(message.PrevActionType==sDoorMsg::kClose)
       {
          Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
       }
       DefaultOnDoorOpening();
    }
    OnDoorClose()
    {
       Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
       DefaultOnDoorClose();
    }
END_SCRIPT(TrigDoorOpen)

a389 18

BEGIN_SCRIPT(TrigUnlock, RootScript)
   MESSAGES:
      OnNowLocked()
      {
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
         DefaultOnNowLocked();
      }
      OnNowUnlocked()
      {
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         DefaultOnNowUnlocked();
      }
END_SCRIPT(TrigUnlock)




a1137 11
BEGIN_SCRIPT(TrigSchemaDone, RootScript)

MESSAGES:
   OnSchemaDone()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      // DefaultOnSchemaDone();
      SCRIPT_CALL_BASE(SchemaDone);
   }
END_SCRIPT(TrigSchemaDone)

a2704 158
// Script:		TrigContained
// Sends "TurnOn" on all outgoing links when the object it is placed on becomes contained 
BEGIN_SCRIPT (TrigContained, RootScript)
MESSAGES:
   OnContained()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice");
      DefaultOnContained();
   }
END_SCRIPT (TrigContained)



// Assumed to be put on an object with an edge-triggered OBB
// physics model.  Triggers when the player intrudes on those bounds.
BEGIN_SCRIPT(TrigOBB, Physics)

METHODS:
   METHOD void Census(object who)
   {
      if(!Link.AnyExist("Population",self,who))
      {
         Link.Create("Population",self,who);
         Object.AddMetaProperty(who,"M-NotifyRegion");
      }
      UpdatePop();
   }
   METHOD void DeCensus(object who)
   {
      Object.RemoveMetaProperty(who,"M-NotifyRegion");
      Link.DestroyMany("Population",self,who);
      UpdatePop();
   }
   METHOD void TrigOBBActivate()
   {
      Sound.PlayEnvSchema(self,"Event Activate",self,NULL,kEnvSoundAtObjLoc);
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
   }
   METHOD void TrigOBBDeactivate()
   {
      Sound.PlayEnvSchema(self,"Event Deactivate",self,NULL,kEnvSoundAtObjLoc);
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
   }
   METHOD void UpdatePop()
   {
      boolean populated=Link.AnyExist("Population",self);
      boolean was_populated=GetData("Populated");

      if(populated!=was_populated)
      {
         if(!populated)
            TrigOBBDeactivate();
         else
            TrigOBBActivate();
      }
      SetData("Populated",populated);
   }      

MESSAGES:

   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kEnterExitMsg);
      if(!IsDataSet("Populated"))
         SetData("Populated",FALSE);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kEnterExitMsg);
      DefaultOnEndScript();
   }
   OnPhysEnter()
   {
      object critter=message.transObj;

      // Debug.MPrint("PhysEnter ",self," by ",critter);

      // only collisions with AI's and players trigger the glyph.
      if((Object.InheritsFrom(critter,"Avatar")
          || Object.InheritsFrom(critter,"Creature")))
      {
         boolean live=TRUE;

         // Dead guys don't trigger.
         if(Property.Possessed(critter,"AI_Mode") &&
            integer(Property.Get(critter,"AI_Mode"))==kAIM_Dead)
            live=FALSE;
         if(Property.Possessed(critter,"DeathStage") &&
            integer(Property.Get(critter,"DeathStage"))!=0)
            live=FALSE;

         if(live)
            Census(critter);
      }
      DefaultOnPhysEnter();
   }
   OnPhysExit()
   {
      object critter=message.transObj;

      // Debug.MPrint("PhysExit ",self," by ",critter);

      if(Link.AnyExist("Population",self,critter))
         DeCensus(critter);
      DefaultOnPhysExit();
   }
   
END_SCRIPT(TrigOBB)


// glyphs fire their triggers when a creature collides with
// their "edge-triggered" physics model.
// upon firing, they actuate some tweq effects.
// otherwise, they're standard triggers.
BEGIN_SCRIPT(Glyph,TrigOBB)

METHODS:
   METHOD integer Shots()
   {
      integer count=-1;
      if(Property.Possessed(self,"StackCount"))
         count=Property.Get(self,"StackCount");
      return count;
   }

   METHOD void TrigOBBActivate()
   {
      integer count=Shots();
      if(count!=0)
      {
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeAll,kTweqDoActivate);
         Base::TrigOBBActivate();
         if(count>0)
         {
            Property.Set(self,"StackCount",--count);
         }
      }
   }

MESSAGES:

   // when our tweqscale completes, stop all tweqs
   OnTweqComplete()
   {
      if(message.Type==kTweqTypeScale)
      {
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeAll,kTweqDoHalt);
         Property.Set(self,"Scale",vector(1.0,1.0,1.0));
         if(Shots()==0 || !Link.AnyExist("ControlDevice",self))
            Object.Destroy(self);
      }
      DefaultOnTweqComplete();
   }

END_SCRIPT(Glyph)


a4091 665
/* TRAP/TRIGGER scripts
@@TODO: move these out into their own file
*/

BEGIN_SCRIPT(TrigRoomPlayer, Room)

MESSAGES:

   OnPlayerRoomEnter()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      DefaultOnPlayerRoomEnter();
   }
   OnPlayerRoomExit()
   {
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      DefaultOnPlayerRoomExit();
   }

END_SCRIPT(TrigRoomPlayer)


BEGIN_SCRIPT(TrigRoomPlayerTrans, Room)

MESSAGES:

   OnPlayerRoomEnter()
   {
      if(Link.AnyExist("Route",message.FromObjId,self))
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      if(Link.AnyExist("Route",self,message.FromObjId))
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      DefaultOnPlayerRoomEnter();
   }
   OnPlayerRoomExit()
   {
      if(Link.AnyExist("Route",self,message.ToObjId))
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      if(Link.AnyExist("Route",message.ToObjId,self))
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      DefaultOnPlayerRoomExit();
   }

END_SCRIPT(TrigRoomPlayerTrans)


/* Keep track of the creatures in a given room, sending
   TurnOn messages when the room is populated and
   TurnOff when the room is depopulated.
   NOTE: This needs to know when creatures in the room die.  Currently, this is done by
   a separate script on the creature itself (NotifyRoomOnSlain, below)
*/
BEGIN_SCRIPT(TrigRoomCreature, Room)

METHODS:
   METHOD void TurnOn()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
   }
   METHOD void TurnOff()
   {
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
   }
   METHOD void UpdatePop()
   {
      boolean populated=Link.AnyExist("Population",self);
      boolean was_populated=GetData("Populated");

      if(populated!=was_populated)
      {
         if(!populated)
            TurnOff();
         else
            TurnOn();
      }
      SetData("Populated",populated);
   }      

MESSAGES:

   OnBeginScript()
   {
      // this counts on our getting room enter messages
      // on simulation start to actually determine initial
      // population (and trigger if appropriate).
      if(!IsDataSet("Populated"))
         SetData("Populated",FALSE);
   }
   OnCreatureRoomEnter()
   {
      object critter=message.MoveObjId;
      boolean live=TRUE;

      // Dead guys don't trigger.
      if(Property.Possessed(critter,"AI_Mode") &&
         integer(Property.Get(critter,"AI_Mode"))==kAIM_Dead)
         live=FALSE;
      if(Property.Possessed(critter,"DeathStage") &&
         integer(Property.Get(critter,"DeathStage"))!=0)
         live=FALSE;

      if(live)
      {  
         Link.Create("Population",self,critter);
         Object.AddMetaProperty(critter,"M-NotifyRegion");
         UpdatePop();
      }
      DefaultOnCreatureRoomEnter();
   }
   OnCreatureRoomExit()
   {
      object critter=message.MoveObjId;

      Object.RemoveMetaProperty(critter,"M-NotifyRegion");
      Link.DestroyMany("Population",self,critter);
      UpdatePop();

      DefaultOnCreatureRoomExit();
   }
   OnPlayerRoomEnter()
   {
      Link.Create("Population",self,"Player");
      UpdatePop();
      DefaultOnPlayerRoomEnter();
   }
   OnPlayerRoomExit()
   {
      Link.DestroyMany("Population",self,"Player");
      UpdatePop();
      DefaultOnPlayerRoomExit();
   }
   OnMessage()
   {
      if(MessageIs("Obituary"))
      {
         Link.DestroyMany("Population",self,message.from);
         UpdatePop();
      }
      DefaultOnMessage();
   }

END_SCRIPT(TrigRoomCreature)

/* Used by population-tracking rooms (and OBB's) to get notification of creature
   death within their bounds.  This script is put on the creature via a metaprop
   while so contained.
   */
BEGIN_SCRIPT(NotifyRegion, RootScript)

MESSAGES:
   // Note: this can behave strangely for zombies, who can be "slain"
   // and then get back up...
   OnSlain()
   {
      Link.BroadcastOnAllLinks(self,"Obituary","~Population");
      DefaultOnSlain();
   }

END_SCRIPT(NotifyRegion)


/* TrigAIAlert:
Triggers when AI (presumably a security camera)
reaches alert level 3 (fully alert of player)
*/
BEGIN_SCRIPT(TrigAIAlert, AI)

MESSAGES:
   OnAlertness()
   {
      if(message.level==kAIAL_High)
      {
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
   }
   // @@TODO: Might really want a TurnOff for when AI loses the PC.
END_SCRIPT(TrigAIAlert)


/* TrigSlain:
Triggers when the object is slain.
*/
BEGIN_SCRIPT(TrigSlain, RootScript)

MESSAGES:
   OnSlain()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      DefaultOnSlain();
   }
END_SCRIPT(TrigSlain)


/* TrigWorldFocus:
   This script sends a standard "TurnOn" message when an object is focused
*/
BEGIN_SCRIPT(TrigWorldFocus, RootScript)

MESSAGES:

   OnWorldSelect()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      DefaultOnWorldDeSelect();
   }
END_SCRIPT(TrigWorldFocus)



/* These should be self-explanatory
 */
BEGIN_SCRIPT(TrigWorldFrob, RootScript)
MESSAGES:
   OnFrobWorldEnd()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      DefaultOnFrobWorldEnd();
    }
END_SCRIPT(TrigWorldFrob)

BEGIN_SCRIPT(TrigInvFrob, RootScript)
MESSAGES:
   OnFrobInvEnd()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      DefaultOnFrobInvEnd();
    }
END_SCRIPT(TrigInvFrob)



// Script:	TrapConverse
/* Put on conversation object so as to be able to start it with a "TurnOn." */
BEGIN_SCRIPT(TrapConverse, RootScript)
MESSAGES:
   OnMessage()
   {
      if (MessageIs("TurnOn"))
         AI.StartConversation(self);
      DefaultOnMessage();
   }
END_SCRIPT(TrapConverse)


// Script: TrapPatrol
/* Turns an AI's patrol on or off.  Could do this with TrapConverse,
   but that's kind of overkill for this speicalized use.

   As a matter of style, this should _only_ be used for behind-the-
   scenes stage managing.  Overt AI decision-making should as a rule
   be handled with the core AI tools!

   @@TODO: Should AIs reset their idle origin when patrolling is
   turned off?
*/
BEGIN_SCRIPT(TrapPatrol, RootScript)
MESSAGES:
   OnMessage()
   {
      if (MessageIs("TurnOn"))
         Property.Set(self,"AI_Patrol",TRUE);
      else if (MessageIs("TurnOff"))
         Property.Set(self,"AI_Patrol",FALSE);
      DefaultOnMessage();
   }
END_SCRIPT(TrapPatrol)


BEGIN_SCRIPT(TrapInverter,RootScript)
MESSAGES:
   OnMessage()
   {
      if(message.from!=self)
      {
         if(!Locked.IsLocked(self))
         {
            if(MessageIs("TurnOn"))
               Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
            else if(MessageIs("TurnOff"))
               Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(TrapInverter)


BEGIN_SCRIPT(TrapRelay, RootScript)
MESSAGES:
   OnMessage()
   {
      if(message.from!=self)
      {
         if(!Locked.IsLocked(self))
         {
            integer percent_filter=100;
         
            if(Property.Possessed(self,"scriptTiming"))
               percent_filter=Property.Get(self,"scriptTiming");

            if(Data.RandFlt0to1()<=(float(percent_filter)/100.0))
               Link.BroadcastOnAllLinks(self,message.message,"ControlDevice",NULL);
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(TrapRelay)


BEGIN_SCRIPT(TrapOnFilter,RootScript)
MESSAGES:
   OnMessage()
   {
      if(message.from!=self)
      {
         if(!Locked.IsLocked(self))
         {
            if(MessageIs("TurnOn"))
               Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(TrapOnFilter)



BEGIN_SCRIPT(TrigPPlate, PressurePlate)
MESSAGES:
   OnPressurePlateActive()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
   }
   OnPressurePlateInactive()
   {
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
   }

END_SCRIPT(TrigPPlate)

BEGIN_SCRIPT(TrigPPlateImmed, PressurePlate)
MESSAGES:
   OnPressurePlateActivating()
   {
      Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
   }
   OnPressurePlateDeactivating()
   {
      Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
   }
END_SCRIPT(TrigPPlateImmed)

// When I get a TurnOn, release my contents into the world.
// When I get TurnOff, contain them again.  Both operations
// are idempotent, of course,
//
// Note that this is only _really_ designed for the case where
// the trap contains exactly one object.
BEGIN_SCRIPT(TrapRelease, RootScript)

METHODS:

   METHOD boolean HasRefs(object obj)
   {
      return(Property.Possessed(obj,"HasRefs") &&
             (Property.Get(obj,"HasRefs")==TRUE));
   }

   METHOD void ReplaceLinks(linkkind was, linkkind shallbe)
   {
      linkset waslinks=Link.GetAll(was,self);
      boolean appear=(was==linkkind("Contains"));

      while(waslinks.AnyLinksLeft())
      {
         link thislink=waslinks.Link();
         object targ=thislink.To();

         // if disappearing objects, don't do anything to those
         // not currently ref'd (e.g., those contained by other
         // things.
         if(appear || HasRefs(targ))
         {
            if(!Link.AnyExist(shallbe,self,targ))
               Link.Create(shallbe,self,targ);
            Link.Destroy(thislink);
            if(appear)
            {
               Object.Teleport(targ,vector(0,0,0),vector(0,0,0),self);
               Property.Set(targ,"HasRefs",TRUE);
            }
            else
            {
               Object.Teleport(self,vector(0,0,0),vector(0,0,0),targ);
            }
         }
         waslinks.NextLink();
      }
   }

MESSAGES:

   OnMessage()
   {
      if(MessageIs("TurnOn"))
         ReplaceLinks("Contains","Owns");
      else if(MessageIs("TurnOff"))
         ReplaceLinks("Owns","Contains");
      DefaultOnMessage();
   }

END_SCRIPT(TrapRelease)

// Actually doesn't create the object, just puts its existing contents into the world.
// Differs from TrapRelease only in that it cannot later dephysicalize the object.
BEGIN_SCRIPT(TrapCreate, TrapRelease)
MESSAGES:
   OnMessage()
   {
      if(!MessageIs("TurnOff"))
         DefaultOnMessage();
   }
END_SCRIPT(TrapCreate)


BEGIN_SCRIPT(TrapTweqEmit, RootScript)

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeEmitter,kTweqDoActivate);
      DefaultOnMessage();
   }      

END_SCRIPT(TrapTweqEmit)


BEGIN_SCRIPT(ReloadTweqEmit, RootScript)

METHODS:
   METHOD void Report(integer warnlevel)
  {
    if(warnlevel>=2)
    {
      if(Property.Possessed(self,"CfgTweqEmit"))
      {
        integer rate=Property.Get(self,"CfgTweqEmit","Rate");
        integer time=Property.Get(self,"StTweqEmit","Cur Time");
        if(time!=(rate-1))
        {
          Debug.MPrint("Suspicious time field on reloading tweq emit trap.");
          Debug.MPrint("rate=",rate," implies time should be ",rate-1," not ",time);
        }
      }
      else
        Debug.MPrint(self," has no CfgTweqEmit property!");
    }
  }

MESSAGES:
   OnTweqComplete()
   {
      if(Property.Possessed(self,"CfgTweqEmit"))
      {
         integer rate=Property.Get(self,"CfgTweqEmit","Rate");
         integer time=rate-1;

         if(time<0) time=0;
         Property.Set(self,"StTweqEmit","Cur Time",time);
         Property.Set(self,"StTweqEmit","Frame #",0);
         DefaultOnTweqComplete();
      }
   }

END_SCRIPT(ReloadTweqEmit)

/* Trigger to be associated with a TweqFlicker-ing fnord.
   Sends a TurnOn on every tweq flicker event.
   */
BEGIN_SCRIPT(TrigFlicker, RootScript)

METHODS:
   METHOD void Fire(boolean on)
   {
      SetData("IsOn",on);
      SetData("LastFiring",GetTime());
      Link.BroadcastOnAllLinks(self,on?"TurnOn":"TurnOff","ControlDevice",NULL);
   }

MESSAGES:

   OnSim()
   {
      if(message.starting)
      {
         SetData("IsOn",FALSE);
         SetData("LastFiring",0.0);
         SetOneShotTimer(self,"check",15.0);
      }
      DefaultOnSim();
   }
   OnTweqComplete()
   {
      if(message.Type==kTweqTypeFlicker &&
         message.Op==kTweqOpFrameEvent)
      {
         boolean on=GetData("IsOn");
         on=!on;
         Fire(on);
      }
   }
   OnMessage()
   {
      if(MessageIs("TurnOn"))
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoActivate);
      else if(MessageIs("TurnOff"))
      {
         // Send a final "off." Don't want to leave controlled thing in an on state,
         // generally.
         Fire(FALSE);
         ActReact.React("tweq_control",1.0,self,0,kTweqTypeFlicker,kTweqDoHalt);
      }
   }
   OnTimer()
   {
      // if we've had no activity in a while, then turn off, as a tweq sim
      // radius may have left us undesirably on.
      if(message.name=="check")
      {
         real time=GetTime();
         real lasttime=GetData("LastFiring");
         boolean on=GetData("IsOn");

         if(on && (time-lasttime)>10.0)
            Fire(FALSE);
         SetOneShotTimer(self,"check",15.0);
      }
      DefaultOnTimer();
   }

END_SCRIPT(TrigFlicker)


/* Used to implement RequireAll and RequireAny meta-traps.

   Keeps track of current state by forging a "ScriptParams"
   link to a correspondent when it gets a "TurnOn", and
   breaking the link if it gets a "TurnOff"
   */
   
BEGIN_SCRIPT(TrapRequirement, RootScript)
MESSAGES:

   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         if(!Link.AnyExist("ScriptParams",self,message.from))
         {
            Link.Create("ScriptParams",self,message.from);
         }
      }
      else if(MessageIs("TurnOff"))
      {
         linkset tally=Link.GetAll("ScriptParams",self,message.from);

         while(tally.AnyLinksLeft())
         {
            Link.Destroy(tally.Link());
            tally.NextLink();
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(TrapRequirement)

/* Trap keeps track of "TurnOn" and "TurnOff" messages,
   sending a "TurnOn" if and only if all items control linked
   to it have sent "TurnOn" more recently.  As soon as the
   first one sends a "TurnOff," so does this trap.
   */
BEGIN_SCRIPT(TrapRequireAll, TrapRequirement)

METHODS:

   METHOD boolean CheckForAllLinked()
   {
      if(Link.AnyExist("~ControlDevice",self))
      {
         linkset controllers=Link.GetAll("~ControlDevice",self);

         while(controllers.AnyLinksLeft())
         {
            if(!Link.AnyExist("ScriptParams",self,controllers.Link().To()))
               return(FALSE);
            controllers.NextLink();
         }
         return TRUE;
      }
      else
         return TRUE;
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         DefaultOnMessage();

         if(CheckForAllLinked())
               Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
      else if(MessageIs("TurnOff"))
      {
         if(CheckForAllLinked())
            Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);

         DefaultOnMessage();
      }
      else
         DefaultOnMessage();
   }
END_SCRIPT(TrapRequireAll)


/* Trap keeps track of "TurnOn" and "TurnOff" messages,
   sending a "TurnOn" as soon as any items control linked
   to it have sent "TurnOn" more recently.  When all have most
   recently sent a "TurnOff," so does this trap.  All other
   "TurnOn" and "TurnOff" messages are filtered out.
   */
BEGIN_SCRIPT(TrapRequireAny, TrapRequirement)

METHODS:

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         if(!Link.AnyExist("ScriptParams",self))
               Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);

         DefaultOnMessage();
      }
      else if(MessageIs("TurnOff"))
      {
         boolean waslinked=Link.AnyExist("ScriptParams",self);

         DefaultOnMessage();
         if(waslinked && !Link.AnyExist("ScriptParams",self))
               Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      }
      else
         DefaultOnMessage();
   }
END_SCRIPT(TrapRequireAny)

a4197 333

/* Destroys all objects it controls.  Obviously, this is rather a one-shot trap.
   Destroys itself when it's done, just to be tidy.
 */
BEGIN_SCRIPT(TrapDestroy, RootScript)

MESSAGES:
   OnMessage()
   {
     if(MessageIs("TurnOn"))
     {
       linkset victims=Link.GetAll("ControlDevice",self);
       while(victims.AnyLinksLeft())
       {
          Damage.Slay(victims.Link().To(),self);
          victims.NextLink();
       }
       if (Property.Possessed(self,"AI"))
          Sound.HaltSpeech(self);
       Object.Destroy(self);
     }
   }
END_SCRIPT(TrapDestroy)


       
/* Trap which teleports its controlled object to its own location.
   No response to "TurnOff"
   */
BEGIN_SCRIPT(TrapTeleporter, RootScript)

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         // Let's don't do a Link.GetAll, since I really don't think we
         // want to teleport several objects to the same location...

         if(Link.AnyExist("ControlDevice",self))
         {
            object victim=Link.GetOne("ControlDevice",self).To();

            // Could be that the victim is the player factory.  No
            // way to link to the actual player object in the edtior,
            // after all...
            if(Link.AnyExist("PlayerFactory",victim))
               victim=Object.Named("Player");

            // remove me from whatever container I might be in.
            Container.Remove(victim);
            Object.Teleport(victim,vector(0,0,0),vector(0,0,0),self);
         }
      }
   }  

END_SCRIPT(TrapTeleporter)


/* When triggered, makes its controlled object(s) no longer rotation-
   or location-controlled.  You'd better know what you're doing!
*/
BEGIN_SCRIPT(TrapDeadfall, RootScript)

METHODS:
  METHOD void Uncontrol(object targ)
  {
     if(Property.Possessed(targ,"PhysControl"))
     {
        integer controls=Property.Get(targ,"PhysControl","Controls Active");

        controls &= (~(kCPT_Location|kCPT_Rotation));
        Property.Set(targ,"PhysControl","Controls Active",controls);
     }
  }
MESSAGES:
  OnMessage()
  {
     if(MessageIs("TurnOn"))
     {
        linkset controls=Link.GetAll("ControlDevice",self);

        while(controls.AnyLinksLeft())
        {
           Uncontrol(controls.Link().To());
           controls.NextLink();
        }
        Object.Destroy(self);
     }
  }

END_SCRIPT(TrapDeadfall)




/* Sends a TurnOn if the AI is brain-killed (killed or KO'd)
 */
BEGIN_SCRIPT(TrigBrainDead, AI)
MESSAGES:
   OnAIModeChange()
   {
      // Debug.MPrint(self," changing mode to ",message.mode);
      if (message.mode == kAIM_Dead)
      {
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
      }
      DefaultOnAIModeChange();
   }
END_SCRIPT(TrigBrainDead)




// Script to derive from with basic parsing routines for
// TrapQVar properties.
BEGIN_SCRIPT(QVarTrapTrigBase, RootScript)

METHODS:

   // Overload me.
   METHOD void ProcessOperation(char op, integer arg, string qvar,
                                boolean reverse)
   {
   }

   METHOD void ParseOperation(boolean ReverseSense) 
   {
      string command, qvar;
      integer NameInd, ArgInd, arg=0, sign=1;
      
      if(Property.Possessed(self,"TrapQVar"))
         command=Property.Get(self,"TrapQVar");
      else
         return;
      
      // Search to just after any occurance of ':'
      // we take this to be our Qvar name
      for(NameInd=0;command[NameInd]!=':';NameInd++)
         if(command[NameInd]==0) return;
      NameInd++;

      qvar=(((const char*)command)+NameInd);
      
      // Okay, at this point, our string is at least 1 char long
      // since we found a ':'.  The first char is taken as our
      // opcode, and contiguous digits after the first char
      // are our argument.  If we first find a '-' sign, parse
      // as a negative number.
      
      ArgInd=1;
      if(command[ArgInd]=='-')
      {
         ArgInd=2; sign=-1;
      }            
      for(ArgInd=1;(command[ArgInd]>='0' && command[ArgInd]<='9');ArgInd++)
         arg=(arg*10)+(command[ArgInd]-'0');
      arg*=sign;

      ProcessOperation(command[0],arg,qvar,ReverseSense);
   }

END_SCRIPT(QVarTrapTrigBase)


/*
   The Quest Var trigger subscribes to changes in a given quest
   variable and sends TurnOns and TurnOffs based on whether that
   quest var satisfies a given critereon of equality or inequality.

   The format of the quest var comparator is similar to that of
   quest var operators in Quest Var traps: 
                     <comparator><argument>:<name>
   Where the comparator is a single character indicating the boolean
   comparison to apply to the quest var of the given name, compared
   to the integer value in the argument.

   The comparator can be '>' '<' or '='.  For the time being, assume
   we're going to implement a Shock-style trap flags property with
   a "reverse sense" flag, so we'll then be able to reverse the
   sense of the _trigger_ for <=, >=, and !=.

 */
BEGIN_SCRIPT(TrigQVar, QVarTrapTrigBase)

   /* Process should be called once on begin script to subscribe
      to variable changes and send initial TurnOn/TurnOff consistent
      with quest variable value.
      */
   METHOD void ProcessOperation(char op, integer arg, string qvar, 
                                boolean reverse)
   {
      integer qvarval=Quest.Get(qvar);
      boolean satisfied=FALSE, wassatisfied;

      switch(op)
      {
         case '=': satisfied=(qvarval==arg); break;
         case '>': satisfied=(qvarval>arg); break;
         case '<': satisfied=(qvarval<arg); break;
      }
      if(reverse) satisfied=!satisfied;

      Debug.MPrint("Comparator satisfied? ",satisfied);

      if(!IsDataSet("WasSatisfied"))
      {
         Quest.SubscribeMsg(self,qvar);
         SetData("WasSatisfied",!satisfied); // So we'll _always send initially
      }
      wassatisfied=GetData("WasSatisfied");

      if(satisfied!=wassatisfied)
      {
         Debug.MPrint("sending message");
         if(satisfied)
            Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         else
            Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
      }
      SetData("WasSatisfied",satisfied);
   }

MESSAGES:

   OnBeginScript()
   {
      ParseOperation(FALSE);
      DefaultOnBeginScript();
   }
   OnQuestChange()
   {
      ParseOperation(FALSE);
      DefaultOnQuestChange();
   }

END_SCRIPT(TrigQVar)
/* 
   The Quest Var trap performs some operation on a quest variable
   as specified by an "operator" string property.

   The format of the quest var operator is <op><argument>:<name>
   the op is a single character indicating the operation to apply
   to the quest var of the specified name.  The argument is a single
   non-negative integer argument which us used if the op is a
   binary operator.  Currently-supported ops are:
   
   Let x be the named quest variable, and a be the argument:
   
   Op    Effect of TurnOn     Effect of TurnOff
   
   =     x=a                  none
   !     x|=a                 x&=(~a)
   +     x+=a                 x-=a
   -     x-=a                 x+=a
   *     x*=a                 x/=a (integer!)
   /     x/=a (integer!)      x*=a
   %     x=x mod a            x*=a
   {     x=x<<a (shift left)  x=x>>a (shift right)
   }     x=x>>a (shift right) x=x<<a (shift left)

   Obvious possibilities to be implemented are x+=a, x-=a, etc.
      
*/
BEGIN_SCRIPT(TrapSetQVar, QVarTrapTrigBase)

METHODS:

   METHOD void ProcessOperation(char op, integer arg, string qvar, 
                                boolean reverse)
   {
      integer qvarval=Quest.Get(qvar);

      switch(op)
      {
         case '=':
            if(!reverse) qvarval=arg;
            break;
         case '!':
            if(!reverse)
               qvarval|=arg; // set bits in arg
            else
               qvarval&=(~arg); // unset bits in arg
            break;
         case '-':
            reverse=!reverse; // and fall through
         case '+':
            if(!reverse)
               qvarval+=arg;
            else
               qvarval-=arg;
            break;
         case '%':
            if(!reverse)
            {
               qvarval=(qvarval%arg);
               break;
            }
            // else fall through
         case '/':
            reverse=!reverse; // and fall through
         case '*':
            if(!reverse)
               qvarval*=arg;
            else
               qvarval/=arg;
            break;
         case '{':
            reverse=!reverse; // and fall through
         case '}':
            if(!reverse)
               qvarval=qvarval<<arg;
            else
               qvarval=qvarval>>arg;
            break;
      }      

      Quest.Set(qvar,qvarval);
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
         ParseOperation(FALSE);
      else if(MessageIs("TurnOff"))
         ParseOperation(TRUE);
      DefaultOnMessage();
   }

END_SCRIPT(TrapSetQVar)


a4362 84


/* TrapCapacitor:
	When it receives a "TurnOn", it relays it, then refuses to relay any more 
	"TurnOn" or "TurnOff" messages for X seconds.  After X seconds pass, it 
	relays the most recently received "TurnOn"/"TurnOff" message, if any.

	X is defined by the data hanging off a ScriptParams link from the object
	to itself, or 30.0 by default if that data does not exist.

   @@TODO: This should use the existing ScriptTiming property, not
   the ScriptParams data.
*/

BEGIN_SCRIPT (TrapCapacitor, RootScript)

States
{
	Uncharged,
	Charged
};

METHODS:
float GetCapacitorTime ()
{
	float delay=30.0;

	if (Link.AnyExist("ScriptParams",self,self))
		delay = (float)Link.GetOne("ScriptParams",self,self).GetData();

	return delay;
}

MESSAGES:
OnSim()
{
	if (message.starting)
		SetState(Uncharged);
	DefaultOnSim();
}

OnMessage()
{
	if(!Locked.IsLocked(self))
	{
		if (StateIs((int)Charged))
		{
			if ( (MessageIs("TurnOn")) || (MessageIs("TurnOff")) )
				SetData("LastMsg",message.message);
		}
		else if (StateIs((int)Uncharged))
		{
			if (MessageIs("TurnOn"))
			{
				SetState(Charged);
				Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
				SetOneShotTimer("Decharge",GetCapacitorTime());
				SetData("LastMsg","NONE");
			}
			else if (MessageIs("TurnOff"))
			{
				Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
			}
		}
	}
	DefaultOnMessage();
}

OnTimer()
{
	if (message.name == "Decharge")
	{
		SetState(Uncharged);

		if (GetData("LastMsg") != "NONE")
		{
			Link.BroadcastOnAllLinks(self,GetData("LastMsg"),"ControlDevice",NULL);
		}
	}

	DefaultOnTimer();
}

END_SCRIPT (TrapCapacitor)
@



1.10
log
@Tweq models on extinguishables don't break in the absence of a model 5.
Side effects on levers don't chain react.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.9 1999/08/03 20:18:42 rsmith Exp $
d544 70
a2382 3
           // use with caution: relaying messages like
           // this put you in peril of cycles.
           Link.BroadcastOnAllLinks(self,message.message,"ControlDevice",NULL);
d2741 26
d3358 17
d4513 22
d4576 1
a4576 1
      if(!Locked.IsLocked(self))
d4578 7
a4584 4
         if(MessageIs("TurnOn"))
            Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
         else if(MessageIs("TurnOff"))
            Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
d4595 1
a4595 1
      if(!Locked.IsLocked(self))
d4597 3
a4599 1
         integer percent_filter=100;
d4601 2
a4602 2
         if(Property.Possessed(self,"scriptTiming"))
            percent_filter=Property.Get(self,"scriptTiming");
d4604 3
a4606 2
         if(Data.RandFlt0to1()<=(float(percent_filter)/100.0))
            Link.BroadcastOnAllLinks(self,message.message,"ControlDevice",NULL);
d4617 1
a4617 1
      if(!Locked.IsLocked(self))
d4619 5
a4623 2
         if(MessageIs("TurnOn"))
            Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
d5164 20
a5261 4
      Debug.MPrint("Calling process on ",op,arg,":",qvar,", reverse=",reverse);

      if(!Quest.Exists(qvar)) return;

a5340 2
      if(!Quest.Exists(qvar)) return;

d5577 3
@



1.9
log
@Added "WorkerRobot" script and "TrapCapacitor" script.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.8 1999/07/31 12:33:22 TJS Exp $
d863 5
a867 1
            deadmodel=Property.Get(self,"CfgTweqModels","Model 5");
d2368 1
a2368 1
     METHOD void TweqActivate()
a2381 1
        Link.BroadcastOnAllLinks(self,"Toggle","ScriptParams","SideEffect");
d2384 12
d2405 1
d2418 6
@



1.8
log
@Added MapSupplement script.
Added SideEffect link for StdTwoState.
Added TurnOn/TurnOff behavior to activate and deactivate cameras.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.7 1999/07/22 09:12:02 TJS Exp $
d5290 182
@



1.7
log
@Extended operations in quest var traps.
Added Quest var triggers.
Moved cameras and turrets to the trap/trigger section, and modified
turret behavior somewhat.
Added randomization to CollisionStick script.
Added scripts for flares and victrolas.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.5 1999/07/16 09:20:33 TJS Exp $
d227 1
d231 1
a231 1
          
d239 3
a241 4
          if(Property.Possessed(otherdoor,"Locked"))
          {
             Property.Set(self,"Locked",Property.Get(otherdoor,"Locked"));
          }
d517 28
a2370 2
           // Debug.MPrint("Event on ",self," generating tags:",tags);

d2378 1
d2390 1
a2390 1
        Link.BroadcastOnAllLinks(self,"SynchUp","~FrobProxy");
a2392 1

a2396 1
        {
a2397 1
        }
a2398 1
        {
d2400 2
a2401 1
        }
d2412 1
d4811 4
d4816 6
d4825 10
a4834 1
      string model=Property.Get(self,"ModelName");
a4835 15
         if(message.level==kHighAlert)
         {
            Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         }
         else if(message.oldLevel==kHighAlert)
         {
            Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
         }

         if(Property.Possessed(self,"CfgTweqModels"))
            model=Property.Get(self,"CfgTweqModels",
                               string("Model ")+string(message.level+1));

         Property.Set(self,"ModelName",(const char*)model);

d4842 1
a4842 3
      if(Property.Possessed(self,"CfgTweqModels"))
         Property.Set(self,"ModelName",
                      Property.Get(self,"CfgTweqModels","Model 0"));
d4845 19
d5289 1
@



1.6
log
@Added script to regulate turret alertness via TurnOn and TurnOff.
@
text
@d320 2
a321 2
              // Debug.MPrint("Setting combine type on ",self," to ",combine);

d1691 5
d1702 2
d1722 4
a1725 1
      return TRUE;
d2772 89
a3356 1
   Cameras green-yellow-red swapping and triggers.
d3359 1
a3362 73
/* Cameras send a "TurnOn" when they reach high alertness,
   and a "TurnOff" when they stand down from high alertness.
   They also animate their models to reflect alertness,
   and when slain.  The TweqModels config property is used to
   parametrize the models used (so, cameras which use TweqModels
   animation are not supported).  Model number 0 is used for the
   dead camera, while 1 and up are used for alertness levels.
   */
BEGIN_SCRIPT(CameraAlert, AI)

MESSAGES:
   OnAlertness()
   {
      string model=Property.Get(self,"ModelName");

         if(message.level==kHighAlert)
         {
            Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
         }
         else if(message.oldLevel==kHighAlert)
         {
            Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
         }

         if(Property.Possessed(self,"CfgTweqModels"))
            model=Property.Get(self,"CfgTweqModels",
                               string("Model ")+string(message.level+1));

         Property.Set(self,"ModelName",(const char*)model);

      DefaultOnAlertness();
   }
   /* Note that if a camera is slain while at Alertness 3, it can
      never send the all-clear "TurnOff".  This is intentional. */
   OnSlain()
   {
      if(Property.Possessed(self,"CfgTweqModels"))
         Property.Set(self,"ModelName",
                      Property.Get(self,"CfgTweqModels","Model 0"));
      DefaultOnSlain();
   }
END_SCRIPT(CameraAlert)


/* Turrets' alertness is controlled by external sensors, such as cameras
   or other triggers.   When a turret gets a "TurnOn," it goes to high
   alertness and stays there.  When it gets a "TurnOff," it goes to low
   alertness and stays _there_.
*/
BEGIN_SCRIPT(TurretAlert, RootScript)

METHODS:
   METHOD void ClampAlert(integer alert)
   {
      Property.Set(self,"AI_AlertCap","Min level",alert);
      Property.Set(self,"AI_AlertCap","Max level",alert);
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         ClampAlert(kHighAlert);
      }
      else if(MessageIs("TurnOff"))
      {
         ClampAlert(kNoAlert);
      }
      DefaultOnMessage();
   }

END_SCRIPT(TurretAlert)
d3751 1
a3751 1
      // Debug.MPrint(self," dying.  Culprit is ",slayer);
d4777 85
d4955 127
d5100 3
d5109 1
a5109 1
BEGIN_SCRIPT(TrapSetQVar, RootScript)
d5111 4
a5114 2
MESSAGES:
   OnMessage()
d5116 1
a5116 6
      if(MessageIs("TurnOn") || MessageIs("TurnOff"))
      {
         string command;
         integer NameInd, ArgInd, arg=0, qvarval;
         char op;
         boolean on=MessageIs("TurnOn");
d5118 1
a5118 8
         if(Property.Possessed(self,"TrapQVar"))
            command=Property.Get(self,"TrapQVar");
         
         // Search to just after any occurance of ':'
         // we take this to be our Qvar name
         for(NameInd=0;command[NameInd]!=':';NameInd++)
            if(command[NameInd]==0) return;
         NameInd++;
d5120 43
a5162 1
         qvarval=Quest.Get(((const char*)command)+NameInd);
d5164 2
a5165 6
         // Okay, at this point, our string is at least 1 char long
         // since we found a ':'.  The first char is taken as our
         // opcode, and contiguous digits after the first char
         // are our argument.
         for(ArgInd=1;(command[ArgInd]>='0' && command[ArgInd]<='9');ArgInd++)
            arg=(arg*10)+(command[ArgInd]-'0');
d5167 9
a5175 29
         op=command[0];
         switch(op)
         {
            case '=':
               if(on) qvarval=arg;
               break;
            case '!':
               if(on)
                  qvarval|=arg; // set bits in arg
               else
                  qvarval&=(~arg); // unset bits in arg
               break;
            case '-':
               on=!on; // and fall through
            case '+':
               if(on)
                  qvarval+=arg;
               else
                  qvarval-=arg;
               break;
            case '{':
               on=!on; // and fall through
            case '}':
               if(on)
                  qvarval=qvarval<<arg;
               else
                  qvarval=qvarval>>arg;
               break;
         }
a5176 3
         Quest.Set(((const char*)command)+NameInd,qvarval);
      }
   }
@



1.5
log
@Added a bunch of new ops to the quest var trap.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.4 1999/07/15 15:59:12 TJS Exp $
d3308 6
d3315 22
@



1.4
log
@Changed Extinguishable script to use TweqModels for the "dead" torch
instead of hardcoding it, so we can have more than one kind.

Added CameraAlert script, heavily based on the analogous script in
System Shock 2.
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.3 1999/07/06 14:28:31 TJS Exp $
a4815 2


d4832 4
a4853 12
         else
         {
            // For temporary back-compatibility to previous hacked way
            // of doing this, try reading the DesignNote instead.  But warn.

            if(!Property.Possessed(self,"DesignNote"))
               return;

            Debug.MPrint("Note fullwise: Quest var trap ",self,
                         " using non-kosher property settings.");
            command=Property.Get(self,"DesignNote");
         }
d4871 1
a4871 3
         if(op=='=' && on)            
            qvarval=arg;
         else if(op=='!')
d4873 25
a4897 4
            if(on)
               qvarval|=arg; // set bits in arg
            else
               qvarval&=(~arg); // unset bits in arg
a4898 1
         // @@TODO: And so on for '+', '-', what have you.
@



1.3
log
@Added TrapPatrol
@
text
@d2 1
a2 1
// $Header: r:/prj/thief2/scripts/src/rcs/gen.scr 1.2 1999/07/05 15:08:25 TJS Exp $
d11 2
a12 1
#include "aitype.h" // for alertness levels
d22 4
d804 13
a816 2
// really, this script is specific to torches, not Extinguishable
// lights in general...
d829 2
d834 4
a837 2
         // @@TODO: don't really want the model new model name coded into this
         ActReact.React("set_model",1.0,self,0,"Newt01");
d3258 1
d3262 46
@



1.2
log
@Added synchronization code for double doors and frob proxied levers,
changed object creation code for rope arrow deployment to deal
with bit rot which broke the teleportation to initial position.
@
text
@d2 1
a2 1
// $Header: r:/prj/cam/scripts/src/RCS/gen.scr 1.204 1998/12/08 16:58:26 TJS Exp $
d4246 24
@



1.1
log
@Initial revision
@
text
@d65 6
d76 13
d114 1
d120 1
d148 1
d154 1
d220 18
d242 1
d1833 1
a1833 1
         object MyRope=Object.Create("RopeArrowRope");
d1838 1
d2321 1
d2333 1
d2350 8
@

