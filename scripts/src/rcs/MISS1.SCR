head	 1.35;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.35
date	 2000.03.06.23.13.23;  author TJS;  state Exp;
branches ;
next	 1.34;

1.34
date	 2000.03.05.21.30.58;  author TJS;  state Exp;
branches ;
next	 1.33;

1.33
date	 2000.03.03.17.34.25;  author TJS;  state Exp;
branches ;
next	 1.32;

1.32
date	 2000.02.27.22.50.46;  author TJS;  state Exp;
branches ;
next	 1.31;

1.31
date	 2000.02.22.06.02.02;  author TJS;  state Exp;
branches ;
next	 1.30;

1.30
date	 2000.02.19.15.02.47;  author TJS;  state Exp;
branches ;
next	 1.29;

1.29
date	 2000.02.19.14.27.57;  author TJS;  state Exp;
branches ;
next	 1.28;

1.28
date	 2000.02.18.22.49.36;  author TJS;  state Exp;
branches ;
next	 1.27;

1.27
date	 2000.02.18.22.39.33;  author TJS;  state Exp;
branches ;
next	 1.26;

1.26
date	 2000.02.18.20.27.32;  author TJS;  state Exp;
branches ;
next	 1.25;

1.25
date	 2000.02.15.19.41.25;  author TJS;  state Exp;
branches ;
next	 1.24;

1.24
date	 2000.02.15.14.47.44;  author TJS;  state Exp;
branches ;
next	 1.23;

1.23
date	 2000.02.14.20.20.37;  author TJS;  state Exp;
branches ;
next	 1.22;

1.22
date	 2000.02.13.22.12.22;  author TJS;  state Exp;
branches ;
next	 1.21;

1.21
date	 2000.02.13.21.36.33;  author TJS;  state Exp;
branches ;
next	 1.20;

1.20
date	 2000.02.08.18.37.22;  author TJS;  state Exp;
branches ;
next	 1.19;

1.19
date	 2000.02.06.11.52.43;  author TJS;  state Exp;
branches ;
next	 1.18;

1.18
date	 2000.02.04.11.35.40;  author TJS;  state Exp;
branches ;
next	 1.17;

1.17
date	 2000.02.02.23.59.43;  author TJS;  state Exp;
branches ;
next	 1.16;

1.16
date	 2000.02.02.22.49.38;  author TJS;  state Exp;
branches ;
next	 1.15;

1.15
date	 2000.02.01.18.55.18;  author TJS;  state Exp;
branches ;
next	 1.14;

1.14
date	 2000.01.31.21.58.02;  author TJS;  state Exp;
branches ;
next	 1.13;

1.13
date	 2000.01.28.19.04.46;  author TJS;  state Exp;
branches ;
next	 1.12;

1.12
date	 2000.01.28.18.36.16;  author TJS;  state Exp;
branches ;
next	 1.11;

1.11
date	 2000.01.28.17.54.03;  author TJS;  state Exp;
branches ;
next	 1.10;

1.10
date	 2000.01.27.23.08.04;  author TJS;  state Exp;
branches ;
next	 1.9;

1.9
date	 2000.01.27.21.57.20;  author TJS;  state Exp;
branches ;
next	 1.8;

1.8
date	 2000.01.27.17.45.35;  author TJS;  state Exp;
branches ;
next	 1.7;

1.7
date	 2000.01.26.19.11.10;  author TJS;  state Exp;
branches ;
next	 1.6;

1.6
date	 2000.01.14.18.26.15;  author TJS;  state Exp;
branches ;
next	 1.5;

1.5
date	 2000.01.10.19.34.33;  author TJS;  state Exp;
branches ;
next	 1.4;

1.4
date	 2000.01.04.20.26.44;  author TJS;  state Exp;
branches ;
next	 1.3;

1.3
date	 1999.12.29.13.35.01;  author TJS;  state Exp;
branches ;
next	 1.2;

1.2
date	 1999.08.03.12.04.39;  author TJS;  state Exp;
branches ;
next	 1.1;

1.1
date	 1999.07.21.14.42.30;  author TJS;  state Exp;
branches ;
next	 ;


desc
@Mission-1-specific scripts.
@


1.35
log
@Fix scoring of escape objective.
@
text
@#include "drkgoalt.h"
#include "invtype.h"

#define GOAL_ESCAPE 1
#define GOAL_SIGNAL 0

#define WEAP_UI_QVAR "WeapUI"
#define WEAP_ID_QVAR "WeapID"
#define INV_UI_QVAR "InvUI"
#define INV_ID_QVAR "InvID"
#define WORLD_ID_QVAR "WorldID"
#define kUnready 0
#define kReady 1
#define kCocked 2


BEGIN_SCRIPT(ExtractionZone, Room)

METHODS:

   METHOD void PopulationCheck(object mover, boolean enter)
   {
      integer goalstate;

      goalstate=Quest.Get(GoalStateVarName(GOAL_ESCAPE));
      // Don't change a failed or cancelled goal
      if(goalstate==kGoalFailed || goalstate==kGoalInactive)
         return;

      if(mover==object("Basso")) Quest.Set("BassoOK",enter);
      else if(mover==object("Jenivere")) Quest.Set("JenOK",enter);
      else if(mover==object("Player")) Quest.Set("PlayerOK",enter);

      if(Quest.Get("PlayerOK") && Quest.Get("BassoOK") && Quest.Get("JenOK"))
         goalstate=kGoalComplete;
      else
         goalstate=kGoalIncomplete;

      Quest.Set(GoalStateVarName(GOAL_ESCAPE),goalstate);
   }

MESSAGES:
   OnCreatureRoomEnter()
   {
      PopulationCheck(message.MoveObjId,TRUE);
      DefaultOnCreatureRoomEnter();
   }
   OnCreatureRoomExit()
   {
      PopulationCheck(message.MoveObjId,FALSE);
      DefaultOnCreatureRoomExit();
   }
   OnPlayerRoomEnter()
   {
      PopulationCheck(message.MoveObjId,TRUE);
      DefaultOnPlayerRoomEnter();
   }
   OnPlayerRoomExit()
   {
      PopulationCheck(message.MoveObjId,FALSE);
      DefaultOnPlayerRoomExit();
   }

END_SCRIPT(ExtractionZone)

/* Basso and Jenivere must remain awake if they're to Escape.
   If they're knocked out or killed, fail the goal.
   */
BEGIN_SCRIPT(AwakeToEscape, AI)
MESSAGES:
   OnAIModeChange()
   {
      if(message.mode==kAIM_Dead)
         Quest.Set(GoalStateVarName(GOAL_ESCAPE),kGoalFailed);
      DefaultOnAIModeChange();
   }
END_SCRIPT(AwakeToEscape)

/* This sets up Jenivere's watch links that make her follow Basso.
 */
BEGIN_SCRIPT(Jenivere, RootScript)
MESSAGES:
   OnMessage()
   {
      if(MessageIs("FollowBasso"))
      {
         object basso=object("Basso");

         Debug.MPrint("Basso=",basso);

         if(basso!=object(0))
         {
            integer follow=0;
            for(;follow<666;follow++)
            {
               object metaprop=object(string("M-Follow")+string(follow));
               if(metaprop!=object(0))
               {
                  Debug.MPrint("Adding metaprop follow (",metaprop,")");
                  // Metaproperty has the watch links default property that
                  // is appropriate to this link in the sequence.  Add meta-
                  // property just long enough to initialize link data correctly.
                  Object.AddMetaProperty(basso,metaprop);
                  Link.Create("AIWatchObj",self,basso);
                  Object.RemoveMetaProperty(basso,metaprop);
               }
               else
                  follow=666;
            }
         }
         // and ALWAYS continue conversation.
         Reply(TRUE);
      }
      else if(MessageIs("SeeBasso"))
      {
         // Start conversation
         if(Link.AnyExist("~AIConversationActor",self))
         {
            object conv=Link.GetOne("~AIConversationActor",self).To();
            Debug.MPrint("Trying to start conversation ",conv);
            AI.StartConversation(conv);
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(Jenivere)


         
/* TRAINING SCRIPTS:
   Scripts from this point below are for coordinating the various messages to
   prompt the player through the training encounters.  In general, none of them
   act on Hard or Expert difficulty.
   */



/* We put this script on each object as it comes into inventory
   (this way, even objects created at run-time, like the arrows
   produced by crystals, should work).
   */
BEGIN_SCRIPT(TrackInv, RootScript)

METHODS:
   METHOD integer InvType()
   {
      integer type=kInvTypeJunk;

      if(Property.Possessed(self,"InvType"))
         type=Property.Get(self,"InvType");
      return(type);
   }
   METHOD void SetUI(integer state)
   {
      integer type=InvType();

      if(type==kInvTypeWeapon)
         Quest.Set(WEAP_UI_QVAR,state);
      else
         Quest.Set(INV_UI_QVAR,state);
   }
   METHOD void SetID(object obj)
   {
      integer type=InvType();

      if(type==kInvTypeWeapon)
         Quest.Set(WEAP_ID_QVAR,obj);
      else
         Quest.Set(INV_ID_QVAR,obj);
   }
MESSAGES:
   OnFrobInvBegin()
   {
      if (message.Abort)
         // aborting attack
         SetUI(kReady);
      else if(InvType()==kInvTypeWeapon)
         // beginning attack
         SetUI(kCocked);

      if(Object.InheritsFrom(self,"Flare"))
         Quest.Set("tr_UseFlareLight",TRUE,kQuestDataCampaign);

      DefaultOnFrobInvBegin();
   }
   OnFrobInvEnd()
   {
      SetUI(kReady);
      DefaultOnFrobInvEnd();
   }
   OnFrobToolEnd()
   {
      SetUI(kReady);
      DefaultOnFrobToolEnd();
   }
   OnInvSelect()
   {
      SetID(self);
      SetUI(kReady);
      DefaultOnInvSelect();
   }

/* Other arrow scripts seem to count on getting deselect for one weapon
   before select for another, so we do too.
   */
   OnInvDeSelect()
   {
      SetUI(kUnready);
      SetID(OBJ_NULL);
      DefaultOnInvDeSelect();
   }

   OnInvFocus()
   {
      SetID(self);
      SetUI(kReady);
      DefaultOnInvFocus();
   }

   OnInvDeFocus()
   {
      SetUI(kUnready);
      SetID(OBJ_NULL);
      DefaultOnInvDeFocus();
   }

// @@TODO: This is not really right.  It's just barely possible for 
// an inventory item that isn't your current one to get destroyed, which
// would queer this.
   OnDestroy()
   {
      SetUI(kUnready);
      SetID(OBJ_NULL);
      BaseOnDestroy();
   }

   OnSlain()
   {
      if(Object.InheritsFrom(self,"FlashBomb") &&
         Link.AnyExist("~Firer",self))
      {
         Quest.Set("tr_DropOrUseFlashBomb",TRUE,kQuestDataCampaign);
         Quest.Set("tr_DropFlashBomb",TRUE,kQuestDataCampaign);
      }
      DefaultOnSlain();
   }


END_SCRIPT(TrackInv)

/* We put this on ALL world objects that can be world-frobbed, at startup,
   because we're just _that_ crazy.  Note that this means that we shouldn't
   count on knowing about world focus on objects that get created at run-time.
   Should be okay.

   Note that this will also require us to set the World focus frob info bits
   on all these things as we put the script on them, which means their FrobInfo
   will be instantiated and any metaproperties with frobinfo that are added
   at runtime will be ignored.  This too should be okay.
   */
BEGIN_SCRIPT(TrackWorldObj,RootScript)
METHODS:
   METHOD void NotMeWorld()
   {
      if(Quest.Get(WORLD_ID_QVAR)==self)
      {
         Quest.Set(WORLD_ID_QVAR,0);
      }
   }
MESSAGES:
   OnWorldSelect()
   {
      Quest.Set(WORLD_ID_QVAR,self);
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      Quest.Set(WORLD_ID_QVAR,0);
      DefaultOnWorldDeSelect();
   }
   OnDestroy()
   {
      NotMeWorld();
      BaseOnDestroy();
   }
   OnContained()
   {
      if(message.event!=kContainRemove)
      {
         NotMeWorld();
      }
      DefaultOnContained();
   }
END_SCRIPT(TrackWorldObj)


BEGIN_SCRIPT(TrackDoor, Door)
METHODS:
   METHOD void Ping()
   {
      object player=object("Player"); // gruesomely single-player
      // for the time being, let's assume the player doesn't care about
      // state changes in doors that are not his world focus.  Cut down
      // on the flurry of messages.
      if(object(self)!=object(Quest.Get(WORLD_ID_QVAR)))
         return;
      if(player!=object(0))
      {
         PostMessage(player,"Prompt");
      }
   }

MESSAGES:
   OnDoorHalt()
   {
      Ping();
      DefaultOnDoorHalt();
   }
   OnDoorOpen()
   {
      Ping();
      DefaultOnDoorOpen();
   }
   OnDoorOpening()
   {
      // Basso doesn't close doors behind himself.  He does this by forgetting
      // that they weren't open in the first place.
      if(Link.AnyExist("AIDoor","Basso",self))
      {
         link doorlink=Link.GetOne("AIDoor","Basso",self);
         doorlink.SetData(FALSE);
      }
      Ping();
      DefaultOnDoorOpening();
   }
   OnDoorClose()
   {
      Ping();
      DefaultOnDoorClose();
   }
   OnDoorClosing()
   {
      Ping();
      DefaultOnDoorClosing();
   }
   OnNowLocked()
   {
      Ping();
      DefaultOnNowLocked();
   }
   OnNowUnlocked()
   {
      Ping();
      DefaultOnNowUnlocked();
   }
   OnFrobWorldEnd()
   {
      integer state=Door.GetDoorState(self);
      object frobr=message.Frobber;

      if(!Locked.IsLocked(self))
      {
         if(Object.InheritsFrom(frobr,"Avatar")) // frobbed by player
         {
            if(state==kDoorOpen || state==kDoorOpening)
               // Closed the door.  Score it.
               Quest.Set("tr_UseDoorClose",TRUE,kQuestDataCampaign);
            else
               Quest.Set("tr_UseDoorOpen",TRUE,kQuestDataCampaign);
         }
      }
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(TrackDoor)


BEGIN_SCRIPT(PromptOnTrig, RootScript)
MESSAGES:
   OnMessage()
   {
      object player=object("Player");
      if(player!=object(0))
         PostMessage(player,"Prompt");
      DefaultOnMessage();
   }
END_SCRIPT(PromptOnTrig)

/* To score, e.g. the water arrow lesson.  Sets the training quest var
   specified in the object's TrapQVar property, and _then_ messages to
   renew the training prompt.
   */
BEGIN_SCRIPT(ScoreLesson, PromptOnTrig)
MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         if(Property.Possessed(self,"TrapQVar"))
         { 
            string qvar=Property.Get(self,"TrapQVar");
            Quest.Set(qvar,TRUE,kQuestDataCampaign);
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(ScoreLesson)


/* To do this, we're going to need to get events about _anything_
   that we factor into our decision that is liable to change in-
   mission.  So far, that includes:
   * Current world focus object (Brute-force iterate through all 
     objects at beginning of mission and add scripts and world 
     select script bits to anything that can be world frobbed.
     Ugly, but functional.)
   * Current inventory focus object [null if inactive?].
     (except for inactive inv object, could just slam a script on
     each object as it comes into inventory.  The inactive object thing
     we have NO!!! way of doing yet.).
   * Whether current inventory item is positioned for tool frob or not
     (redundant frob event state machine in script?)
   * Current weapon. (ditto).
   * Wheather current weapon is pulled back. (ditto).
   * Whether world focus object is locked. (see below).
   * Door open state of world focus object (if a door).  (When we are
     putting scripts on all world objects, doors get a special one that
     pings about state changes and lock/unlock state changes).
   * Contents of player's inventory (use OnContainer message).
   * Event when player brings up the map (NO!!! way to do it yet).
   * Presence of a AI eligible for blackjacking in front of the player.
     (NO!! way to do it yet).
   * Player's hit points (use OnDamage message).
   * Player's position in relation to certain marks (script on marks).
   */

#define NO_OBJ object(0)


const integer kM1TipNone=0;
const integer kM1TipCheckMap=1;
const integer kM1TipCheckVisGem=2;
const integer kM1TipVictoryNewgoal=3;
const integer kM1TipVictoryDonegoal=4;

BEGIN_SCRIPT(Training, RootScript)
  METHODS:
    /* Many things will want to know if your current inventory item is a
       tool, since this _can_ prevent world frobs.  It doesn't prevent
       world frobs to pick things up, however, because we're idiots
       with a gruesome highly contextual interface.
       */
    METHOD boolean IsTool(object obj)
    {
       if(obj==NO_OBJ) return FALSE;
       if(Property.Possessed(obj,"FrobInfo"))
       {
          integer tool=Property.Get(obj,"FrobInfo","Tool Action");
          return(tool!=0);
       }
       return FALSE;
    }
    METHOD boolean ObjContainsAny(object obj, object type)
    {
       if(obj!=NO_OBJ && type!=NO_OBJ)
       {
          linkset contlinks=Link.GetAll("Contains",obj);
          while(contlinks.AnyLinksLeft())
          {
             if(Object.InheritsFrom(contlinks.Link().To(),type))
                return TRUE;
             contlinks.NextLink();
          }
       }
       return FALSE;
    }
    /* Action is the full description of the action to be attempted (e.g.
       "USE Door to open"), while Key describes only the interface binding
       to be prompted (e.g. the identity of the USE key).

       The quest variable tracking successful completion of the lesson
       is derived from the name of the Action string by prepending "tr_".
       */
    METHOD boolean LessonDone(const string ref Action)
    {
       integer difficulty=Quest.Get("difficulty");
       boolean done=(difficulty>0) || Quest.Get(string("tr_")+Action);

       return done;
    }
    /* Returns FALSE if this lesson has already been done (meaning we did
       nothing) and TRUE otherwise.
       */
    METHOD boolean DoLesson(const string ref Action, const string ref Key,
                            const string ref Key2=string(""),
                            const string ref Key3=string(""))
    {
       string DisplayOutput = "";
       string Command = Data.GetString("PlayCmd",Key+"_command");
       string Command2 = Data.GetString("PlayCmd",Key2+"_command");
       string Command3 = Data.GetString("PlayCmd",Key3+"_command");
       boolean done=LessonDone(Action);

       // Debug.MPrint("Call DoLesson ",Action);
       
       if(!done)
       {
          if (Key!="" && DarkUI.IsCommandBound(Command))
          {
             /* Build string of the form (e.g.) "USE = Mouse2" */
             DisplayOutput = Data.GetString("PlayAct",Key) + " = "
                           + DarkUI.DescribeKeyBinding(Command);
          }
          if (Key2!="" && DarkUI.IsCommandBound(Command2))
             DisplayOutput = DisplayOutput + "\n"
                           + Data.GetString("PlayAct",Key2) + " = "
                           + DarkUI.DescribeKeyBinding(Command2);
          if (Key3!="" && DarkUI.IsCommandBound(Command3))
             DisplayOutput = DisplayOutput + "\n"
                           + Data.GetString("PlayAct",Key3) + " = "
                           + DarkUI.DescribeKeyBinding(Command3);
          /* Tack string descriptive of action in question on front */
          DisplayOutput = Data.GetString("PlayHint",Action)
                          + DisplayOutput;
          DarkUI.TextMessage(DisplayOutput,rgb(255,0,0),30000);
          SetData("LessonTime",GetTime());
          return TRUE;
       }
       else
       {
          // Debug.MPrint("Already done lesson: ",Action);
          return FALSE;
       }
    }

    METHOD void TransientTip(integer tip)
    {
       SetData("Tip",tip);
    }
    METHOD boolean TrainTransientTip(void)
    {
       integer tip=kM1TipNone;

       if(IsDataSet("Tip"))
          tip=integer(GetData("Tip"));
       if(tip==kM1TipCheckMap)
       {
          DoLesson("CheckMap","Map","");
       }
       else if(tip==kM1TipCheckVisGem)
       {
          DoLesson("VisGem","","");
       }
       else if(tip==kM1TipVictoryNewgoal)
       {
          string DisplayOutput=Data.GetString("PlayHint","NewGoal");
          DarkUI.TextMessage(DisplayOutput);
          SetOneShotTimer(self,"TipClear",5.0);
       }
       else if(tip==kM1TipVictoryDonegoal)
       {
          string DisplayOutput=Data.GetString("PlayHint","DoneGoal");
          DarkUI.TextMessage(DisplayOutput);
          SetOneShotTimer(self,"TipClear",5.0);
       }
       else return FALSE;
    
       // Keep tip up for at least 5 seconds.
       SetData("TipLock",TRUE);
       SetOneShotTimer(self,"TipUnlock",5.0);
       return TRUE;
    }
    METHOD boolean TrainHealing (object world, object inv, object weap)
    {
      integer hp=Property.Get(self,"HitPoints");
      integer max=Property.Get(self,"MAX_HP");

      if(world==NO_OBJ &&
         Object.InheritsFrom(inv,"HealingPotion") &&
         hp<max)
        return DoLesson("UsePotionHeal","Use");
      return FALSE;
    }
    METHOD boolean ObjPortable(object world)
    {
       if(world!=NO_OBJ &&
          Property.Possessed(world,"FrobInfo"))
       {
          integer worldfrob=Property.Get(world,"FrobInfo","World Action");
          if(worldfrob & kFrobMove)
          {
             if(Link.AnyExist("~Contains",world))
             {
                object container=Link.GetOne("~Contains",world).To();
                integer aware=kAIAL_Lowest;

                Debug.MPrint("Checking portability given container ",container);
                Debug.MPrint("Player object=",object("Player"));

                if(Property.Possessed(container,"AI"))
                {
                   if(Link.AnyExist("AIAwareness",container,self))
                      aware=Link.GetOne("AIAwareness",container,self).GetData("Level");

                   if(aware==kAIAL_Lowest)
                      return TRUE;
                   else
                      return FALSE;
                }
             }
             return TRUE;
          }
       }
       return FALSE;
    }
    // @@TODO: We don't score the pickpocketing lesson, nor update our
    // lesson when AI awareness changes.
    METHOD boolean TrainPickpocket (object world, object inv, object weap)
    {
       if(ObjPortable(world) && Link.AnyExist("~Contains",world))
       {
          // For one frame after picking things up, this could be an item
          // now in _our_ inventory.  So, check that.
          if(Object.InheritsFrom(Link.GetOne("~Contains",world).To(),"Creature"))
             return DoLesson("UsePickpocket","Use");
       }
       return FALSE;
    }
    // In general, objects you can pick up are a single lesson.  However,
    // we have a lesson about keys and loot specifically, to drive these
    // important cases home. 
    METHOD boolean TrainPickUpKey (object world, object inv, object weap)
    {
       if(ObjPortable(world) && Object.InheritsFrom(world,"Key"))
          return DoLesson("UseKeyTake","Use");
       return FALSE;
    }
    METHOD boolean TrainGetLoot (object world, object inv, object weap)
    {
       if(ObjPortable(world) && Property.Possessed(world,"Loot"))
          return DoLesson("UseLootTake","Use");
       return FALSE;
    }
    METHOD boolean TrainPortable (object world, object inv, object weap)
    {
       if(ObjPortable(world))
          return DoLesson("UsePortable","Use");
       return FALSE;
    }
       
    /* How to train flash bombs?  Seems impossible to tell whether AIs
       stand to be affected, which kind of blows.
       */

    METHOD boolean TrainUseFlash (object world, object inv, object weap)
    {
       if(Object.InheritsFrom(inv,"FlashBomb"))
       {
          if(world!=NO_OBJ)
             return DoLesson("DropFlashBomb","Drop");
          else
             return DoLesson("DropOrUseFlashBomb","Drop","Use");
       }
       return FALSE;
    }

    METHOD boolean TrainUseFlare (object world, object inv, object weap)
    {
       if(Object.InheritsFrom(inv,"LitFlare"))
          if(world!=NO_OBJ)
             return DoLesson("DropFlare","Drop");
          else
             return DoLesson("DropOrUseFlare","Drop","Use");
       else if(Object.InheritsFrom(inv,"Flare"))
          if(world==NO_OBJ)
             return DoLesson("UseFlareLight","Use");
       return FALSE;
    }

    METHOD boolean IsKeyFrom(object parent, object targ)
    {
       if(Property.Possessed(parent,"KeySrc"))
          return(Key.TryToUseKey(parent,targ,kKeyUseCheck));
       else
       {
          linkset descend=Link.GetAll("~MetaProp",parent);
          while(descend.AnyLinksLeft())
          {
             // We loves recursion.
             if(IsKeyFrom(descend.Link().To(),targ))
                return TRUE;
             descend.NextLink();
          }
          return FALSE;
       }
    }
    /* How the heck do we do the map lesson?
       What about the light gem lesson?  Do we just score it complete N
       seconds after putting it up?
       */
    METHOD boolean TrainLockedDoor (object world, object inv, object weap)
    {
       boolean keyfit=Key.TryToUseKey(inv,world,kKeyUseCheck);

       if(keyfit)
       {
          // @@TODO: Check whether key is in frob position
          return DoLesson("UseKeyUnlock","Use");
       }
       else
       {
          linkset invlinks=Link.GetAll("Contains",self);
          while(!keyfit && invlinks.AnyLinksLeft())
          {
             keyfit=Key.TryToUseKey(invlinks.Link().To(),world,kKeyUseCheck);
             invlinks.NextLink();
          }
          if(keyfit) // some key in inventory fits
          {
             return DoLesson("SelectKey","CycleInventory","Countercycle");
          }
          else
          {
             // Oh, Jesus, now we have to check if there even _is_ a key.
             if(IsKeyFrom("Key",world) &&
                world != object("JenivereDoor"))
                return DoLesson("GoFindKey","");
             else
                return DoLesson("NoKeyDoor","");
          }
       }
    }
    METHOD boolean IsDoor(object obj)
    {
       if(obj==NO_OBJ) return FALSE;
       return(Property.Possessed(obj,"RotDoor") ||
              Property.Possessed(obj,"TransDoor"));
    }
   METHOD boolean TrainDoor (object world, object inv, object weap)
   {
      if(IsDoor(world))
      {
         integer state=Door.GetDoorState(world);
         
         Debug.MPrint(world," is a door, state ",state);
         
         if(Locked.IsLocked(world) && TrainLockedDoor(world, inv, weap))
            return TRUE;
         if(IsTool(inv))
         {
            // If tool is a key that fits, tell us that we can _lock_
            // doors with keys.
            if(Key.TryToUseKey(inv,world,kKeyUseCheck))
               return DoLesson("UseKeyLock","Use");
            else
               return DoLesson("SelectNonTool","Use","CycleInventory","Countercycle");
         }
         if(state==kDoorOpen || state==kDoorOpening) 
            return DoLesson("UseDoorClose","Use");
         else
            return DoLesson("UseDoorOpen","Use");
      }
      return FALSE;
   }

   METHOD boolean Populating(object room_or_obb)
   {
      if(Link.AnyExist("~Population",self))
      {
         linkset habitations=Link.GetAll("~Population",self);
         while(habitations.AnyLinksLeft())
         {
            if(habitations.Link().To()==room_or_obb)
               return TRUE;
            habitations.NextLink();
         }
      }
      return FALSE;
   }

   METHOD boolean TrainBlackjack (object world, object inv, object weap)
   {
      boolean retval=FALSE;
      object kenny=object("CoshTarget");

      // This way, we only have to score the one thing to shut down all
      // of this logic:
      if(LessonDone("SelectBlackjack"))
         return FALSE;
      if(kenny==NO_OBJ) return FALSE;
      if(!Populating("CoshPromptRoom"))
         return FALSE;

      if(Property.Possessed(kenny,"AI_Mode") &&
         integer(Property.Get(kenny,"AI_Mode"))==kAIM_Dead)
         return FALSE;
      
      vector delta=Object.Position(kenny)-Object.Position(self);
      // figure angle from me to Kenny
      double angle=atan2(delta.y,delta.x)*180.0/3.14159;

      {
         float kennyface=Object.Facing(kenny).z;
         double deltang=fmod(1080.0+angle-kennyface,360.0);
         const float KENNYFACE_TOLERANCE=45.0;

         // IS his back turned?  The lesson claims it is.
         if(angle>KENNYFACE_TOLERANCE && angle<(360.0-KENNYFACE_TOLERANCE))
            return FALSE;

         // @@TODO: Check that our pigeon cannot see you?
         if(Object.InheritsFrom(weap,"Blackjack"))
         {
            // got the blackjack selected
            integer weapui=Quest.Get(WEAP_UI_QVAR);
         
            if(weapui==kReady)
            {
               retval=DoLesson("PullBackArm","Attack");
            }  
            else if(weapui==kCocked)
            {
               float distance=1000.0;
               const float COSH_RANGE=4.5; // pretty safe guestimate
               const float FACE_TOLERANCE=10.0;
               float facing=Object.Facing(self).z;
               distance=delta.Magnitude();
               angle=fmod(1080.0+angle-facing,360.0);

               if(distance>COSH_RANGE)
                  retval=DoLesson("ReleaseArm","Attack");
               else
               {
                  if(angle<FACE_TOLERANCE || angle>(360.0-FACE_TOLERANCE))
                     retval=DoLesson("ReleaseArmClose","Attack");
                  else
                     retval=DoLesson("ReleaseArm","Attack");
               }
            }
            else
               return FALSE; // how did we get here anyway?
         }
         else
         {
            retval=DoLesson("SelectBlackjack","ReadyBlackjack");
         }
      }
      if(retval)
      {
         // while we have this lesson up, check back _often_
         SetOneShotTimer(self,"Update",0.25);
         Sound.PlayVoiceOver(self,"gar0108");
      }
      return retval;
   }

   METHOD boolean TrainShootTorch (object world, object inv, object weap)
   {
      boolean positioned=FALSE;
      boolean retval=FALSE;

      // This way, we only have to score the one thing to shut down all
      // of this logic:
      if(LessonDone("SelectWaterArrow"))
         return FALSE;

      // Are we even in position to do this lesson?
      if(!Populating("TorchTrig"))
            return(FALSE);
      if(Object.InheritsFrom(weap,"water"))
      {
         // got a water arrow selected
         integer weapui=Quest.Get(WEAP_UI_QVAR);
         
         if(weapui==kReady)
         {
            return retval=DoLesson("PullArrow","Attack");
         }
         else if(weapui==kCocked)
         {
            return retval=DoLesson("ReleaseArrow","Attack");
         }
         else
            return FALSE; // how did we get here anyway?d
      }
      else
      {
         if(ObjContainsAny("Player","water"))
            retval=DoLesson("SelectWaterArrow","ReadyWater");
      }

      if(retval)
         Sound.PlayVoiceOver(self,"gar0106");
      return retval;
   }

   METHOD void Prompt()
   {
      object inv=Quest.Get(INV_ID_QVAR);
      object weap=Quest.Get(WEAP_ID_QVAR);
      object world=Quest.Get(WORLD_ID_QVAR);

      // Debug.MPrint("Checking prompt.  Objects=",world,",",inv,",",weap);
      
      // Update of world obj can lag a frame behind picking it up.  Since
      // we're going to do a lot of checking of this below anyway, we might
      // as well get it right.
      if(world!=NO_OBJ &&
         Link.AnyExist("Contains",self,world))
         world=NO_OBJ;

      if(IsDataSet("TipLock") && TrainTransientTip()) return;

      // @@TODO: In a perfect universe, we'd just have an array of function pointers
      // and remove the call from the list entirely once that lesson was over.
      // Ah, well.

      if(
         (Quest.Get("difficulty") > 0) ||
         TrainHealing(world,inv,weap) ||
         TrainBlackjack(world,inv,weap) ||
         TrainShootTorch(world,inv,weap) ||
         TrainDoor(world,inv,weap) ||
         TrainUseFlash(world,inv,weap) ||
         TrainPickpocket(world,inv,weap) ||
         TrainPickUpKey(world,inv,weap) ||
         TrainGetLoot(world,inv,weap) ||
         TrainPortable(world,inv,weap) ||
         TrainUseFlare(world,inv,weap))
      {
         TransientTip(kM1TipNone);
         return;
      }
      else if (TrainTransientTip())
         return;

      {
         // Don't clear messages less than 1/2 second old, please.
         // So they don't just flash by.
         float lessontime=GetData("LessonTime");
         if((GetTime()-lessontime)>1.0)
            DarkUI.TextMessage("",rgb(255,0,0),30000);
         else
            SetOneShotTimer(self,"Update",0.5);
      }
   }
   METHOD void Score(const string ref Action)
   {
      Quest.Set(string("tr_")+Action,TRUE,kQuestDataCampaign);
      Prompt();
   }

MESSAGES:
   OnBeginScript()
   {
      // don't want starting point to bother with these messages.
      if(Object.InheritsFrom(self,"Avatar") &&
         (Quest.Get("difficulty")==0))
      {
         // Create quest vars, if not already there.
         Quest.Set(WEAP_ID_QVAR,Quest.Get(WEAP_ID_QVAR));
         Quest.Set(INV_ID_QVAR,Quest.Get(INV_ID_QVAR));
         Quest.Set(WORLD_ID_QVAR,Quest.Get(WORLD_ID_QVAR));
         Quest.Set(WEAP_UI_QVAR,Quest.Get(WEAP_UI_QVAR));
         
         Quest.SubscribeMsg(self,WEAP_ID_QVAR);
         Quest.SubscribeMsg(self,INV_ID_QVAR);
         Quest.SubscribeMsg(self,WORLD_ID_QVAR);
         Quest.SubscribeMsg(self,WEAP_UI_QVAR);
       
         if(!IsDataSet("Init"))
         {
            integer objmax=0;

            SetData("Init",TRUE);
            SetData("LessonTime",0.0);

            SetOneShotTimer(self,"Prompt",25.0);

            // Woo hoo.  Put tracking scripts on all world-frobbable items,
            // and set their FrobInfo to make sure they send select messages to
            // scripts.
            if(DarkGame.ConfigIsDefined("obj_max"))
               DarkGame.ConfigGetInt("obj_max",objmax);

            if(objmax>0)
            {
               integer object_id=1;
               integer frobinfo=0;

               for(object_id=1;object_id<=objmax;object_id++)
               {
                  if(Object.Exists(object_id))
                  {
                     frobinfo=Property.Get(object_id,"FrobInfo","World Action");

                     if(frobinfo!=0)
                     {
                        if(!(frobinfo & kFrobFocusScript))
                        {
                           frobinfo=frobinfo|kFrobFocusScript;
                           Property.Set(object_id,"FrobInfo","World Action",frobinfo);
                        }
                        if(IsDoor(object_id) && 
                           !Object.HasMetaProperty(object_id,"M1_TrackDoor"))
                           Object.AddMetaProperty(object_id,"M1_TrackDoor");
                        else 
                        {
                           if(!Object.HasMetaProperty(object_id,"M1_TrackWorld"))
                              Object.AddMetaProperty(object_id,"M1_TrackWorld");
                           if((frobinfo & kFrobMove) &&
                              (!Object.HasMetaProperty(object_id,"M1_TrackInv")))
                              Object.AddMetaProperty(object_id,"M1_TrackInv");
                        }
                     }
                  }
               }
            }
         }
      }
      DefaultOnBeginScript();
   }
   /*
   To track the interface state of the player's arrows and such, we will
   add a script to them.  We'll do this when the player contains them
   so that water crystals work correctly and so we have no chance for
   error.  He claimed.
   */
   OnContainer()
   {
      if(Quest.Get("difficulty")==0)
      {
         object containee=message.containee;
         if(message.event==kContainAdd || message.event==kContainCombine)
         {
            integer invtype=kInvTypeJunk; // by default

            if(Property.Possessed(containee,"InvType"))
               invtype=Property.Get(containee,"InvType");

            if(!Object.HasMetaProperty(containee,"M1_TrackInv"))
               Object.AddMetaProperty(containee,"M1_TrackInv");
            if(invtype==kInvTypeJunk)
            {
               Quest.Set(INV_ID_QVAR,containee);
               Quest.Set(INV_UI_QVAR,kUnready);
            }

            // Okay, this is a hack, but don't score any of this stuff
            // in the first few moments of the sim, so we don't score
            // based on the player's loadout.  Duh.
            if(GetTime()>0.0)
            {
               if(Property.Possessed(containee,"Loot"))
                  if(LessonDone("UseLootTake"))
                     Score("UsePortable");
                  else
                     Score("UseLootTake");
               else if(Object.InheritsFrom(containee,"Key"))
                  if(LessonDone("UseLootTake"))
                     Score("UsePortable");
                  else
                     Score("UseKeyTake");
               else
                  Score("UsePortable");
            }
         }
         else
         {
            // Object leaving container.  Note that we can't count on this
            // message for objects using "ammo" off a stack.
            if(Object.InheritsFrom(containee,"LitFlare"))
               Score("DropOrUseFlare");
         }
         Prompt();
      }
      DefaultOnContainer();
   }
   OnQuestChange()
   {
      Prompt();
      DefaultOnQuestChange();
   }
   OnDamage()
   {
      if((message.damage<0) && 
         Object.InheritsFrom(message.culprit,"HealingPotion"))
         Score("UsePotionHeal");
      Prompt();
      DefaultOnDamage();
   }
   OnMessage()
   {
      boolean prompt=TRUE;

      if(MessageIs("CheckMap"))
         TransientTip(kM1TipCheckMap);
      else if(MessageIs("VisGem"))
         TransientTip(kM1TipCheckVisGem);
      else if(MessageIs("Popup"))
      {
         // Victory scripts trying to pop up a notification.   
         // Takes precedence over training text.
         const char *popup=message.data;
         prompt=TRUE;

          if(stricmp(popup,"NewGoal")==0)
            TransientTip(kM1TipVictoryNewgoal);
         else if(stricmp(popup,"DoneGoal")==0)
            TransientTip(kM1TipVictoryDonegoal);
      }
      else if(!MessageIs("Prompt"))
         prompt=FALSE;

      if(prompt)
         Prompt();
      DefaultOnMessage();
   }
   OnTimer()
   {
      if(message.name=="Prompt")
      {
         Prompt();
         SetOneShotTimer(self,"Prompt",25.0);
      }
      else if(message.name=="Update")
      {
         Prompt();
      }
      else if(message.name=="TipUnlock")
      {
         ClearData("TipLock");
         Prompt();
      }
      else if(message.name=="TipClear")
      {
         TransientTip(kM1TipNone);
         Prompt();
      }
      DefaultOnTimer();
   }

END_SCRIPT(Training)


BEGIN_SCRIPT(MapTipster, RootScript)
MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         object player=object("Player"); // gruesomely single-player
         if(player!=object(0))
         {
            PostMessage(player,"CheckMap");
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(MapTipster)


BEGIN_SCRIPT(VisGemText, RootScript)
MESSAGES:
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         object player=object("Player"); // gruesomely single-player
         if(player!=object(0))
         {
            PostMessage(player,"VisGem");
         }
      }
      DefaultOnMessage();
   }
END_SCRIPT(VisGemText)


BEGIN_SCRIPT(WhistleCall, RootScript)

METHODS:

   METHOD boolean WithinRange(object target, integer sigdistance)
   {
      vector mypos = Object.Position(self);
      vector targpos = Object.Position(target);

      return ((mypos-targpos).Magnitude() < sigdistance);
   }

MESSAGES:
   OnFrobInvEnd()
   {
      object signaltarget;
      if(Link.AnyExist("ScriptParams",self))
      {
         linkset allparamlinks = Link.GetAll("ScriptParams",self);
         while (allparamlinks.AnyLinksLeft())
         {
            link currentparamlink = allparamlinks.Link();
            integer sigdistance = (integer)currentparamlink.GetData();
            object target = (object)currentparamlink.To();
            Debug.MPrint("Attempting to signal ",target);
            if (WithinRange(target,sigdistance) &&
                Quest.Get(GoalStateVarName(GOAL_SIGNAL))!=kGoalComplete)
            {
               Quest.Set(GoalStateVarName(GOAL_SIGNAL),kGoalComplete);
               AI.Signal(target,"GoTo");
            }
            allparamlinks.NextLink();
         }
      }
      else
         Debug.MPrint("No script param links found!");
      DefaultOnFrobInvEnd();
   }

END_SCRIPT(WhistleCall)


BEGIN_SCRIPT(Basso, RootScript)
METHODS:

   METHOD void SetThinkTimer(float delay)
   {
      vector mypos=Object.Position(self);
      Property.Set(self,"AI_IdleOrgn","Original Location",mypos);

      Debug.MPrint("Setting next thought to ",delay);

      if(IsDataSet("ThinkTimer"))
      {
         timer_handle thinkt=GetData("ThinkTimer");
         KillTimer(thinkt);
         Debug.MPrint("Killing old think timer");
      }
      timer_handle newthinkt=SetOneShotTimer(self,"Think",delay,delay);
      SetData("ThinkTimer",newthinkt);
   }
   METHOD void GoToNextMarker(void)
   {
      /* Basso wants to follow a route while changing motion speeds and motion
         tags along the way.  Patrols won't do this.  We can send him from point
         to point with pseudoscripts, but if his locomotion is interrupted by some
         high-priority action (such as getting damaged) he won't pick it back up
         again as a goal.  So, we keep a link to the next point, which has a signal
         response property on it which we copy and trigger.  This way, we can re-trigger
         the signal response regularly if it seems like we might not be making progress.
         */
      if(Link.AnyExist("Route",self))
      {
         object targ=Link.GetOne("Route",self).To();
         if(!Link.AnyExist("AIWatchObj",self,targ))
            Link.Create("AIWatchObj",self,targ);
         Property.CopyFrom(self,"AI_SigRsp",targ);
         Debug.MPrint("Copying response from marker ",targ," and going.");
         SetThinkTimer(5.0);
         AI.Signal(self,"GoTo");
      }
   }

MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         Sound.PreLoad("bas0101a");
         SetThinkTimer(11.0);
      }
      DefaultOnSim();
   }
   OnDamage()
   {
      // Kinda obvious that we need to do some thinking after we're done
      // flinching, if we don't die.  Flinching could take up to 4 or 5 seconds,
      // but we want to reset the timer.
      SetThinkTimer(5.0);
      DefaultOnDamage();
   }
   OnMessage()
   {
      object thedoor=object("JenivereDoor");

      Debug.MPrint("Basso handling message ",message.message);

      if(MessageIs("GoTo"))
      {
         GoToNextMarker();
      }
      else if(MessageIs("StartPicking"))
      {
         Link.DestroyMany("Route",self,AnyObject);
         if(Object.HasMetaProperty(self,"M-DoesPatrol"))
            Object.RemoveMetaProperty(self,"M-DoesPatrol");
         Link.DestroyMany("AICurrentPatrol",self,AnyObject);
         // Don't want to accidentally change what we're doing during this pseudoscript
         SetThinkTimer(11.0);
      }
      else if(MessageIs("DoorPickSpoof"))
      {
         Sound.PlaySchema(thedoor,"lockpik",thedoor);
         ActReact.React("tweq_control",1.0,thedoor,0,kTweqTypeJoints,kTweqDoActivate);
      }
      else if(MessageIs("FinishPicking"))
      {
         Sound.HaltSchema(thedoor);
         ActReact.React("tweq_control",1.0,thedoor,0,kTweqTypeJoints,kTweqDoHalt);
         Object.AddMetaProperty(self,"M-DoesPatrol");
      }
      else if(MessageIs("StartJenConv"))
      {
         // Don't want to reconsider actions during Jen conversation.  We set up our
         // Patrol link at the very beginning, so we know to just move if the conversation
         // gets disrupted.
         SetThinkTimer(15.0);
      }
      else if(MessageIs("GrabJen"))
      {
         PostMessage(object("Jenivere"),"FollowBasso");
         GoToNextMarker();
      }
      Reply(TRUE);
      DefaultOnMessage();
   }
   OnTimer()
   {
      if(message.name=="Think")
      {
         float time_since_think=message.data;
         vector mypos=Object.Position(self);
         boolean timerset=FALSE;

         // Basso certainly doesn't want to return to idle origin.
         // Sooo... we subvert his Idle Origin property to keep track of his progress.
         vector lastpos=Property.Get(self,"AI_IdleOrgn","Original Location");

         ClearData("ThinkTimer");
         Debug.MPrint(self," thinking in scripts. Last update ",time_since_think," sec ago.");
         if(Quest.Get(GoalStateVarName(GOAL_SIGNAL))==kGoalIncomplete)
         {
            object thedoor=object("GatehouseDoor");
            // @@TODO: Gruesomely single-player.
            vector playerpos=Object.Position(object("Player"));
            vector selfpos=Object.Position(self);
            vector doorpos=Object.Position(thedoor);

            if(((doorpos-selfpos).Magnitude()<40.0) &&
               ((selfpos-playerpos).Magnitude()>90.0))
            {
               // Okay, this is a hack.  Basso, like all AIs, is apt
               // to lock any door he can behind him.  We don't want
               // that, so the gatehouse door doesn't have a KeyDst
               // property at all until the player is safely away from
               // it and Basso is good and ready to lock it.
               Property.Set(thedoor,"Locked",TRUE);
               Property.CopyFrom(thedoor,"KeyDst",object("FrontGateRight"));
            }
         }
         else
         {
            // Don't reconsider next marker if you're making good progress somewhere
            float travel=(mypos-lastpos).Magnitude();
            float rate=travel/time_since_think;

            if(rate<0.5)
            {
               GoToNextMarker();
               timerset=TRUE;
            }
         }

         if(!timerset)
            SetThinkTimer(time_since_think);
      }
      DefaultOnTimer();
   }
END_SCRIPT(Basso)



BEGIN_SCRIPT(GatehouseDoor, RootScript)
MESSAGES:
   OnNowUnlocked()
   {
      Property.Remove(self,"Locked");
      Property.Remove(self,"KeyDst");
      DefaultOnNowUnlocked();
   }
END_SCRIPT(GatehouseDoor)


BEGIN_SCRIPT(JenDoor, Door)

MESSAGES:
   OnBeginScript()
   {
      if(!IsDataSet("Done"))
      {
         SetData("Done",FALSE);
      }
      DefaultOnBeginScript();
   }
   OnWorldSelect()
   {
      boolean done=FALSE;
      boolean basso_coming=(Quest.Get(GoalStateVarName(GOAL_SIGNAL))==kGoalComplete);

      if(IsDataSet("Done")) done=GetData("Done");

      if(!(done||basso_coming))
      {
         Sound.PlayVoiceOver(self,"gar0112");
         SetData("Done",TRUE);
      }
      DefaultOnWorldSelect();
   }
   OnDoorOpening()
   {
      SetData("Done",TRUE);
      DefaultOnDoorOpening();
   }

END_SCRIPT(JenDoor)
@


1.34
log
@Relax constraint on Basso's proximity to gatehouse door.
@
text
@a22 1
      linkkind poplink=linkkind("Population");
a24 13
      // Update population links
      if(mover==object("Basso") ||
         mover==object("Jenivere") ||
         Object.InheritsFrom(mover,object("Avatar")))
      {
         if(enter && !Link.AnyExist(poplink,self,mover))
            Link.Create(poplink,self,mover);
         else
            Link.DestroyMany(poplink,self,mover);
      }
      else
         return;

d30 5
a34 5
      // and check whether all principals have escaped
      // @@TODO: Fix for multiplayer
      if(Link.AnyExist(poplink,self,object("Basso")) &&
         Link.AnyExist(poplink,self,object("Jenivere")) &&
         Link.AnyExist(poplink,self,object("Player")))
@


1.33
log
@Made NewGoal and DoneGoal tips so training system doesn't step on top
of goal notification.
@
text
@d1362 1
a1362 1
            if(((doorpos-selfpos).Magnitude()<20.0) &&
@


1.32
log
@Lessons tracked in campaign quest variables, so they can carry over to
mission 2.
@
text
@d457 2
a459 1

d568 12
d581 1
a581 1

d1114 12
d1128 1
d1147 5
@


1.31
log
@Changed handling of Basso/Jen conversation to have Basso patrolling
while going in and out of conversation, since there seemed to be
problems with him trying to run other pseudoscripts going in and out
of the conversation.
Left in a bunch of debugging spew for Basso in case there are more
problems.
@
text
@d196 1
a196 1
         Quest.Set("tr_UseFlareLight",TRUE);
d253 2
a254 1
      if(Object.InheritsFrom(self,"FlashBomb"))
d256 2
a257 2
         Quest.Set("tr_DropOrUseFlashBomb",TRUE);
         Quest.Set("tr_DropFlashBomb",TRUE);
d381 1
a381 1
               Quest.Set("tr_UseDoorClose",TRUE);
d383 1
a383 1
               Quest.Set("tr_UseDoorOpen",TRUE);
d416 1
a416 1
            Quest.Set(qvar,TRUE);
d950 1
a950 1
      Quest.Set(string("tr_")+Action,TRUE);
@


1.30
log
@Added an OBJ_NULL check in the portability check method to eliminate
warnings.
Took out some mprints.
@
text
@d1212 2
d1218 1
d1267 2
d1275 4
d1291 1
a1291 1
         GoToNextMarker();
d1296 1
a1296 1
         // Route link at the very beginning, so we know to just move if the conversation
@


1.29
log
@Basso keeps better track of his current destination, making his
pseudoscripts resiliant in the face of taking damage and such
(except in his conversation...)
@
text
@d543 1
a543 1
          Debug.MPrint("Already done lesson: ",Action);
d586 2
a587 1
       if(Property.Possessed(world,"FrobInfo"))
d597 2
a598 1
                Debug.MPrint("Checking protability given container ",container);
d904 7
d913 4
@


1.28
log
@Add M1_TrackInv to portable objects at sim start so they'll give tips
correctly when first picked up.
@
text
@d1174 2
a1175 1
            if (WithinRange(target,sigdistance))
d1177 2
a1178 3
               if(Object.HasMetaProperty(target,"M-WhistleResponse"))
                  Quest.Set(GoalStateVarName(GOAL_SIGNAL),kGoalComplete);
               AI.Signal(target,"WhistleBlown");
a1179 2
            else
               Debug.MPrint("Out of range");
d1192 1
d1194 35
d1235 1
a1235 1
         SetOneShotTimer(self,"CheckDoor",11.0);
d1239 8
d1251 5
a1255 1
      if(MessageIs("StartPicking"))
d1257 5
d1269 8
a1276 1
         // Property.Set(thedoor,"Locked",FALSE);
d1278 5
d1288 1
a1288 1
      if(message.name=="CheckDoor")
d1290 10
a1318 2
            else
               SetOneShotTimer(self,"CheckDoor",11.0);
d1320 15
@


1.27
log
@Set up faux lockpicking on Jenivere's door.
@
text
@d994 8
a1001 2
                        else if(!Object.HasMetaProperty(object_id,"M1_TrackWorld"))
                           Object.AddMetaProperty(object_id,"M1_TrackWorld");
@


1.26
log
@Special-purpose script for door to Jenivere's room.
@
text
@d1194 1
d1198 18
@


1.25
log
@Changed torch prompt trigger to an OBB.
@
text
@d1241 33
@


1.24
log
@Reversed order of signal and escape goals.
@
text
@d764 1
a764 1
   METHOD boolean Populating(object room)
d771 1
a771 1
            if(habitations.Link().To()==room)
d866 1
a866 1
      if(!Populating("TorchPromptRoom"))
@


1.23
log
@Make Basso not close doors behind himself.
@
text
@d4 2
a5 2
#define GOAL_ESCAPE 0
#define GOAL_SIGNAL 1
@


1.22
log
@Set up scripts for gatehouse door.
@
text
@d339 7
@


1.21
log
@Fixed Jenivere script to stop aborting their conversation.
Added Basso script to stage his hiding out in gatehouse, listening
for signal whistle.
@
text
@d1177 1
a1177 1
END_SCRIPT(WhistleCall);
d1206 5
d1212 1
d1224 9
a1232 1

@


1.20
log
@Added flash bomb lesson.
@
text
@d125 2
d1163 2
a1164 1
               Quest.Set(GoalStateVarName(GOAL_SIGNAL),kGoalComplete);
d1178 41
@


1.19
log
@Added Focus and DeFocus handlers to check for inventory objects timing
out.
@
text
@d249 11
d643 13
d902 1
@


1.18
log
@Added previous item tips to all cycle inventory hints, which required
adding a possible _third_ key to DoLesson.
Fixed possible one-frame bug in pickpocketing hint code.
@
text
@d225 14
@


1.17
log
@Minimum time on HUD messages.
@
text
@d473 2
a474 1
                            const string ref Key2=string(""))
d479 1
d496 4
d586 4
a589 1
          return DoLesson("UsePickpocket","Use");
d671 1
a671 1
             return DoLesson("SelectKey","CycleInventory");
d707 1
a707 1
               return DoLesson("SelectNonTool","Use","CycleInventory");
a1135 7







@


1.16
log
@Bunch of new training messages.
@
text
@d498 1
d866 10
a875 1
      DarkUI.TextMessage("",rgb(255,0,0),30000);
d906 1
@


1.15
log
@Tips don't time out.
Jenivere's door doesn't prompt you to go find a key.
Goofy basic map message.
@
text
@d526 4
d707 16
a722 1
   METHOD boolean TrainShootTorch (object world, object inv, object weap)
d724 2
a725 1
      boolean positioned=FALSE;
d729 8
a736 1
      if(LessonDone("SelectWaterArrow"))
d738 4
a742 2
      // Are we even in position to do this lesson?
      if(Link.AnyExist("~Population",self))
d744 41
a784 2
         linkset habitations=Link.GetAll("~Population",self);
         while(!positioned && habitations.AnyLinksLeft())
d786 1
a786 3
            if(habitations.Link().To()==object("TorchPromptRoom"))
               positioned=TRUE;
            habitations.NextLink();
d788 6
a793 1
         if(!positioned) return FALSE;
d795 11
a805 1
      else
d807 4
d818 1
a818 1
            return DoLesson("PullArrow","Attack");
d822 1
a822 1
            return DoLesson("ReleaseArrow","Attack");
d830 1
a830 1
            return DoLesson("SelectWaterArrow","ReadyWater");
d832 4
a835 1
      return FALSE;
d844 3
a846 1
      Debug.MPrint("Checking prompt.  Objects=",world,",",inv,",",weap);
d851 1
d1011 2
d1026 9
d1058 17
d1116 7
@


1.14
log
@Set up Basso/Jenivere conversation.
@
text
@d419 5
d480 1
a480 1
       Debug.MPrint("Call DoLesson ",Action);
d507 21
d662 2
a663 1
             if(IsKeyFrom("Key",world))
d768 5
d799 1
a799 1

d805 3
d916 7
a922 1
      if(MessageIs("Prompt"))
d926 9
d938 16
@


1.13
log
@Set signal whistle script to check off objective when it signals Basso.
@
text
@d126 10
@


1.12
log
@Pulled WhistleCall script out from gen.
@
text
@d5 1
a895 1
      integer distancetotarget;
d906 2
d909 1
@


1.11
log
@Check whether any key exists for door before telling player to go
get one.
@
text
@d877 42
@


1.10
log
@Training script always subscribes to qvars on begin script.
@
text
@d579 18
d623 7
a629 1
             return DoLesson("GoFindKey","");
@


1.9
log
@Added pickpocket lesson.
Don't tell player to select water arrows if he hasn't any.
@
text
@d719 2
a720 3
      if((Quest.Get("difficulty")==0) && 
         !IsDataSet("Init") && 
         Object.InheritsFrom(self,"Avatar"))
d722 1
a722 4
         integer objmax=0;

         SetData("Init",TRUE);
         // Create quest vars.
d733 3
a735 5
         // Woo hoo.  Put tracking scripts on all world-frobbable items,
         // and set their FrobInfo to make sure they send select messages to
         // scripts.
         if(DarkGame.ConfigIsDefined("obj_max"))
            DarkGame.ConfigGetInt("obj_max",objmax);
d737 6
a742 4
         if(objmax>0)
         {
            integer object_id=1;
            integer frobinfo=0;
d744 1
a744 1
            for(object_id=1;object_id<=objmax;object_id++)
d746 4
a749 1
               if(Object.Exists(object_id))
d751 3
a753 1
                  frobinfo=Property.Get(object_id,"FrobInfo","World Action");
d755 1
a755 3
                  if(frobinfo!=0)
                  {
                     if(!(frobinfo & kFrobFocusScript))
d757 10
a766 2
                        frobinfo=frobinfo|kFrobFocusScript;
                        Property.Set(object_id,"FrobInfo","World Action",frobinfo);
a767 5
                     if(IsDoor(object_id) && 
                        !Object.HasMetaProperty(object_id,"M1_TrackDoor"))
                        Object.AddMetaProperty(object_id,"M1_TrackDoor");
                     else if(!Object.HasMetaProperty(object_id,"M1_TrackWorld"))
                        Object.AddMetaProperty(object_id,"M1_TrackWorld");
@


1.8
log
@Set a bunch of lessons to be scored,
set up Jenivere to follow Basso.
@
text
@d425 14
d502 40
d547 1
a547 1
       if(Object.InheritsFrom(world,"Key"))
d553 1
a553 1
       if(Property.Possessed(world,"Loot"))
d559 2
a560 6
       if(Property.Possessed(world,"FrobInfo"))
       {
          integer worldfrob=Property.Get(world,"FrobInfo","World Action");
          if(worldfrob & kFrobMove)
             return DoLesson("UsePortable","Use");
       }
d678 1
a678 1
            return FALSE; // how did we get here anyway?
d682 2
a683 3
         // @@TODO: This doesn't handle the slim chance that the player _has_
         // no water arrows.
         return DoLesson("SelectWaterArrow","ReadyWater");
d685 1
d701 1
@


1.7
log
@Rewrite of basic training infrastructure.
@
text
@d92 38
d182 3
d357 20
d517 1
a517 1
    METHOD boolean TrainUseFlares (object world, object inv, object weap)
d647 8
a654 7
      TrainHealing(world,inv,weap) ||
      TrainShootTorch(world,inv,weap) ||
      TrainDoor(world,inv,weap) ||
      TrainPickUpKey(world,inv,weap) ||
      TrainGetLoot(world,inv,weap) ||
      TrainPortable(world,inv,weap) ||
      TrainUseFlares(world,inv,weap))
d668 3
a670 1
      if(!IsDataSet("Init") && Object.InheritsFrom(self,"Avatar"))
a673 2
         Debug.MPrint("Doing avatar setup");

d730 1
a730 1
      if(message.event==kContainAdd || message.event==kContainCombine)
d733 3
a735 1
         integer invtype=kInvTypeJunk; // by default
d737 2
a738 2
         if(Property.Possessed(containee,"InvType"))
            invtype=Property.Get(containee,"InvType");
d740 7
a746 7
         if(!Object.HasMetaProperty(containee,"M1_TrackInv"))
            Object.AddMetaProperty(containee,"M1_TrackInv");
         if(invtype==kInvTypeJunk)
         {
            Quest.Set(INV_ID_QVAR,containee);
            Quest.Set(INV_UI_QVAR,kUnready);
         }
d748 15
a762 8
         // Okay, this is a hack, but don't score any of this stuff
         // in the first few moments of the sim, so we don't score
         // based on the player's loadout.  Duh.
         if(GetTime()>0.0)
         {
            if(Property.Possessed(containee,"Loot"))
               if(LessonDone("UseLootTake"))
                  Score("UsePortable");
a763 3
                  Score("UseLootTake");
            else if(Object.InheritsFrom(containee,"Key"))
               if(LessonDone("UseLootTake"))
d765 8
a772 4
               else
                  Score("UseKeyTake");
            else
               Score("UsePortable");
d774 1
d776 1
a776 1
      Prompt();
d785 3
@


1.6
log
@Added new stuff for healing potions and flash bombs.
Decided it was all rather a mess, really.
@
text
@d10 1
d101 3
a103 239
/*
  Many of these scripts will have in common the need to display information on
  uses of various key and mouse button commands.  We define a script for them
  to inherit a method for this.
  */
BEGIN_SCRIPT(KeyPrompter,RootScript)

METHODS:

   /* Action is the full description of the action to be attempted (e.g.
      "USE Door to open"), while Key describes only the interface binding
      to be prompted (e.g. the identity of the USE key).

      The quest variable tracking successful completion of the lesson
      is derived from the name of the Action string by prepending "tr_".
      */
   METHOD boolean LessonDone(const string ref Action)
   {
      integer difficulty=Quest.Get("difficulty");
      boolean done=(difficulty>0) || Quest.Get(string("tr_")+Action);

      return done;
   }      
   METHOD void KeyString(const string ref Action, const string ref Key, 
                         const string ref Key2=string(""))
   {
      string DisplayOutput = "";
      string Command = Data.GetString("PlayCmd",Key+"_command");
      string Command2 = Data.GetString("PlayCmd",Key2+"_command");
      boolean done=LessonDone(Action);

      if(!done)
      {
         if (Key!="" && DarkUI.IsCommandBound(Command))
         {
            /* Build string of the form (e.g.) "USE = Mouse2" */
            DisplayOutput = Data.GetString("PlayAct",Key) + " = " 
                          + DarkUI.DescribeKeyBinding(Command);
         }
         if (Key2!="" && DarkUI.IsCommandBound(Command2))
            DisplayOutput = DisplayOutput + "\n"
                          + Data.GetString("PlayAct",Key2) + " = " 
                          + DarkUI.DescribeKeyBinding(Command2);
         /* Tack string descriptive of action in question on front */
         DisplayOutput = Data.GetString("PlayHint",Action)
                          + DisplayOutput;
         DarkUI.TextMessage(DisplayOutput,rgb(255,0,0),30000);
      }
      else
         Debug.MPrint("Already done lesson: ",Action);
   }
   // derived scripts will override this.  In particular, the Prompt()
   // method on the player should handle anything other than world focus
   // hints, basically.
   METHOD void Prompt()
   {
      ;
   }
   // Note that since NewHint messages to elicit further prompting (on other
   // lessons), Prompt() should not call NewHint() (or, for that matter, Score()).
   METHOD void NewHint(void)
   {
      DarkUI.TextMessage("");
      PostMessage(object("Player"),"Prompt?");
   }
   METHOD void Score(const string ref Action)
   {
      Quest.Set(string("tr_")+Action,TRUE);
      NewHint();
   }

MESSAGES:
   OnMessage()
   {
      if(MessageIs("Prompt?"))
         Prompt();
      DefaultOnMessage();
   }

END_SCRIPT(KeyPrompter)


/* This script goes on the player, to track any state changes that will affect
   our training messages.  It also handles training of inventory objects (although
   we need scripts on those objects themselves to score the lesson).
   */
BEGIN_SCRIPT(TrainPlayer, KeyPrompter)

METHODS:
   METHOD void Prompt()
   {
      object invobj=object(Quest.Get(INV_ID_QVAR));

      Debug.MPrint("TrainPlayer.  inv obj=",invobj);

      if(Object.Exists(invobj))
      {
         if(Object.InheritsFrom(invobj,"HealingPotion"))
         {
            integer hp=Property.Get(self,"HitPoints");
            integer max=Property.Get(self,"MAX_HP");

            if(hp<max)
            {
               KeyString("UsePotionHeal","Use");
            }
         }
         else if(Object.InheritsFrom(invobj,"Flashbomb"))
         {
            KeyString("UseFlashbomb","Use","Drop");
         }
      }
   }
MESSAGES:

   OnBeginScript()
   {
      // don't want starting point to bother with these messages.
      if(!IsDataSet("Init") && Object.InheritsFrom(self,"Avatar"))
      {
         SetData("Init",TRUE);
         Quest.SubscribeMsg(self,INV_UI_QVAR);
         Quest.SubscribeMsg(self,INV_ID_QVAR);
      }
   }

   OnQuestChange()
   {
      Prompt();
      DefaultOnQuestChange();
   }

   OnDamage()
   {
      Prompt();
      DefaultOnDamage();
   }


/*
   To track the interface state of the player's arrows and such, we will
   add a script to them.  We'll do this when the player contains them
   so that water crystals work correctly and so we have no chance for
   error.  He claimed.
   */
   OnContainer()
   {
      if(message.event==kContainAdd || message.event==kContainCombine)
      {
         object containee=message.containee;
         integer invtype=kInvTypeJunk; // by default

         if(Property.Possessed(containee,"InvType"))
            invtype=Property.Get(containee,"InvType");

         if(invtype!=kInvTypeJunk &&
            !Object.HasMetaProperty(containee,"M1_TrainWeapon"))
         {
            Object.AddMetaProperty(containee,"M1_TrainWeapon");
         }
      }
   }
END_SCRIPT(TrainPlayer)
      


BEGIN_SCRIPT(EntryDoor, KeyPrompter)
MESSAGES:
   OnWorldSelect()
   {
      KeyString("UseDoorOpen","Use");
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      NewHint();
      DefaultOnWorldDeSelect();
   }
   OnFrobWorldEnd()
   {
      Score("UseDoorOpen");
      DefaultOnFrobWorldEnd();
   }
END_SCRIPT(EntryDoor)


BEGIN_SCRIPT(FirstKey, KeyPrompter)
MESSAGES:
   OnWorldSelect()
   {
      KeyString("UseKeyTake","Use");
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      NewHint();
      DefaultOnWorldDeSelect();
   }
   OnFrobWorldEnd()
   {
      Score("UseKeyTake");
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(FirstKey)


BEGIN_SCRIPT(TakeLoot, KeyPrompter)
MESSAGES:
   OnWorldSelect()
   {
      KeyString("UseLootTake","Use");
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      NewHint();
      DefaultOnWorldDeSelect();
   }
   OnFrobWorldEnd()
   {
      Score("UseLootTake");
      DefaultOnFrobWorldEnd();
   }

END_SCRIPT(TakeLoot)



/* The prompter about shooting out the torch does not score
   each individual "lesson" as it is completed.  Rather, it scores
   them all when the torch is shot out, since each is a thing about
   which a novice player may need guidance until the torch is shot out.
   */
/*
   First, track interface state of water arrows.  History will absolve
   us of keeping all of this in quest variables.  Basically, we can
   communicate between scripts, and automatically get state change
   messages because we can subscribe to the quest vars.
d105 1
a105 1

a106 2
BEGIN_SCRIPT(TrainWeapon, RootScript)

d122 1
a122 1
      else if(type==kInvTypeItem)
d131 1
a131 1
      else if(type==kInvTypeItem)
d173 3
d183 1
a183 3
END_SCRIPT(TrainWeapon)


d185 9
a193 6
/* We will assume that notification of player's presence in region where we
   want to prompt will come from a separate player room trigger.

   Note again, we do not score the player on this lesson ourselves.  When
   the torch goes out, traps will delete the trap that has this script,
   and it will clean up.
d195 1
a195 1
BEGIN_SCRIPT(ShootTorchHere, KeyPrompter)
d197 24
a220 1
   METHOD void Prompt()
d222 1
d224 1
a224 3
         Debug.MPrint("Might prompt.  On=",GetData("On"));
         Debug.MPrint("Weapon ObjID=",Quest.Get(WEAP_ID_QVAR));
         Debug.MPrint("Weapon UI state=",Quest.Get(WEAP_UI_QVAR));
d226 3
a229 1
      object CurrentWeapon=object(Quest.Get(WEAP_ID_QVAR));
d231 9
a239 3
      if(GetData("On")==FALSE)
      {
         NewHint();
d241 1
a241 3
      }
      if(!Object.Exists(CurrentWeapon) ||
         !Object.InheritsFrom(CurrentWeapon,"water"))
d243 1
a243 3
         // @@TODO: Really, only prompt player if he actually had got
         // water arrows.
         KeyString("SelectWaterArrow","ReadyWater");
d245 1
a245 3
      else
      {
         integer weapui=Quest.Get(WEAP_UI_QVAR);
d247 15
a261 9
         if(weapui==kReady)
         {
            KeyString("PullArrow","Attack");
         }
         else if(weapui==kCocked)
         {
            KeyString("ReleaseArrow","Attack");
         }
      }
d263 1
a263 2
MESSAGES:
   OnBeginScript()
d265 2
a266 5
      Quest.SubscribeMsg(self,WEAP_UI_QVAR);
      Quest.SubscribeMsg(self,WEAP_ID_QVAR);
      if(!IsDataSet("On"))
         SetData("On",FALSE);
      DefaultOnBeginScript();
d268 1
a268 1
   OnEndScript()
d270 2
a271 3
      // Do we need to do this?
      Quest.UnsubscribeMsg(self,WEAP_ID_QVAR);
      Quest.UnsubscribeMsg(self,WEAP_UI_QVAR);
d273 1
a273 1
   OnDestroy()
d275 2
a276 4
      // Just to be tidy.
      Score("SelectWaterArrow");
      Score("PullArrow");
      Score("ReleaseArrow");
d278 1
a278 1
   OnQuestChange()
d280 2
a281 2
      Prompt();
      DefaultOnQuestChange();
d283 1
a283 1
   OnMessage()
d285 4
a288 5
      if(MessageIs("TurnOn"))
         SetData("On",TRUE);
      else if(MessageIs("TurnOff"))
         SetData("On",FALSE);
      else
d290 8
a297 2
         DefaultOnMessage();
         return;
d299 13
a311 1
      Prompt();
d314 2
a315 1
END_SCRIPT(ShootTorchHere);
d317 187
a503 4
/* Script for locked doors in the first area.  Need to prompt player to use key. */
BEGIN_SCRIPT(TrainLockedDoors,KeyPrompter)
METHODS:
   METHOD void Prompt()
d505 1
d507 19
a525 3
         Debug.MPrint("Might prompt.  On=",GetData("On"));
         Debug.MPrint("Inventory ObjID=",Quest.Get(INV_ID_QVAR));
         Debug.MPrint("Inventory UI state=",Quest.Get(INV_UI_QVAR));
d527 6
d534 4
a537 1
      object CurrentItem=object(Quest.Get(INV_ID_QVAR));
d539 2
a540 1
      if(GetData("On")==FALSE)
d542 8
a549 2
         NewHint();
         return;
d551 3
a553 2
      if(Object.Exists(CurrentItem) &&
         Key.TryToUseKey(CurrentItem,self,kKeyUseCheck))
d555 13
a567 6
         integer invui=Quest.Get(WEAP_UI_QVAR);

         // Well, we'd love to know whether the tool was zipped to the
         // center of the screen or not.  Luckily it's all on the same
         // USE key, so let's just write our way around it.
         KeyString("UseKeyUnlock","Use");
d571 58
a628 4
         // only prompt player to cycle inventory if he's actually got 
         // the key in his inventory.  Of course, _all_ of this is brutally
         // single-player specific.
         linkset invlinks=Link.GetAll("Contains",object("Player"));
d630 1
a630 1
         while(invlinks.AnyLinksLeft())
d632 4
a635 1
            if(Key.TryToUseKey(invlinks.Link().To(),self,kKeyUseCheck))
d637 18
a654 2
               KeyString("SelectKey","CycleInventory");
               return;
a655 1
            invlinks.NextLink();
a656 1
         KeyString("GoFindKey","");
a657 9
   }

MESSAGES:
   OnBeginScript()
   {
      Quest.SubscribeMsg(self,INV_UI_QVAR);
      Quest.SubscribeMsg(self,INV_ID_QVAR);
      if(!IsDataSet("On"))
         SetData("On",FALSE);
d660 7
a666 1
   OnEndScript()
d668 35
a702 7
      // Do we need to do this?
      Quest.UnsubscribeMsg(self,INV_ID_QVAR);
      Quest.UnsubscribeMsg(self,INV_UI_QVAR);
   }
   OnWorldSelect()
   {
      SetData("On",TRUE);
a703 7
      DefaultOnWorldSelect();
   }
   OnWorldDeSelect()
   {
      NewHint();
      SetData("On",FALSE);
      DefaultOnWorldDeSelect();
d710 1
a710 1
   OnNowUnlocked()
d712 2
a713 4
      Score("SelectKey");
      Score("UseKeyUnlock");
      Score("UseKeyCenter");
      DefaultOnNowUnlocked();
d715 1
a715 9
END_SCRIPT(TrainLockedDoors)


/* Script goes on the metaproperty that all of our inventory objects
   get.  Handles various training messages depending on object type.
   */
BEGIN_SCRIPT(TrainInvent, KeyPrompter)
MESSAGES:
   OnFrobInvEnd()
d717 4
a720 2
      object frobber=message.Frobber;
      integer hp=0, max=0;
d722 1
a722 22
      if(Object.InheritsFrom(self,"HealingPotion"))
      {
         if(Property.Possessed(frobber,"HitPoints"))
            hp=Property.Get(frobber,"HitPoints");
         if(Property.Possessed(frobber,"MAX_HP"))
            max=Property.Get(frobber,"MAX_HP");
         if(hp<max)
            Score("UsePotionHeal");
      }
      DefaultOnFrobInvEnd();
   }
   OnContained()
   {
      if(Object.InheritsFrom(self,"Flashbomb") &&
         message.event==kContainRemove &&
         Object.InheritsFrom(message.container,"Avatar"))
      {
         Score("UseFlashbomb");
      }
      DefaultOnContained();
   }
END_SCRIPT(TrainInvent);
@


1.5
log
@Bunches of new training scripts.
@
text
@d6 9
a98 31
/* This script goes on the player, to track any state changes that will affect
   our training messages.
   */
BEGIN_SCRIPT(TrainPlayer, RootScript)

MESSAGES:
/*
   To track the interface state of the player's arrows, we will
   add a script to them.  We'll do this when the player contains them
   so that water crystals work correctly and so we have no chance for
   error.
   */
   OnContainer()
   {
      if(message.event==kContainAdd || message.event==kContainCombine)
      {
         object containee=message.containee;
         integer invtype=kInvTypeJunk; // by default

         if(Property.Possessed(containee,"InvType"))
            invtype=Property.Get(containee,"InvType");

         if(invtype!=kInvTypeJunk &&
            !Object.HasMetaProperty(containee,"M1_TrainWeapon"))
         {
            Object.AddMetaProperty(containee,"M1_TrainWeapon");
         }
      }
   }
END_SCRIPT(TrainPlayer)
      
d116 9
a124 1
   METHOD void KeyString(const string ref Action, const string ref Key)
d128 2
a129 2
      integer difficulty=Quest.Get("difficulty");
      boolean done=(difficulty>0) || Quest.Get(string("tr_")+Action);
d139 4
d151 10
a160 1
   METHOD void ClearHint(void)
d163 1
d168 9
a176 1
      ClearHint();
d182 84
d275 1
a275 1
      ClearHint();
d295 1
a295 1
      ClearHint();
d316 1
a316 1
      ClearHint();
d328 1
a340 7
#define WEAP_UI_QVAR "WeapUI"
#define WEAP_ID_QVAR "WeapID"
#define INV_UI_QVAR "InvUI"
#define INV_ID_QVAR "InvID"
#define kUnready 0
#define kReady 1
#define kCocked 2
d442 1
a442 1
         ClearHint();
d483 1
a483 1
      // Just to be tidy.  At least it will call ClearHint();
d524 1
a524 1
         ClearHint();
d580 1
a580 1
      ClearHint();
d599 32
@


1.4
log
@Added script to track weapons, train the player in water arrow.
@
text
@d112 1
a112 1
         if(invtype==kInvTypeWeapon &&
d147 1
a147 1
         if (DarkUI.IsCommandBound(Command))
d152 3
a154 2
            /* Tack string descriptive of action in question on front */
            DisplayOutput = Data.GetString("PlayHint",Action)
a155 1
         }
d250 2
d257 28
d290 2
a291 2
         Quest.Set(WEAP_UI_QVAR,kReady);
      else
d293 1
a293 1
         Quest.Set(WEAP_UI_QVAR,kCocked);
d299 1
a299 1
      Quest.Set(WEAP_UI_QVAR,kReady);
d302 5
a306 1

d309 2
a310 2
      Quest.Set(WEAP_ID_QVAR,integer(self));
      Quest.Set(WEAP_UI_QVAR,kReady);
d319 2
a320 2
      Quest.Set(WEAP_UI_QVAR,kUnready);
      Quest.Set(WEAP_ID_QVAR,OBJ_NULL);
d326 3
a328 2
      Quest.Set(WEAP_UI_QVAR,kUnready);
      Quest.Set(WEAP_ID_QVAR,OBJ_NULL);
d362 2
d423 88
@


1.3
log
@Added training scripts.
@
text
@d2 1
d89 33
d130 8
d236 149
@


1.2
log
@Added AwakeToEscape script
@
text
@d82 116
@


1.1
log
@Initial revision
@
text
@d67 15
@
