head	 1.37;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.37
date	 2000.03.22.23.41.28;  author adurant;  state Exp;
branches ;
next	 1.36;

1.36
date	 2000.03.17.18.05.27;  author adurant;  state Exp;
branches ;
next	 1.35;

1.35
date	 2000.03.16.17.41.24;  author adurant;  state Exp;
branches ;
next	 1.34;

1.34
date	 2000.03.08.21.35.08;  author TJS;  state Exp;
branches ;
next	 1.33;

1.33
date	 2000.03.06.23.39.20;  author adurant;  state Exp;
branches ;
next	 1.32;

1.32
date	 2000.03.06.20.09.17;  author TJS;  state Exp;
branches ;
next	 1.31;

1.31
date	 2000.03.04.20.07.53;  author TJS;  state Exp;
branches ;
next	 1.30;

1.30
date	 2000.03.01.09.56.00;  author adurant;  state Exp;
branches ;
next	 1.29;

1.29
date	 2000.02.29.23.44.47;  author adurant;  state Exp;
branches ;
next	 1.28;

1.28
date	 2000.02.27.12.57.17;  author adurant;  state Exp;
branches ;
next	 1.27;

1.27
date	 2000.02.23.10.09.23;  author adurant;  state Exp;
branches ;
next	 1.26;

1.26
date	 2000.02.21.01.29.04;  author TJS;  state Exp;
branches ;
next	 1.25;

1.25
date	 2000.02.20.05.57.13;  author rsmith;  state Exp;
branches ;
next	 1.24;

1.24
date	 2000.02.19.18.13.33;  author TJS;  state Exp;
branches ;
next	 1.23;

1.23
date	 2000.02.18.17.09.42;  author TJS;  state Exp;
branches ;
next	 1.22;

1.22
date	 2000.02.17.23.54.10;  author adurant;  state Exp;
branches ;
next	 1.21;

1.21
date	 2000.02.16.20.39.15;  author adurant;  state Exp;
branches ;
next	 1.20;

1.20
date	 2000.02.16.16.44.14;  author adurant;  state Exp;
branches ;
next	 1.19;

1.19
date	 2000.02.15.22.40.11;  author rsmith;  state Exp;
branches ;
next	 1.18;

1.18
date	 2000.02.15.17.38.02;  author adurant;  state Exp;
branches ;
next	 1.17;

1.17
date	 2000.02.14.20.46.35;  author adurant;  state Exp;
branches ;
next	 1.16;

1.16
date	 2000.02.13.12.50.28;  author TJS;  state Exp;
branches ;
next	 1.15;

1.15
date	 2000.02.11.18.58.28;  author TJS;  state Exp;
branches ;
next	 1.14;

1.14
date	 2000.02.11.17.04.21;  author adurant;  state Exp;
branches ;
next	 1.13;

1.13
date	 2000.02.11.16.45.35;  author TJS;  state Exp;
branches ;
next	 1.12;

1.12
date	 2000.02.08.22.31.30;  author adurant;  state Exp;
branches ;
next	 1.11;

1.11
date	 2000.02.08.09.48.00;  author adurant;  state Exp;
branches ;
next	 1.10;

1.10
date	 2000.02.07.09.46.57;  author adurant;  state Exp;
branches ;
next	 1.9;

1.9
date	 2000.02.06.00.54.02;  author TJS;  state Exp;
branches ;
next	 1.8;

1.8
date	 2000.02.04.20.21.13;  author TJS;  state Exp;
branches ;
next	 1.7;

1.7
date	 2000.02.02.15.18.52;  author adurant;  state Exp;
branches ;
next	 1.6;

1.6
date	 2000.01.31.17.39.22;  author TJS;  state Exp;
branches ;
next	 1.5;

1.5
date	 2000.01.30.00.10.48;  author rsmith;  state Exp;
branches ;
next	 1.4;

1.4
date	 2000.01.29.23.11.54;  author rsmith;  state Exp;
branches ;
next	 1.3;

1.3
date	 2000.01.27.10.33.03;  author adurant;  state Exp;
branches ;
next	 1.2;

1.2
date	 2000.01.26.18.01.28;  author TJS;  state Exp;
branches ;
next	 1.1;

1.1
date	 2000.01.23.21.26.40;  author TJS;  state Exp;
branches ;
next	 ;


desc
@Not really all AI scripts per se.  Scripts related to creatures in
general, really.
@


1.37
log
@AICheatScript
@
text
@#include "dmgprop.h" //kslaynormal
#include "aiaware.h"
#include "aiteams.h"
#include "drkgoalt.h"
#include "invtype.h"
#include "aitype.h"

/* Causes damage done by "HolyStim" (holy water) stimulus to affect
   zombies permanently, while other types of damage will just put the
   zombie down for a limited period of time.
   */
BEGIN_SCRIPT(ZombieRegen, Physics)

METHODS:
   METHOD void Resurrect()
   {
      Object.RemoveMetaProperty(self,"M-ZombiePossum");
      Link.DestroyMany("AIWatchObj",self,self);
   }

MESSAGES:

   // Zombies should get up if you actually bump into them.
   // in fact, it quite causes problems if they don't.
   OnBeginScript()
   {
      Physics.SubscribeMsg(self, kCollisionMsg);
      DefaultOnBeginScript();
   }
   OnEndScript()
   {
      Physics.UnsubscribeMsg(self, kCollisionMsg);
      DefaultOnEndScript();
   }

   // Problem: will this resurrect the zombie as soon as it dies,
   // due to hitting the player's sword?  Probably ok.
   OnPhysCollision()
   {
      object WhatIHit=message.collObj;

      if(WhatIHit!=object("Player"))
         return;
      // Debug.MPrint("Resurrecting ",self," due to collision with ",WhatIHit);
      Resurrect();
   }

   /* Zombies have a NULL slay result, so we can catch the slain event 
      here and decide what to do.  If we _really_ want to slay them, we
      can always resurrect them, set their slay result to terminate, and
      slay them all over again.
   */
   OnSlain()
   {
      integer slay=Property.Get(self,"SlayResult");

      // Debug.MPrint(self," slain.");
      Property.Remove(self,"AI_IdleOrgn");
      if(Property.Possessed(self,"MAX_HP"))
      {
         integer max=Property.Get(self,"MAX_HP");
         if(max<=0)
         {
            // set me up to explode
            object parts=Object.Named("M-ZombieParts");
            if(Object.InheritsFrom(self,Object.Named("HammerZombie")))
               parts=Object.Named("M-HamZombieParts");
            Object.AddMetaProperty(self,parts);
            Property.Set(self,"SlayResult",kSlayNormal);
            Sound.HaltSpeech(self);
            // Debug.MPrint(self," Really Dead");
         }
         else if(slay!=kSlayNormal)
         {
            boolean possum=GetData("Possum");

            Damage.Resurrect(self);
            if(!possum)
            {
               AI.Signal(self,"Possum");
               // Debug.MPrint(self," Playing Possum");
            }
         }
      }
   }

   OnDamage()
   {
      integer damage=message.damage;
      integer max, hp=Property.Get(self,"HitPoints");
      object stim=message.kind;
      object culprit=message.culprit;
      real permanent=0.0;
      
      if(culprit!=object(0) && Link.AnyExist("~CulpableFor",culprit))
         culprit=Link.GetOne("~CulpableFor",culprit).To();

      if(stim==object("HolyStim") ||
         stim==object("FireStim"))
         permanent=1.0;
      else if(stim==object("LightBright"))
         permanent=0.5;

      if(culprit!=object(0) &&
         Object.InheritsFrom(culprit,"Mechanist"))
         permanent=1.0;
       
      if(Property.Possessed(self,"MAX_HP"))
      {
         max=Property.Get(self,"MAX_HP");
         max-=(damage*permanent);
         Property.Set(self,"MAX_HP",max);
      }

      // Okay, the only way we're going to get damaged by WaterStim
      // is drowning.  If we drown, best to just lie down and stop
      // embarrassing us.
      if(stim==object("WaterStim") && hp<=0)
      {
         Property.Set(self,"SlayResult",kSlayNormal);
      }
      DefaultOnDamage();
   }
   OnMessage()
   {
      if(MessageIs("Resurrect"))
      {
         // Debug.MPrint("Resurrecting ",self," due to message request.");
         Resurrect();
      }
      if(MessageIs("Possum?"))
      {
         // pseudoscript wanting to know if it should add the possum
         // metaproperty/link.  Don't do it if they're already there.
         Reply(!Object.HasMetaProperty(self,"M-ZombiePossum"));
      }
      DefaultOnMessage();
   }
END_SCRIPT(ZombieRegen)
      

BEGIN_SCRIPT(AllAIScript, RootScript)
MESSAGES:
   OnSim()
   {
      if(message.starting)
      {
         if(Property.Possessed(self,"Creature"))
         {
            /* Down with the iron cross.  Pose creature at sim start so you never
               see iron-cross posed creatures, even if they've never come out of
               efficiency.
               */
            // Don't interfere with existing pose, if any
            if(!Property.Possessed(self,"CretPose"))
            {
               Property.CopyFrom(self,"CretPose","M-StandPose");
            }
            Property.Remove(self,"CretPose"); //DAMN YOU!
         }
      }
      DefaultOnSim();
   }
   OnMessage()
   {
      // For use in pseudoscripts that want to randomly continue or not. 
      if (MessageIs("Randomize"))
      {
         int continue_chance = (int)message.data;
         int r = Data.RandInt(0,100);

         Reply(r <= continue_chance);
      }
      DefaultOnMessage();
   }

END_SCRIPT(AllAIScript)


BEGIN_SCRIPT(CorpseFrobHack, AI)

METHODS:
   METHOD void MakeFrobbable(boolean frobbable)
   {
      // Debug.MPrint("Call ",self," MakeFrobbable, ",frobbable);
      if(frobbable)
         Object.RemoveMetaProperty(self,"FrobInert");
      else if(!Object.HasMetaProperty(self,"FrobInert"))
         Object.AddMetaProperty(self,"FrobInert");

      // Frobbable creatures are not responsible for their own actions or safety.
      Property.Set(self,"Culpable",!frobbable);
   }


   METHOD void CheckFrobbable()
   {
      if(Property.Possessed(self,"AI"))
      {
         string set=Property.Get(self,"AI","Behavior Set");
      
         if(set=="null")
            MakeFrobbable(TRUE);
         else if(Property.Possessed(self,"AI_Mode"))
         {
            integer mode=Property.Get(self,"AI_Mode");

            MakeFrobbable(mode==kAIM_Dead);
         }
         else
            MakeFrobbable(FALSE); // Can't tell AI mode; no frob
      }
      else
         MakeFrobbable(TRUE); // No AI, assume it's okay
   }

   METHOD object GetCarriedObj(object myself)
   {
       object candidate = myself;
       linkset contlinks = Link.GetAll("Contains",myself);
       while (contlinks.AnyLinksLeft())
       {
           link curlink = contlinks.Link();
           if ((integer)curlink.GetData() < 0)  //external carry
               candidate = curlink.To();
           contlinks.NextLink();
       }
       return candidate;       
   }

MESSAGES:
   OnBeginScript()
   {
      CheckFrobbable();
      DefaultOnBeginScript();
   }


   OnAIModeChange()
   {
      if (message.mode == kAIM_Dead)
      {
         MakeFrobbable(TRUE); 
      }
      else if (message.previous_mode == kAIM_Dead)
         MakeFrobbable(FALSE); 
      
      // Otherwise, stay how you were 
         
      DefaultOnAIModeChange(); 
   }

   OnFrobWorldEnd()
   {
      if (DarkGame.BindingGetFloat("auto_search") != 0.0)
      {
         Debug.MPrint("Performing Loot And Lug");
         object carriedobj = GetCarriedObj(self);
         if (carriedobj != object(self))
         {
            Container.Add(carriedobj,message.Frobber);
            Reply(FALSE);
         }       
      }
      DefaultOnFrobWorldEnd();
   }

   OnSlain()
   {
      // we're no longer knocked out.
      object ko = object("M-KnockedOut"); 
      if (ko != object(0))
//next line was causing a hang
//         while (Object.HasMetaProperty(self,ko))
            Object.RemoveMetaProperty(self,ko); 
      // de-physicalize
      if (Property.Possessed(self,"PhysType"))
         Property.Set(self,"PhysType","Remove On Sleep",TRUE); 
      DefaultOnSlain(); 
   }


END_SCRIPT(CorpseFrobHack)



BEGIN_SCRIPT(Corpsed, Physics)
MESSAGES:
   OnBeginScript()
   {
      /* If we have a non-zero death stage, instantiate down.
         Fixes bug with damage system killing pre-placed corpses.
         */
      integer stage=0;
      
      // Seems as though Property.Possessed is returning FALSE if this is on a metaprop.
      // but it should still default to an interesting non-zero value in that case if
      // we just add it.
      // Of course, if Property.Possessed returns TRUE against our expectations, we
      // should still make sure the property is instantiated.
      Property.Add(self,"DeathStage");
      stage=Property.Get(self,"DeathStage");
      if(stage==0)
         Property.Remove(self,"DeathStage");

      DefaultOnBeginScript();
   }
   OnContained()
   {
      if(Object.InheritsFrom(message.container,"Avatar"))
      {
         if(message.event==kContainAdd)
         {
            PlayerLimbs.Equip(self);
            Property.Set(self, "NonPhysCreature", FALSE);
         }
         else if(message.event==kContainRemove)
         {
            // If not unconscious, de-physicalize on sleep
            if (!Object.InheritsFrom(self,"M-KnockedOut"))
            {
//just set it anyway.
//               if (Property.Possessed(self,"PhysType"))
                  Property.Set(self,"PhysType","Remove On Sleep",TRUE); 
            }
            PlayerLimbs.UnEquip(self);
         }
      }
      DefaultOnContained();
   }

// This is re-physicalization code if the body throw code is set up to
// auto-remove on sleep. 
#ifdef RE_PHYSICALIZE
   OnPhysMadeNonPhysical()
   {
      if (Object.InheritsFrom(self,"M-KnockedOut"))
         PostMessage(self,"ReFiz"); 
      DefaultOnPhysMadeNonPhysical(); 
   }

   OnMessage()
   {
      if (MessageIs("ReFiz"))
      {
         // re-add physics
         Property.Remove(self,"PhysType"); 
         Property.Add(self,"PhysType"); 
         Property.Set(self,"PhysType","Remove On Sleep",FALSE); 
      }
   } 

#endif // RE_PHYSICALIZE

END_SCRIPT(Corpsed)




/* Cameras send a "TurnOn" when they reach high alertness,
   and a "TurnOff" when they stand down from high alertness.
   They also animate their models to reflect alertness,
   and when slain.  The TweqModels config property is used to
   parametrize the models used (so, cameras which use TweqModels
   animation are not supported).  Model number 0 is used for the
   dead camera, while 1 and up are used for alertness levels.
   */
BEGIN_SCRIPT(CameraAlert, AI)
METHODS:
   METHOD void SetTweqModel(integer tweqmod)
   {
      string model=Property.Get(self,"ModelName");

      if(Property.Possessed(self,"CfgTweqModels"))
         model=Property.Get(self,"CfgTweqModels",
                            string("Model ")+string(tweqmod));

      Property.Set(self,"ModelName",(const char*)model);
   }
   METHOD void Broadcast(boolean on)
   {
      Link.BroadcastOnAllLinks(self,on?"TurnOn":"TurnOff","ControlDevice",NULL);
      // In the future, turrets will handle this message by acquiring the camera's awareness.
      Link.BroadcastOnAllLinks(self,"CUSIC","ControlDevice",NULL);
   }
   METHOD void Update(void)
   {
      // Well, this is hard-coded in the AI, so let's hard-code it here...
      integer AttentionSpan=20; // seconds
      boolean update=FALSE;

      if(Property.Possessed(self,"AI_Alertness") &&
         integer(Property.Get(self,"AI_Alertness","Level"))==kHighAlert)
      {
         integer time=GetTime();
         integer contact=time;
         boolean seeplayer=FALSE;


         if(Link.AnyExist("AIAwareness",self))
         {
            linkset awarelinks=Link.GetAll("AIAwareness",self);

            while(awarelinks.AnyLinksLeft())
            {
               link awarelink=awarelinks.Link();

               if(Object.InheritsFrom(awarelink.To(),"Avatar"))
               {
                  contact=awarelink.GetData("Time Last Contact");
                  // GetTime() is in seconds, while the time here is in milliseconds.
                  // So, round it down.
                  contact/=1000;

                  // Oh, what the heck
                  if(Property.Possessed(self,"ScriptTiming"))
                  {
                     AttentionSpan=Property.Get(self,"ScriptTiming");
                     AttentionSpan=(AttentionSpan+500)/1000;
                  }

                  // Debug.MPrint("Aware of ",awarelink.To()," at time ",contact,"; currently ",time);

                  if((time-contact)>AttentionSpan)
                  {
                     // in an ordinary AI this would lose us a lot of data we
                     // wanted to keep, but in a dumb camera it's probably OK.
                     Link.Destroy(awarelink);
                  }
                  else
                     update=TRUE; // still aware of a player.  Check back.
               }
               awarelinks.NextLink();
            }
         }
      }
      if(update)
         SetOneShotTimer("Update",self,2.0);
   }

   METHOD void SleepMode(boolean asleep)
   {
      integer mode=Property.Get(self,"AI_Mode");

      if(asleep)
      {
         Property.Set(self,"AI_Alertness","Level",kNoAlert);
         Link.DestroyMany("AIAwareness",self,AnyObject);
         Broadcast(FALSE);
         mode=kAIM_Asleep;
      }
      else if(mode==kAIM_Asleep)
         mode=kAIM_Normal;

      Property.Set(self,"AI_Mode",mode);
   }

MESSAGES:
   OnAlertness()
   {
      if(message.level==kHighAlert)
      {
         Broadcast(TRUE);
         Update();
      }
      else if(message.oldLevel==kHighAlert)
      {
         Broadcast(FALSE);
      }
      if(!Object.HasMetaProperty(self,"M-AI-Stasis"))
         SetTweqModel(message.level+1);

      DefaultOnAlertness();
   }
   /* Note that if a camera is slain while at Alertness 3, it can
      never send the all-clear "TurnOff".  This is intentional. */
   OnSlain()
   {
      SetTweqModel(0);
      Broadcast(FALSE);
      DefaultOnSlain();
   }
   OnMessage()
   {
      if(MessageIs("TurnOn"))
      {
         if(Object.HasMetaProperty(self,"M-AI-Stasis"))
         {
            SleepMode(FALSE);
            SetTweqModel(1); // as per 0 alertness, since we know we're alert-capped when off
            Object.RemoveMetaProperty(self,"M-AI-Stasis");
         }
      }
      else if(MessageIs("TurnOff"))
      {
         SleepMode(TRUE);
         if(!Object.HasMetaProperty(self,"M-AI-Stasis"))
            Object.AddMetaProperty(self,"M-AI-Stasis");
         SetTweqModel(5);
      }
      DefaultOnMessage();
   }
   OnTimer()
   {
      if(message.name=="Update")
         Update();
      DefaultOnTimer();
   }

END_SCRIPT(CameraAlert)


// Script: CameraAlert2
// This poorly-named script derives from CameraAlert and overrides the behavior
// whereby Cameras send "TurnOff" OnSlain.  Otherwise identical.
BEGIN_SCRIPT (CameraAlert2, CameraAlert)
   OnSlain()
   {
      SetTweqModel(0);
//      Broadcast(FALSE);
//      DefaultOnSlain();
   }
END_SCRIPT (CameraAlert2)


/* QuaffHeal:
Prompt AI to use a healing potion, if he has one and has lost
hit points.
*/
BEGIN_SCRIPT(QuaffHeal, AI)
METHODS:
   METHOD object MyPotion()
   {
      boolean gotpotion=FALSE;
      object potion, item;
      linkset inventlinks=Link.GetAll("Contains",self);
      object healing=Object.Named("HealingPotion");
      
      for(;!gotpotion && inventlinks.AnyLinksLeft();inventlinks.NextLink())
      {
         item=inventlinks.Link().To();
         //only allow belt or alt potions (ones the player can SEE)
         if (Object.InheritsFrom(item,healing) && 
            (((integer)inventlinks.Link().GetData()==kContainTypeAlt) ||
             ((integer)inventlinks.Link().GetData()==kContainTypeBelt)))
         {
            gotpotion=TRUE;
            potion=item;
         }
      }
      if(gotpotion)
         return potion;
      else
         return object(0);
   }
   METHOD void ConsiderPotion()
   {
      if ((integer)GetData("IgnorePotion")==1)
         return; //we're ignoring potions.
      if(Property.Possessed(self,"AI_Mode") &&
         integer(Property.Get(self,"AI_Mode"))==kAIM_Normal &&
         Property.Possessed(self,"HitPoints") &&
         Property.Possessed(self,"MAX_HP"))
      {
         integer hp=Property.Get(self,"HitPoints");
         integer max=Property.Get(self,"MAX_HP");

         if(hp<max)
         {
            object potion=MyPotion();
            if(potion!=object(0))
            {
               // Play drinking motion
               // @@TODO: Attach potion to hand?
               if ((integer)Link.GetOne("Contains",self,potion).GetData()==kContainTypeAlt)
                  Object.AddMetaProperty(self,"M-LeftHandAlt");
               else //assumes Belt is other type
                  Object.AddMetaProperty(self,"M-LeftHandBelt");
               //don't change the contain type anymore
               SetData("Drinking",TRUE);
               Puppet.PlayMotion(self,"humgulp");
            }
         }
      }
   }

MESSAGES:
   OnBeginScript()
   {
      if (!IsDataSet("IgnorePotion"))
         SetData("IgnorePotion",0);
      DefaultOnBeginScript();
   }
   OnAIModeChange()
   {
      SetOneShotTimer(self,"ConsiderPotion",0.2);
      DefaultOnAIModeChange();
   }
   OnDamage()
   {
      SetOneShotTimer(self,"ConsiderPotion",0.2);
      DefaultOnDamage();
   }
   OnMotionEnd()
   {
      if(message.MotionName=="humgulp" && IsDataSet("Drinking"))
      {
         object potion=MyPotion();
         if(potion!=object(0)) FrobObj(potion,kHighPriorityAction);
         ClearData("Drinking");
         Object.RemoveMetaProperty(self,"M-LeftHandAlt");
         Object.RemoveMetaProperty(self,"M-LeftHandBelt");
      }
      DefaultOnMotionEnd();
   }
   OnMessage()
   {
      if (MessageIs("IgnorePotion"))
         SetData("IgnorePotion",1);
      DefaultOnMessage();
   }
   OnTimer()
   {
      if (message.name == "ConsiderPotion")
         ConsiderPotion();
      DefaultOnTimer();
   }
END_SCRIPT(QuaffHeal)



/* WorkerRobot:

	===WorkerBot metaprops===
  
	 "searching"  - alert cap: max = 3, min = 2; don't fidget; don't return-to-origin, vision = average,
                   shape = model of robot with camera out.  Notices bodies.
	 "camera out" - alert cap: max = 3, min = 1; vision = average, notices bodies.  Shape = model of robot
                   with camera out.


	===WorkerBot pseudoscripts===

	Alert response 2: 
	  * ScriptMessage "DoISearch?" to make sure I'm not already searching
	  * If that passes, add "searching" metaprop
	  * ScriptMessage "DoSearch" to trigger script-controlled search behavior
	  * Some cosmetic stuff, too

	Signal Response "TurnAround":
	  * Play a "TurnAround" motion
	  * Call back to this script with a "DoneATurnAround" msg

	===WorkerBot scripted behavior===

  -> Upon receiving "DoISearch?" msg, it returns F if the robot already has either of
     the metaprops "M-WorkBot-Searching" or "M-WorkBot-CameraOut" or T otherwise.

  -> When prompted by msg "DoSearch" from AlertResponse pseudoscript, the robot
	  plays searching motions (by sending itself "TurnAround" signals) for 
	  GetSearchDuration() seconds.  It also gives itself the "searching"
	  metaprop (which it should already have anyway, but just to be safe) 

  -> If the robot achieves high alertness, it removes the "searching" metaprop.
     It gains the "camera out" metaprop.  The default AI fleeing behavior
	  is assumed to take over.

  -> If the robot ramps down to low alertness, it removes the "camera out" metaprop.  
	  Since the robot cannot ramp down below moderate alert while it has the "searching" 
	  metaprop, we know that since the robot has just ramped down it is not "searching".

*/
BEGIN_SCRIPT (WorkerRobot, AI)

METHODS:
// Start a chain of "TurnAround" events that lasts
// for GetSearchDuration() seconds and terminates with a "DoneSearching" timer.
void DoSearch ()
{
	// I should already have these metaprop, but just in case I don't
	while (!Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
		Object.AddMetaProperty(self,Object.Named("M-WorkBot-Searching"));

   //AMSD removed since we only have Searching XOR Camera
   //while (!Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
	//	Object.AddMetaProperty(self,Object.Named("M-WorkBot-CameraOut"));

	AI.Signal(self,"TurnAround");
	SetOneShotTimer("DoneSearching",GetSearchDuration());
}

// remove the "searching" metaprop
void StopSearching ()
{
	Debug.MPrint(" Stop searching");
	while (Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
		Object.RemoveMetaProperty(self,Object.Named("M-WorkBot-Searching"));
}

// add the "camera out" metaprop
void PullCameraOut ()
{   
   Debug.MPrint(" Pull camera out");
   while (!Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
      Object.AddMetaProperty(self,Object.Named("M-WorkBot-CameraOut"));
}

// remove the "camera out" metaprop
void PutCameraAway()
{
	Debug.MPrint(" Put camera away");
	while (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		Object.RemoveMetaProperty(self,Object.Named("M-WorkBot-CameraOut"));
}

// return search duration in seconds (see DoSearch, above)
float GetSearchDuration ()
{
	return 17.0;
}

MESSAGES:
OnMessage()
{
	if (MessageIs("DoISearch?"))
	{
		// reply F if I have either of these metaprops and T otherwise
		Reply (	!(	(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) ||
					(Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))	)	);
	}
	else if (MessageIs("DoSearch"))
	{
		// I get this message at the end of my alert response 
		// pseudoscript (after it passes "DoISearch?", above)
		DoSearch();
	}
	else if (MessageIs("DoneATurnAround"))
	{
		// call back from pseudoscript at the termination of one "TurnAround" event
		// if we are still "searching", then start another
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
			AI.Signal(self,"TurnAround");
	}
	else if (MessageIs("test"))
	{
		// spew which metaprops I have
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching")))
			Debug.MPrint(self," has metaprop Searching");
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
			Debug.MPrint(self," has metaprop CameraOut");
	}
	DefaultOnMessage();
}

OnTimer()
{
	// "DoneSearching"
	if (	(message.name == "DoneSearching") && 
			(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) )
	{
		StopSearching ();

		// @@NOTE: uncomment the below to force the robot to put his camera away 
		// when he gets done searching.
		// (consider the case when, while searching, the robot doesn't find enough evidence of the
		// player to go to alert 3, but does find enough evidence to keep him at alert 1 or 2 
		// uncommenting this code makes him put his camera away anyway, commenting it 
		// out makes him wait til he ramps down to put it away.
/*		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
			PutCameraAway ();*/
	}

	DefaultOnTimer();
}
OnAlertness()
{
	if (message.level == kHighAlert)
	{
		// since the "searching" metaprop is about not idling and being capped at 2, remove this 
		// and let the natural AI take over and flee - 
      // but don't make sure the robot can still see, add his "camera out" metaprop
		StopSearching();
      PullCameraOut();
	}
	// if you ramp down to or below level 1, when you had been at a higher than 1 alert,
	// you can put your camera away now
	else if ( (message.level <= kLowAlert) && (message.oldLevel > kLowAlert) )
	{
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		{
			PutCameraAway ();
		}
	}
	DefaultOnAlertness();
}

END_SCRIPT (WorkerRobot)





const float kTransluceFreq=0.1;
const float kTransluceTime=1.0; // total time to fade in/out
const float MAX_TLUC=0.5;

/* Handles fading the phantom in and out and moving it to its mark.  Also, phantom is
   set to be always efficient unless needed.
   */
BEGIN_SCRIPT(Phantom, RootScript)

METHODS:
   METHOD void KillAnyTimer()
   {
      if(IsDataSet("Timer"))
      {
         timer_handle timr=GetData("Timer");
         KillTimer(timr);
      }
   }

MESSAGES:
/*
   OnSim()
   {
      if(message.starting && !Object.HasMetaProperty(self,"M-EasilyEfficient"))
         Object.AddMetaProperty(self,"M-EasilyEfficient");
      DefaultOnSim();
   }
   */
   OnMessage()
   {
      if(MessageIs("PhantomBegin"))
      {
         // Move us to our mark
         if(Link.AnyExist("Route",self))
         {
            object mark=Link.GetOne("Route",self).To();
            
            Object.Teleport(self,vector(0,0,0),vector(0,0,0),mark);
         }
         else if(Property.Possessed(self,"AI_IdleOrgn"))
         {
            vector pos=Property.Get(self,"AI_IdleOrgn","Original Location");
            float fac=Property.Get(self,"AI_IdleOrgn","Original Facing");
            vector orient=vector(0,0,fac);

            Object.Teleport(self,pos,orient);
         }

         // Start fade-in
         Property.Set(self,"HasRefs",TRUE);
         Property.Set(self, "RenderAlpha", 0);
         KillAnyTimer();
         SetData("Timer",SetOneShotTimer("In",0));
         // Object.RemoveMetaProperty(self,"M-EasilyEfficient");
      }
      else if(MessageIs("PhantomEnd"))
      {
         KillAnyTimer();
         SetData("Timer",SetOneShotTimer("Out",0));
         // halt all schemas on object
         Sound.HaltSchema(self);
      }
      Reply(TRUE);
      DefaultOnMessage();
   }
   OnTimer()
   {
      const float TransluceRate=MAX_TLUC/(kTransluceTime/kTransluceFreq);
      ClearData("Timer");
      
      // It's still stupid that we don't have TweqAlpha, but this will do.
      float trans = Property.Get(self, "RenderAlpha");
      if (message.name == "Out")
      {
         if (trans>0)
         {
            Property.Set(self, "RenderAlpha", max(trans-TransluceRate, 0));
            SetData("Timer",SetOneShotTimer("Out",kTransluceFreq));
         }
         else
         {
            Property.Set(self,"HasRefs",FALSE);
         }
      }
      else if (message.name == "In")
      {
         if (trans<MAX_TLUC)
         {
            Property.Set(self, "RenderAlpha", min(trans+TransluceRate, MAX_TLUC));
            SetData("Timer",SetOneShotTimer("In", kTransluceFreq));
         }
      }
   }

END_SCRIPT(Phantom)

BEGIN_SCRIPT(ReactsNoisemakers, AI)
METHODS:

METHOD object GetNoisemakerID(string testsignal)
{
    cAnsiStr tempstr = (cAnsiStr)testsignal;
    integer result;
    
    result = tempstr.Find("noisemaker");
    if (result == -1)
        return 0;
    tempstr.Remove(result,strlen("noisemaker"));
    return (atoi(tempstr));
}

MESSAGES:

OnBeginScript()
{
    if (!IsDataSet("NoiseTrack"))
        SetData("NoiseTrack",0);
    DefaultOnBeginScript();
}

OnSignalAI()
{
    object noiseid = GetNoisemakerID(message.signal);
    if (((integer)noiseid > 0) && ((integer)noiseid != (integer)GetData("NoiseTrack")))
      {
	SetData("NoiseTrack",(integer)noiseid);
	GotoObjLoc(noiseid);
      }
    DefaultOnSignalAI();
}

END_SCRIPT(ReactsNoisemakers)


// Script: NoticesPlayerBumps

// The Plan: If the player collides with me and if I don't already have an
// alertness cap, give myself one for a second - long enough to get to alert 2.
// Also, stuff the AIAwarenessLink to the player with data about where the player is, so
// I can logically look in basically the right place for what bumped into me.
// The Reality: In practice, this script is not effective.  The AI only turns to investigate
// the player's former location occasionally for some reason known only the underlying AI.  
// Therefore this script is being used only by WorkerBots at present (1/29/00).  
// For them, they just go to alert 2 temporarily when bumped into if they are not already alert.

BEGIN_SCRIPT(NoticesPlayerBumps ,Physics)

METHODS:
// stuff my info about where I last contacted the player with the
// player's current position
void StuffLinkInfo()
{
	if (!Link.AnyExist("AIAwareness",self,Object.Named("Player")))
	{
		Link.Create("AIAwareness",self,Object.Named("Player"));
	}

	vector player_pos = Object.Position(Object.Named("Player"));
	Link.GetOne("AIAwareness",self,Object.Named("Player")).SetData("Pos last contact",player_pos);
}

MESSAGES:
OnBeginScript()
{
	Physics.SubscribeMsg(self, kCollisionMsg);
	DefaultOnBeginScript();
}
OnEndScript()
{
	Physics.UnsubscribeMsg(self, kCollisionMsg);
	DefaultOnEndScript();
}
OnPhysCollision()
{
	//@@NOTE: bad multiplayer assumption
	// If I collided with the player
	if ((object)message.collObj == Object.Named("Player"))
	{
		// if my alertness < 2
		if ((int)Property.Get(self,"AI_Alertness","Level") < 2)
		{
			// if I have standard Alert Cap properties
/*			if ( (Property.Get(self,"AI_AlertCap","Max level") == 3) &&
				(Property.Get(self,"AI_AlertCap","Min level") == 0) &&
				(Property.Get(self,"AI_AlertCap","Min relax after peak") == 1) ) */
			{
				// stuff my info about where I last contacted the player with the
				// player's current position
//				StuffLinkInfo();

				// cap my alert then upcap it 1 second later
				Property.Set (self,"AI_AlertCap","Min level",2);
				SetOneShotTimer("Uncap",1.0);
			}
		}
	}
	DefaultOnPhysCollision();
}

OnTimer()
{
	if (message.name == "Uncap")
	{
//		Property.Set (self,"AI_AlertCap","Min level",0);
		Property.Remove (self,"AI_AlertCap");
	}
	DefaultOnTimer();
}

END_SCRIPT(NoticesPlayerBumps)

BEGIN_SCRIPT(ShutUpYerDead, RootScript)

MESSAGES:

  OnBeginScript()
  {
    if (!IsDataSet("Snapped"))
      SetData("Snapped",0);

    if (GetData("Snapped")==0)
    {
      Debug.MPrint("Snapping awareness links on ",self);
      linkset awlinks = Link.GetAll("AIAwareness",self);
      while (awlinks.AnyLinksLeft())
      {
        Debug.MPrint("Lowering link to ",awlinks.Link().To());
        awlinks.Link().SetData("flags",kAIAL_Lowest);
        awlinks.NextLink();
      }
    }
    
    //don't drink any more potions.
    PostMessage(self,"IgnorePotion");

    SetData("Snapped",1);
    DefaultOnBeginScript();
  }

END_SCRIPT(ShutUpYerDead)

BEGIN_SCRIPT(SuspiciousReactions, AI)

//ugh, this is getting ugly.  Sigh.  AMSD

METHODS:

   METHOD BOOL ShouldILight()
   {
      integer should = Data.RandInt(1,6);
      return (should == 1);
   }
  
   //We have a semaphore "DoingSuspicious" for not stomping over ourselves,
   //but new suspicious objects can grab our attention if they are high
   //priority.

   //RunOtherLinked is really the heart of the ugliness.

   //Basically, we look through our suspicious links for others of the 
   //same type.  Why, I don't know if there's a good reason anymore, but
   //it originally had the faint hope of extensibility.  Anyway.
   //So we go through links of the same type.  If they are still suspicious,
   //we act on them.  If we don't find any such objects, we check the queue,
   //which holds one other type (door or gaslight), and clear the queue and
   //check that type.   So we should be able to basically react to all
   //things that require more complex reactions (gaslights, doors).  If 
   //a third things needs a more complex reaction, this function is probably
   //better scrapped and rewritten.

 
   METHOD void RunOtherLinked(ObjID suspobj,string susptype)
   {
     linkset susplinks = Link.GetAll("AISuspiciousLink",self);
 
     Debug.MPrint("Running Other Linked");  

     if (AI.GetAlertLevel(self) >= kAIAL_Moderate)
     {
        Debug.MPrint("Alert 2 or higher.  Aborting RunOtherLinked");
        return; //abort.
     }

     while ((susplinks.AnyLinksLeft()) && (GetData("DoingSuspicious")==0))
     { //links left, and semaphore not blocking us.
       link cursusplink = susplinks.Link();
       if (cursusplink.To()!=(object)suspobj) //don't do ourselves again
       {
         if (Property.Possessed(cursusplink.To(),"SuspObj")) //make sure
         {
           if (((string)Property.Get(cursusplink.To(),"SuspObj","Suspicious Type")==susptype) && //verify same type
               ((boolean)Property.Get(cursusplink.To(),"SuspObj","Is Suspicious")==TRUE))
           {
             Debug.MPrint("Found another.  Object: ",cursusplink.To());
             TypeParser(cursusplink.To(),susptype); //it is the same type
           }
	   else
             if ((((string)Property.Get(cursusplink.To(),"SuspObj","Suspicious Type"))!=susptype) &&
                 ((boolean)Property.Get(cursusplink.To(),"SuspObj","Is Suspicious")==TRUE))  //different type, queue it up
		if ((string)GetData("SuspiciousQueueType")=="NULL")
                {
                  if ((string)Property.Get(cursusplink.To(),"SuspObj","Suspicious Type")==(string)"door")
		    SetData("SuspiciousQueueType","door");
                  if ((string)Property.Get(cursusplink.To(),"SuspObj","Suspicious Type")==(string)"gaslight")
                    SetData("SuspiciousQueueType","gaslight");
                }
         }
       }
       susplinks.NextLink();
     } //end while

     if ((string)GetData("SuspiciousQueueType")!="NULL")
     {
       string thedata = (string)GetData("SuspiciousQueueType");
       SetData("SuspiciousQueueType","NULL");
       RunOtherLinked(suspobj,thedata);  //suspobj isn't quite right but ok.
     }

   }

   METHOD void TypeParser(ObjID suspobj, string susptype)
   {
     Debug.MPrint("Type Parsers parsing ",suspobj,", ",susptype,".");
     if (susptype=="torch")
       TorchCall(suspobj);
     if (susptype=="gaslight")
       GasLightCall(suspobj);
     if (susptype=="missingloot")
       LootCall(suspobj);
     if (susptype=="door")
       DoorCall(suspobj);
     if (susptype=="blood")
       BloodCall(suspobj);
     if (susptype=="Generic")
       GenericParser(suspobj);
   }

   METHOD void GenericParser(ObjID suspobj)
   {
     Debug.MPrint("Generic parser called");
     //HACK: We know they are called windows.  So sue me.
     if (Object.InheritsFrom((object)suspobj,Object.Named("Windows")))
       GlassCall(suspobj);
     if (Object.InheritsFrom((object)suspobj,Object.Named("ExBanner")))
       BannerCall(suspobj);
     if (Object.InheritsFrom((object)suspobj,Object.Named("RopeArrowRope")))
       RopeCall(suspobj);
   }

   METHOD void TorchCall(ObjID suspobj)
   {
     Debug.MPrint("Running torch reaction");
     //All we do here is say something.  And the pseudoscript has
     //handled that.  So we're done.  Also, the torch is low priority,
     //so we have a semaphore check to abort early.  Not that aborting
     //early currently means anything, but we should check.
//taking check out so that we can search for gas lights or doors
 //    if ((integer)GetData("DoingSuspicious")!=0)
       RunOtherLinked(suspobj,"gaslight");
 
   }

   METHOD void GasLightCall(ObjID suspobj)
   {
     Debug.MPrint("Running gas light reaction");
     if (!ShouldILight())
        return;
     if ((integer)GetData("DoingSuspicious")!=0)
     {
       if ((integer)GetData("DoingSuspicious")!=1) //not currently doing gaslight
	 SetData("SuspiciousQueueType","gaslight");
       return;
     }
     SetData("DoingSuspicious",1);  //semaphore for a gaslight
     SetData("CurrentObj",suspobj);//BAD BAD WRONG WRONG save/load problems
                                   //but unlikely to save/load at just
                                   //wrong time AND screw up... and we
                                  //don't delete these or anything
                                   //so live for now.  AMSD
     //Our plan here is to walk over to the light, then frob it, then
     //unset our semaphore, and look for the next suspicious thing.
     if (!GotoObjLoc(suspobj,kNormalSpeed,kNormalPriorityAction,"gogaslight"))
     {
        Debug.MPrint(self," failed suspicious Goto reaction to ",suspobj," (gaslight?)");
	SetData("DoingSuspicious",0);
        SetData("CurrentObj",0);
	//don't runotherlinked, because we don't want to loop back and
	//forth.  Let this just be a failure case.
     }
   }

   METHOD void ContinueGasLight(ObjID suspobj)
   {
     Debug.MPrint(self," continuing Gas Light check on ",suspobj);
     //ok, now we went to it.  Frob it.
     FrobObj(suspobj);
     SetData("DoingSuspicious",0);
     SetData("CurrentObj",0);
     RunOtherLinked(suspobj,"gaslight");
   }

   METHOD void RopeCall(ObjID suspobj)
   {
     Debug.MPrint("Running rope reaction");
     //Our plan here is just to say something.  So we're done.  
     //The rope is low priority, so we have a semaphore check to abort
     //early.  Not that aborting early currently means anything, but we
     //should check anyway.
       RunOtherLinked(suspobj,"gaslight");
//     if ((integer)GetData("DoingSuspicious")!=0)
//       return;
   }

   METHOD void DoorCall(ObjID suspobj)
   {
     Debug.MPrint("Running door reaction");
     if ((integer)GetData("DoingSuspicious")!=0)
     {
       if ((integer)GetData("DoingSuspicious")!=2) //not currently doing door
	 SetData("SuspiciousQueueType","door");
       return;
     }
     if (!Link.AnyExist("AIDoor",self,suspobj)) //we opened it
     {  
        SetData("DoingSuspicious",2);  //semaphore for doing a door 
        SetData("CurrentObj",suspobj);
     //Our plan here is to walk over to the door and frob it to open/close
     //it.  If we can lock it(we have the key), we will.  Then we reset
     //our semaphore and look for more.
     //Of course we have a semaphore problem here.  How do I decide between
     //the gaslights and the doors?  If I'm doing one and I start doing
     //the other, I lose the fact that I was working on gaslights...
        if (!GotoObjLoc(suspobj,kNormalSpeed,kNormalPriorityAction,"godoor"))
        {
           Debug.MPrint(self," failed suspicious Goto reaction to ",suspobj," (door?)");
	   SetData("DoingSuspicious",0);
           SetData("CurrentObj",0);
	   //don't runotherlinked, because we don't want to loop back and
	   //forth.  Let this just be a failure case.
        }
     }
     else
     {
        return; //we opened the door we weren't supposed to, something
                //important must be up, abort this suspicious stuff.
     }
   }

   METHOD void ContinueDoor(ObjID suspobj)
   {
     Debug.MPrint(self," continuing Door check on ",suspobj);
     //ok, now we went to it.  Frob it.
     FrobObj(suspobj);
     SetData("DoingSuspicious",0);
     SetData("CurrentObj",0);
     RunOtherLinked(suspobj,"door");
   }


   METHOD void GlassCall(ObjID suspobj)
   {
     Debug.MPrint("Running glass reaction");
     //We've already said something, now we need to go to Alert 2.
     SetMinimumAlert(kModerateAlert); //go to alert 2
     SetOneShotTimer(self,"removeminimum",5.0);
     RunOtherLinked(suspobj,"gaslight");
   }

   METHOD void BannerCall(ObjID suspobj)
   {
     Debug.MPrint("Running banner reaction");
     //We've already said something, now we need to go to Alert 2.
     SetMinimumAlert(kModerateAlert); //go to alert 2
     SetOneShotTimer(self,"removeminimum",5.0);
     RunOtherLinked(suspobj,"gaslight");
   }

   METHOD void BloodCall(ObjID suspobj)
   {
     Debug.MPrint("Running blood reaction");
     //We've already said something, now we need to go to Alert 3.
     SetMinimumAlert(kHighAlert); //go to alert 3
     SetOneShotTimer(self,"removeminimum",10.0);
     //at alert 3... ignore other stuff, don't run other linked.
   }


   METHOD void LootCall(ObjID suspobj)
   {     
     Debug.MPrint("Running loot reaction");
     //We've already said something, now we need to go to Alert 2.
     SetMinimumAlert(kModerateAlert); //go to alert 2
     SetOneShotTimer(self,"removeminimum",5.0);
     RunOtherLinked(suspobj,"gaslight");
   }

MESSAGES:

   OnSim()
   {
     if (message.starting)
     {
       SetData("DoingSuspicious",0);
       SetData("CurrentObj",0);
       SetData("SuspiciousQueueType","NULL"); //assumes only 2 semaphore types
     }
     DefaultOnSim();
   }

   OnMessage()
   {
     if (MessageIs("Suspicious"))
     {
       Debug.MPrint(self," got suspicious message ",message.data,", ",message.data2,".");
       if (AI.GetAlertLevel(self) < kAIAL_Moderate)
          TypeParser((ObjID)message.data,(string)message.data2);
       else
          Debug.MPrint("Alert 2, aborting suspicious reaction.");
     }
     DefaultOnMessage();
   }

   OnObjActResult()
   {
     if (((string)message.data == "gogaslight") && 
         ((integer)GetData("DoingSuspicious")==1) &&
         ((integer)GetData("CurrentObj")!=0))  //make sure 
     {
       ContinueGasLight((ObjID)GetData("CurrentObj"));
     }

     if (((string)message.data == "godoor") && 
         ((integer)GetData("DoingSuspicious")==2) &&
         ((integer)GetData("CurrentObj")!=0))  //make sure 
     {
       ContinueDoor((ObjID)GetData("CurrentObj"));
     }

     DefaultOnObjActResult();
   }

   OnTimer()
   {
     if (message.name=="removeminimum")
       SetMinimumAlert(kLowAlert); //not zero again
     DefaultOnTimer();
   }

END_SCRIPT(SuspiciousReactions)


BEGIN_SCRIPT(SummonMeBoiler, AI)

METHODS:

   METHOD void BringBoiler()
   {
     SetData("MyBoiler",0);
     Debug.MPrint("Summoning boiler for ",self);
     //hack, know name of boiler
     object myboiler = Object.BeginCreate(Object.Named("RobotBoiler"));

     Object.Teleport(myboiler,Object.Position(self),Object.Facing(self));
	
     Object.EndCreate(myboiler);

     link altclink = Link.Create("Contains",self,myboiler);
     altclink.SetData(kContainTypeAlt); //make it alternate

     Property.Add(myboiler,"PhysAttr"); //reinstantiate physics
     Property.Add(myboiler,"PhysType");
     Property.Set(myboiler,"HasRefs",TRUE); //reref ourselves.
     SetData("MyBoiler",(integer)myboiler);
   }

   METHOD object FindBoiler()
   {
     object toreturn = self;  //failure case
     linkset contlinks = Link.GetAll("Contains",self);
     while (contlinks.AnyLinksLeft())
     {
       Debug.MPrint("Searching for Boiler for ",self);
       if ((integer)contlinks.Link().GetData()==kContainTypeAlt)
         toreturn = contlinks.Link().To();
       contlinks.NextLink();
     }
     return toreturn;
   }

MESSAGES:

   OnSim()
   {
     if (message.starting)
       BringBoiler();
     DefaultOnSim();
   }

   OnAIModeChange()
   {
     if (message.mode==kAIM_Dead)   
     {
       Debug.MPrint(self," destroying boiler.");
       object myboiler = FindBoiler();
       Debug.MPrint("Found boiler ",myboiler);
       if ((object)myboiler!=(object)self)
           Object.Destroy(myboiler);
       else
           Debug.MPrint("No boiler to destroy, really.");
     }
     DefaultOnAIModeChange();
   }

END_SCRIPT(SummonMeBoiler)

//ContainWaterProp is not really an AI script, but its only used for robots
//since it's specific to water

BEGIN_SCRIPT(ContainWaterProp, RootScript)

METHODS:
  
   METHOD void ContainPropagate(stimulus_kind thestim, real theintensity)
   {
     linkset clinks = Link.GetAll("~Contains",self);
     while (clinks.AnyLinksLeft())
     {
       ActReact.Stimulate(clinks.Link().To(),thestim,theintensity);
       clinks.NextLink();
     }
   }

MESSAGES:
 
   OnBeginScript()
   {
     ActReact.SubscribeToStimulus(self,"WaterStim");
     DefaultOnBeginScript();
   }
   
   OnStimulus(WaterStim)
   {
     ContainPropagate(message.stimulus,message.intensity);
     //no base class
   }

//to get the stim message

   SCRIPT_BEGIN_MESSAGE_MAP()
     STIMULUS_MESSAGE_MAP_ENTRY(WaterStim)
   SCRIPT_END_MESSAGE_MAP()

END_SCRIPT(ContainWaterProp)



/* We don't want dead AIs to ping back mines.  This takes care of that.
 */
BEGIN_SCRIPT(NoPingBack, AI)

   OnAIModeChange()
   {
      if (message.mode == kAIM_Dead && !Object.HasMetaProperty(self,"NoPingBack"))
         Object.AddMetaProperty(self,"NoPingBack");
      DefaultOnAIModeChange();
   }
END_SCRIPT(NoPingBack)

/* Script so that turret cannonballs don't need to arc to work properly
*/

BEGIN_SCRIPT(ReGravitize, Physics)

   OnBeginScript()
   {
     if (!IsDataSet("Gravitized"))
       SetData("Gravitized",0);
     if ((integer)GetData("Gravitized")==0)
       SetOneShotTimer("GiveMeGravity",0.3);
     Physics.SubscribeMsg(self,kCollisionMsg);
     DefaultOnBeginScript();
   }

   OnEndScript()
   {
     Physics.UnsubscribeMsg(self,kCollisionMsg);
     DefaultOnEndScript();
   }

   OnPhysCollision()
   {
     Property.Set(self,"PhysAttr","Gravity %",66.0); 
     SetData("Gravitized",1);
     DefaultOnPhysCollision();
   }

   OnTimer()
   {
     if (message.name == "GiveMeGravity")
       Property.Set(self,"PhysAttr","Gravity %",66.0);
     DefaultOnTimer();
   }

END_SCRIPT(ReGravitize);

//knockedout robots should still corpse swap.  We already have a corpse link
//so just do the real slay.  We must be our own culprit so that the player
//gets the appropriate blame stats (deactivate/destroy).
BEGIN_SCRIPT(RobotSlayScript, AI)

MESSAGES:

   OnAIModeChange()
   {
      if (message.mode == kAIM_Dead)
      {
         if ((integer)Property.Get(self,"HitPoints")>0)
            Damage.Slay(self,self); //really just kill me.
      }
      DefaultOnAIModeChange();
   }

END_SCRIPT(RobotSlayScript)


/* Controls alertness-dependent smokestack steam effect on combat bots.
 */
BEGIN_SCRIPT(RoboSteam, AI)
METHODS:
   METHOD object MySteam()
   {
      object archi=object("RoboSteam");
      if(!Object.Exists(archi))
         return object(0);
      if(Link.AnyExist("~ParticleAttachement",self))
      {
         linkset particles=Link.GetAll("~ParticleAttachement",self);
         while(particles.AnyLinksLeft())
         {
            if(Object.InheritsFrom(particles.Link().To(),archi))
               return particles.Link().To();
            particles.NextLink();
         }
      }
      return object(0);
   }
MESSAGES:
   OnTweqComplete()
   {
      if(message.Type==kTweqTypeFlicker &&
         message.Op==kTweqOpFrameEvent)
      {
         integer rate=Property.Get(self,"CfgTweqBlink","Rate");
         integer turnoff=250;
         object effect=MySteam();
         if(effect!=object(0))
         {
            if(Property.Possessed(effect,"ScriptTiming"))
               turnoff=Property.Get(effect,"ScriptTiming");
            // turn off shouldn't come after next expected tweq.  In fact, limit it to 50%
            // of that time.
            if(turnoff*2>rate)
               turnoff=rate/2;
            PGroup.SetActive(effect,TRUE);
            if(IsDataSet("SteamTimer"))
            {
               timer_handle steamt=GetData("SteamTimer");
               KillTimer(steamt);
            }
            SetData("SteamTimer",SetOneShotTimer(self,"SteamOff",float(turnoff)/1000.0));
         }
      }
      DefaultOnTweqComplete();
   }
   OnTimer()
   {
      if(message.name=="SteamOff")
      {
         object effect=MySteam();
         ClearData("SteamTimer");
         if(effect!=object(0))
         {
            PGroup.SetActive(effect,FALSE);
         }
      }
      DefaultOnTimer();
   }
   OnAlertness()
   {
      integer divisor=message.level+1;
      if(divisor!=0 && Property.Possessed(self,"CfgTweqBlink"))
      {
         integer newrate=2000/divisor;
         Property.Set(self,"CfgTweqBlink","Rate",newrate);
         Property.Set(self,"StTweqBlink","Cur Time",newrate-1);
      }
      DefaultOnAlertness();
   }


END_SCRIPT(RoboSteam)

BEGIN_SCRIPT(CleanUpAttack, AI)

MESSAGES:
  
   OnAIModeChange()
   {
      if (message.mode == kAIM_Dead)
         PostMessage(self,"AbortAttack");
      DefaultOnAIModeChange();
   }

END_SCRIPT(CleanUpAttack)

BEGIN_SCRIPT(SlayHaltSpeech, AI)

MESSAGES:

   OnSlain()
   {
      Sound.HaltSpeech(self);
      DefaultOnSlain();
   }
END_SCRIPT(SlayHaltSpeech)

BEGIN_SCRIPT(AICheatScript, AI)

METHODS:
  METHOD void Catch(string whatdata)
  {
     if ((integer)GetData(whatdata)==0)
        return;
     Debug.MPrint(self," Catching Garrett");
     integer i;
     for (i = 0; i<20; i++)
     {
       if (Quest.Get(GoalVisibleVarName(i)))
          Quest.Set(GoalStateVarName(i),kGoalFailed);
     }
  }

MESSAGES:

  OnSim()
  {
     if (message.starting)
     {
        //FailOnSee logic.
        if (DarkGame.ConfigIsDefined("FailOnSee"))
           SetData("FailOnSee",1);
        else
           SetData("FailOnSee",0);
        if (DarkGame.ConfigIsDefined("FailOnKO"))
           SetData("FailOnKO",1);
        else
           SetData("FailOnKO",0);
        if (Object.InheritsFrom(self,Object.Named("Rat")))
           SetData("FailOnSee",0);
        if (Object.InheritsFrom(self,Object.Named("EyeballPlant")))
           SetData("FailOnSee",0);
        if (Property.Possessed(self,"AI_Team"))
        {
           integer myteam = (integer)Property.Get(self,"AI_Team");
           if (myteam<=kAIT_Neutral)
           {
              SetData("FailOnSee",0);
           }              
        }
        else
        {
           Property.Add(self,"AI_Team");
           integer myteam = (integer)Property.Get(self,"AI_Team");
           if (myteam<=kAIT_Neutral)
           {
              SetData("FailOnSee",0);
           }
           Property.Remove(self,"AI_Team");
        }
        if ((integer)GetData("FailOnSee")==1)
           Debug.MPrint(self," is looking for Garrett.");
        if ((integer)GetData("FailOnKO")==1)
           Debug.MPrint(self," should not get KO'd by Garrett.");
     }
     DefaultOnSim();
  }

  OnAIModeChange()
  {
     if (message.mode==kAIM_Dead)
     {
           integer hp = 99;
      
           if (Property.Possessed(self,"HitPoints"))
              hp=Property.Get(self,"HitPoints");
           if (hp>0)
              Catch("FailOnKO");
     }
     DefaultOnAIModeChange();
  }

  OnHighAlert()
  {
     int hp = 99;
     if (Property.Possessed(self,"HitPoints"))
        hp = Property.Get(self,"HitPoints");

     if ((!Object.HasMetaProperty(self,Object.Named("M-KnockedOut"))) &&
         (hp>0))
        Catch("FailOnSee");
     DefaultOnHighAlert();
  }

END_SCRIPT(AICheatScript)

@


1.36
log
@SlayHaltSpeech script for rats and frogbeasts to make them shut up
when dead
@
text
@d3 2
d1628 89
@


1.35
log
@Script CleanUpAttack to send AbortAttack message on Mode Dead so that
AI's with AttackActivate particle effects clean them up.
AI's no longer move healing potions to their hands when knocked out.
If an AI has a healing potion and a quiver arrow, he no longer moves both
to his hand when drinking the potion.
AI's no longer drink healing potions that they have generically contained,
only belt and alternate potions
@
text
@d1614 13
a1626 1
END_SCRIPT(CleanUpAttack)@


1.34
log
@Instantiate non-zero death stage in Corpsed script.
@
text
@d540 4
a543 1
         if(Object.InheritsFrom(item,healing))
d556 2
d573 5
a577 2
               Object.AddMetaProperty(self,"M-LeftHandAlt");
               Link.GetOne("Contains",self,potion).SetData(kContainTypeAlt);
d586 6
d594 1
a594 1
      ConsiderPotion();
d599 1
a599 1
      ConsiderPotion();
d610 1
d614 12
d1033 3
d1602 13
@


1.33
log
@fixed worker bot behaviours... will flee again
@
text
@d287 19
@


1.32
log
@Robo steam
@
text
@d588 4
a591 2
	 "searching"  - alert cap: max = 3, min = 2; don't fidget; don't return-to-origin 
	 "camera out" - shape::model of "robot with camera out",  vision = average (not NULL like usual)
a592 3
	A robot can have "camera out" but not be "searching" in the case where it has seen the 
	player, ramped up to alert 3, and run away.
	A robot should never be "searching" unless it has "camera out", however.
d598 1
a598 1
	  * If that passes, add "searching" and "camera out" metaprops
d613 1
a613 1
	  GetSearchDuration() seconds.  It also gives itself the "searching" and "camera out"
d617 1
a617 1
     It retains the "camera out" metaprop.  The default AI fleeing behavior
a634 2
	while (!Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		Object.AddMetaProperty(self,Object.Named("M-WorkBot-CameraOut"));
d636 4
d647 1
a647 1
//	Debug.MPrint(" Stop searching");
d652 8
d663 1
a663 1
//	Debug.MPrint(" Put camera away");
d732 2
a733 2
		// and let the natural AI take over and flee - but don't remove the robots
		// "camera out" metaprop
d735 1
@


1.31
log
@Teleportation of phantoms: facing is _z_ orientation.
Phantom script handlers reply TRUE.
@
text
@d1465 78
@


1.30
log
@random relighting
@
text
@d788 1
a788 1
            vector orient=vector(fac,0,0);
d807 1
@


1.29
log
@suspicious don't do stuff at higher alert
don't close doors I open
@
text
@d987 6
d1106 2
@


1.28
log
@robot slay script
@
text
@d1012 6
d1155 4
a1158 2
     SetData("DoingSuspicious",2);  //semaphore for doing a door 
     SetData("CurrentObj",suspobj);
d1165 10
a1174 1
     if (!GotoObjLoc(suspobj,kNormalSpeed,kNormalPriorityAction,"godoor"))
d1176 2
a1177 5
        Debug.MPrint(self," failed suspicious Goto reaction to ",suspobj," (door?)");
	SetData("DoingSuspicious",0);
        SetData("CurrentObj",0);
	//don't runotherlinked, because we don't want to loop back and
	//forth.  Let this just be a failure case.
d1247 4
a1250 1
       TypeParser((ObjID)message.data,(string)message.data2);
@


1.27
log
@blood/banners suspicious
@
text
@a1220 1
       Debug.MPrint("Sim starting ",self," suspicious reaction.");
d1420 19
@


1.26
log
@Mechanists damage zombies.
@
text
@d1060 2
d1072 2
d1186 19
@


1.25
log
@added CameraAlert2, which is identical to CameraAlert except
that it does not send "TurnOff"s OnSlain
@
text
@d103 1
a103 1
         Object.InheritsFrom(culprit,"Hammerite"))
@


1.24
log
@Don't put CretPose on something that's not a Creature.
@
text
@d492 13
@


1.23
log
@Cameras and turrets are in Asleep mode when inactive.  Should keep
inactive cameras from tracking.
@
text
@d146 1
a146 6
         /* Down with the iron cross.  Pose creature at sim start so you never
            see iron-cross posed creatures, even if they've never come out of
            efficiency.
            */
         // Don't interfere with existing pose, if any
         if(!Property.Possessed(self,"CretPose"))
d148 10
a157 1
            Property.CopyFrom(self,"CretPose","M-StandPose");
a158 1
         Property.Remove(self,"CretPose"); //DAMN YOU!
@


1.22
log
@waxing eloquent
@
text
@d140 1
a140 5
/* Down with the iron cross.  Pose creature at sim start so you never
   see iron-cross posed creatures, even if they've never come out of
   efficiency.
   */
BEGIN_SCRIPT(PoseInit, AI)
d146 4
d155 1
a155 1
	 Property.Remove(self,"CretPose"); //DAMN YOU!
d159 14
a172 1
END_SCRIPT(PoseInit)
d175 1
a175 1
BEGIN_SCRIPT(CorpseFrobHack, PoseInit)
d356 6
d417 17
d439 1
a439 1
         Link.BroadcastOnAllLinks(self,"TurnOn","ControlDevice",NULL);
d444 1
a444 1
         Link.BroadcastOnAllLinks(self,"TurnOff","ControlDevice",NULL);
d456 1
d465 2
a466 1
            SetTweqModel(1); // as per 0 alertness, since we know we're alert-capped
d472 1
d1381 1
a1381 1
END_SCRIPT(ReGravitize);@


1.21
log
@Fixed bug where AI's would destroy wrong obj when destroying boiler
@
text
@d1042 5
a1046 1
     SetData("CurrentObj",suspobj);
@


1.20
log
@ReGravitize script for turret firing hack
@
text
@d1208 1
d1210 12
d1238 6
a1243 3
       if ((integer)GetData("MyBoiler")!=0)
         if (Object.Exists((object)GetData("MyBoiler")))
           Object.Destroy((object)GetData("MyBoiler"));
@


1.19
log
@modified WorkerBot to daisy-chain "turn around" signals
immediately instead of padding them out with a second pause.
this prevents the little buggers from taking steps of
their patrol in-between said motins.
@
text
@d1286 37
@


1.18
log
@PoseInit now immediately removes the pose after adding it.  Fixes
AI's dying and getting back up on save/load.
@
text
@d607 1
a607 1
	return 16.0;
d630 1
a630 1
			SetOneShotTimer ("TurnNow",1.0);
a660 5
	else if (message.name == "TurnNow")
	{
		// do another "TurnAround" iteration
		AI.Signal(self,"TurnAround");
	}
@


1.17
log
@always remove dead AI phys models on sleep, whether they have prop or not.
Fixes diff between dropping and throwing (timing issue?)
@
text
@d155 1
@


1.16
log
@Typo.  Property is CretPose, not CretPos.
@
text
@d284 2
a285 1
               if (Property.Possessed(self,"PhysType"))
@


1.15
log
@Added NoPingBack
@
text
@d153 1
a153 1
            Property.CopyFrom(self,"CretPos","M-StandPose");
@


1.14
log
@SummonMeBoiler script for robots to get their vulnerable boilers
ContainWaterProp script to go on boilers so they can propagate
water stim to the robots
@
text
@d1278 3
d1282 7
@


1.13
log
@Added PoseInit.
@
text
@d1186 89
a1274 1
END_SCRIPT(SuspiciousReactions);
@


1.12
log
@SuspiciousReactiosn on Ai to deal with suspicion.
@
text
@d140 22
a161 1
BEGIN_SCRIPT(CorpseFrobHack, AI)
@


1.11
log
@New script ShutUpYerDead for snapping awareness links on guys being
knocked unconscious
@
text
@d908 262
@


1.10
log
@include invtype.h
ai should build on it's own, dagnabbit.
@
text
@d4 1
d882 26
@


1.9
log
@Added correct motion to QuaffHeal, had it attach potion to hand.
@
text
@d3 1
@


1.8
log
@Cameras become unaware faster, tunable in their ScriptTiming property.
@
text
@d467 4
a470 1
               // Play drinking motion?
d472 1
a472 1
               Puppet.PlayMotion(self,"BH214113");
d491 1
a491 1
      if(message.MotionName=="BH214113" && IsDataSet("Drinking"))
d496 1
@


1.7
log
@ai's with "reactsnoisemakers" script will go over to noisemakers
@
text
@d2 1
a3 1

d318 55
d379 1
d414 6
@


1.6
log
@Pulled out Elemental scripts.
@
text
@d699 2
d702 33
@


1.5
log
@removed Debug.Mprint commands I accidentally left in
@
text
@a2 176
// Script behaviors common to elementals, such
// as changing size based on hit points.
BEGIN_SCRIPT(Elemental, AI)

METHODS:

   METHOD void NotifyParticleGroups(string mess)
   {
      Link.BroadcastOnAllLinks(self,mess,"~ParticleAttachement");
   }

MESSAGES:

   OnDamage()
   {
      // @@TODO: Change scale smoothly, using tweq?
      const float MIN_ELEMENTAL_SCALE=0.375;
      vector newprop;
      float newsc;

      if(Property.Possessed(self,"HitPoints") &&
         Property.Possessed(self,"MAX_HP"))
      {
         int max=Property.Get(self,"MAX_HP");

         if(max==0) return; // whaddaya gonna do?
         newsc=Property.Get(self,"HitPoints");

         // even at negative hit points, don't scale to less than MIN
         if(newsc<0) newsc=0;

         newsc/=max;
         newsc=MIN_ELEMENTAL_SCALE+((1.0-MIN_ELEMENTAL_SCALE)*newsc);
         newprop.x=newprop.y=newprop.z=newsc;
         Property.Set(self,"Scale",newprop);
      }
      else
         Debug.MPrint(self," got damage message without HP properties!");;
   }

   // if we have any particle groups associated with us,
   // we'll want to shut them down.
   OnSlain()
   {
      // set our tweqscale so that we shrink away
      const float TIME_TO_SHRINK=10.0;
      vector rates, tmpvec, scale=vector(1.0,1.0,1.0);

      if(Property.Possessed(self,"StTweqScale"))
      {
         if(Property.Possessed(self,"Scale"))
            scale=Property.Get(self,"Scale");

         Property.Add(self,"CfgTweqScale");

         rates.x=-scale.x/TIME_TO_SHRINK;
         rates.y=-scale.y/TIME_TO_SHRINK;
         rates.z=-scale.z/TIME_TO_SHRINK;

         // why, oh why, didn't we write this the other way?
         tmpvec=Property.Get(self,"CfgTweqScale","x rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.y=0;
         tmpvec.z=scale.x;
         Property.Set(self,"CfgTweqScale","x rate-low-high",tmpvec);
         tmpvec=Property.Get(self,"CfgTweqScale","y rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.z=scale.y;
         Property.Set(self,"CfgTweqScale","y rate-low-high",tmpvec);
         tmpvec=Property.Get(self,"CfgTweqScale","z rate-low-high");
         tmpvec.x=rates.x;
         tmpvec.z=scale.z;
         Property.Set(self,"CfgTweqScale","z rate-low-high",tmpvec);

         ActReact.React("tweq_control",1.0,self,0, kTweqTypeAll, kTweqDoActivate); 
      }
      Sound.HaltSpeech(self);

      DefaultOnSlain();
   }

END_SCRIPT(Elemental)

// Special effects associated with fire elemental AI
BEGIN_SCRIPT(FireElement,Elemental)

MESSAGES:

   OnDamage()
   {
      integer hp=Property.Get(self,"HitPoints");

      if (message.damage>0 && hp>=0)
      {
         object spang;
         object spang_arch;

         // @@TODO: You'd really like this to be done through the
         // blood splatter system.
  
         if(object(message.kind)==object("WaterStim"))
         {
            spang_arch=Object.Named("SteamPuff");
         }
         else
            spang_arch=Object.Named("FElemHit");

         if(Object.InheritsFrom(object(message.culprit),spang_arch))
         {
            Debug.MPrint("Pelligro! Heading off potential chain reaction of spang from ",self);
            spang_arch=object(0);
         }

         if(spang_arch!=object(0))
         {
            spang=Object.Create(spang_arch);
            Object.Teleport(spang,vector(0.0,0.0,0.0),vector(0.0,0.0,0.0),self);
         }
      }
      DefaultOnDamage();
   }
   OnAlertness()
   {
      // @@TODO: This calculation is of course riddled
      // with magic numbers which should be dealth with.
      
      // I still like an interpolation from like .4-1.0 or so,
      // but .4 is obviously not very flashy, so let's jack
      // this up a little bit at least for E3.
      float litelvl=.6+((.4/3.0)*message.level);
      
      float alpha=.3+(.2*message.level);
      int selflit=25+25*message.level;
      static const string moods[]={"Mood0","Mood1","Mood2","Mood3"};
      
      if(message.level<0 || message.level>=(sizeof(moods)/sizeof(moods[0])))
      {
         Debug.MPrint("Invalid alertness in obj ",self," script!");
         return;
      }

      if(message.level<2)
      {
         // Turn off heat source
         Object.RemoveMetaProperty(self,Object.Named("BigHeatSource"));
      }
      else
      {
         object metaprop=Object.Named("BigHeatSource");
         // Turn on heat source
         if(!Object.HasMetaProperty(self,metaprop))
         {
            Object.AddMetaProperty(self,metaprop);
         }
      }
      
      if(litelvl>1.0)
         litelvl=1.0;
      Property.Set(self,"ExtraLight","Amount (-1..1)",litelvl);
      Property.Set(self,"RenderAlpha",alpha);
      Property.Set(self,"SelfLit",selflit);
      
      NotifyParticleGroups(moods[message.level]);
   }
/* Screw this.  Replace it with CorpsePart
   OnSlain()
   {
      object puff=Object.Create("SmokePuff");
      Object.Teleport(puff,vector(0.0,0.0,0.0),vector(0.0,0.0,0.0),self);
      DefaultOnSlain();
   }
*/

END_SCRIPT(FireElement)


@


1.4
log
@Polished up the WorkerRobot script, added actual useful comments,
made it work with the new, real robot instead of the old, placeholder
robot.
Also added: NoticesPlayerBumps, an attempt at getting the AI to
notice when the player bumps into it, which didn't work so good and
therefore is being used only in the special case of the WorkerBot.
@
text
@d676 1
a676 1
	Debug.MPrint(" Stop searching");
d684 1
a684 1
	Debug.MPrint(" Put camera away");
@


1.3
log
@include dmgprop.h  now it builds alone
@
text
@d616 4
a619 8
  Upon receiving "DoISearch?" msg, it returns F if the robot already has either of
  the metaprops "M-WorkBot-Searching" or "M-WorkBot-CameraOut" or T otherwise.
  When prompted by msg "DoSearch" from AlertResponse pseudoscript, the robot
  gives itself the "M-WorkBot-Searching" metaprop and plays searching motions
  (defined by GetSearchMotion()) for GetSearchDuration() seconds.
  If the robot achieves high alertness, it removes the searching metaprop.
  If the robot ramps down to low alertness, it prompts the SignalResponse
  pseudoscript to put the robots camera away.
d621 34
d659 2
d663 1
d666 2
d669 1
a669 2
	AI.SetScriptFlags(self, kMotionOff);  // disallow new motions
	Puppet.PlayMotion(self,GetSearchMotion());
d672 2
d676 1
a676 2
	AI.SetScriptFlags(self, 0x00); 		// Allow new motions again 

d680 3
a682 1
string GetSearchMotion ()
d684 3
a686 1
	return "BH111210";  // turn 90 deg to left
d688 2
d692 1
a692 1
	return 15.0;
d706 2
d710 1
a710 6
	DefaultOnMessage();
}
OnMotionEnd()
{
	if (	(message.MotionName == GetSearchMotion()) && 
			(Object.HasMetaProperty(self,Object.Named("M-WorkBot-Searching"))) )
d712 4
a715 1
		SetOneShotTimer ("TurnNow",1.0);
d717 9
a725 1
	DefaultOnMotionEnd();
d727 1
d730 1
d735 9
a743 4
		if (Object.HasMetaProperty(self,Object.Named("M-WorkBot-CameraOut")))
		{
			AI.Signal(self, "PutCameraAway");
		}
d745 1
d748 2
a749 1
		Puppet.PlayMotion(self,GetSearchMotion());
d757 3
d762 3
a764 1
	else if ( (message.level == kLowAlert) && (message.oldLevel > kLowAlert) )
d768 1
a768 1
			AI.Signal(self, "PutCameraAway");
d776 4
d876 78
@


1.2
log
@New, improved QuaffHeal script.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d564 1
a564 2
MESSAGES:
   OnAlertness()
d567 1
a567 2
         integer(Property.Get(self,"AI_Mode"))!=kAIM_Dead &&
         message.level!=kAIAL_High && 
d585 12
a596 1
      DefaultOnAlertness();
@
