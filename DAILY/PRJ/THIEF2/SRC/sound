// $Header: r:/t2repos/thief2/src/sound/ambbase.h,v 1.7 2000/01/29 13:41:38 adurant Exp $
// ambient sound wackiness for Dark
// internal definitions
#pragma once

#ifndef  __AMBBASE_H
#define  __AMBBASE_H

#include <label.h>

///////////////
// constants and flags
#define MAX_AMB_OBJS          (256)

// static flags
#define AMBFLG_S_ENVIRON      (1<<0)  // this is environmental
#define AMBFLG_S_NOSHARPCURVE (1<<1)  // dont use the sharper attenuation curve for objs
#define AMBFLG_S_TURNEDOFF    (1<<2)  // the amb is currently not playing

#define AMBFLG_S_REMOVE       (1<<3)  // remove the property (oneshot, basically)
#define AMBFLG_S_MUSIC        (1<<4)  // this is music
#define AMBFLG_S_SYNCH        (1<<5)  // synch on downbeats
#define AMBFLG_S_NOFADE       (1<<6)  // do you want this env sound to not fade
#define AMBFLG_S_KILLOBJ      (1<<7)  // kill the object
#define AMBFLG_S_AUTOOFF      (1<<8)  // turn off after firing once

//////////////
// structures

typedef struct {
   int    rad;          // radius, in feet, of effect
   int    over_volume;  // override volume, or 0 to play at schema default
   ushort flags;        // static flags field, ie. designer set
   ushort pad;       // keep us dword aligned   
   Label  schema_name;  // as you would expect
   Label  aux_schema_1; //   aux schemas to play with the base one
   Label  aux_schema_2; //   wooo-wooo
} AmbientSound;

#endif  // __AMBBASE_H
// $Header: r:/t2repos/thief2/src/sound/ambient.c,v 1.29 1999/04/26 15:12:00 mwhite Exp $
// ambient sound object initial cut
// actual system which do things sound things
// ambprop has the prop sys side

#include <stdlib.h>
#include <string.h>

#include <mprintf.h>
#include <timer.h>
#include <config.h>
#include <matrix.h>
#include <appagg.h>

#include <objremap.h>
#include <schbase.h>
#include <schema.h>
#include <objpos.h>
#include <tagfile.h>
#include <vernum.h>
#include <wrtype.h>
#include <simtime.h>
#include <dmgmodel.h>

#include <ambbase.h>
#include <ambient_.h>
#include <rand.h>

#include <dbmem.h>

#include <songutil.h>

// @TODO: this is the only thing bound by MAX_AMB_OBJS
AmbientRunTime  ambRTData[MAX_AMB_OBJS];

#ifdef PLAYTEST
bool ambient_mono=FALSE, ambient_heartbeat=FALSE;
 int amb_heartbeat_count=0;
#define amb_info(x)  do { if (ambient_mono) mprintf x ; } while (0)
#define amb_info2(x) do { if (ambient_mono) mprintf x ; } while (0)
#define amb_hbeat()  if (ambient_heartbeat&&(((++amb_heartbeat_count)&0x7f)==0)) ShowHeartbeatStats()
#define _amb_xtra_clear(hnd) \
 do { \
    if (hnd!=NO_CUR_HANDLE) \
       mprintf("Ambient: inloop Halt didnt null handle for %x\n",hnd); \
    hnd=NO_CUR_HANDLE; \
 } while (0)
#else
#define amb_info(x)
#define amb_info2(x)
#define amb_hbeat()
#define _amb_xtra_clear(h)
#endif

#define AMB_ENV_INACTIVE (-1)

// this is dorky - i really want to make entry 0 in our list always the current environment
// and not let any objects get assigned to it, but im not sure how to do that
int            cur_env_idx = AMB_ENV_INACTIVE, last_env_idx=AMB_ENV_INACTIVE;
int            hAuxSch1, hAuxSch2;

//AmbientSound   curEnv;   // track the current "environment"

// @HACK for beta milestone, so we don't play in edit mode
ObjID          restore_obj = OBJ_NULL;

static int sgCurrSongThemeIdx;

#define _ambsnd_handle(i)   (ambRTData[i].schemaHandle)
#define _ambsnd_lastplay(i) (ambRTData[i].last_played)

#define AMB_ENV_PDATA     (-1)
#define AMB_ENV_AUX_PDATA (-2)

#define NO_CUR_HANDLE  SCH_HANDLE_NULL
#define MIN_REFIRE     1000

// setup the initial data 'n such...
void AmbientRunTimeInit(void)
{
   int i;

   for (i=0; i<MAX_AMB_OBJS; i++)
   {
      _ambsnd_handle(i)=NO_CUR_HANDLE;
      _ambsnd_lastplay(i)=0;
   }
   hAuxSch1=hAuxSch2=NO_CUR_HANDLE;
}         // no currently running handle either

void AmbientReset()
{
#ifndef SHIP   
   int i;
   for (i=0; i<MAX_AMB_OBJS; i++)
   {
      if (_ambsnd_handle(i)!=NO_CUR_HANDLE)
      {
         mprintf("Warning... currently slot %d has handle %x\n",i,_ambsnd_handle(i));
         if (i==cur_env_idx)
            mprintf("Warning... this is the current environment schema\n");
         else if (i==last_env_idx)
            mprintf("Warning... this is the last environment schema\n");
      }
      _ambsnd_handle(i)=NO_CUR_HANDLE;          
      _ambsnd_lastplay(i)=0;
   }
   if (hAuxSch1!=NO_CUR_HANDLE)
      mprintf("Warning... currenty have active auxSch1 %x\n",hAuxSch1);
   if (hAuxSch2!=NO_CUR_HANDLE)
      mprintf("Warning... currenty have active auxSch2 %x\n",hAuxSch2);
#endif   
   AmbientRunTimeInit();
}

#ifdef PLAYTEST
static void ShowHeartbeatStats(void)
{
   int i;
   if (cur_env_idx!=AMB_ENV_INACTIVE)
      mprintf("CurEnv is %s\n",ambState(cur_env_idx)->schema_name.text);
   for (i=0; i<MAX_AMB_OBJS; i++)
   {
      if (_ambsnd_handle(i)!=NO_CUR_HANDLE)
      {
         AmbientSound *state=ambState(i);
         mprintf("Amb slot %d: currently %x [%s]",i,_ambsnd_handle(i),state?state->schema_name.text:"Unknown");
         if (i==cur_env_idx)
            mprintf(" current env");
         else if (i==last_env_idx)
            mprintf(" last env");
         mprintf("\n");
      }
   }
   if (hAuxSch1!=NO_CUR_HANDLE)
      mprintf("Amb AuxSch1 currently %x\n",hAuxSch1);
   if (hAuxSch2!=NO_CUR_HANDLE)
      mprintf("Amb AuxSch2 currently %x\n",hAuxSch2);
}
#endif

// if we get kill callback
static void _AmbSchemaKillCallback(int hSchema, ObjID schemaID, void *pData)
{
   int idx=(int)pData;
   if (idx==AMB_ENV_AUX_PDATA)  // if secret hacked aux thing, deal and get out
   {
      if (hSchema==hAuxSch1)
      {
         amb_info(("schema kill of aux env 1 (%x)\n",hSchema));
         hAuxSch1=NO_CUR_HANDLE;
      }
      else if (hSchema==hAuxSch2)
      {
         amb_info(("schema kill of aux env 2 (%x)\n",hSchema));
         hAuxSch2=NO_CUR_HANDLE;
      }
      else
         Warning(("Ambient: Got kill event for aux sample im not using!!\n"));
      return;
   }
   if (idx==AMB_ENV_PDATA)
   {
      if (hSchema==_ambsnd_handle(cur_env_idx))
         idx=cur_env_idx;
      else if (hSchema==_ambsnd_handle(last_env_idx))
         idx=last_env_idx;
      else
         mprintf("Amb seeing ENV handle (%x) but isnt cur or last\n",hSchema);
   }
   // if we make it here, it is primary environment or an object
#ifdef PLAYTEST
   else if (idx>=0)
      if (hSchema!=_ambsnd_handle(idx))
         mprintf("AmbSchemaKillCallback:  idx v. handle mismatch (idx %d gave %x v. %x)\n",idx,_ambsnd_handle(idx),hSchema);
#endif
   if (idx>=0)
   {
      AmbientSound *state=ambState(idx);
#ifdef PLAYTEST
      if (idx==cur_env_idx)
         amb_info(("schema kill active environment (idx %d) %s (%x)\n",idx,ambState(cur_env_idx)->schema_name.text,hSchema));
      else if (idx==last_env_idx)
         amb_info(("schema kill last environment (idx %d) (%x)\n",idx,hSchema));
      else
         amb_info(("schema kill of object ambient (idx %d) %s (%x)\n",idx,ambState(idx)->schema_name.text,hSchema));
#endif
      _ambsnd_handle(idx)=NO_CUR_HANDLE;  // look, im done playing
      if (idx==cur_env_idx)
         cur_env_idx=AMB_ENV_INACTIVE;
      else if (idx==last_env_idx)
         last_env_idx=AMB_ENV_INACTIVE;

      if (state)
      {
         if (state->flags&AMBFLG_S_KILLOBJ)
         {
            IDamageModel *pDmgModel=AppGetObj(IDamageModel);
            IDamageModel_SlayObject(pDmgModel,ambObjID(idx),OBJ_NULL);
            SafeRelease(pDmgModel);
         }
         else if (state->flags&AMBFLG_S_REMOVE)
            ambRemove(idx);
         else if (state->flags&AMBFLG_S_AUTOOFF)
            ambSetFlags(idx,state->flags|AMBFLG_S_TURNEDOFF);
      }
#ifdef PLAYTEST
      else
         mprintf("AmbSchemaKillCallback: NULL state for idx %d\n",idx);
#endif      
   }
#ifdef PLAYTEST   
   else
      amb_info(("Schema kill of nothing? (idx %d) (schema %x)\n", idx, hSchema));
#endif   
}

// default callback
static sSchemaCallParams schemaCallData={0,0,OBJ_NULL,NULL,0,_AmbSchemaKillCallback,0,NULL};

int _AmbientRestore();

// for now, we boneheadly scan the whole area every frame
// really, we should cache for each object how far away it was
// things greater than 2x rad can update every couple seconds
// as opposed to checking every frame
void AmbientRunFrame(mxs_vector *head_pos)  // where is the head?
{  
   ulong sim_time=tm_get_millisec();  // should probably use sim-time, eh?
   int i, near_env_idx=AMB_ENV_INACTIVE;
   float near_env_dist=1e20;
   float rad;

   for (i=0; i< ambMax(); i++)
      if (ambObjID(i)!=OBJ_NULL)
      {  // go through and check ranges for each object from the head
         ObjPos* pos = ObjPosGet(ambObjID(i));
         AmbientSound* state = ambState(i);
         float realdist;
         mxs_vector diff;

         // Song hack.
         if ( state->flags & AMBFLG_S_MUSIC )
         {
            if (i != sgCurrSongThemeIdx)
            {
               // Check to see if head is inside sphere.
               rad = (float)state->rad;
               mx_sub_vec(&diff,&pos->loc.vec,head_pos);
               if ( mx_mag2_vec(&diff) < (rad * rad) )
               {
                  // Head is inside sphere... Change theme.
                  sgCurrSongThemeIdx = i;
                  SongUtilSetTheme ( state->schema_name.text );
               }
            }
            continue; // Sorry.. I never use these, but it's easier here than a big "else".
         }

         if (state->flags&AMBFLG_S_TURNEDOFF)
         {  // if ive been turned off, make sure im not active
            if (_ambsnd_handle(i)!=NO_CUR_HANDLE)
            {  // if we are currently playing
               if (i==cur_env_idx)
               {
                  SchemaPlayHalt(_ambsnd_handle(i));
                  if (hAuxSch1!=NO_CUR_HANDLE) SchemaPlayHalt(hAuxSch1);
                  if (hAuxSch2!=NO_CUR_HANDLE) SchemaPlayHalt(hAuxSch2);
               }
               else
                  SchemaPlayHalt(_ambsnd_handle(i));
            }
            continue;
         }

         mx_sub_vec(&diff,&pos->loc.vec,head_pos);

#define RAD_MUL 1.05
         rad = (float)state->rad;

         if (((state->flags&AMBFLG_S_ENVIRON)==0)&&(_ambsnd_handle(i)!=NO_CUR_HANDLE))
         {  // we are already playing - but have we gone too far away 
            if ( mx_mag2_vec(&diff)*RAD_MUL > ( rad * rad ) )
            {
               SchemaPlayHalt(_ambsnd_handle(i));
               amb_info(("Killing local ambient (idx %d) %s (%x)\n",
                         i,state->schema_name.text,_ambsnd_handle(i)));
               _amb_xtra_clear(_ambsnd_handle(i));
            }
         }
         else
            // This "quick test" is apparently a mistake: should be "abs(diff.x)+abs(diff.y)+abs(diff.z)",
            // but abs is roughly as expensive as actually doing the squaring.  The test happens to not
            // actually break code, and shortcuts some cases, but in general is misleading and inefficient.
            // (It's additional computation that generally becomes "if (true)").
            //if ((diff.x+diff.y+diff.z)<(float)(state->rad<<1))  // may be worth considering
               if ( ( realdist=mx_mag2_vec(&diff)*RAD_MUL ) < ( rad *  rad ) )
                  if (state->flags&AMBFLG_S_ENVIRON)
                  {  // within radius of an environmental ambient object
                     if (realdist<near_env_dist)
                     {
                        near_env_dist=realdist;
                        near_env_idx=i;
                     }
                  }
                  else if (sim_time>_ambsnd_lastplay(i)+MIN_REFIRE)
                  {  // check to make sure we dont refire within time x passed
                     schemaCallData.flags    = SCH_SET_OBJ|SCH_SET_CALLBACK|SCH_RADIUS_VOLUME;
                     if ((state->flags&AMBFLG_S_NOSHARPCURVE)==0)
                        schemaCallData.flags |= SCH_SHARP_ATTEN;
                     schemaCallData.sourceID = ambObjID(i);  // objID
                     schemaCallData.pData    = (void *)i;    // handle
                     schemaCallData.volume   = state->rad;
                     _ambsnd_handle(i)=SchemaPlay(&state->schema_name,&schemaCallData,NULL);
                     if (_ambsnd_handle(i)==SCH_HANDLE_NULL)
                        Warning(("Ambient couldn't play %s\n",state->schema_name.text));
                     _ambsnd_lastplay(i)     = sim_time;
                     amb_info(("Fired ambient object (idx %d) %s (%x)\n",
                               i,state->schema_name.text,_ambsnd_handle(i)));
                  }  // not sure how to wire up the modify callback, sadly
      }

   if (restore_obj != OBJ_NULL)
      near_env_idx = _AmbientRestore();

   if (near_env_idx != AMB_ENV_INACTIVE)
   {  // Bail if we're in the currently active schema
      if (near_env_idx == cur_env_idx)
         return;

      last_env_idx = cur_env_idx;
      cur_env_idx = near_env_idx;
      amb_info(("Switching into env %d from %d\n",cur_env_idx,last_env_idx));

      if (last_env_idx!=AMB_ENV_INACTIVE && ambState(last_env_idx)==NULL)
      {
#ifdef PLAYTEST
         mprintf("Needing to use INACTIVE since state of %d is NULL\n",last_env_idx);
#endif
         amb_info(("Needing to use INACTIVE since state of %d is NULL\n",last_env_idx));
         last_env_idx=AMB_ENV_INACTIVE;
      }

      // Don't start main if it has the same name
      if ((last_env_idx==AMB_ENV_INACTIVE)||
          (stricmp(ambState(last_env_idx)->schema_name.text,ambState(cur_env_idx)->schema_name.text)))
      {  // it is an environmental of a different name
         if ((last_env_idx!=AMB_ENV_INACTIVE)&&(_ambsnd_handle(last_env_idx)!=NO_CUR_HANDLE))
         {  // we are currently playing, want to stop it
            amb_info(("Leaving environment schema (idx %d) %s (%x)\n",
                      last_env_idx,ambState(last_env_idx)->schema_name.text,_ambsnd_handle(last_env_idx)));
            SchemaPlayHalt(_ambsnd_handle(last_env_idx));  // @TODO: Fade?
            _amb_xtra_clear(_ambsnd_handle(last_env_idx));
         }
#ifdef PLAYTEST         
         else
         {
            if (last_env_idx==AMB_ENV_INACTIVE)
            {
               if ((hAuxSch1!=NO_CUR_HANDLE)||(hAuxSch2!=NO_CUR_HANDLE))
                  Warning(("Had aux 1 or 2, no primary ambient bed\n"));
               amb_info(("Leaving environment NULL (%x %x)\n",hAuxSch1,hAuxSch2));
            }
            else
               amb_info(("Leaving environment %s main inactive (aux %x %x)\n",
                         ambState(last_env_idx)->schema_name.text,hAuxSch1,hAuxSch2));
         }
#endif         
         if (ambState(near_env_idx)->schema_name.text[0]!='\0')
         {
            schemaCallData.flags    = SCH_SET_CALLBACK;
            schemaCallData.pData    = (void *)AMB_ENV_PDATA; // cur_env_idx;
            _ambsnd_handle(cur_env_idx)=SchemaPlay(&ambState(cur_env_idx)->schema_name, &schemaCallData, NULL);
            amb_info(("Entering environment schema (idx %d) %s (%x)\n",
                      cur_env_idx,ambState(cur_env_idx)->schema_name.text,_ambsnd_handle(cur_env_idx)));
         }
         else
            amb_info(("Entering environment schema NULL\n"));
      }
      else if (last_env_idx!=AMB_ENV_INACTIVE)
      {  // same base schema, maybe new aux stuff
         _ambsnd_handle(cur_env_idx)=_ambsnd_handle(last_env_idx);
         _ambsnd_handle(last_env_idx)=NO_CUR_HANDLE;
      }

      // Stop auxiliaries
      if (hAuxSch1!=NO_CUR_HANDLE)
      { 
         amb_info2(("kill aux 1 %x\n",hAuxSch1));
         SchemaPlayHalt(hAuxSch1); 
         _amb_xtra_clear(hAuxSch1);
      }
      if (hAuxSch2!=NO_CUR_HANDLE)
      { 
         amb_info2(("kill aux 2 %x\n",hAuxSch2));
         SchemaPlayHalt(hAuxSch2); 
         _amb_xtra_clear(hAuxSch2);         
      }

      // Start auxiliaries
      if (ambState(near_env_idx)->aux_schema_1.text[0]!='\0')
      {
         schemaCallData.flags    = SCH_SET_CALLBACK;
         schemaCallData.pData = (void *)AMB_ENV_AUX_PDATA;    
         hAuxSch1=SchemaPlay(&ambState(cur_env_idx)->aux_schema_1, &schemaCallData,NULL);
         amb_info2(("start aux 1 %x\n",hAuxSch1));
      }
      if (ambState(near_env_idx)->aux_schema_2.text[0]!='\0')
      {
         schemaCallData.flags    = SCH_SET_CALLBACK;
         schemaCallData.pData = (void *)AMB_ENV_AUX_PDATA;             
         hAuxSch2=SchemaPlay(&ambState(cur_env_idx)->aux_schema_2, &schemaCallData, NULL);
         amb_info2(("start aux 2 %x\n",hAuxSch2));
      }
   }
   amb_hbeat();
}

//////////////////////////
// save/load support

static TagVersion AmbientVersion = {1, 2};
static TagFileTag AmbientTag = {"AMBIENT"};

BOOL AmbientSave(ITagFile *file)
{
   HRESULT result = ITagFile_OpenBlock(file, &AmbientTag, &AmbientVersion);
   BOOL rv = FALSE;

   if (result == S_OK)
   {
      ObjID obj = ambObjID(cur_env_idx);
      ITagFile_Write(file, (char *) &obj, sizeof(obj));
      ITagFile_CloseBlock(file);
   }
   if (cur_env_idx != -1)
   {  // @HACK for beta: make sound start again
      restore_obj = ambObjID(cur_env_idx);
//      cur_env_idx = -1;
   }

   return rv;
}


BOOL AmbientLoad(ITagFile *file)
{
   TagVersion found_version = AmbientVersion;
   HRESULT result = ITagFile_OpenBlock(file, &AmbientTag, &found_version);
   BOOL rv = FALSE;

   if (result == S_OK
    && found_version.major == AmbientVersion.major
    && found_version.minor == AmbientVersion.minor)
   {
      ITagFile_Read(file, (char *) &restore_obj, sizeof(restore_obj));
      ITagFile_CloseBlock(file);
   }
   return rv;
}

// attempt to restore on load
static int _AmbientRestore(void)
{
   ObjID obj = ObjRemapOnLoad(restore_obj);

   restore_obj = OBJ_NULL;

   if (obj != OBJ_NULL) {
      int max = ambMax();
      int i;
      for (i = 0; i < max; ++i)
         if (ambObjID(i) == obj)
         {
            amb_info(("Restore idx %d from obj %d\n",i,obj));
            return i;
         }
   }
   Warning(("Could not restore old ambient state from obj %d.\n", obj));
   return -1;
}

#ifdef PLAYTEST
#include <r3d.h>
#include <g2.h>
#include <fix.h>
void AmbientDrawRadii(BOOL all)
{
   int ocol = gr_get_fcolor();
   r3s_point pt;
   int i;

   gr_set_fcolor(241);
   for (i=0; i<ambMax(); i++)
      if (ambObjID(i)!=OBJ_NULL)      
      {
         if (!all && (_ambsnd_handle(i)==NO_CUR_HANDLE))
            continue;
         r3_start_block();
         r3_transform_block(1, &pt, &ObjPosGet(ambObjID(i))->loc.vec);
         if (pt.ccodes == 0)
         {
            AmbientSound *state=ambState(i);
            int s=(int)r3_get_hsize(pt.p.z,(float)state->rad);
            int rad=fix_div(s,grd_bm.w);
            g2_circle(pt.grp.sx, pt.grp.sy, rad);
         }
         r3_end_block();
      }
   gr_set_fcolor(ocol);
}
#endif
// $Header: r:/t2repos/thief2/src/sound/ambient.h,v 1.6 2000/01/29 13:41:39 adurant Exp $
// ambient sound object initial cut
#pragma once

#ifndef __AMBIENT_H
#define __AMBIENT_H

// init run time data structures - ie. clear out arrays and stuff
EXTERN void AmbientRunTimeInit(void);

// this runs a frame of ambient object self update
// should be called once a frame, with head set right
// this might make more sense to query the head
// it is all kinda temporary at the moment
EXTERN void AmbientRunFrame(struct mxs_vector *head_pos);

// reset, clears out handles
EXTERN void AmbientReset();

// for saving & loading in-game
EXTERN BOOL AmbientSave(ITagFile *file);
EXTERN BOOL AmbientLoad(ITagFile *file);

// there is no term yet
// if you want to term, for now, you have to term all schemas, i guess
// this probably needs to be fixed

#ifdef PLAYTEST
EXTERN void AmbientDrawRadii(BOOL all);
#endif

#endif  // __AMBIENT_H
// $Header: r:/t2repos/thief2/src/sound/ambient_.h,v 1.5 2000/01/29 13:41:40 adurant Exp $
// ambient sound object initial cut
#pragma once

#ifndef __AMBIENT__H
#define __AMBIENT__H

#include <objtype.h>
#include <ambbase.h>

EXTERN int ambMax();  // max # of ambient objects
EXTERN ObjID ambObjID(int idx);  // the objid for ambient N 
EXTERN AmbientSound* ambState(int idx);  // the state for ambient N
EXTERN void ambRemove(int idx);
EXTERN void ambSetFlags(int idx, int flags);

// this data is run time used by the system to track playing
typedef struct {
   int   schemaHandle;   // the schemaHandle if we are now playing
   ulong last_played;    // this should be sim time
} AmbientRunTime;

#endif  // __AMBIENT__H
// $Header: r:/t2repos/thief2/src/sound/ambprop.cpp,v 1.13 1999/05/26 12:18:55 JON Exp $
// ambient sound wackiness for Dark
// initial hacked version, sorry

#include <propert_.h>
#include <propbase.h>
#include <propcary.h>

#include <sdesc.h>
#include <sdesbase.h>

#include <schema.h>
#include <ambbase.h>
#include <ambient.h>
#include <ambprop.h>
#include <ambient_.h>

#include <objedit.h>
#include <mprintf.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////////////////////////
// Ambient Sound Object Property Declaration
//

// this is SO hacked.  keep this in sync with the declaration in ambient.c

EXTERN AmbientRunTime ambRTData[MAX_AMB_OBJS];

//
// My data ops. 
// If you wanted to change how the data gets manipulated (e.g. read and written)
// overload the operations of the base class. 

class cAmbientDataOps : public cClassDataOps<AmbientSound>
{

}; 

static cAmbientDataOps ambient_ops; 


class cAmbientSoundProperty : public cGenericProperty<IAmbientSoundProperty,&IID_IAmbientSoundProperty,AmbientSound*>
{
  typedef cGenericProperty<IAmbientSoundProperty,&IID_IAmbientSoundProperty,AmbientSound*> cParent; 

public:
   cAmbientSoundProperty(const sPropertyDesc* desc, IPropertyStore* store)
      : cParent(desc,store, &ambient_ops)
   {
   }; 

   void OnListenMsg(ePropertyListenMsg msg, ObjID objID, uPropListenerValue value)
   {
      if (msg & kListenPropUnset)
      { 
         for (int i=0; i<ambMax(); i++)
         {
            // shouldnt we call some abstracted version of the kill code in ambient
            // !!!bug!!! what if this is a env sound
            if (ambObjID(i) == objID)
               if (ambRTData[i].schemaHandle!=SCH_HANDLE_NULL)
                  SchemaPlayHalt(ambRTData[i].schemaHandle);
         }
      }
      
      cParent::OnListenMsg(msg, objID, value);
   }

   // our type descriptor
   STANDARD_DESCRIBE_TYPE(AmbientSound); 

};

static char *flags_names[] =
 { "Environmental", "NoSharpCurve", "TurnedOff", "RemoveProp (OneShot)", "Music", "Synch", "NoFade", "DestroyObj", "DoAutoOff" };

// structure descriptor fun
static sFieldDesc amb_fields [] =
{
   { "Radius",           kFieldTypeInt,    FieldLocation(AmbientSound,rad) },
   { "Override Volume",  kFieldTypeInt,    FieldLocation(AmbientSound,over_volume) },
   { "Flags",            kFieldTypeBits,   FieldLocation(AmbientSound,flags), FullFieldNames(flags_names) },
   { "Schema Name",      kFieldTypeString, FieldLocation(AmbientSound,schema_name) },
   { "Aux Schema 1",     kFieldTypeString, FieldLocation(AmbientSound,aux_schema_1) },
   { "Aux Schema 2",     kFieldTypeString, FieldLocation(AmbientSound,aux_schema_2) },
};

static sStructDesc amb_struct = StructDescBuild(AmbientSound,kStructFlagNone,amb_fields);

// the property descriptor
static sPropertyDesc ambpropdesc =
{
   PROP_AMBIENTSOUND_NAME,
   kPropertyNoInherit|kPropertyInstantiate|kPropertyConcrete,
   NULL
};

static cGenericCompactArrayPropertyStore* ambstore = NULL;

IAmbientSoundProperty *g_pAmbientProp = NULL;

// let us attempt to initialize ourselves
BOOL AmbSoundPropInit(void)
{
   AmbientRunTimeInit();
   StructDescRegister(&amb_struct);
   ambstore = new cGenericCompactArrayPropertyStore(); 
   g_pAmbientProp = new cAmbientSoundProperty(&ambpropdesc,ambstore);
   return TRUE;
}

void AmbSoundPropTerm(void)
{
   SafeRelease(g_pAmbientProp);
}

#ifdef PLAYTEST
EXTERN void AmbSoundDump(void)
{
   for (int i=0; i<MAX_AMB_OBJS && i<ambstore->MaxIdx(); i++)
   {
      ObjID objID = ambObjID(i);
      mprintf("Amb [%d]: %s\n", i, (objID != OBJ_NULL) ? ObjWarnName(ambObjID(i)) : "OBJ_NULL");
   }
}
#endif

int ambMax()
{
#ifdef PLAYTEST
   if (ambstore->MaxIdx() >= MAX_AMB_OBJS)
      AmbSoundDump();
#endif
   AssertMsg(ambstore->MaxIdx() < MAX_AMB_OBJS, "Out of ambient objects!");
   return ambstore->MaxIdx(); 
}

ObjID ambObjID(int idx)
{
#ifdef PLAYTEST
   if (idx >= MAX_AMB_OBJS)
      AmbSoundDump();
#endif
   AssertMsg1(idx < MAX_AMB_OBJS, "Invalid ambient index %d requested!", idx);
   return ambstore->Idx2Obj(idx); 
}

AmbientSound* ambState(int idx)
{
   return (AmbientSound*)(*ambstore)[idx].value; 
}

void ambRemove(int idx)
{
   ObjID obj=ambObjID(idx);
   if (obj==OBJ_NULL)
   {
      Warning(("Trying to Remove NULL\n"));
      return;
   }
   g_pAmbientProp->Delete(obj);
}

void ambSetFlags(int idx, int flags)
{
   ObjID obj=ambObjID(idx);
   AmbientSound *snd;
   if (obj==OBJ_NULL)
   {
      Warning(("Trying to SetFlags on NULL\n"));
      return;
   }
   if (g_pAmbientProp->Get(obj,&snd))
   {
      snd->flags=flags;
      g_pAmbientProp->Set(obj,snd);
   }
}
// $Header: r:/t2repos/thief2/src/sound/ambprop.h,v 1.4 2000/01/29 13:41:41 adurant Exp $
// ambient sound wackiness for Dark
#pragma once

#ifndef __AMBPROP_H
#define __AMBPROP_H

#include <property.h>
#include <ambbase.h>

#undef INTERFACE
#define INTERFACE IAmbientSoundProperty
DECLARE_PROPERTY_INTERFACE(IAmbientSoundProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(AmbientSound*); 
}; 


#define PROP_AMBIENTSOUND_NAME "AmbientHacked"

EXTERN BOOL AmbSoundPropInit(void);

#endif  // __AMBPROP_H
// $Header: r:/t2repos/thief2/src/sound/appsfx.cpp,v 1.127 2000/03/24 22:57:27 adurant Exp $
// remedial sound system for DromEd/Dark/AIR/So on

#include <dynarray.h>
#include <math.h>
#include <arqapi.h>

#include <timer.h>

#include <appagg.h>

#include <matrix.h>
#include <lgsound.h>
#include <config.h>
#include <mprintf.h>

#include <storeapi.h>
#include <resapi.h>
#include <sndrstyp.h>

#include <appsfx.h>
#include <appsfxi.h>
#include <wrtype.h>
#include <objpos.h>
#include <auxsnd.h>
#include <prikind.h>

#include <rooms.h>
#include <roomsys.h>
#include <roomeax.h>
#include <roomprop.h>
#include <playrobj.h>
#include <osysbase.h>
#include <timelog.h>
#include <simtime.h>  // for horror of dynamic channels

#include <songutil.h>

#ifdef EDITOR
#include <songedtr.h>
#endif

#include <objmedia.h>
#include <physapi.h>

////////////
// profiling and timers

// define this to get mono-prints of timing
//   info, and to get play_sfx timings to work
//#define APPSFX_TIMINGS

#ifdef APPSFX_TIMINGS
#define PROFILE_ON
#endif

// We ask the mixer for more channels than the user requests
// so that some channels are always available to metagame.
// There's no speed overhead since in-game allocation is self-
// limiting.
#define SFX_BONUSCHANNELS 6

#include <timings.h>

#include <dbmem.h>      // last header, yada yada

//#define MIXER_COUNTS
//#define MPRINT_TRACK
//#define STRESS_ASYNCH
//#define DYNAMIC_CHANNELS

#ifdef MPRINT_TRACK
#define snd_mprintf(x) mprintf x
static int GetRefCount(IRes *p) { int x=0; if (p) { x=p->AddRef(); p->Release(); } return x-1; }
#else
#define snd_mprintf(x)
#define GetRefCount(p) (666)
#endif

DECLARE_TIMER(StartPlayTimer, Average);
DECLARE_TIMER(SndMixerTimer, Average);
DECLARE_TIMER(SfxUpdateTimer, Average);

///////////////////////////////////////
// data structures, static globals

typedef struct {
   uchar  type;      // sound effect type, set by user/app
   char   ID;        // location in fxlist
   ushort pad;       // i hate everything
   uint   flags;     // for quick determination of what to do in updates
   ObjID  attach;    // object attached to
   mxs_vector loc;   // location for non-attached sounds, or bounce loc
   ISndSample *pSnd; // actual sound effect we are playing
   IRes* pRes;       // handle to resource being used
   char  *name;      // for streaming sounds, i guess, for now, maybe
   int master_gain;  // master volume for the sample, as opposed to attenuated/cur
   int distance;     // distance to sound origination point (-1 == stright line)
   sfx_parm parm;    // current parameters locally for the sample
   ulong  play_time; // when did we first get sample
   char* pStreamBuffer;  // Buffer used when streaming.  NULL if not streamed.
   mxs_real blocking_factor;  // current blocking factor
} _sfx;              // maybe name should be for all, extension generates type


int                  sfx_use_channels           = 8; // SFX_CHANNELS;
static _sfx          fxlist[SFX_MAX_COUNT];
static ISndMixer*    pSndMixer                  = NULL;
static sfx_parm      def_parms                  = {0,0,0,0,0,-1,0,0,0,-1,NULL,NULL};
static float         attenuation_factor         = 55;
static float         pan_factor                 = 0.4;
static eSnd3DMethod  sfx3DMethod                = kSnd3DMethodSoftware;
static int           max_simul_hardware_3d_snds = 0;  // @TODO: pick which ones we use less idiotically
static BOOL          in_kill;
static BOOL          sfxCheckChannels           = TRUE;
static int           sgLastVolumeSetting        = 0; // So we can restore volume between close and init.
static int           sgLastRoomType;
static float         sgSourceReverbMix          = 0.6;
static float         sgGainScale                = 1.0;
static int           sgMixerTimeout             = -1;
static BOOL          rev_stereo                 = FALSE;
static char          dummy_sound[64]            = {'\0',};
static BOOL          sound_always_delay         = FALSE;
static BOOL          sfx_loud_cap               = FALSE;
static cDynArray<_sfx> g_DeferredCallbackList;
static BOOL          g_deferCallbacks;
static BOOL          g_allowAsynch              = TRUE;
static BOOL          g_asynchAll                = TRUE;
static BOOL          sgLogRoomTransitions       = FALSE;
static BOOL          sgSpewMixerAttribs         = FALSE;
static int           sgVol2D;
static int           sgVol3D;
static int           sgVol2DHW;
static int           sgVol3DHW;
static int           sgVolMusic;
static BOOL          sgVolsChanged;
static BOOL          use2DHWmod; //add in sgVol2DHW
static BOOL          use3DHWmod; //add in sgVol3DHW

///////////////////////////////////////////////////////////
// Function callback definitions.
BOOL (*appsfxModeCallback)(sfx_mode mode, int handle, sfx_parm *parm) = NULL;

#define SFX_GAME_BASE_INDEX     0
#define SFX_METAGAME_BASE_INDEX SFX_MAX_MODE_COUNT
static int          base_index; // this is a dumb name

#define _sfx_get_hnd_from_ptr(fx) (fx-fxlist)

///////////////////////////////////////////////////////////
// Forward declarations of the internal functions
static BOOL _sfx_update(_sfx *fx, BOOL init, ulong cur_time);
static void _sfx_free(_sfx *fx, BOOL makeCallback);
static void SFX_Store_Config();

// simple system to set flags fields for app called types
// this array is [BF][type], and takes a BF and user type and tells
// what flags that implies.  
#define SFX_BF_RAW 0
#define SFX_BF_OBJ 1
#define SFX_BF_VEC 2
uchar base_flags[3][3]=
{
   {SFXFLG_STATIC,SFXFLG_STATIC,SFXFLG_STATIC},
   {SFXFLG_STATIC,SFXFLG_STATIC|SFXFLG_OBJ,SFXFLG_POS|SFXFLG_OBJ},
   {SFXFLG_STATIC,SFXFLG_STATIC,SFXFLG_POS},
};

#define set_flags(fx,which,app) \
    (fx->flags=base_flags[which][fx->type]|(app&SFXFLG_APP_MASK))
 
BOOL _sfx_priority_callback( ISndMixer    *pMixer,
                             ISndSample   *pSample,
                             void         *pCBData );

#ifdef DBG_ON
void DbgCheckInUseChannels(void);  // check to make sure we are all cleaned up
#else
#define DbgCheckInUseChannels()
#endif

ISearchPath *pSoundPath = 0;

static int  g_SFX_Device = SFXDEVICE_Software;

///////////////////////////////////////
// have some horror

#ifdef DYNAMIC_CHANNELS
#define FRAME_HISTORY_LEN     (0x20)
#define FRAME_HISTORY_MASK    (0x1f)
#define FRAME_HISTORY_SHIFT      (5)
static int sfx_time_log[FRAME_HISTORY_LEN];
static int sfx_time_total=0;
static int sfx_time_index=0;
#define IDEAL_MIN_FRAME_RATE    (16)
#define IDEAL_MIN_FRAME_MS    (1000/IDEAL_MIN_FRAME_RATE)
#define DYNAMIC_MODIFIER(fr)    ((IDEAL_MIN_FRAME_RATE-fr)/4)  // 0 - 3 channels 
#endif DYNAMIC_CHANNELS

///////////////////////////////////////
// startup/shutdown

void SFXClose(void)
{
   // Store config variables.
   SFX_Store_Config ();

   if (pSndMixer)
   {
      // Store current master volume setting.
      sgLastVolumeSetting = SFX_GetMasterVolume();

      int i;
      pSndMixer->StopAllSamples();
      pSndMixer->Update();      // trigger those callbacks
      for (i=0; i<SFX_MAX_COUNT; i++)
         if (fxlist[i].type!=SFX_NONE)
            _sfx_free(&fxlist[i], TRUE);
      
#ifndef SHIP
      for (i=0; i<SFX_MAX_COUNT; i++)
         if (fxlist[i].pSnd)
         {
            Warning(("Some sounds were not fully cleaned up\n"));
            break;
         }
#endif
      
      // Shutdown reverb if in use.
      if ( pSndMixer->Have3DReverb () )
         pSndMixer->Shutdown3DReverb();

      // Shut down song system.
#ifdef EDITOR
      SongEd_Shutdown();
#endif
      SongUtilShutdown();

      TIMELOG_DUMP( "sndlog.txt" );
      int ref = pSndMixer->Release();
      AssertMsg1(!ref, "Sound mixer reference count is not 0. (%d)\n", ref);
   }
   DbgCheckInUseChannels();
   pSndMixer=NULL;

   if (pSoundPath) {
      pSoundPath->Release();
      pSoundPath = NULL;
   }
}


#ifndef SHIP
#define IfLoud_SFX_Quick_List(all) do { if (sfx_loud_cap)  SFX_Quick_List(all); } while (0)
#else
#define IfLoud_SFX_Quick_List(all)
#endif   

// refresh any config vars we are allowed to
// doesnt allow channels yet
void SFX_Refresh_Config(void)
{

#ifndef SHIP
   if (config_is_defined("all_one_sound"))
   {
      config_get_raw("all_one_sound",dummy_sound,64);
      if (dummy_sound[0]=='\0')
         strcpy(dummy_sound,"alarm");
   }
   sound_always_delay   = config_is_defined ("sfx_always_delay");
   sfx_loud_cap         = config_is_defined ("sfx_loud_cap");
   sgSpewMixerAttribs   = config_is_defined ("sfx_spew_mixer_attribs");
#endif

   config_get_int       ("sfx_mixer_timeout",   &sgMixerTimeout);
   config_get_float     ("attenuation_factor",  &attenuation_factor);
   config_get_float     ("pan_factor",          &pan_factor);
   config_get_int       ("sfx_device",          &g_SFX_Device);
   config_get_int       ("max_sfx_3d",          &max_simul_hardware_3d_snds);
   config_get_float     ("sfx_source_reverb_mix", &sgSourceReverbMix);
   config_get_float     ("sfx_gain_scale",      &sgGainScale);

   config_get_int       ("sfx_vol_2d",          &sgVol2D);
   config_get_int       ("sfx_vol_3d",          &sgVol3D);
   // volume offsets to add only when hw acceleration is on
   sgVol2DHW = -300;
   sgVol3DHW = 0;
   config_get_int       ("sfx_vol_2d_hw",       &sgVol2DHW);
   config_get_int       ("sfx_vol_3d_hw",       &sgVol3DHW);
   config_get_int       ("sfx_vol_music",       &sgVolMusic);

   g_allowAsynch        = ! (config_is_defined  ("sfx_no_asynch"));
   g_asynchAll          = ! (config_is_defined  ("sfx_no_asynch_all"));
   sfxCheckChannels     = ! (config_is_defined  ("sfx_preset_3d_channels"));
   sgLogRoomTransitions = config_is_defined     ("sfx_log_room_transitions");

#ifdef DYNAMIC_CHANNELS   
   for (int i=0; i<FRAME_HISTORY_LEN; i++)
      sfx_time_log[i]=IDEAL_MIN_FRAME_MS;
   sfx_time_total=i*IDEAL_MIN_FRAME_MS;
#endif   
}

//
// Save standard config variables.
//
void SFX_Store_Config()
{
   config_set_int       ("sfx_device",          g_SFX_Device);
   config_set_int       ("sfx_vol_2d",          sgVol2D);
   config_set_int       ("sfx_vol_3d",          sgVol3D);
   config_set_int       ("sfx_vol_music",       sgVolMusic);
}

BOOL SFXInit(void)
{
   sSndAttribs attribs;
   int mixer_rate=22050;
   BOOL createOk;
   sSndEnvironment snd3DEnv;
   char methodName[256];

   if (pSndMixer)
      return TRUE;

   sgLastRoomType          = -1;
   sgGainScale             = 1.0F;
   sgVol2D                 = 0;
   sgVol3D                 = 0;
   sgVolMusic              = 0;
   sgVolsChanged           = TRUE;
   use2DHWmod              = FALSE;
   use3DHWmod              = FALSE;

   SFX_Refresh_Config();  // refresh reloadable config parms

   if (config_is_defined("no_sound") || (g_SFX_Device == SFXDEVICE_NoSound))
      return TRUE;

   if (config_is_defined("reverse_stereo"))
      rev_stereo = TRUE;

   for (int i = 0; i < SFX_MAX_COUNT; i++) {
      fxlist[i].type=SFX_NONE;
      fxlist[i].pSnd=NULL;
      fxlist[i].pRes=NULL;
      fxlist[i].ID = i;
   }

   base_index = SFX_METAGAME_BASE_INDEX;

   config_get_int("mixer_rate", &mixer_rate);
   
   // generic parms for mixer
   attribs.dataType = kSndDataPCM;  // PCM data
   attribs.sampleRate = mixer_rate; // 22kHz
   attribs.nChannels = 2;           // Stereo

   // the following have no effect in Init
   attribs.bytesPerBlock = 0;
   attribs.samplesPerBlock = 0;
   attribs.numSamples = 0;
   
   if (config_is_defined("force_8_bit_sound"))
      attribs.bitsPerSample = 8;
   else
      attribs.bitsPerSample = 16;

   // Intialize channels in use.
   sfx_use_channels = 12;
   config_get_int("default_sfx_channels", &sfx_use_channels);
   config_get_int("sfx_channels", &sfx_use_channels);

   

#ifndef SHIP
   config_get_int("sfx_channels_override",&sfx_use_channels);
#endif

   //
   // Set up pSoundPath to point to the sound files
   //
   AutoAppIPtr(ResMan);
   pSoundPath = pResMan->NewSearchPath();
   pSoundPath->AddPathTrees("snd2\\", FALSE);
   pSoundPath->AddPathTrees("snd\\", FALSE);
   pSoundPath->Ready();

   //
   // pick 3D sound method - default is dark's built-in pan/vol
   //
   config_get_raw( "snd3d", methodName, sizeof(methodName) );
   if ( ! strcmpi(methodName, "a3d") )
      g_SFX_Device = SFXDEVICE_A3D;

#ifdef USE_QSOUND
   else if ( ! strcmpi(methodName, "qmixer") )
      g_SFX_Device = SFXDEVICE_QMIXER;
#endif

   createOk = FALSE;

   switch (g_SFX_Device)
   {
      case SFXDEVICE_Software:
      {
         sfx3DMethod = kSnd3DMethodNone;
         createOk = SndCreateMixer(&pSndMixer,NULL);
         use2DHWmod = FALSE;
         use3DHWmod = FALSE;
         break;
      }

      case SFXDEVICE_A3D:
      {
         sfx3DMethod = kSnd3DMethodHardware;
         // this really just means "use 3d audio HW acceleration", not just
         //   A3d devices
         //createOk = SndCreateA3DMixer(&pSndMixer,NULL);
         createOk = SndCreateMixer(&pSndMixer,NULL);
         // factor in volume offsets which are used to balance volumes
         //  when hardware acceleration is enabled
         // Don't factor in these offsets.  Just tell the vol get to do it.
         // AMSD 3/24/00
         //sgVol2D += sgVol2DHW;
         //sgVol3D += sgVol3DHW;
         use2DHWmod = TRUE;
         use3DHWmod = TRUE;
         break;
      }

#ifdef USE_QSOUND
      case SFXDEVICE_QMIXER:
      {
         sfx3DMethod = kSnd3DMethodSoftware;
         createOk = SndCreateQSMixer(&pSndMixer, NULL);
         use2DHWmod = FALSE;
         use3DHWmod = FALSE;
         break;
      }
#endif

      default:
      {
         Warning(("Unknown mixer type: %d\n", g_SFX_Device));
         use2DHWmod = FALSE;
         use3DHWmod = FALSE;
         break;
      }
   }

   if ( createOk ) {
      TIMELOG_INIT( 16384 );
      if (sgMixerTimeout != -1)
      {
         pSndMixer->SetTimeout(sgMixerTimeout);
      }

      SongUtilInit(pSndMixer);
      SongUtilSetVolume(sgVolMusic);
#ifdef EDITOR
      SongEd_Init();
#endif

      pSndMixer->Set3DMethod(  sfx3DMethod );
      if (pSndMixer->Init(NULL,sfx_use_channels + SFX_BONUSCHANNELS,&attribs)==kSndOk)
      {
#ifndef SHIP
         // Set config var to make sure mixer initializes to expected format.
         if (sgSpewMixerAttribs)
         {
            sSndAttribs actualAttribs;
            pSndMixer->GetAttribs (&actualAttribs);
            mprintf ("Primary sound buffer format : %d bits, %d Hz, ",
            actualAttribs.bitsPerSample, actualAttribs.sampleRate);
            switch (actualAttribs.nChannels)
            {
               case 1:
                  mprintf ("mono.\n");
                  break;
               case 2:
                  mprintf ("stereo.\n");
                  break;
               default:
                  mprintf ("%d channels (STRANGE!)\n", actualAttribs.nChannels);
                  break;
            }
         }
#endif
         // Restore old volume, if any (0 if not).
         SFX_SetMasterVolume (sgLastVolumeSetting);
         pSndMixer->RegisterPriorityCallback(  _sfx_priority_callback, NULL );
         if ( sfx3DMethod != kSnd3DMethodNone ) {
            // Init reverb.
            int useReverb = 1;
            config_get_int ("sfx_eax", &useReverb);
            // if ( ! (config_is_defined ("sfx_no_reverb")) )
            if (useReverb)
               pSndMixer->Init3DReverb();

            // Init 3D Environment.
            snd3DEnv.dopplerFactor = 1.0;

            // The sound library does meters, dark does feet
            snd3DEnv.distanceFactor = 0.3048;

            // We do our own attenuation for consistency between hw and sw.
            snd3DEnv.rolloffFactor = 0.0;
            config_get_float( "snd3d_distance", &(snd3DEnv.distanceFactor) );
            config_get_float( "snd3d_rolloff", &(snd3DEnv.rolloffFactor) );
            pSndMixer->Set3DEnvironment(  &snd3DEnv );
         }
         return TRUE;      // seems to have worked
      }
   }
   pSndMixer=NULL;
   SFXClose();
   Warning(("Sound failed to correctly init\n"));
   return FALSE;
}

BOOL SFXReset(void)
{
   g_deferCallbacks = TRUE;

   SFXClose();
   BOOL retval = SFXInit();

   g_deferCallbacks = FALSE;

   // If we sucessfully reset, we can pass on our callbacks.  If not,
   // then we should keep them around until we sucessfully reset.
   if (retval)
   {
      for (int i=0; i<g_DeferredCallbackList.Size(); i++)
      {
         _sfx fx = g_DeferredCallbackList[i];
         fx.parm.end_callback(fx.ID, fx.parm.user_data);
      }
      g_DeferredCallbackList.SetSize(0);
   }

   return retval;
}

BOOL SFX_SetSoundDevice(int device, BOOL reset)
{
   g_SFX_Device = device;

   if (reset)
      return SFXReset();
   else
      return TRUE;
}

int SFX_GetSoundDevice()
{
   return g_SFX_Device;
}

BOOL SFXActive(void)
{
   return pSndMixer != NULL; 
}

///////////////////////////////////////
// internal creation/destruction of samples

static int hndInUse = 0;
static int chanInUse = 0;
static int cur3dSndCnt = 0;

int SFX_Get(void)
{
   int i;
   if (pSndMixer!=NULL)  // lets not "get" effects if we have no mixer
      for (i=0; i<SFX_MAX_MODE_COUNT; ++i)
         if (fxlist[i + base_index].type==SFX_NONE)
         {
            hndInUse++;
            return i + base_index;
         }
   IfLoud_SFX_Quick_List(FALSE);
   return SFX_NO_HND;
}

#ifdef DBG_ON
  // check to make sure we are all cleaned up
void DbgCheckInUseChannels(void)
{
   if (hndInUse) { Warning(("appsfx: HndInUse %d on close\n",hndInUse)); hndInUse=0; }
   if (chanInUse) { Warning(("appsfx: chanInUse %d on close\n",chanInUse)); chanInUse=0; }
   if (cur3dSndCnt) { Warning(("appsfx: cur3dSndCnt %d on close\n",cur3dSndCnt)); cur3dSndCnt=0; }   
}
#endif

///////////////////////////////////////
// internal convienience functions

// just set the _sfx vector location to be where us is
static void _sfx_fill_vec_from_obj(_sfx *us)
{  
   ObjPos* pos = ObjPosGet(us->attach);
   if (pos!=NULL)
      mx_copy_vec(&us->loc,&pos->loc.vec);
   else
      Warning(("fillvecfromobj: nonexistant objid %d\n",us->attach));
}

// load up new from type/parm/name correctly
void _sfx_basic_setup(int which, _sfx *newfx, int type, sfx_parm *parm, char *sfx_name)
{
   if (parm)
      newfx->parm=*parm;
   else
      newfx->parm=def_parms;
   newfx->attach=0;
   newfx->pSnd=NULL;
   newfx->pRes=NULL;
   newfx->pStreamBuffer = NULL;

#ifndef SHIP   
   if (dummy_sound[0]!='\0')
       newfx->name=dummy_sound;
   else
#endif
      newfx->name=sfx_name;
   
   // real issue is now setting type and flags correctly
   newfx->type=type;  // easy for now, eh?

   // Set gain.  Gain scale is normally 1, so we test this to avoid float->int expense.
   if ( 1.0F == sgGainScale )
      newfx->master_gain = newfx->parm.gain;
   else
      newfx->master_gain = (int) ((float)newfx->parm.gain * sgGainScale);

   newfx->distance=newfx->parm.distance;

   set_flags(newfx,which,newfx->parm.flag);
   newfx->play_time = tm_get_millisec_unrecorded();
   if (newfx->parm.delay>0)
      newfx->flags |= SFXFLG_DELAY;
#ifndef SHIP
   if (sound_always_delay)
      newfx->flags |= SFXFLG_DELAY;
#endif
}

static void _sfx_cleanup_fx(_sfx *fx, BOOL make_callback)
{
   snd_mprintf(("Cleanup %d: type %d IRes %x (%d) snd %x name %s%s (%d %x %d)\n",
                _sfx_get_hnd_from_ptr(fx),fx->type,fx->pRes,GetRefCount(fx->pRes),fx->pSnd,fx->name,(fx->flags&SFXFLG_ASYNCHWAIT)?" InAsychQueue":"",
                make_callback&&fx->parm.end_callback,fx->ID,fx->parm.user_data));

   if (fx->pRes!=NULL)
   {
      if (fx->flags&SFXFLG_ASYNCHWAIT)
      {
         void * pSound;
         fx->pRes->GetAsyncResult(&pSound);
         snd_mprintf(("Cleanup %d: %s was in async queue\n",_sfx_get_hnd_from_ptr(fx),fx->name));
      }

      // Unlock only if non-stream (since streams never get locked).
      if ( ! (fx->flags & SFXFLG_STREAM) )
         fx->pRes->Unlock();

      fx->pRes->Release();
      fx->pRes = NULL;
   }

   fx->type=SFX_NONE;
   fx->pSnd=NULL;

   // Clean up streaming buffer if any.
   if ( NULL != fx->pStreamBuffer )
   {
      delete [] (fx->pStreamBuffer);
      fx->pStreamBuffer = NULL;
   }

   if (fx->flags&SFXFLG_IS3D)
   {
      if (cur3dSndCnt<=0)
         Warning(("3d Sound Underflow in cleanup %d\n",_sfx_get_hnd_from_ptr(fx)));
      cur3dSndCnt--;
   }
   if ((fx->flags&SFXFLG_NOCALLBACK)==0)
   {
      if (make_callback && fx->parm.end_callback)
      {
         snd_mprintf(("making callback flags %x\n",fx->flags));
         if (g_deferCallbacks)
            g_DeferredCallbackList.Append(*fx);
         else
            fx->parm.end_callback(fx->ID, fx->parm.user_data);
      }
   }
   else
      snd_mprintf(("Abort callback due to NOCALLBACK\n"));
   hndInUse--;
}

// called when a sound stops
static void _sfx_end_callback(ISndSample *pSample, void *pCBD)
{
   _sfx *fx = (_sfx *) pCBD;

   if (fx)
      _sfx_cleanup_fx(fx, TRUE);

   pSample->Release();
   chanInUse--;
}

// This is called at the end of each iteration of a looped sample,
// including the last, shortly _before_ that iteration ends.
static void _sfx_loop_callback(ISndSource *pSndSource, uint32 *pCBD)
{
   _sfx *fx;
   long *pTmp;

   // skip first param (arg count), next param is sfx ptr
   pTmp = (long *) pCBD;
   fx = (_sfx *) pTmp[1];

   if (fx && fx->parm.loop_callback)
      fx->parm.loop_callback(fx->ID, fx->parm.user_data);
}

// software free
static void _sfx_free(_sfx *fx, BOOL makeCallback)
{
   if (fx->type==SFX_NONE)
   {
      Warning(("Trying to free non-alloced sample %d\n",
               _sfx_get_hnd_from_ptr(fx)));
      return;
   }

   if (fx->pSnd)
      fx->pSnd->Stop();
   else
      _sfx_cleanup_fx(fx, makeCallback);
}

// actually goes and gets the ISndSample, fills in the real data
// for now, it also looks up the resource, cause why not
static bool _sfx_start_play(_sfx *fx, BOOL after_delay)
{
   AutoAppIPtr(ResMan);
   AUTO_TIMER(StartPlayTimer);
   char *tmpname=fx->name;
   // The actual sound data:
   void *pSound = NULL;
   bool bHaveDataSource = false;

   // if we're delaying, then skip start
   if (fx->flags & SFXFLG_DELAY)
      return TRUE;

   //   fx->name=NULL;     // so we dont mistakenly refer to it later
   // We prep and lock the sound together (and will unlock and release
   // together later), because we can't allow the memory to go away while
   // the sound may be playing...

   if (fx->pRes==NULL)
   {
      fx->pRes = pResMan->Bind(tmpname, RESTYPE_SOUND, pSoundPath);
      snd_mprintf(("Binding %d: %s (%d)\n",_sfx_get_hnd_from_ptr(fx),tmpname,GetRefCount(fx->pRes)));
   }

   if (fx->pRes)
   {
      if (fx->flags & SFXFLG_STREAM)
         bHaveDataSource = true;
      else
      {
         // @SHIP: if we get pumpevents going in metagame, remove the base_index == below
         if (g_allowAsynch&&((fx->flags&SFXFLG_ASYNCHWAIT)==0)&&
             ((g_asynchAll&&(base_index==SFX_GAME_BASE_INDEX))||(fx->flags&SFXFLG_ASYNCH)))
         {
            fx->pRes->AsyncLock(kPriorityNormal);  // does this return anything real?
            snd_mprintf(("AsynchLock %d: %s (%d)\n",_sfx_get_hnd_from_ptr(fx),tmpname,GetRefCount(fx->pRes)));
            fx->flags|=SFXFLG_ASYNCHWAIT;
            fx->flags&=~SFXFLG_ASYNCH;
#ifdef STRESS_ASYNCH         
            return TRUE; // to always delay a frame
#endif         
         }

         if (fx->flags&SFXFLG_ASYNCHWAIT)
         {
            if (fx->pRes->IsAsyncFulfilled())  // can check this outside, too
            {
               fx->pRes->GetAsyncResult(&pSound);
               snd_mprintf(("AsynchFulfill %d: %s (%d)\n",_sfx_get_hnd_from_ptr(fx),tmpname,GetRefCount(fx->pRes)));
               fx->flags&=~SFXFLG_ASYNCHWAIT;
            }
            else
               return TRUE; // still waiting
         }
         else
         {
            snd_mprintf(("NormalLock %d: %s (%d)\n",_sfx_get_hnd_from_ptr(fx),tmpname,GetRefCount(fx->pRes)));;
            pSound = fx->pRes->Lock();
         }

         // Check for successful lock.
         if (pSound)
            bHaveDataSource = true;
         else
         {
            Warning(("sfx_start_play: couldn't Lock %s\n", tmpname));
            fx->pRes->Release();
            fx->pRes = NULL;
         }
      }
   }
   else
      Warning(("sfx_start_play: couldn't Prep %s\n", tmpname));

   if (bHaveDataSource)
   {
#ifndef SHIP
      // Allow config var to exercise bad mixer.
      int forceFailCount = -1;
      fx->pSnd = NULL;
      config_get_int( "sfx_break_mixer", &forceFailCount );
      if (forceFailCount == -1 || SFX_Channel_Count() < forceFailCount )
#endif
      {
      // Do we want callbacks for looping?
      if (fx->parm.flag & SFXFLG_LOOP)
      {
         fx->pSnd = CreateMemSoundSourceLooped(pSndMixer,
                                              pSound,
                                              fx->pRes->GetSize(),
                                              _sfx_end_callback, 
                                              fx,
                                              &fx->parm.pSndSource,
                                              fx->parm.num_loops,
                                              _sfx_loop_callback, 
                                              fx);
      }                                        
      else if (fx->parm.flag & SFXFLG_STREAM)
      {
         fx->pSnd = CreateNRezStreamedSoundSource (pSndMixer,
                                           fx->pRes,
                                           &(fx->pStreamBuffer),
                                           _sfx_end_callback,
                                           fx,
                                           &fx->parm.pSndSource);
      }
      else
      {
         fx->pSnd = CreateMemSoundSource(pSndMixer,
                                        pSound,
                                        fx->pRes->GetSize(),
                                        _sfx_end_callback,
                                        fx);
      }
      }

      if (fx->pSnd)
      {
         NAME_SAMPLE( fx->pSnd, fx->name );
         if ( (fx->flags & SFXFLG_POS) && (sfx3DMethod != kSnd3DMethodNone) )
         {  // if we want 3D, make sure we arent using too many hardware channels
            eSnd3DMethod useMethod=sfx3DMethod;
            if (sfx3DMethod==kSnd3DMethodHardware)
            {
               long HW3dcnt=1;
               if (sfxCheckChannels)
                  pSndMixer->FreeHWChannelCount(NULL, &HW3dcnt);
               if (HW3dcnt>0 &&
                   ( (max_simul_hardware_3d_snds==0) ||
                     (cur3dSndCnt < max_simul_hardware_3d_snds) ) )
               {
                  cur3dSndCnt++;
                  fx->flags |= SFXFLG_IS3D;

                  // Set reverb mix.
                  if ( pSndMixer->Have3DReverb() )
                     fx->pSnd->Set3DReverbMix(sgSourceReverbMix);
               }
               else
               {  // dont set method hardware, cause the driver just uses HW anyway
                  useMethod=kSnd3DMethodNone;
                  Warning(("Out of channels for 3d sounds for %d (%s)\n",
                           _sfx_get_hnd_from_ptr(fx),fx->name));
               }
            }
            fx->pSnd->Set3DMethod( useMethod );
            fx->pSnd->Set3DMode( kSnd3DModeNormal );
         }
         
         _sfx_update(fx,TRUE,tm_get_millisec_unrecorded());
         fx->flags |= SFXFLG_HAPPY;
         // give sample back ptr to us so it can clear happy if play fails
         fx->pSnd->SetData((long) fx );
         fx->pSnd->SetGroup((uint32) fx->parm.group);
         fx->pSnd->Play();

         chanInUse++;  // since we will always hit the appsfx callback now
         
         if ( fx->flags&SFXFLG_HAPPY )
         {
            snd_mprintf(("Play %d: type %d pRes %x (%d) snd %x name %s\n",
                         _sfx_get_hnd_from_ptr(fx),fx->type,fx->pRes,GetRefCount(fx->pRes),fx->pSnd,fx->name));
            return TRUE;
         }
         else
         {
            snd_mprintf(("_sfx_start_play: couldnt play sound sample for %s (aftrdlay = %d)\n",tmpname,after_delay));
            // if this is the frame we called into appsfx
            // i.e. the frame that SFX_PlayRaw or whatever was called
            // and we are failing right away
            // we are going to return handle -1 to the app
            // so lets not make the app callback
            // since, really, we are gonna tell the app we arent playing
            if (!after_delay)
            {
               fx->flags|=SFXFLG_NOCALLBACK;
               snd_mprintf(("tried to set callback flags, %x\n",fx->flags));
            }
            IfLoud_SFX_Quick_List(FALSE);
         }
      } 
      else
      {
#if defined(DBG_ON) || defined(MPRINT_TRACK) || defined(PLAYTEST)
         mprintf("_sfx_start_play: couldnt create %s\n",tmpname);
#endif         
         IfLoud_SFX_Quick_List(FALSE);         
      }
   }
#if defined(DBG_ON) || defined(MPRINT_TRACK)
   else
      mprintf("_sfx_start_play: couldnt Prep and Lock %s\n",tmpname);
#endif
   TLOG1( "failed to alloc chan to [%d]", fx->ID );
   if (after_delay==FALSE)
   {
      snd_mprintf(("sfx_free fx flg %x ad %d\n",fx->flags,after_delay));
   }
   _sfx_free(fx,after_delay);
   return FALSE;
}

int SFX_Attenuate(int master_gain, int dist)
{
   return master_gain - (dist * attenuation_factor);
}

int SFX_MaxDist(int gain)
{
   int max_dist;

   max_dist = (int)((5000 + gain) / attenuation_factor);

   TLOG2( "Max dist %d for gain %d", max_dist, gain );
   return max_dist;
}

const char *SFX_Name(int hnd)
{
   return fxlist[hnd].name;
}

const sfx_parm *SFX_Parm(int hnd)
{
   return &fxlist[hnd].parm;
}

///////////////////////////////////////
// playback/update loop subsystems

#define NEAH_SND  (6.0)
#define PAN_RANGE (4000) // even though 10k is max, it seems to be too much...
#define SND_GAIN_MIN (-5000) // likewise

static mxs_vector head_pos;
static mxs_angvec head_ang;

static BOOL _sfx_check_delay(_sfx *fx, BOOL *init, ulong cur_time)
{
   if (fx->flags&SFXFLG_DELAY)
      if (cur_time>=fx->play_time+fx->parm.delay)
      {  // times up, go start the sample
         fx->flags = fx->flags&~SFXFLG_DELAY;
         if (!_sfx_start_play(fx,TRUE))
            return FALSE;
         *init = TRUE;
      }
      else
         return FALSE;
   if (g_allowAsynch)
      if (fx->flags&SFXFLG_ASYNCHWAIT)
         if (fx->pRes->IsAsyncFulfilled())
         {
            if (!_sfx_start_play(fx,TRUE))
               return FALSE;
            else
               *init = TRUE;
         }
      else
         return FALSE;
   return TRUE;
}

// returns whether or not it asked for a remix
static BOOL _sfx_update(_sfx *fx, BOOL init, ulong cur_time)
{
   bool change=FALSE;
   int master_gain;
   BOOL fade = FALSE;
   sSndVector sndPos;
  
   if (!fx->pSnd)
   {
      Warning(("_sfx_update with no sound (pSnd NULL) handle %d\n",
                _sfx_get_hnd_from_ptr(fx)));
      return FALSE;
   }

   master_gain = fx->master_gain;
   // This fade stuff is done manually rather than through the sound library
   // so that it interacts with our 3d stuff properly. This will all presumably
   // go away when you we use the new sound library stuff.
   if (fx->parm.fade>0)
   {
      if (cur_time<fx->play_time+fx->parm.fade)
      {
         // fade in
         master_gain += (int)((float)(fx->play_time+fx->parm.fade-cur_time)/(float)fx->parm.fade*
            (float)(SND_GAIN_MIN-fx->master_gain));
         fade = TRUE;
      }
      else
      {
         ulong remaining_time = fx->pSnd->PlayTimeRemaining();
         if (remaining_time<fx->parm.fade)
         {
            // fade out
            master_gain += (int)((1.-(float)remaining_time/(float)fx->parm.fade)*
               (float)(SND_GAIN_MIN-fx->master_gain));
            fade = TRUE;
         }
      }
   }
   if (!(fx->flags&SFXFLG_STATIC))
   {  // if we have dynamic update, lets go
      if (fx->flags&SFXFLG_OBJ)   // get new object position
         _sfx_fill_vec_from_obj(fx);
      if (fx->flags&SFXFLG_POS)
      {
         // Calculate gain.  Now same for both hardware and software.
         float dist = fx->distance;
         int gain;

         if (dist < 0) {
            dist = mx_dist_vec(&head_pos,&fx->loc);
         }
         // gain check first
         gain = SFX_Attenuate(master_gain, (int)dist);
         if (gain!=fx->parm.gain)
         {
            fx->parm.gain=gain;
            change=TRUE;
         }

         // Calculate stereo mix.
         if ( sfx3DMethod == kSnd3DMethodNone )
         {
            // calc pan
            {
               mxs_matrix locframe;
               mxs_vector delta;
               mxs_real   headon;
               mxs_real   headon_abs;
               int pan;

               // calc our heading matrix and the normal from head to sound
               mx_ang2mat(&locframe, &head_ang);
               mx_sub_vec(&delta, &fx->loc, &head_pos);
               mx_normeq_vec(&delta);

               // determine how directly facing the sound we are
               headon = mx_dot_vec(&delta, &locframe.vec[1]);
               headon_abs = fabs(headon) * pan_factor;
               pan = ((int)(10000 - 10000 * cos(1.570796 * headon_abs)));

               // reverse if on other side
               if (headon > 0)
                  pan = -pan;

               // reverse if forced to
               if (rev_stereo)
                  pan = -pan;

               // only update if changed
               if (pan != fx->parm.pan)
               {
                  fx->parm.pan = pan;
                  change = TRUE;
               }
            }
         }
         else
         {
            // Stereo mix in hardware is done using Set3DPosition.
            sndPos.x = fx->loc.x;
            sndPos.y = fx->loc.y;
            sndPos.z = fx->loc.z;
            fx->pSnd->Set3DPosition(&sndPos);
         }
      }
   }
   else if (fade)
   {
      fx->parm.gain = master_gain;
      change = TRUE;
   }

   // Apply independent volume controls.
   if (sgVolsChanged)
   {
      change = TRUE;
   }

   if ( fx->blocking_factor != fx->parm.blocking_factor ) {
      // blocking factor has changed
      fx->blocking_factor = fx->parm.blocking_factor;
      change = TRUE;
   }

   if (change||init)
   {
      // Adjust 2d and 3d independent volumes.
      int net_gain = fx->parm.gain;

      if (fx->flags & SFXFLG_POS)
         net_gain += SFX_Get3dVolume();
      else
         net_gain += SFX_Get2dVolume();

      // Clip volume to valid range.
      if (net_gain < kSndMinVolume)
         net_gain = kSndMinVolume;
      if (net_gain > kSndMaxVolume)
         net_gain = kSndMaxVolume;

      fx->pSnd->SetVolume(net_gain);
      if (fx->pSnd->Get3DMethod() == kSnd3DMethodNone )
         fx->pSnd->SetPan(fx->parm.pan);

      if ( (fx->flags & SFXFLG_POS) && (sfx3DMethod == kSnd3DMethodHardware) && pSndMixer->Have3DOcclusion() ) {
         // set the occlusion here
         long occlusionLevel;
         float modBF;   // modified blocking factor
         static float bfBreakOut = 0.6;

         // do a simple two-piece linear mapping
         //  I do this because sounds become silent well before attenuation reaches kSndMinVolume
         //  0 ... BF_BREAK_IN ... 1    ->   0 ... bfBreakOut ... 1
#define BF_BREAK_IN  0.9
#define bfBreakOut  0.5
         modBF = fx->parm.blocking_factor;
         if ( modBF < BF_BREAK_IN ) {
            modBF *= (bfBreakOut / BF_BREAK_IN);
         } else {
            modBF = bfBreakOut + ( ((modBF - BF_BREAK_IN) / (1.0 - BF_BREAK_IN))
                                       *  (1.0 - bfBreakOut) );
         }
         occlusionLevel = modBF * (kSndMinVolume - net_gain);
         fx->pSnd->Set3DOcclusion( occlusionLevel );
      }
      return TRUE;
   }
   return FALSE;
}

#ifdef MIXER_COUNTS
static int sfx_cnts[256];
static int sfx_remix[256];
static int sfx_total=0;
static int sfx_remixes=0;
static int sfx_ptr=0;
#endif

void SFX_Frame(mxs_vector *pos, mxs_angvec *ang)
{
   static ulong cur_time;     // current time, updated each frame
   mxs_matrix orient;
   BOOL init;
   int i;

#ifdef DYNAMIC_CHANNELS
   sfx_time_total-=sfx_time_log[sfx_time_index];
   sfx_time_log[sfx_time_index]=GetSimFrameTime();
   sfx_time_total+=sfx_time_log[sfx_time_index];
   sfx_time_index=(sfx_time_index+1)&FRAME_HISTORY_MASK;
#endif   

#ifdef MIXER_COUNTS
   sfx_total-=sfx_cnts[sfx_ptr];
   sfx_remixes-=sfx_remix[sfx_ptr];
   sfx_cnts[sfx_ptr]=0;
#endif // MIXER_COUNTS

   if (pSndMixer==NULL) return;

   // update our global time 
   cur_time = tm_get_millisec_unrecorded();

   // @TODO: really this is an editor check only
   //  in game mode, we know we have a view position, so we should punt the ifs
   if (pos) head_pos=*pos;
   if (ang) head_ang=*ang;

// @TODO: this should only be done if camera is at player
//        otherwise, we should go decide to get Location of camera, not player

   // here is where we would like to know if we are/are not the player
   // we also only want to do this in game mode... i guess i could SimTimePassing
   if ( IsSimTimePassing() && pSndMixer->Have3DReverb() )   // just use (1) for test
   {
      // for now, assume we are the player
      cRoom *player_room = g_pRooms->GetObjRoom(PlayerObject());
      int room_type = player_room==NULL?-1:
                       g_pRoomEAX->GetAcoustics(player_room->GetRoomID());
      if ( room_type == -1 ) {
         if ( PhysGetObjMediaState(PlayerObject()) == kMS_Liquid_Submerged ) {
            room_type=kREVERB_UnderWater; // blub blub blub
         }
      }
      if (room_type==-1)
         room_type=GetMissionSecretEAXVar();
      if (room_type==-1)
         room_type=GetGameSysSecretEAXVar();
      if (room_type==-1)
         room_type=kREVERB_Generic; // well, who knows

      // Only set reverb when player enters a new room.
      if (room_type!=sgLastRoomType)
      {
#ifndef SHIP
         if (sgLogRoomTransitions)
         {
#ifdef EDITOR
            mprintf("new RT %s\n", g_RoomTypes[room_type]);
#else
            mprintf("new RT %d\n",room_type);
#endif
         }
#endif

         sgLastRoomType=room_type;

         if ( room_type!=-1 )
         {
            ReverbSettings revSet;
            revSet.flags = kREVERB_FlagType;
            revSet.type = room_type;
            pSndMixer->Set3DReverbSettings(&revSet);
         }
      }
   }
   
   // lets do some 3d whackitude
   TIMER_Start(SndMixerTimer);
   if ( sfx3DMethod != kSnd3DMethodNone ) {
      // update listener's position & orientation
      pSndMixer->Set3DPosition( (sSndVector *) &head_pos);
      mx_ang2mat( &orient, &head_ang );
      pSndMixer->Set3DOrientation(  (sSndVector *) &(orient.vec[0]), (sSndVector *) &(orient.vec[2]) );
   }

   pSndMixer->Update();
   TIMER_MarkStop(SndMixerTimer);

   TIMER_Start(SfxUpdateTimer);
   // go through all of our modes SFX's and update them
   for (i = 0; i < SFX_MAX_MODE_COUNT; ++i)   
      if (fxlist[i+base_index].type!=SFX_NONE)
      {
         init = FALSE;
#ifdef MIXER_COUNTS
         if (_sfx_check_delay(&fxlist[i+base_index], &init, cur_time))
            sfx_remix[sfx_ptr]+=_sfx_update(&fxlist[i+base_index], init, cur_time)?1:0;
         sfx_cnts[sfx_ptr]++;
#else
         if (_sfx_check_delay(&fxlist[i+base_index], &init, cur_time))
            _sfx_update(&fxlist[i+base_index], init, cur_time);
#endif
      }

#ifdef MIXER_COUNTS
   sfx_total+=sfx_cnts[sfx_ptr];
   sfx_remixes+=sfx_remix[sfx_ptr];
   sfx_ptr=(sfx_ptr+1)&0xff;
   if (sfx_ptr==0)
      mprintf("sfx: Cur %d, avg %g (remix %g)\n", sfx_cnts[(sfx_ptr-1)&0xff], (float)sfx_total/256.0, (float)sfx_remixes/256.0);
#endif

   // Don't constantly adjust 2d/3d volume.
   sgVolsChanged = FALSE;

   TIMER_MarkStop(SfxUpdateTimer);
}

static void FinishAsynchOps(void)
{
   BOOL init;
   int i, start_time=tm_get_millisec_unrecorded();
   
   AutoAppIPtr(AsyncReadQueue);
   pAsyncReadQueue->FulfillAll();
   
   for (i=0; i<SFX_MAX_COUNT; i++)
      if (fxlist[i].type!=SFX_NONE)
         if (fxlist[i].flags&SFXFLG_ASYNCHWAIT)
            while (!_sfx_check_delay(&fxlist[i], &init, 0))
               if (start_time+500>tm_get_millisec_unrecorded())
               {
#ifndef SHIP
                  mprintf("AsynchOp timeout\n");
#endif                  
                  break;
               }
}

///////////////////////////////////////
// Volume is attenuation from full volume, in millibels
void SFX_SetMasterVolume(int vol)
{
   if (pSndMixer)
      pSndMixer->SetMasterVolume(vol);
}


int SFX_GetMasterVolume()
{
   if (pSndMixer)
      return pSndMixer->GetMasterVolume();
   return 0;
}

///////////////////////////////////////
// These are the independently controllable volumes.
void SFX_Set2dVolume (int vol)
{
   sgVol2D              = vol;
   sgVolsChanged        = TRUE;
}

int SFX_Get2dVolume ()
{
   if (use2DHWmod)
      return sgVol2D + sgVol2DHW;
   else
      return sgVol2D;
}

void SFX_Set3dVolume (int vol)
{
   sgVol3D              = vol;
   sgVolsChanged        = TRUE;
}

int SFX_Get3dVolume ()
{
   if (use3DHWmod)
      return sgVol3D + sgVol3DHW; 
   else
      return sgVol3D;
}

void SFX_SetMusicVolume (int vol)
{
   // Turn off music at lowest volume.
   if( vol < -5000 )
   {
      SongUtilSetVolume( vol );
      SongUtilDisableMusic();
   }
   else
   {
      SongUtilEnableMusic();
      SongUtilSetVolume( vol );
   }

   sgVolMusic = vol;
}

int SFX_GetMusicVolume ()
{
   return ( SongUtilGetVolume() );
}

// if you are need of this, say, to do some group volume stuff
ISndMixer *SFX_GetMixer(void)
{
   if (pSndMixer)
   {
      pSndMixer->AddRef();
      return pSndMixer;
   }    
   else
      return NULL;
}

int SFX_GetNumChannels ()
{
   return sfx_use_channels;
}

///////////////////////////////////////

void SFX_SetReverseStereo(BOOL state)
{
   rev_stereo = state;
}

BOOL SFX_StereoReversed()
{
   return rev_stereo;
}

///////////////////////////////////////

void SFX_Slam_Dist(int hnd, int distance, BOOL force_update)
{
   AssertMsg(fxlist[hnd].distance >= 0, "Attempt to distance override on absolute sample");
   fxlist[hnd].distance = distance;
   fxlist[hnd].parm.blocking_factor = 0.0;

   if (force_update && fxlist[hnd].pSnd)
      _sfx_update(&fxlist[hnd],TRUE,tm_get_millisec_unrecorded());
}

///////////////////////////////////////

void SFX_Slam_Dist_BF(int hnd, int distance, mxs_real blocking_factor, BOOL force_update)
{
   AssertMsg(fxlist[hnd].distance >= 0, "Attempt to distance override on absolute sample");
   fxlist[hnd].distance = distance;
   fxlist[hnd].parm.blocking_factor = blocking_factor;

   if (force_update && fxlist[hnd].pSnd)
      _sfx_update(&fxlist[hnd],TRUE,tm_get_millisec_unrecorded());
}

///////////////////////////////////////

// This not only sets the mode between game and metagame, but pauses
// or clobbers sounds, as appropriate.
void SFX_SetMode(sfx_mode mode)
{
   int old_index = base_index;
   int i;

   FinishAsynchOps();
   switch (mode)
   {
      // We're switching from the metagame to the game.
      case SFX_mode_game:
      {
         for (i = 0; i < SFX_MAX_MODE_COUNT; ++i)
         {
            _sfx *fx=&fxlist[i + SFX_GAME_BASE_INDEX];
            if ((fx->type != SFX_NONE)&&(fx->pSnd))
               if ((appsfxModeCallback==NULL) || (*appsfxModeCallback)(mode,i,&fx->parm))
                  fx->pSnd->Resume();
            _sfx *mfx=&fxlist[i + SFX_METAGAME_BASE_INDEX];
            if ((mfx->type != SFX_NONE)&&(mfx->pSnd))
               _sfx_free(mfx, TRUE);
         }
         base_index = SFX_GAME_BASE_INDEX;
         break;
      }

      // We're switching from the game to the metagame.
      case SFX_mode_metagame:
      {
         for (i = 0; i < SFX_MAX_MODE_COUNT; ++i)
         {
            _sfx *fx=&fxlist[i + SFX_GAME_BASE_INDEX];
            if ((fx->type != SFX_NONE)&&(fx->pSnd))
               if ((appsfxModeCallback==NULL) || (*appsfxModeCallback)(mode,i,&fx->parm))
                  fx->pSnd->Pause();
         }
         base_index = SFX_METAGAME_BASE_INDEX;
         break;
      }
   }
   snd_mprintf(("SFX_SetMode: setting mode to  %s\n", (mode == SFX_mode_game)? "GAME" : "METAGAME"));
#ifndef SHIP
   if (old_index == base_index)
      Warning(("SFX_SetMode: setting mode to same as before: %s\n",
               (mode == SFX_mode_game)? "GAME" : "METAGAME"));
#endif // ~SHIP
}


///////////////////////////////////////

EXTERN void SFX_KillAll(sfx_mode mode)
{
   in_kill = TRUE;
   
   if (pSndMixer&&mode==SFX_mode_all)
   {
      pSndMixer->StopAllSamples();
      pSndMixer->Update();      // trigger those callbacks
      for (int i = 0; i < SFX_MAX_COUNT; i++)
         if (fxlist[i].type != SFX_NONE)
            _sfx_free(&fxlist[i], TRUE);
   }
   else
   {
      int base=(mode==SFX_mode_metagame)?SFX_METAGAME_BASE_INDEX:SFX_GAME_BASE_INDEX;
      for (int i=0; i<SFX_MAX_MODE_COUNT; i++)
      {
         _sfx *fx=&fxlist[i + base];
         if (fx->type!=SFX_NONE)
            _sfx_free(fx,TRUE);
      }
#ifdef MPRINT_TRACK
      int nbase=(mode!=SFX_mode_metagame)?SFX_METAGAME_BASE_INDEX:SFX_GAME_BASE_INDEX;
      for (int ni=0; ni<SFX_MAX_MODE_COUNT; ni++)
         if (fxlist[ni + nbase].type!=SFX_NONE)
            mprintf("Still using %d\n",ni+nbase);
#endif
   }

   in_kill = FALSE;
}

///////////////////////////////////////


int SFX_Channel_Count()
{
   int i, cnt;
   for (i=0, cnt=0; i<SFX_MAX_COUNT; i++)
      if (fxlist[i].type!=SFX_NONE)
         cnt++;
   //mprintf("appsfx %d channels\n",cnt);

   // Hack: add music channel.
   cnt++;

   return cnt;
}

///////////////////////////////////////
// lets try and preload a sound

BOOL SFX_PreLoad(const char *pName)
{
   IRes *pRes;
   AutoAppIPtr(ResMan);   
   pRes = pResMan->Bind(pName, RESTYPE_SOUND, pSoundPath);
   if (pRes)
   {
      pRes->Lock();
      pRes->Unlock();
      pRes->Release();
      return TRUE;
   }
   return FALSE;
}

//////////////////////
// hack for "frame rate attention paying horror"
// if frame rate is low, pretend we are using more channels

BOOL SFX_IsChannelAvail()
{
#ifdef DYNAMIC_CHANNELS
   int modifier=0;  // how many "channels" is our low frame rate worth
   if (sfx_use_channels>4)
   {
      int avg_frame=(sfx_time_total>>FRAME_HISTORY_SHIFT);
      if (avg_frame>IDEAL_MIN_FRAME_MS)
      {
         int pain=1000/avg_frame;
         modifier=DYNAMIC_MODIFIER(pain);
//         mprintf("%1.1d",modifier);
      }
   }
   return (SFX_Channel_Count() + modifier < sfx_use_channels);   
#else   
   return (SFX_Channel_Count() < sfx_use_channels);
#endif   
}

///////////////////////////////////////
// app side creation/destruction of samples

int SFX_Play_Raw(int type, sfx_parm *parm, char *sfx_name)
{
   if (in_kill)
      return SFX_NO_HND;

   int hnd=SFX_Get();
   if (hnd!=SFX_NO_HND)
   {
      _sfx *newfx=&fxlist[hnd];
      _sfx_basic_setup(SFX_BF_RAW,newfx,type,parm,sfx_name);
      if (!_sfx_start_play(newfx,FALSE)) {
         TLOG1( "SFX_Play_Raw [%d] - play failed", hnd );
         hnd=SFX_NO_HND;
      }
   }
   return hnd;
}

int SFX_Play_Obj(int type, sfx_parm *parm, char *sfx_name, int objid)
{
   int hnd=SFX_Get();
#ifndef SHIP
   if (!ObjExists(objid))
   {
      mprintf("PlayObj: called with %d, an invalid obj (sfxtype %d)\n",objid,type);
      return SFX_NO_HND;
   }
#endif
   if (hnd!=SFX_NO_HND)
   {
      _sfx *newfx=&fxlist[hnd];
      _sfx_basic_setup(SFX_BF_OBJ,newfx,type,parm,sfx_name);
      newfx->attach=objid;
      if (!_sfx_start_play(newfx,FALSE)) {
         TLOG1( "SFX_Play_Obj [%d] - play failed", hnd );
         hnd=SFX_NO_HND;
      }
   }
#ifdef STRESS_ASYNCH
   static int harold=0;
   if (((harold++)&0x3)==0)
      SFX_Play_Obj(type,NULL,sfx_name,objid);
#endif   
   return hnd;
}

int SFX_Play_Vec(int type, sfx_parm *parm, char *sfx_name, mxs_vector *vector)
{
   int hnd=SFX_Get();
   if (hnd!=SFX_NO_HND)
   {
      _sfx *newfx=&fxlist[hnd];
      _sfx_basic_setup(SFX_BF_VEC,newfx,type,parm,sfx_name);
      mx_copy_vec(&newfx->loc,vector);
      newfx->attach=0;
      if (!_sfx_start_play(newfx,FALSE)) {
         TLOG1( "SFX_Play_Vec [%d] - play failed", hnd );
         hnd=SFX_NO_HND;
      }
   }
   return hnd;
}

// kill off fxlist[hnd]
void SFX_Kill_Hnd(int hnd)
{
   _sfx_free(&fxlist[hnd], TRUE);
}

// kill all sounds which refer to this object
void SFX_Kill_Obj(int objid)
{
   int i;

   for (i=0; i<SFX_MAX_COUNT; i++)
      if ((fxlist[i].attach==objid) && (fxlist[i].type != SFX_NONE))
         SFX_Kill_Hnd(i);
}

// callback invoked when a play command fails to get a channel
//   return TRUE if app has freed a channel, FALSE if not
static BOOL
_sfx_priority_callback( ISndMixer    *pMixer,
                        ISndSample   *pSample,
                        void         *pCBData )
{
   _sfx  *pSFX;

   pSFX = (_sfx *) pSample->GetData();
   // signal that this sample couldn't be played
   pSFX->flags &= ~SFXFLG_HAPPY;

   snd_mprintf(("priority unhappy\n"));

   TLOG1( "failed to alloc chan to [%d]", pSFX->ID );

   // TBD: put in a priority scheme which kills off a low priority sound
   //   if this is a high priority sound - return TRUE in that case
   return FALSE;
}

///////////////////////
// EAX control

void SFX_Enable_EAX (void)
{
   // Test for null and initialize.
   if (NULL != pSndMixer)
   {
      pSndMixer->Init3DReverb();

      if (pSndMixer->Have3DReverb())
      {
         // Force current room to initialize reverb if in game mode.
         sgLastRoomType = -1;

         // Set to generic 50%.  This makes the options panel's left/right thing
         // sound cool.
         ReverbSettings revSet;
         revSet.flags = kREVERB_FlagType | kREVERB_FlagLevel;
         revSet.type = kREVERB_Generic;
         revSet.level = 0.5;
         pSndMixer->Set3DReverbSettings(&revSet);
      }
   }
}

void SFX_Disable_EAX (void)
{
   // Test for null and shutdown.
   if (NULL != pSndMixer)
      pSndMixer->Shutdown3DReverb();
}

BOOL SFX_Is_EAX_Enabled (void)
{
   // Test for null and query.
   if (NULL != pSndMixer)
      return ( pSndMixer->Have3DReverb() );

   // If no mixer, we don't have EAX.
   return FALSE;
}

BOOL SFX_Is_EAX_Available (void)
{
   // Test for null and query.
   if (NULL != pSndMixer)
      return ( pSndMixer->CanDo3DReverb() );

   // If no mixer, we can't do EAX.
   return FALSE;
}

BOOL SFX_Use_Occlusion( int sfxHandle )
{
   _sfx *pSFX = &(fxlist[sfxHandle]);

   if ( (pSndMixer != NULL) && (pSFX != NULL) ) {
      return (pSFX->flags & SFXFLG_POS) && (sfx3DMethod == kSnd3DMethodHardware) && pSndMixer->Have3DOcclusion();
   }

   return FALSE;
}


// what follows are utility functions for the editor
// basically the command interpreter, and the status dump/state check code
#ifndef SHIP
void SFX_Dump_Single(_sfx *fx)
{
   mprintf("Effect %x: type %d (flags %x): (pRes %x) Name %s\n",
           _sfx_get_hnd_from_ptr(fx),fx->type,fx->flags,fx->pRes,
           (fx->pRes==NULL)?"NoName":fx->pRes->GetName());
   mprintf("  Snd %x, attach %x, location %g %g %g\n",fx->pSnd,fx->attach,
           fx->loc.x,fx->loc.y,fx->loc.z);
   mprintf("  [%s %s] Parm pan %d gain %d (misc %d %d %d)\n",
           (fx->flags&SFXFLG_IS3D)?"Our3d":"Our2d",
           fx->pSnd==NULL?"NoSnd":
              fx->pSnd->Get3DMethod()==kSnd3DMethodHardware?"L3dHW":
              fx->pSnd->Get3DMethod()==kSnd3DMethodSoftware?"L3dSW":"Lib2d",
           fx->parm.pan,fx->parm.gain,fx->parm.flag,fx->parm.pri,fx->parm.group);
}

void SFX_Quick_List(BOOL dump_all)
{
   int i;
   for (i=0; i<SFX_MAX_COUNT; i++)
      if (dump_all||fxlist[i].type!=SFX_NONE)
      {
         _sfx *fx=&fxlist[i];
         mprintf("sfx %x: %s (res %x): gainpan %d %d [%d %x]\n",_sfx_get_hnd_from_ptr(fx),
                 (fx->pRes==NULL)?"NoName":fx->pRes->GetName(),fx->pRes,
                 fx->parm.pan,fx->parm.gain,fx->type,fx->flags);
      }
}

void SFX_Dump_List(BOOL dump_all)
{
   int i;
   for (i=0; i<SFX_MAX_COUNT; i++)
      if (dump_all||fxlist[i].type!=SFX_NONE)
         SFX_Dump_Single(&fxlist[i]);
}

#ifdef APPSFX_TIMINGS
void SFX_Dump_Timings(void)
{
   mprintf("Dumping and Clearing timing info for Sound\n");
   TIMER_OutputResult(StartPlayTimer);
   TIMER_OutputResult(SndMixerTimer);
   TIMER_OutputResult(SfxUpdateTimer);
   TIMER_Clear(StartPlayTimer);
   TIMER_Clear(SndMixerTimer);
   TIMER_Clear(SfxUpdateTimer);
}
#endif

void SFX_command(char *sfx_name)
{
   if (strnicmp(sfx_name,"show",4)==0)
      SFX_Dump_List((bool)(stricmp(sfx_name,"show_all")==0));
   else if (strnicmp(sfx_name,"quick_show",10)==0)
      SFX_Quick_List(FALSE);
   else if (strnicmp(sfx_name,"refresh",7)==0)
      SFX_Refresh_Config();
#ifdef APPSFX_TIMINGS
   else if (strnicmp(sfx_name,"timings",7)==0)
      SFX_Dump_Timings();
#endif
   else if (stricmp(sfx_name, "startup")==0)
      SFXInit();
   else if (stricmp(sfx_name, "shutdown")==0)
      SFXClose();
   else
      SFX_Play_Raw(SFX_STATIC, NULL, sfx_name);
}
#endif // SHIP
// $Header: r:/t2repos/thief2/src/sound/appsfx.h,v 1.33 2000/01/29 13:41:42 adurant Exp $
#pragma once

#ifndef __APPSFX_H
#define __APPSFX_H

#include <playlist.h>
#include <matrixs.h>

// says "this parm isnt being set in this struct"
#define SFX_DEF_PARM (-1)

// prototype parms for sfx
typedef struct {
   int    pan;       // using standard sndlib pan (-10k to 10k)
   uint   flag;      // flag overrides, not all are app setable
   ushort dummy;     // a couple of bytes for good alignment
   uchar  pri;       // priority for the sound
   uchar  group;     // what group the sound effect goes into
   int    gain;      // currently in snd.lib decibel format, maybe not a good idea
   int    delay;     // initial delay
   ulong  fade;      // fade in and out time
   int    radius;    // forced sound radius
   int    distance;  // distance to sound origination point (-1 == straight line)
   void (*end_callback)(int hSound, void *user_data);  // when sample ends
   void (*loop_callback)(int hSound, void *user_data); // when each loop ends
   void  *user_data; // for callbacks
   ISndSource *pSndSource; // for identifying our sound in the loop callback
   int    num_loops; // 
   mxs_real blocking_factor;  // sound attenuation due to doors (0.0 is no attenuation, 1.0 is full)
} sfx_parm;          //    since we really want local vol overrides? who knows

#define SFX_LOOP_INFINITE 0

#define SFX_MAX_MODE_COUNT 16
#define SFX_MAX_COUNT (SFX_MAX_MODE_COUNT * 2)
#define SFX_CHANNELS  8

#define SFX_NO_HND   (-1)

// system mode, for transitions between sim & metagame
typedef enum sfx_mode {
   SFX_mode_metagame = 65536,
   SFX_mode_game,
   SFX_mode_all,
} sfx_mode;

// types of sfx
#define SFX_NONE      0
#define SFX_STATIC    1
#define SFX_3D        2

// some flags can be set by the app, others are internal only
// app sfx flags
#define SFXFLG_LOOP        (1<<0)  // does the sample loop
#define SFXFLG_STREAM      (1<<5)  // this sample is a stream, not all in memory
#define SFXFLG_QSOUND      (1<<7)  // really a qsounded thing, deal with it
#define SFXFLG_PHYS        (1<<8)  // consider speed of object in sound calc
#define SFXFLG_NOCACHE     (1<<11) // dont cache, drop right after use
#define SFXFLG_SHARP       (1<<12) // sharp attenuation curve
#define SFXFLG_ASYNCH      (1<<13) // does one try and asynch load me
#define SFXFLG_NET_AMB     (1<<15) // network this ambient sound
#define SFXFLG_NO_NET      (1<<16) // don't network this spatial sound
#define SFXFLG_APP_MASK \
   (SFXFLG_LOOP|SFXFLG_STREAM|SFXFLG_QSOUND|SFXFLG_PHYS|SFXFLG_NOCACHE|SFXFLG_SHARP|SFXFLG_ASYNCH|SFXFLG_NET_AMB|SFXFLG_NO_NET)

// internal only flags
#define SFXFLG_STATIC      (1<<1)  // if static, never update pan/gain
#define SFXFLG_POS         (1<<2)  // do pain/gan positional update
#define SFXFLG_OBJ         (1<<3)  // reload location out of object
#define SFXFLG_DELAY       (1<<4)  // delay start of sample

#define SFXFLG_HAPPY       (1<<9)  // happy or not, ie. did i play
#define SFXFLG_IS3D        (1<<10) // did i ask for 3d hardware for this or not?
#define SFXFLG_ASYNCHWAIT  (1<<14) // am i waiting for the asynch load to finish?
#define SFXFLG_NOCALLBACK  (1<<17) // dont make the callback

//   valid type/so ons are
// _Raw, STATIC - just play the darn effect, right here, right now
// _Obj, STATIC - just play it, but if obj goes away, kill it
// _Obj, 3D - play it, compute pan and gain continually, based on object pos
// _Vec, STATIC - compute pan/gain once for vec, the play it there??? if useful
// _Vec, 3D - play it, compute pan and gain continually, based on src vec

//   the parm->flag field can be used to make a given sample loop, or tell it
// that it is really a data stream, and so on.  this is somewhat inconvienient
// as you have to get parm struct, default out all the other fields, and then
// set flags.  maybe we should just have an int flags you pass in to all the
// SFX_Play calls?

//////////////////////////////
// ProtoTypes

// setup functions
EXTERN void SFXClose(void);
EXTERN BOOL SFXInit(void);
EXTERN BOOL SFXReset(void);

#define SFXDEVICE_NoSound      (0)
#define SFXDEVICE_Software     (1)
#define SFXDEVICE_A3D          (2)
#define SFXDEVICE_QMIXER       (3)

EXTERN BOOL SFX_SetSoundDevice(int device, BOOL reset);
EXTERN int  SFX_GetSoundDevice();

// pass in an sfx_mode
EXTERN void SFX_SetMode(sfx_mode mode);

// if you want to set a mode callback
// return TRUE to mean "go ahead and deal with it (ie. auto pause-resume)
// else FALSE to mean "let me deal with it"/"i dealt with it"/etc
EXTERN BOOL (*appsfxModeCallback)(sfx_mode mode, int handle, sfx_parm *parm);

// stop all sounds w/out making callbacks
EXTERN void SFX_KillAll(sfx_mode mode);

// TRUE iff we are between SFX init and close 
EXTERN BOOL SFXActive(void);

// Test for free physical channel, or get count
EXTERN int  SFX_Channel_Count(void);
EXTERN BOOL SFX_IsChannelAvail(void);

// the play functions
EXTERN BOOL SFX_PreLoad(const char *pName);

//  *parm can always be NULL to default, or can be filled in by APP
EXTERN int SFX_Play_Raw(int type, sfx_parm *parm, char *sfx_name);
EXTERN int SFX_Play_Obj(int type, sfx_parm *parm, char *sfx_name, int objid);
EXTERN int SFX_Play_Vec(int type, sfx_parm *parm, char *sfx_name, mxs_vector *vector);

// Set stereo reversal
EXTERN void SFX_SetReverseStereo(BOOL state);
EXTERN BOOL SFX_StereoReversed();

// Master volume
EXTERN void SFX_SetMasterVolume(int vol);
EXTERN int SFX_GetMasterVolume();
EXTERN int SFX_GetNumChannels ();

// Volumes.
EXTERN void SFX_Set2dVolume (int vol);
EXTERN int  SFX_Get2dVolume ();
EXTERN void SFX_Set3dVolume (int vol);
EXTERN int  SFX_Get3dVolume ();
EXTERN void SFX_SetMusicVolume (int vol);
EXTERN int  SFX_GetMusicVolume ();

// Distance override
EXTERN void SFX_Slam_Dist(int hnd, int distance, BOOL force_update);
// Distance override with blocking factor
EXTERN void SFX_Slam_Dist_BF(int hnd, int distance, mxs_real blocking_factor, BOOL force_update);


// Attenuation stuff
EXTERN int SFX_MaxDist(int gain);
EXTERN int SFX_Attenuate(int master_gain, int dist);

// removing particular effects
EXTERN void SFX_Kill_Hnd(int hnd);
EXTERN void SFX_Kill_Obj(int objid);

// frame update call me often sort of thing
EXTERN void SFX_Frame(mxs_vector *pos, mxs_angvec *ang);

// calculate attenuate volume at a distance
EXTERN int SFX_Attenuate(int master_gain, int dist);

// name of resource for sound
EXTERN const char *SFX_Name(int hnd);
// parm struct for sound
EXTERN const sfx_parm *SFX_Parm(int hnd);

#ifndef SHIP
EXTERN void SFX_command(char *sfx_name);
EXTERN void SFX_Dump_List(BOOL dump_all);
EXTERN void SFX_Quick_List(BOOL dump_all);
#endif

///////////////////////
// EAX control

EXTERN void SFX_Enable_EAX (void);
EXTERN void SFX_Disable_EAX (void);
EXTERN BOOL SFX_Is_EAX_Enabled (void);
EXTERN BOOL SFX_Is_EAX_Available (void);
// TRUE IFF we are using EAX 2+ occlusion for doors and such
EXTERN BOOL SFX_Use_Occlusion( int sfxHandle );

#endif //  __APPSFX_H
// $Header: r:/t2repos/thief2/src/sound/appsfxi.h,v 1.1 1998/08/25 23:19:32 dc Exp $
// private im very special header for appsfx stuff

#pragma once

#ifndef __APPSFXI_H
#define __APPSFXI_H

#include <lgsound.h> // great, just great

// if you are need of this, say, to do some group volume stuff
EXTERN ISndMixer *SFX_GetMixer(void);

#endif  // __APPSFX_H
// $Header: r:/t2repos/thief2/src/sound/auxsnd.cpp,v 1.8 1999/06/28 21:28:12 mwhite Exp $
// memory sound source stuff from Pat

#include <stdio.h>

#include <lg.h>
#include <sndsrc.h>
#include <playlist.h>

#include <auxsnd.h>  // so we get our own EXTERN 

// must be last header
#include <dbmem.h>

#define kAUXSND_SecondsOfBuffer 1.0F

typedef struct _fakeSplicerThingy {
   ISndSource        *pSource;
   SndEndCallback    userCB;
   void              *pUserCBData;
   uint32            *pPlaylist;
} fakeSplicerThingy;

//
// endFakeSplicer - free stuff this stream was using
//
static void
endFakeSplicer( ISndSample    *pSample,
                void          *pCBData )
{
   fakeSplicerThingy *pFakeSplicer = (fakeSplicerThingy *) pCBData;

   if ( pFakeSplicer->userCB != NULL ) {
      pFakeSplicer->userCB( pSample, pFakeSplicer->pUserCBData );
   }
   pFakeSplicer->pSource->DisconnectFromPlayer();
   pFakeSplicer->pSource->Release();

   Free( pFakeSplicer->pPlaylist );
   Free( pFakeSplicer );
}

//
// create a sound source which will play the data in pBuffer (size in bufferLen)
//
// endCB is the user end-of-play callback, will be called when sample is
//   done playing - this needs to be done here so we can wrap the end
//   callback with a callback which cleans up the sound source
//   and any other crud we create
//
ISndSample *
CreateMemSoundSource( ISndMixer        *pMixer,          // your mixer
                      void             *pBuffer,         // the sound data
                      uint32           bufferLen,        // sizeof the sound data
                      SndEndCallback   endCB,            // your end callback
                      void             *pEndCBData )     // data for endCB
{
   ISndSample           *pSample;
   sSndAttribs          attribs;
   uint32               totalSamples, dummy;
   ISndSource           *pSndSrc;
   uint32               *pPlaylistBase;
   void                 *pRawData;
   char                 *pListTmp;
   uint32               rawDataLen, nSamples, finalDataLen;
   fakeSplicerThingy    *pFakeSplicer;
   SSPLMemSingle        *pMemSingle;
   SSPLEndList          *pEndList;

   if ( pMixer == NULL ) {
      return NULL;
   }

   //
   // get the attribs for source from 1st resource
   //
   if ( SndCrackRezHeader( pBuffer, bufferLen, &pRawData, &rawDataLen,
                           &nSamples, &attribs )  ) {
      Warning(("error cracking header\n"));
      return NULL;
   } else {
      //
      // cracked the header successfully, if ADPCM, change the
      //  sound attributes to those of the decompressed data
      //
      if ( attribs.dataType == kSndDataIMAADPCM ) {
         attribs.dataType = kSndDataPCM;
         attribs.bitsPerSample = 16;
         finalDataLen = ( attribs.numSamples << 1 ) * attribs.nChannels;
      } else {
         finalDataLen = rawDataLen;
      }
   }

   pSndSrc = SndCreateSource( &attribs );

   //
   // build the playlist
   //  The playlist is just two ops:
   //    1 - plays a memory buffer
   //    2 - ends the playlist
   //
   pPlaylistBase = (uint32 *)Malloc( sizeof(SSPLMemSingle) + sizeof(SSPLEndList) );

   pListTmp = (char *) pPlaylistBase;

   pMemSingle = (SSPLMemSingle *) pListTmp;
   pMemSingle->op = plMemSingle;
   pMemSingle->nSamples = attribs.numSamples;
   pMemSingle->pData = pBuffer;
   pListTmp += sizeof( SSPLMemSingle );

   pEndList = (SSPLEndList *) pListTmp;
   pEndList->op = plEndList;

   pSndSrc->SetPlaylist( pPlaylistBase );


   // find out total #samples in playlist
   pSndSrc->GetPositions( &dummy, &dummy, &totalSamples );

   //
   // Da Magic:  When we create a raw sample of type "Normal" (a JohnB-ism),
   //  this usually creates the DirectSoundBuffer and copies the data directly
   //  to it - but since we pass in NULL for the sound data address, it calls
   //  the stream refill callback, which in this case is sndsrc code which will read
   //  compressed data from the passed-in memory buffer, and will decompress
   //  directly to the DirectSoundBuffer.
   //
   pSample = ISndMixer_CreateRawSample( pMixer, kSndSampleNormal, NULL,
                                        finalDataLen, totalSamples, &attribs );
   if ( pSample == NULL ) {

      pSndSrc->Release();
      Free( pPlaylistBase );
      pSndSrc = NULL;

   } else {

      // wrap the user end callback in our own
      pFakeSplicer = (fakeSplicerThingy *) Malloc( sizeof(fakeSplicerThingy) );
      pFakeSplicer->userCB = endCB;
      pFakeSplicer->pUserCBData = pEndCBData;
      pFakeSplicer->pSource = pSndSrc;
      pFakeSplicer->pPlaylist = pPlaylistBase;

      pSample->RegisterEndCallback( endFakeSplicer, pFakeSplicer );
      pSample->SetData( (long) pFakeSplicer );

      // connect the sound source to the sample
      pSndSrc->ConnectToPlayer( pSample );
   }

   return pSample;
}


// ppSndSrc    a returned handle so that you can diddle sound source
// nLoops      # of loops, 0 == infinite
// loopCB      the loop callback (NULL is ok)
// pLoopCBData ptr to data which will be available to the loop callback

// to do a semi-infinite loop which exits at next loop end:
//  pSndSrc->SetGate( 0, 1 );   // set loop counter 0 to 1

//
// create a sound source which will play the data in pBuffer (size in bufferLen)
//  a specified number of times
//
// endCB is the user end-of-play callback, will be called when sample is
//   done playing - this needs to be done here so we can wrap the end
//   callback with a callback which cleans up the sound source
//   and any other crud we create
//
ISndSample *
CreateMemSoundSourceLooped( ISndMixer           *pMixer,          // your mixer
                            void                *pBuffer,         // the sound data
                            uint32              bufferLen,        // sizeof the sound data
                            SndEndCallback      endCB,            // your end callback
                            void                *pEndCBData,      // data for endCB
                            ISndSource          **ppSndSrc,       // handle to the sound source
                            int                 nLoops,           // # of times to play it
                            SndPlaylistCallback loopCB,           // your loop callback
                            void                *pLoopCBData )    // data for loopCB
{
   ISndSample           *pSample;
   sSndAttribs          attribs;
   uint32               totalSamples, dummy;
   ISndSource           *pSndSrc;
   uint32               *pPlaylistBase;
   void                 *pRawData;
   char                 *pListTmp;
   uint32               rawDataLen, nSamples, finalDataLen;
   fakeSplicerThingy    *pFakeSplicer;
   SSPLMemSingle        *pMemSingle;
   SSPLEndList          *pEndList;
   SSPLLabel            *pLabel;
   SSPLBranch           *pBranch;
   SSPLCallback         *pCallback;
   SSPLSetGate          *pSetGate;
   long                 *pWoof;

   if ( ppSndSrc != NULL ) {
      *ppSndSrc = NULL;
   }

   if ( pMixer == NULL ) {
      return NULL;
   }

   //
   // get the attribs for source from 1st resource
   //
   if ( SndCrackRezHeader( pBuffer, bufferLen, &pRawData, &rawDataLen,
                           &nSamples, &attribs )  ) {
      Warning(("error cracking header\n"));
      return NULL;
   } else {
      //
      // cracked the header successfully, if ADPCM, change the
      //  sound attributes to those of the decompressed data
      //
      if ( attribs.dataType == kSndDataIMAADPCM ) {
         attribs.dataType = kSndDataPCM;
         attribs.bitsPerSample = 16;
         finalDataLen = ( attribs.numSamples << 1 ) * attribs.nChannels;
      } else {
         finalDataLen = rawDataLen;
      }
   }

   pSndSrc = SndCreateSource( &attribs );


   //
   // build the playlist
   //
   //  The playlist is just five ops:
   //    1 - loop start label
   //    2 - plays a memory buffer
   //    3 - does app loop callback
   //    4 - branch to label
   //    3 - ends the playlist
   pPlaylistBase = (uint32 *)Malloc( sizeof(SSPLSetGate) +
                                     sizeof(SSPLLabel) +
                                     sizeof(SSPLMemSingle) +
                                     sizeof(SSPLCallback) + sizeof(uint32) +
                                     sizeof(SSPLBranch) +
                                     sizeof(SSPLEndList)  + 32 );
         
   pListTmp = (char *) pPlaylistBase;

   // set # loops
   // this should just be pSndSrc->SetGate( 0, nLoops ), but that's broken!
   pSetGate = (SSPLSetGate *) pListTmp;
   pSetGate->op = plSetGate;
   pSetGate->gateNum = 0;
   pSetGate->gateValue = nLoops;
   pListTmp += sizeof( SSPLSetGate );

   pLabel = (SSPLLabel *) pListTmp;
   pLabel->op = plLabel;
   pLabel->labelNum = 0;
   pListTmp += sizeof( SSPLLabel );

   pMemSingle = (SSPLMemSingle *) pListTmp;
   pMemSingle->op = plMemSingle;
   pMemSingle->nSamples = attribs.numSamples;
   pMemSingle->pData = pBuffer;
   pListTmp += sizeof( SSPLMemSingle );

   pCallback = (SSPLCallback *) pListTmp;
   pCallback->op = plCallback;
   pCallback->func = loopCB;
   pCallback->nArgs = 1;
   pListTmp += sizeof( SSPLCallback );
   // add the single argument - the app callback data ptr
   pWoof = (long *) pListTmp;
   *pWoof++ = (long) pLoopCBData;
   pListTmp += sizeof( long );

   // branch to label 0 if gate var 0 is not 0 after decrementing
   pBranch = (SSPLBranch *) pListTmp;
   pBranch->op = plBranch;
   pBranch->labelNum = 0;
   pBranch->gateNum = 0;
   pBranch->indirect = 0;
   pBranch->branchType = SSPLBTDecrementBranchNotZero;
   pListTmp += sizeof( SSPLBranch );

   pEndList = (SSPLEndList *) pListTmp;
   pEndList->op = plEndList;

   pSndSrc->SetPlaylist( pPlaylistBase );

   // set loop counter (gate var 0) 
   //pSndSrc->SetGate( 0, nLoops );

   // find out total #samples in playlist
   pSndSrc->GetPositions( &dummy, &dummy, &totalSamples );

   //
   // Da Magic:  When we create a raw sample of type "Normal" (a JohnB-ism),
   //  this usually creates the DirectSoundBuffer and copies the data directly
   //  to it - but since we pass in NULL for the sound data address, it calls
   //  the stream refill callback, which in this case is sndsrc code which will read
   //  compressed data from the passed-in memory buffer, and will decompress
   //  directly to the DirectSoundBuffer.
   //
   pSample = ISndMixer_CreateRawSample( pMixer, kSndSampleStream, NULL,
                                        finalDataLen, totalSamples, &attribs );
   if ( pSample == NULL ) {

      pSndSrc->Release();
      Free( pPlaylistBase );
      pSndSrc = NULL;

   } else {

      // wrap the user end callback in our own
      pFakeSplicer = (fakeSplicerThingy *) Malloc( sizeof(fakeSplicerThingy) );
      pFakeSplicer->userCB = endCB;
      pFakeSplicer->pUserCBData = pEndCBData;
      pFakeSplicer->pSource = pSndSrc;
      pFakeSplicer->pPlaylist = pPlaylistBase;

      pSample->RegisterEndCallback( endFakeSplicer, pFakeSplicer );
      pSample->SetData( (long) pFakeSplicer );

      // connect the sound source to the sample
      pSndSrc->ConnectToPlayer( pSample );
   }

   // give app handle to the sound source
   if ( ppSndSrc != NULL ) {
      *ppSndSrc = pSndSrc;
   }

   return pSample;
}




// ppSndSrc    a returned handle so that you can diddle sound source
// nLoops      # of loops, 0 == infinite
// loopCB      the loop callback (NULL is ok)
// pLoopCBData ptr to data which will be available to the loop callback

// to do a semi-infinite loop which exits at next loop end:
//  pSndSrc->SetGate( 0, 1 );   // set loop counter 0 to 1

//
// create a sound source which will play the data in pBuffer (size in bufferLen)
//  a specified number of times
//
// endCB is the user end-of-play callback, will be called when sample is
//   done playing - this needs to be done here so we can wrap the end
//   callback with a callback which cleans up the sound source
//   and any other crud we create
//
ISndSample *
CreateNRezStreamedSoundSource( ISndMixer           *pMixer,          // your mixer
                               IRes                *pRez,
                               char                **ppStreamBuffer, // the stream buffer
//                            uint32              bufferLen,         // sizeof the sound data
                               SndEndCallback      endCB,            // your end callback
                               void                *pEndCBData,      // data for endCB
                               ISndSource          **ppSndSrc )       // handle to the sound source
//                            int                 nLoops,           // # of times to play it
//                            SndPlaylistCallback loopCB,           // your loop callback
//                            void                *pLoopCBData )    // data for loopCB
{
   ISndSample           *pSample;
   sSndAttribs          attribs;
   uint32               totalSamples, dummy;
   ISndSource           *pSndSrc;
   uint32               *pPlaylistBase;
   void                 *pRawData;
   char                 *pListTmp;
   uint32               rawDataLen, nSamples;
   fakeSplicerThingy    *pFakeSplicer;
   SSPLNRezSingle       *pNRezSingle;
   SSPLEndList          *pEndList;
   /*
   SSPLEndList          *pEndList;
   SSPLLabel            *pLabel;
   SSPLBranch           *pBranch;
   SSPLCallback         *pCallback;
   SSPLSetGate          *pSetGate;
   long                 *pWoof;
   */

   if ( ppSndSrc != NULL )
   {
      *ppSndSrc = NULL;
   }

   if ( pMixer == NULL )
   {
      return NULL;
   }

   //
   // get the attribs for source from 1st resource
   //

   // Hack to extract header info from the .wav.  Eventually I want to replace "crackheader"
   // raw memory .wav processing with IStream stuff so that memory/file/nres stuff is all
   // handled through a common interface (and so looping info can be extracted without
   // reading in a whole file).
   int len = pRez->GetSize();
   char tmpBuff[256];
   int bytesToRead = ( len < sizeof(tmpBuff) ) ? len : sizeof(tmpBuff);
   //   int nSamples;
   pRez->ExtractPartial( 0, bytesToRead - 1, tmpBuff );
   if ( SndCrackRezHeader( tmpBuff, bytesToRead,
                               &pRawData, &rawDataLen,
                               &nSamples, &attribs ) )
   {
      Warning(("error cracking header\n"));
      return NULL;
   } 
   else
   {
      //
      // cracked the header successfully, if ADPCM, change the
      //  sound attributes to those of the decompressed data
      //
      if ( attribs.dataType == kSndDataIMAADPCM )
      {
         attribs.dataType = kSndDataPCM;
         attribs.bitsPerSample = 16;
      }
   }

   pSndSrc = SndCreateSource( &attribs );


   //
   // build the playlist
   //
   //  The playlist is just two ops:
   //    1 - plays an nrez buffer
   //    2 - ends the playlist
   pPlaylistBase = (uint32 *)Malloc( sizeof(SSPLNRezSingle) +
                                     sizeof(SSPLEndList) +
                                     32 );
   pListTmp = (char *) pPlaylistBase;

   pNRezSingle = (SSPLNRezSingle *) pListTmp;
   pNRezSingle->op = plNRezSingle;
   pNRezSingle->pRes = pRez;
   pListTmp += sizeof ( SSPLNRezSingle );

   pEndList = (SSPLEndList *) pListTmp;
   pEndList->op = plEndList;

   pSndSrc->SetPlaylist( pPlaylistBase );

   // find out total #samples in playlist
   pSndSrc->GetPositions( &dummy, &dummy, &totalSamples );

   //
   // Da Magic:  When we create a raw sample of type "Normal" (a JohnB-ism),
   //  this usually creates the DirectSoundBuffer and copies the data directly
   //  to it - but since we pass in NULL for the sound data address, it calls
   //  the stream refill callback, which in this case is sndsrc code which will read
   //  compressed data from the passed-in memory buffer, and will decompress
   //  directly to the DirectSoundBuffer.
   //
   int streamBufSize = attribs.sampleRate * kAUXSND_SecondsOfBuffer * (attribs.bitsPerSample >> 3);
   *ppStreamBuffer = new char[streamBufSize];
   pSample = ISndMixer_CreateRawSample( pMixer, kSndSampleStream, *ppStreamBuffer,
                                        streamBufSize, totalSamples, &attribs );
   if ( pSample == NULL )
   {
      pSndSrc->Release();
      Free( pPlaylistBase );
      pSndSrc = NULL;
   }
   else
   {
      // wrap the user end callback in our own
      pFakeSplicer = (fakeSplicerThingy *) Malloc( sizeof(fakeSplicerThingy) );
      pFakeSplicer->userCB = endCB;
      pFakeSplicer->pUserCBData = pEndCBData;
      pFakeSplicer->pSource = pSndSrc;
      pFakeSplicer->pPlaylist = pPlaylistBase;

      pSample->RegisterEndCallback( endFakeSplicer, pFakeSplicer );
      pSample->SetData( (long) pFakeSplicer );

      // connect the sound source to the sample
      pSndSrc->ConnectToPlayer( pSample );
   }

   // give app handle to the sound source
   if ( ppSndSrc != NULL ) {
      *ppSndSrc = pSndSrc;
   }

   return pSample;
}

struct sSongSrcSegment
{
   SSPLLabel         label;
   SSPLCallback      callback;
   uint32            cbData;
   SSPLNRezSingle    nresSingle;
   SSPLBranch        loopBranch;
   SSPLBranch        segmentBranch;
};


ISndSample*
CreateSongSoundSource ( ISndMixer           *pMixer,
                        uint32              numSegments,
                        IRes*               *pResArray,     // An array of resources, size is numSegments.
                        char                **ppStreamBuffer,
                        SndEndCallback      endCB,
                        void                *pEndCBData,
                        ISndSource          **ppSndSrc,
                        SndPlaylistCallback segmentCB,         // segment callback
                        void                *pSegmentCBData )  // data for CB
{
   ISndSample           *pSample;
   sSndAttribs          attribs;
   ISndSource           *pSndSrc;
   uint32               *pPlaylistBase;
   uint32               totalSamples, dummy;
   void                 *pRawData;
   uint32               rawDataLen, nSamples;
   sSongSrcSegment      *pCurrSeg;
   SSPLCallback         *pCallback;
   uint32               *pCallbackData;
   SSPLLabel            *pLabel;
   SSPLNRezSingle       *pNRezSingle;
   SSPLBranch           *pBranch;
   SSPLEndList          *pEndList;
   fakeSplicerThingy    *pFakeSplicer;

//   SSPLCallback         *pCallback; Hmmm... callbacks....

   //
   // get the attribs for source from 1st resource
   //
   // Hack to extract header info from the .wav.  Eventually I want to replace "crackheader"
   // raw memory .wav processing with IStream stuff so that memory/file/nres stuff is all
   // handled through a common interface (and so looping info, which usually resides after
   // sample data, can be easily extracted without reading in a whole file).
   int len = pResArray[0]->GetSize();
   char tmpBuff[256];
   int bytesToRead = ( len < sizeof(tmpBuff) ) ? len : sizeof(tmpBuff);
   //   int nSamples;
   pResArray[0]->ExtractPartial( 0, bytesToRead - 1, tmpBuff );
   if ( SndCrackRezHeader( tmpBuff, bytesToRead,
                               &pRawData, &rawDataLen,
                               &nSamples, &attribs ) )
   {
      Warning(("error cracking header\n"));
      return NULL;
   } 
   else
   {
      //
      // cracked the header successfully, if ADPCM, change the
      //  sound attributes to those of the decompressed data
      //
      if ( attribs.dataType == kSndDataIMAADPCM )
      {
         attribs.dataType = kSndDataPCM;
         attribs.bitsPerSample = 16;
      }
   }

   // Create the sound source.  The "<<1" is because each segment has 2 gates:
   // one for looping and one for branching to other segments.
   pSndSrc = SndCreateSourceEx( &attribs,
                                numSegments + 1,        // Number of labels (+1 for "end song" label)
                                3 );                    // current seg, next seg, loop count.
   //                                (numSegments << 1) );   // Number of branches (2 branches per segment)

   // Allocate the play list.
   pPlaylistBase = (uint32 *)Malloc( (sizeof(sSongSrcSegment) * numSegments) +
                                     sizeof(SSPLEndList) +
                                     sizeof (SSPLLabel) +
                                     32 );

   // Point at the start of the play list.
   //   pListTmp = (char *) pPlaylistBase;
   pCurrSeg = (sSongSrcSegment*) pPlaylistBase;

   // Fill in the segments of the play list.
   for (int i = 0; i < numSegments; i++)
   {
      // Add label for this section.
      pLabel                  = &(pCurrSeg->label);
      pLabel->op              = plLabel;
      pLabel->labelNum        = i;

      // Add the callback
      pCallback                 = &(pCurrSeg->callback);
      pCallback->op             = plCallback;
      pCallback->func           = segmentCB;
      pCallback->nArgs          = 1;

      // Add the callback data.
      pCallbackData             = &(pCurrSeg->cbData);
      *pCallbackData            = (uint32)pSegmentCBData;

      // Add sample.
      pNRezSingle             = &(pCurrSeg->nresSingle);
      pNRezSingle->op         = plNRezSingle;
      pNRezSingle->pRes       = pResArray[i];

      // Add loop branch.
      pBranch                 = &(pCurrSeg->loopBranch);
      pBranch->op             = plBranch;
      pBranch->labelNum       = i;
      pBranch->gateNum        = 2; // 2 is the loopCount gate.
      //      pBranch->gateNum        = i << 1;
      pBranch->indirect       = 0;
      pBranch->branchType     = SSPLBTDecrementBranchNotZero;

      // Add goto branch.
      // Branch to the label whose value is stored in the gate referenced by pBranch->labelNum
      // i.e. "branch gate[pBranch->labelNum]"
      pBranch                 = &(pCurrSeg->segmentBranch);
      pBranch->op             = plBranch;
      pBranch->labelNum       = 1; // 1 is the next segment gate.
      //      pBranch->labelNum       = (i << 1) + 1;
      pBranch->gateNum        = 0; // Unused on branch unconditional.
      pBranch->indirect       = 1;
      pBranch->branchType     = SSPLBTBranch;

      pCurrSeg++;
   }
   
   // Add "end of song" label.
   pLabel               = (SSPLLabel*) pCurrSeg;
   pLabel->op           = plLabel;
   pLabel->labelNum     = numSegments;
   pLabel++;

   // Add "end of playlist".
   pEndList             = (SSPLEndList*) pLabel;
   pEndList->op         = plEndList;

   pSndSrc->SetPlaylist( pPlaylistBase );

      // find out total #samples in playlist
   pSndSrc->GetPositions( &dummy, &dummy, &totalSamples );

   //
   // Da Magic:  When we create a raw sample of type "Normal" (a JohnB-ism),
   //  this usually creates the DirectSoundBuffer and copies the data directly
   //  to it - but since we pass in NULL for the sound data address, it calls
   //  the stream refill callback, which in this case is sndsrc code which will read
   //  compressed data from the passed-in memory buffer, and will decompress
   //  directly to the DirectSoundBuffer.
   //
   int streamBufSize = attribs.sampleRate * kAUXSND_SecondsOfBuffer * (attribs.bitsPerSample >> 3);
   *ppStreamBuffer = new char[streamBufSize];
   pSample = ISndMixer_CreateRawSample( pMixer, kSndSampleStream, *ppStreamBuffer,
                                        streamBufSize, totalSamples, &attribs );
   if ( pSample == NULL )
   {
      pSndSrc->Release();
      Free( pPlaylistBase );
      pSndSrc = NULL;
   }
   else
   {
      // wrap the user end callback in our own
      pFakeSplicer = (fakeSplicerThingy *) Malloc( sizeof(fakeSplicerThingy) );
      pFakeSplicer->userCB = endCB;
      pFakeSplicer->pUserCBData = pEndCBData;
      pFakeSplicer->pSource = pSndSrc;
      pFakeSplicer->pPlaylist = pPlaylistBase;

      pSample->RegisterEndCallback( endFakeSplicer, pFakeSplicer );
      pSample->SetData( (long) pFakeSplicer );

      // connect the sound source to the sample
      pSndSrc->ConnectToPlayer( pSample );
   }

   // give app handle to the sound source
   if ( ppSndSrc != NULL ) {
      *ppSndSrc = pSndSrc;
   }

   return pSample;
}
// $Header: r:/t2repos/thief2/src/sound/vocore.h,v 1.1 1998/09/16 00:17:12 mahk Exp $
#pragma once  
#ifndef __VOCORE_H
#define __VOCORE_H
#include <comtools.h>

////////////////////////////////////////////////////////////
// CORE VOICE-OVER SYSTEM 
//
// This is a tiny system for playing "voice overs" which are special
// schemas that can be omitted if their context isn't right. 
// 

typedef BOOL (LGAPI *tVOTestFunc)(void); 

//
// The voice-overs class
//


F_DECLARE_INTERFACE(IVoiceOverSys);
#undef INTERFACE 
#define INTERFACE IVoiceOverSys
DECLARE_INTERFACE_(IVoiceOverSys,IUnknown)
{
   DECLARE_UNKNOWN_PURE(); 

   //
   // Play a voiceover schema 
   // May actually choose not to play, if the conditions for playing 
   // the schema are not right.  
   //
   // Returns a schema handle 
   //
   STDMETHOD_(int,Play)(THIS_ int schema) PURE; 

   //
   // Observe whether a schema has been played.
   // Mark a schema as having been played, or not played already 
   //
   STDMETHOD_(BOOL,AlreadyPlayed)(THIS_ int schema) PURE; 
   STDMETHOD(SetAlreadyPlayed)(THIS_ int schema, BOOL played) PURE; 

   //
   // Set the game-specific callback that tests whether or not we
   // are "in combat."  Each call to Play() will call it.  
   //
   STDMETHOD(SetCombatTest)(THIS_ tVOTestFunc func) PURE; 

}; 
#undef INTERFACE 

EXTERN void VoiceOverCreate(void); 

#endif // __VOCORE_H
// $Header: r:/t2repos/thief2/src/sound/vocprop.h,v 1.2 2000/01/31 10:02:58 adurant Exp $
#pragma once

/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\
   vocprop.h

   A voice is an abstract object with two propeties: SynName and this.
   All this gives us is a handle into spch.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */


#ifndef _VOCPROP_H_
#define _VOCPROP_H_

#include <lg.h>
#include <objtype.h>


#define PROP_VOICE_INDEX_NAME "VoiceIndex"

EXTERN BOOL ObjGetVoiceIndex(ObjID obj, int* iIndex);
EXTERN void ObjSetVoiceIndex(ObjID obj, int iIndex);

#endif // ~_VOCPROP_H_
#pragma once
DEFINE_LG_GUID(IID_IVoiceOverSys, 0x1da);
// $Header: r:/t2repos/thief2/src/sound/esnd.h,v 1.5 2000/01/31 10:03:01 adurant Exp $
#pragma once

/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   environmental sound--C++ functions

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

#ifndef _ESND_H_
#define _ESND_H_

#include <matrixs.h>

#include <objtype.h>
#include <osystype.h>
#include <tagdbt.h>
#include <schbase.h>
#include <esndprop.h>
#include <ctagset.h>


extern void ESndNotifyTextParseEnd();

// This one plays a schema ambiently, as for a voiceover.
extern int ESndPlay(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2, 
                    sSchemaCallParams *pParams = NULL, 
                    void *pData = NULL);

extern int ESndPlayObj(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2, 
                       sSchemaCallParams *pParams = NULL, 
                       void *pData = NULL);

extern int ESndPlayLoc(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2, 
                       const mxs_vector *pLoc, sSchemaCallParams *pParams = NULL, 
                       void *pData = NULL);


enum eESndTagSets
{
   kObj1ClassTags,
   kObj1MaterialTags,
   kObj2ClassTags,
   kObj2MaterialTags,
   kRoomTags,
   kAppTags, 
   kNumESndTagSets,
};

typedef struct sESndEvent 
{
   ObjID obj1;
   ObjID obj2;
   cTagSet* tagsets[kNumESndTagSets];
   sSchemaCallParams *params; 
} sESndEvent; 


typedef void (*tESndGameCallback)(sESndEvent* ev); 

tESndGameCallback ESndSetGameCallback(tESndGameCallback pfFunc);

#endif // ~_ESND_H_
// $Header: r:/t2repos/thief2/src/sound/esndglue.h,v 1.4 2000/01/31 10:03:02 adurant Exp $
#pragma once

/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\
   esndglue.h

   These are the elements of the environmental sound system which need
   to be exported as C.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */


#ifndef _ESNDGLUE_H_
#define _ESNDGLUE_H_


#include <objtype.h>
#include <dispatch.h>


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   For each tag we're working with we need to keep track of where we
   got it: the current room, our first object, our second object, the
   app proper.  We stuff this into the upper byte of each tag type
   field in our database.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */


// app-level flow control
EXTERN void ESndDatabaseNotify(DispatchData *msg);
EXTERN void ESndInit(void);
EXTERN void ESndTerm(void);

EXTERN void ESndSetTagRequired(const Label *pTagName);

// These functions amount to an iterator.
EXTERN void ESndSchemaNewStart(const Label *pSchemaName, ObjID SchemaObjID);
EXTERN void ESndSchemaNewAddEnumTag(const Label *pTagName,
                                    const Label *pEnum);
EXTERN void ESndSchemaNewAddIntTag(const Label *pTagName,
                                   int iMin, int iMax);
EXTERN void ESndSchemaNewFinish(void);

// destroy all databases
EXTERN void ESndDestroy(void);

#ifndef SHIP
EXTERN void ESndDump();
#endif

#endif // ~_ESNDGLUE_H_
// $Header: r:/t2repos/thief2/src/sound/esndprop.cpp,v 1.4 1998/08/04 22:49:47 mahk Exp $

#include <esndprop.h>
#include <property.h>
#include <propbase.h>
#include <propface.h>
#include <propfac_.h>
#include <dataops_.h>
#include <proplist.h>
#include <objnotif.h>

#include <sdesbase.h>
#include <sdestool.h>

// Include these last 
#include <dbmem.h>
#include <initguid.h>
#include <esndprid.h>

/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   The structure descriptor is also used by both properties.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static sFieldDesc g_Fields [] =
{
   { "1: Tags", kFieldTypeString, 
     FieldLocation(sESndTagList, m_TagStrings) },
};

static sStructDesc g_ListStruct
  = StructDescBuild(sESndTagList, kStructFlagNone, g_Fields);


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   The class property is for archetypes.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static IESndTagProperty* g_pESndClassProp = NULL;

//
// This version of sESndTagList is used by the data ops
// It keeps its cTagList in synch with the string.
// 

struct sOpsList : public sESndTagList 
{
   sOpsList()
   {
      m_pTagSet = new cTagSet; 
      m_TagStrings[0] = '\0'; 
   } 

   sOpsList(const sESndTagList& dat)
   {
      strncpy(m_TagStrings,dat.m_TagStrings,sizeof(m_TagStrings)); 
      m_pTagSet = new cTagSet(m_TagStrings); 
   }

   sOpsList(const sOpsList& dat)
   {
      strncpy(m_TagStrings,dat.m_TagStrings,sizeof(m_TagStrings)); 
      m_pTagSet = new cTagSet(m_TagStrings); 
   }

   sOpsList& operator=(const sOpsList& dat)
   {
      strncpy(m_TagStrings,dat.m_TagStrings,sizeof(m_TagStrings)); 
      m_pTagSet->FromString(m_TagStrings); 
      return *this; 
   }

   ~sOpsList()
   {
      delete m_pTagSet; 
   }

} ; 

class cESndTagOps : public cClassDataOps<sOpsList>
{
   typedef cClassDataOps<sOpsList> cParent; 
public: 

   cESndTagOps() : cParent(kNoFlags) {} ; 
   STDMETHOD(Read)(THIS_ sDatum* dat, IDataOpsFile* file, int version)
   {
      if (!dat->value)
         *dat = New(); 
      sOpsList* list = (sOpsList*)dat->value; 
      sESndTagList tmp;
      memset(&tmp,0,sizeof(tmp)); 
      // we derive from cClassDataOps, thus version == size; 
      int sz = (version < sizeof(tmp)) ? version : sizeof(tmp); 
      Verify(file->Read(&tmp,sz) == sz); 
      *list = tmp; 
      return S_OK; 
   }

}; 

class cESndTagStore : public cListPropertyStore<cESndTagOps>
{
}; 

class cESndTagProperty : public cSpecificProperty<IESndTagProperty,
   &IID_IESndTagProperty, sESndTagList*, cESndTagStore>

{
   typedef cSpecificProperty<IESndTagProperty,
                             &IID_IESndTagProperty,
                             sESndTagList*,
                             cESndTagStore> cParent;

public: 
   cESndTagProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
   }

   STANDARD_DESCRIBE_TYPE(sESndTagList); 


}; 


static sPropertyDesc g_ClassPropDesc =
{
   PROP_ESND_CLASS_NAME,
   0,
   NULL,
   0,0, // verison
   { "Schema", "Class Tags" }, 
};

EXTERN BOOL ObjGetESndClass(ObjID obj, sESndTagList **pData)
{
   Assert_(g_pESndClassProp);
   return g_pESndClassProp->Get(obj, pData);
}


EXTERN BOOL ObjSetESndClass(ObjID obj, sESndTagList *pData)
{
   Assert_(g_pESndClassProp);
   return g_pESndClassProp->Set(obj, pData);
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   The material property is for material archetypes and terrain.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static IESndTagProperty* g_pESndMaterialProp = NULL;

static sPropertyDesc g_MaterialPropDesc =
{
   PROP_ESND_MATERIAL_NAME,
   0,
   NULL,
   0,0, // verison
   { "Schema", "Material Tags" }, 
};

EXTERN BOOL ObjGetESndMaterial(ObjID obj, sESndTagList **pData)
{
   Assert_(g_pESndMaterialProp);
   return g_pESndMaterialProp->Get(obj, pData);
}


EXTERN BOOL ObjSetESndTagList(ObjID obj, sESndTagList *pData)
{
   Assert_(g_pESndMaterialProp);
   return g_pESndMaterialProp->Set(obj, pData);
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   Initialization of both properties and listeners.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

void ESndPropsInit()
{
   AutoAppIPtr_(StructDescTools, pTools);

   pTools->Register(&g_ListStruct);
   g_pESndClassProp = new cESndTagProperty(&g_ClassPropDesc);
   g_pESndMaterialProp = new cESndTagProperty(&g_MaterialPropDesc);
}

void ESndPropsTerm()
{
   SafeRelease(g_pESndClassProp); 
   SafeRelease(g_pESndMaterialProp); 
}


// $Header: r:/t2repos/thief2/src/sound/esndprop.h,v 1.4 2000/01/31 10:03:04 adurant Exp $
#pragma once

#ifndef _ESNDPROP_H_
#define _ESNDPROP_H_

#include <property.h>
#include <label.h>
#include <esndglue.h>
#include <ctagset.h>

////////////////////////////////////////////////////////////
// GENERIC "TAG LIST" PROPERTY INTERFACE
//
// The tag list is exposed as a string to the designer, but secretly 
// maintains a cTagSet for speed. 
//

//
// The actual "tag list" structure used by the property.
//

#define kESndStringMax (256 - sizeof(cTagSet*))

struct sESndTagList
{
   // This is first so we can make the string longer if we like.
   cTagSet *m_pTagSet;
   char m_TagStrings[kESndStringMax];
};

//////////////////////////////////////////////
// We'll be using this on archetypes.


F_DECLARE_INTERFACE(IESndTagProperty);
#undef INTERFACE
#define INTERFACE IESndTagProperty

DECLARE_PROPERTY_INTERFACE(IESndTagProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sESndTagList*);
};
#undef INTERFACE 

////////////////////////////////////////////
// This is for tags that describe the "class" of object 

#define PROP_ESND_CLASS_NAME "Class Tags"

EXTERN BOOL ObjGetESndClass(ObjID obj, sESndTagList **ppList);
EXTERN BOOL ObjSetESndClass(ObjID obj, sESndTagList *pList);

////////////////////////////////////////////
// This is for material archetypes, terrain, and who knows what else.

#define PROP_ESND_MATERIAL_NAME "Material Tags"

EXTERN BOOL ObjGetESndMaterial(ObjID obj, sESndTagList **ppList);
EXTERN BOOL ObjSetESndMaterial(ObjID obj, sESndTagList *pList);

//////////////////////////////////////////////
// other

EXTERN void ESndPropsInit(void);
EXTERN void ESndPropsTerm(void); 


#endif // ~_ESNDPROP_H_

#pragma once
DEFINE_LG_GUID(IID_IESndTagProperty, 0x13d);
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psndapi.h,v 1.14 2000/01/29 13:41:44 adurant Exp $
//
// Sound propagation api header
//
#pragma once

#ifndef __PSNDAPI_H
#define __PSNDAPI_H

#include <objtype.h>
#include <appsfx.h>

////////////////////////////////////////////////////////////////////////////////

EXTERN void SoundPropagationInit();
EXTERN void SoundPropagationTerm();
EXTERN void SoundPropagationReset();


enum eGenerateSoundFlags
{
   kGSF_None       = 0x0000,
   kGSF_WantHandle = 0x0001,
   kGSF_Networked  = 0x0002,
   kGSF_NetSent    = 0x0004,
   kGSF_ForcePlay  = 0x0008,
};

// Returned from GenerateSound functions if we don't actually make a sound:
#define kPSndFail  (-1)

EXTERN int  GenerateSoundObj(ObjID objID, ObjID schemaID, const char *sampleName, 
                             float atten_factor, sfx_parm *parms, int flags, void *data);
EXTERN int  GenerateSoundVec(mxs_vector *vec, ObjID src_obj, ObjID schemaID, const char *sampleName, 
                             float atten_factor, sfx_parm *parms, int flags, void *data);
EXTERN int  GenerateSound(const char *sampleName, sfx_parm *parms);

EXTERN void SoundHalt(int handle);
EXTERN void SoundHaltObj(ObjID objID);

EXTERN void ApplyPropSounds();
EXTERN void ClearPropSounds();
EXTERN void CleanupSoundObjects();

EXTERN BOOL IsSoundListener(ObjID objID);

#ifndef SHIP
EXTERN void DrawSounds();
EXTERN void SpewSounds();

EXTERN BOOL g_show_sounds;
#endif

////////////////////////////////////////////////////////////////////////////////

#endif
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psndinfo.h,v 1.18 2000/01/29 13:41:45 adurant Exp $
//
// Sound information class header
//
#pragma once

#ifndef __SNDINFO_H
#define __SNDINFO_H

#include <objtype.h>
#include <matrix.h>
#include <appsfx.h>

#include <dlist.h>

////////////////////////////////////////////////////////////////////////////////

typedef int ObjID;

typedef class cSoundInfo cSoundInfo;

typedef cDList<cSoundInfo, 0>     cSoundInfoList;
typedef cDListNode<cSoundInfo, 0> cSoundInfoListNode;

////////////////////////////////////////////////////////////////////////////////

enum eSoundInfoFlags
{
   kSIF_None           = 0x0000,
   kSIF_HasBeenUpdated = 0x0001,   // Has been repropagated and updated
   kSIF_OnObject       = 0x0002,   // Attached to an object
   kSIF_Deferred       = 0x0004,   // A deferred sound
   kSIF_Intercept      = 0x0008,   // Being bumped, don't tell schema
   kSIF_Static         = 0x0010,   // Non-directional sound
   kSIF_NetSent        = 0x0020,   // Has this sound been sent over the network?
   kSIF_Networked      = 0x0040,   // This is a sound that we've been told to play
   kSIF_ForcePlay      = 0x0080,   // This sound was forced to play
};

struct sSoundInfo
{
   ulong      flags;
   int        Volume;         // Volume of virtual sound 
   mxs_vector Position;       // Position of virtual sound
   mxs_real   Distance;       // munged distance to actual sound (includes blocking factor)

   mxs_vector SrcPoint;       // The location of sound source

   ObjID      SrcObject;      // Object causing the sound (-1 if not applicable)
   ObjID      Object;         // Object hearing the sound
   ObjID      ActiveObject;   // Object placed at the virtual sound

   void      *Data;           // Data propagated with the sound

   float      AttenFactor;    // Attenuation factor

   int        FramesUntilUpdate; // # of frames until sound is re-propagated (only if it's active)

   char       SampleName[16]; // Name of playing sample

   sfx_parm   AppsfxParms;    // Parameters to appsfx for this sound

   int        Handle;         // Sound propagation handle
   int        SFXHandle;      // Handle of playing sample

   ObjID      SchemaID;       // ObjID of schema

   mxs_real   BlockingFactor; // amount of obstruction along sound path
   mxs_real   RealDistance;   // real distance to actual sound (not including blocking factor)
};

class cSoundInfo : public cSoundInfoListNode, public sSoundInfo
{
public:
   cSoundInfo(const cSoundInfo& info)
      : sSoundInfo(info)
   {
   }

   cSoundInfo()
   {
      flags = 0;

      Volume = -1;

      mx_zero_vec(&Position);
      mx_zero_vec(&SrcPoint);

      Distance = 0.0;

      SrcObject = OBJ_NULL;
      Object = OBJ_NULL;
      ActiveObject = OBJ_NULL;

      Data = NULL;

      AttenFactor = 1.0;
      FramesUntilUpdate = 0;
      SampleName[0] = '\0';

      Handle = -1;
      SFXHandle = SFX_NO_HND;

      SchemaID = OBJ_NULL;
   } 

};

////////////////////////////////////////////////////////////////////////////////

class cPlayerSoundList : public cSoundInfoList
{
public:

   // Callback and info for schema system
   void (*SchemaCallback)(int hSound, void *user_data);
   void (*SchemaLoopCallback)(int hSound, void *user_data);
   void *SchemaUserData;
};

////////////////////////////////////////////////////////////////////////////////

#endif




///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psndinst.h,v 1.22 2000/01/29 13:41:46 adurant Exp $
//
// Sound propagation instance header
//
#pragma once

#ifndef __PSNDINST_H
#define __PSNDINST_H

#include <matrixs.h>

#include <dynarray.h>
#include <hashpp.h>

#include <appsfx.h>
#include <roomsys.h>
#include <roompa.h>

#include <psndinfo.h>

F_DECLARE_INTERFACE(IAIManager);

////////////////////////////////////////

// Max active sounds.
const int kMaxActiveSounds = 32;

////////////////////////////////////////////////////////////////////////////////

EXTERN void EndSampleCallback(int hSound, void *ptr);
EXTERN void LoopSampleCallback(int hSound, void *ptr);

////////////////////////////////////////////////////////////////////////////////

typedef cHashTableFunctions<ObjID> ObjIDHashFunctions;

typedef cHashTable<ObjID, cSoundInfoList *, ObjIDHashFunctions> cSoundInfoTable;
typedef cHashTable<ObjID, mxs_real, ObjIDHashFunctions>         cSoundPropTable;

typedef cDynArray<ObjID> cSoundObjectList;

typedef cDynArray<const cRoomPortal *> cPortalStack;

typedef struct 
{
   mxs_vector pos;
   BOOL valid;
} sAnchorPt;

////////////////////
enum PrioritizationResult
{
   PRIORITY_RES_OK,
   PRIORITY_RES_FAIL,
   PRIORITY_RES_DEFERRED
};

enum eDeferredHaltType
{
   kDH_Kill,
   kDH_Silence,
};

typedef struct
{
   int sfx_handle;
   int type;
} sDeferredHalt;


////////////////////////////////////////////////////////////////////////////////

class cPropSndInst : public cRoomPAFuncs
{
public:

   /////////////////
   //
   // Constructor / Destructor
   //
   cPropSndInst();
   ~cPropSndInst();

   void Init(int handle, ObjID objID, const mxs_vector &loc, ObjID schemaID, const char *sampleName, 
             int flags, float atten_factor, sfx_parm *parms, void *data);
   void Cleanup();

   void ApplySoundInfo();
   void ClearSoundInfo();

   cPlayerSoundList *GeneratePlayerSoundList(int handle);

   void AddDeferredHalt(int sfx_handle, int type);
   void ApplyDeferredHaltList();

   void AddActiveSound(cSoundInfo *pSoundInfo);
   void EndActiveSound(cSoundInfo *pSoundInfo);

   void BumpActiveSound(cPlayerSoundList *pPlayerList);

   void SetupPlayerSoundListCallbacks (cPlayerSoundList* pCurPlayerList);
   BOOL PlaySoundList (cPlayerSoundList* pCurPlayerList);

   #ifndef SHIP
   void SetDrawSoundPath(BOOL state) { m_DrawSoundPath = state; };

   void DrawActiveSounds();
   void SpewActiveSounds();
   #endif

protected:

   ////////////////////////////

   mxs_real    m_MaxDistance;    // Maximum distance the sound can be heard
   mxs_real    m_ScaleDistance;  // Forces max distance for sound

   ObjID       m_SrcObject;      // ID of object making sound (-1 if not applicable)
   mxs_vector  m_SrcPoint;       // Coordinates of sound source 

   const char *m_SampleName;     // Name of sample being propagated
   sfx_parm   *m_pParms;         // Parameters from schema system

   ObjID       m_SchemaID;       // ObjID of the schema

   void       *m_Data;           // Any data that wants to be propagated too

   int         m_Handle;         // Sound propagation handle

   int         m_Flags;          // Sound info flags 

   ////////////////////////////

   cSoundInfoTable  m_InfoTable;      // Hash by objid to list sounds heard this frame
   cSoundObjectList m_InfoList;       // List of objects that have heard a sound this frame

   cSoundInfo      *m_ActiveSound[kMaxActiveSounds];
   ObjID            m_ActiveObject[kMaxActiveSounds];
   int              m_nActiveSoundObjects;

   cDynArray<sDeferredHalt> m_deferredHaltList;

   short m_roomNoBlock1;
   short m_roomNoBlock2;

   float m_attenFactor;

#ifndef SHIP
   BOOL m_DrawSoundPath;

   BOOL m_SoundSpew;
   BOOL m_SoundFullSpew;
   BOOL m_SoundGhostSpew;
   BOOL m_SoundFullAISpew;
   BOOL m_SoundPathSpew;
   BOOL m_SoundHearSpew;
#endif

   void FindSoundPath(const mxs_vector &src_pt, const mxs_vector &hear_pt, const cBFRoomInfo *room_table, int end_room, 
                      mxs_real *dist, mxs_vector *position, mxs_real *realDist, mxs_real *blockingFactor);
   void BackCastPath(sAnchorPt *anchor_list, cRoomPortal **portal_list, int i, const mxs_vector &L, const mxs_vector &src_pt); 

private:

   BOOL MergeSounds(cSoundInfoList *pSoundInfoList);

   BOOL ActiveSound(cSoundInfo *pSoundInfo); 

   void ResolveActiveSounds(ObjID hearingObj);
   void UpdateActiveSounds();

   void ResolveDeferredSounds(ObjID hearingObj);
   void UpdateDeferredSounds();

   IAIManager * m_pAIManager;
};

////////////////////////////////////////////////////////////////////////////////

class cPropSndInstHigh : public cPropSndInst
{
public:

   /////////////////
   //
   // Callbacks
   //
   BOOL     EnterCallback(const cRoom *room, const cRoomPortal *enterPortal, const mxs_vector &enterPt, mxs_real dist);
   void     ExitCallback(const cRoom *room);
   mxs_real PortalsCallback(const cRoomPortal *enterPortal, const cRoomPortal *exitPortal, mxs_real dist);
};

////////////////////////////////////////////////////////////////////////////////

#endif








// $Header: r:/t2repos/thief2/src/sound/spchprop.h,v 1.7 2000/01/31 10:02:51 adurant Exp $
#pragma once

#ifndef __SPCHPROP_H
#define __SPCHPROP_H

#include <propface.h>

#include <spchtype.h>

#undef INTERFACE
#define INTERFACE ISpeechProperty
DECLARE_PROPERTY_INTERFACE(ISpeechProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(sSpeech*); 
}; 


#define PROP_SPEECH "Speech"

EXTERN sSpeech *SpeechPropCreateAndGet(ObjID objID);
EXTERN void SpeechPropInit();

// Last usage property
#define PROP_SPEECH_NEXT_PLAY "SpchNextPlay"
EXTERN IIntProperty *g_pPropSpeechNextPlay;
EXTERN void SpeechNextPlayPropInit(void);
EXTERN int SpeechNextPlayGet(ObjID objID);
#define SPEECH_NEXT_PLAY_SET(objID, time) PROPERTY_SET(g_pPropSpeechNextPlay, (objID), (time))

// Voice name property
#define PROP_SPEECH_VOICE "SpchVoice"
EXTERN ILabelProperty *g_pPropSpeechVoice;
EXTERN void SpeechVoicePropInit(void);
EXTERN Label *ObjGetSpeechVoice(ObjID objID);
#define OBJ_SET_SPEECH_VOICE(objID, voiceID) PROPERTY_SET(g_pPropSpeechVoice, (objID), (voiceID))

// voice index property
#define PROP_VOICE_INDEX_NAME "VoiceIdx"
EXTERN IIntProperty *g_pPropSpeechVoiceIndex;
EXTERN BOOL ObjGetSpeechVoiceIndex(ObjID obj, int* iIndex);
EXTERN void ObjSetSpeechVoiceIndex(ObjID obj, int iIndex);

// Speech pause properties
#define PROP_SPEECH_PAUSE_MIN "MinSpchPause"
EXTERN IIntProperty *g_pPropSpeechPauseMin;
EXTERN void SpeechPauseMinPropInit(void);
EXTERN int SpeechPauseMinGet(ObjID objID);
#define SPEECH_PAUSE_MIN_SET(objID, time) \
   PROPERTY_SET(g_pPropSpeechPauseMin, (objID), (time))
#define PROP_SPEECH_PAUSE_MAX "MaxSpchPause"
EXTERN IIntProperty *g_pPropSpeechPauseMax;
EXTERN void SpeechPauseMaxPropInit(void);
EXTERN int SpeechPauseMaxGet(ObjID objID);
#define SPEECH_PAUSE_MAX_SET(objID, time) \
   PROPERTY_SET(g_pPropSpeechPauseMax, (objID), (time))

// Initialize all speech properties
EXTERN void SpeechPropsInit(void);

#endif



// $Header: r:/t2repos/thief2/src/sound/spchreq.cpp,v 1.3 1998/10/05 17:28:07 mahk Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchreq.cpp

   A request is the thing you hand the speech system to make it play a
   sound.  It is specific to a given domain, and has names which match
   its concept and its (tag, value) pairs.  Before you actually use it
   you need to have spch tokenize it, looking up the indices or
   whatever based on these names.

   The idea is that you keep these around, wherever possible, so that
   you spend as little time tokenizing as possible.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <spchreq.h>


// Must be last header 
#include <dbmem.h>


extern cSpeechDomain g_Domain;


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   All cSpeechTagNamePair needs is a couple of constructors.  We assume
   that the labels passed in are already null terminated.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */

cSpeechTagNamePair::cSpeechTagNamePair(Label *pTagName, Label *pValueName)
{
   memcpy(m_TagName.text, pTagName, 16);
   memcpy(m_ValueName.text, pValueName, 16);
}


cSpeechTagNamePair::cSpeechTagNamePair()
{
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   The main event: heeeere's our cSpeechRequest methods.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */

cSpeechRequest::~cSpeechRequest()
{
}


void cSpeechRequest::Clear()
{
   m_TagValuePair.SetSize(0);
   m_TagDBInput.SetSize(0);
}


void cSpeechRequest::ClearTags()
{
   m_TagValuePair.SetSize(0);
}


void cSpeechRequest::AddTag(Label *pTagName, Label *pValueName)
{
   const cSpeechTagNamePair Pair(pTagName, pValueName);
   m_TagValuePair.Append(Pair);

   // invalidate tokenized data
   m_TagDBInput.SetSize(0);
}


void cSpeechRequest::AddTagList(Label *pStartOfList)
{
   while (pStartOfList->text[0] != 0) {
      AddTag(pStartOfList, pStartOfList + 1);
      ++pStartOfList;
   }
}


void cSpeechRequest::AddToTagInput(cTagDBInput *pInput)
{
   int iSize = m_TagDBInput.Size();

   for (int i = 0; i < iSize; ++i)
      pInput->Append(m_TagDBInput[i]);
}


// Our return value indicates whether tokenization was possible.
// (The domain issues monospew if any token wasn't found).
BOOL cSpeechRequest::Tokenize()
{
   // find our concept
   m_ConceptIndex = g_Domain.ConceptIndex(&m_ConceptName);
   if (m_ConceptIndex == kNameMapIndexNotFound) {
      return FALSE;
   }

   int iSize = m_TagValuePair.Size();
   m_TagDBInput.SetSize(iSize);

   for (int i = 0; i < iSize; ++i) {
      tTagDBKeyType TagIndex
         = g_Domain.TagIndex(&m_TagValuePair[i].m_TagName);
      if (m_ConceptIndex == kNameMapIndexNotFound) {
         return FALSE;
      }

      tTagDBKeyValue ValueIndex
         = g_Domain.TagValueIndex(TagIndex, &m_TagValuePair[i].m_ValueName);

      cTagDBInputPair NewPair(TagIndex, ValueIndex);
      m_TagDBInput.SetItem(&NewPair, i);
   }

   return TRUE;
}
// $Header: r:/t2repos/thief2/src/sound/spchreq.h,v 1.6 2000/01/31 10:02:52 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchreq.h

   A request is the thing you hand the speech system to make it play a
   sound.  It has names which match its concept and its (tag, value)
   pairs.  Before you actually use it you need to tokenize it.

   The idea is that you keep these around, wherever possible, so that
   you spend as little time tokenizing as you can.

   The Labels you pass in should already be null terminated.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _SPCHREQ_H_
#define _SPCHREQ_H_


#include <string.h>

#include <lgassert.h>
#include <dynarray.h>

#include <label.h>
#include <tagfile.h>
#include <tagdbin.h>
#include <spchdom.h>
#include <speech.h>

#include <spcht.h>
#include <tagdbt.h>
#include <namemap.h>



// Internal helper
class cSpeechTagNamePair
{
public:
   Label m_TagName;
   Label m_ValueName;

   cSpeechTagNamePair(Label *TagName, Label *ValueName);
   cSpeechTagNamePair();
};


extern cSpeechDomain g_Domain;


const Label kSpeechRequestEndTag = {""};

class cSpeechRequest
{
public:
   cSpeechRequest(Label *pConceptName)
   {
      m_ConceptName = *pConceptName;
   }

   ~cSpeechRequest();

   void Clear();

   // We expect to be tokenized again after this is called.
   void ClearTags();

   // This, of course, invalidates any tokenization.
   void AddTag(Label *pTagName, Label *pValueName);

   void AddTagList(Label *pStartOfList);

   // This lets us put any number of requests into a single query.
   void AddToTagInput(cTagDBInput *pInput);

   // A request starts off with the names tags and tag values.  This
   // finds the corresponding indices, or returns FALSE if it can't.
   BOOL Tokenize();

   int ConceptIndex()
   {
      return m_ConceptIndex;
   }

   int ConceptPriority()
   {
      return g_Domain.FindConceptPriority(m_ConceptIndex);
   }

   const Label* ConceptName(void) const { return &m_ConceptName; }; 

   // raw names of stuff
   Label m_ConceptName;
   cDynArray<cSpeechTagNamePair> m_TagValuePair;

protected:
   // tokenized data
   int m_ConceptIndex;
   cTagDBInput m_TagDBInput;
};


#endif // ~_SPCHREQ_H_
// $Header: r:/t2repos/thief2/src/sound/spcht.h,v 1.2 2000/01/31 10:02:53 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spcht.h

   This gives you all the typedefs and classes for the spch system.
   In the case of the handle typedefs, this is the only place you'll
   find them, no matter where you look.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _SPCHT_H_
#define _SPCHT_H_


class cSpeechDomain;
class cSpeechVoice;
class cSpeechRequest;


#endif // ~_SPCHT_H_
// $Header: r:/t2repos/thief2/src/sound/spchtype.h,v 1.2 2000/01/31 10:02:54 adurant Exp $
#pragma once

#ifndef __SPCHTYPE_H
#define __SPCHTYPE_H

typedef struct sSpeech sSpeech;

#endif
// $Header: r:/t2repos/thief2/src/sound/spchvoc.cpp,v 1.5 1998/10/05 17:28:09 mahk Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchvoc.cpp

   A cSpeechVoice depends on the global domain to be constant--in
   particular, in its number of concepts--over the life of the
   cSpeechVoice.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <limits.h>

#include <tagdbdat.h>
#include <tagdbkst.h>
#include <tagdbout.h>
#include <spchdom.h>

#include <spchvoc.h>


// Must be last header 
#include <dbmem.h>


extern cSpeechDomain g_Domain;


// We depend on the appropriate domain to already have been loaded, so
// that we know how many concepts we've got.
cSpeechVoice::cSpeechVoice()
{
   m_pCurrentAddition = NewITagDBKeySet();
   int iNumConcepts = g_Domain.NumConcepts();
   m_ConceptDatabase.SetSize(iNumConcepts);

   for (int i = 0; i < iNumConcepts; ++i)
      m_ConceptDatabase[i] = NewITagDBDatabase();
}


cSpeechVoice::~cSpeechVoice()
{
   int iSize = m_ConceptDatabase.Size();
   for (int i = 0; i < iSize; ++i)
      delete m_ConceptDatabase[i];

   delete m_pCurrentAddition;
}


void cSpeechVoice::AddDataStart(sTagDBData Data, const Label *pConceptName)
{
   m_iCurrentConcept = g_Domain.ConceptIndex(pConceptName);
   m_CurrentData = Data;
   m_pCurrentAddition->Clear();
}


void cSpeechVoice::AddDataAddTag(const Label *pTagName, int iMin, int iMax)
{
   tTagDBKeyType iTagIndex = g_Domain.TagIndex(pTagName);
   cTagDBKey NewKey(iTagIndex, iMin, iMax);

   m_pCurrentAddition->AddKey(&NewKey);
}


// pEnum is expected to be an array of eight const labels.
void cSpeechVoice::AddDataAddTag(const Label *pTagName, const Label *pEnum)
{
   tTagDBKeyEnum aEnum[8];
   tTagDBKeyType iTagIndex = g_Domain.TagIndex(pTagName);

   for (int i = 0; i < 8; ++pEnum, ++i)
      if (!pEnum->text[0])
         aEnum[i] = kTagDBKeyEnumUnused;
      else
         aEnum[i] = g_Domain.ValueIndex(pEnum);

   cTagDBKey NewKey(iTagIndex, aEnum);
   m_pCurrentAddition->AddKey(&NewKey);
}


void cSpeechVoice::AddDataFinish()
{
   if (m_iCurrentConcept == kNameMapIndexNotFound)
      return;

   ITagDBDatabase *pCurrent = m_ConceptDatabase[m_iCurrentConcept];

   pCurrent->Insert(m_pCurrentAddition, m_CurrentData);
}


BOOL cSpeechVoice::SelectSchemas(cTagDBInput *pInput, int iConceptIndex,
                                 cTagDBOutput *pOutput)
{
   m_ConceptDatabase[iConceptIndex]->MatchSubset(pInput, pOutput);

   if (pOutput->Size() > 0)
      return TRUE;
   else
      return FALSE;
}


void cSpeechVoice::TransformData(void Func(sTagDBData *))
{
   int iNumConcepts = g_Domain.NumConcepts();

   for (int i = 0; i < iNumConcepts; ++i)
      m_ConceptDatabase[i]->TransformData(Func);
}


void cSpeechVoice::TransformKeys(void Func(cTagDBKey *))
{
   int iNumConcepts = g_Domain.NumConcepts();

   for (int i = 0; i < iNumConcepts; ++i) {
      ITagDBDatabase *pTemp = m_ConceptDatabase[i]->CopyWithFilter(Func);
      delete m_ConceptDatabase[i];
      m_ConceptDatabase[i] = pTemp;
   }
}


void cSpeechVoice::Load(ITagFile *pFile)
{
   for (int i = 0; i < g_Domain.NumConcepts(); ++i)
      m_ConceptDatabase[i]->Load(pFile);
}


void cSpeechVoice::Save(ITagFile *pFile)
{
   for (int i = 0; i < g_Domain.NumConcepts(); ++i)
      m_ConceptDatabase[i]->Save(pFile);
}


void cSpeechVoice::Clear()
{
   for (int i = 0; i < m_ConceptDatabase.Size(); ++i)
      delete m_ConceptDatabase[i];
}

// $Header: r:/t2repos/thief2/src/sound/spchvoc.h,v 1.3 2000/01/31 10:02:56 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchvoc.h

   A voice maintains a collection of tag databases, one for each
   concept in the speech system.

   The voice has no notion of an individual tag or tag value.  But it
   does pass these things on to the tag databases it manages.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _SPCHVOC_H_
#define _SPCHVOC_H_


#include <lgassert.h>
#include <dynarray.h>
#include <objtype.h>
#include <osystype.h>
#include <tagfile.h>
#include <tagdbkst.h>

#include <spcht.h>
#include <tagdbt.h>


class cSpeechVoice
{
public:
   cSpeechVoice();
   ~cSpeechVoice();

   // We expect our schemas and tags to be loaded before we try
   // building any voices.
   void AddDataStart(sTagDBData Data, const Label *pConceptName);
   void AddDataAddTag(const Label *pTagName, int iMin, int iMax);
   void AddDataAddTag(const Label *pTagName, const Label *pEnum);
   void AddDataFinish();

   BOOL SelectSchemas(cTagDBInput *pInput, int iConceptIndex, 
                      cTagDBOutput *pOutput);

   void TransformData(void Func(sTagDBData *));
   void TransformKeys(void Func(cTagDBKey *));

   // Our load and save routines do not open or close their tag
   // blocks, just use them.  So they have no sense of version.
   void Load(ITagFile *pFile);
   void Save(ITagFile *pFile);
   void Clear();

protected:
   cDynArray<ITagDBDatabase *> m_ConceptDatabase;

   // for building new entries
   ITagDBKeySet *m_pCurrentAddition;
   int m_iCurrentConcept;
   sTagDBData m_CurrentData;
};


#endif // ~_SPCHVOC_H_
// $Header: r:/t2repos/thief2/src/sound/speech.cpp,v 1.61 2000/02/08 23:10:40 patmac Exp $

// This is the procedural core of spch.  No classes are defined here.
//
// Some of this is exposed in spchglue.h, which is a C interface for
// the YACC/LEX schema parser.  The rest is strictly C++.

#include <lgassert.h>
#include <dynarray.h>
#include <mprintf.h>
#include <comtools.h>

#include <timer.h>
#include <stdlib.h>
#include <cfgdbg.h>
#include <matrix.h>

#include <recapi.h>

#include <linkbase.h>
#include <relation.h>
#include <traitman.h>
#include <appagg.h>
#include <iobjsys.h>
#include <linkman.h>
#include <lnkquery.h>
#include <propman.h>
#include <objquery.h>
#include <objremap.h>
#include <traitbas.h>
#include <edittool.h>
#include <wrtype.h>
#include <objpos.h>

#include <command.h>
#include <playrobj.h>

#include <speech.h>
#include <spchglue.h>
#include <spchprop.h>
#include <spchbase.h>

#include <schbase.h>
#include <schema.h>
#include <schprop.h>
#include <schsamps.h>

#include <tag.h>

#include <dbasemsg.h>
#include <dispbase.h>

#include <hashfast.h>
#include <dlist.h>
#include <dlisttem.h>

#include <ctag.h>
#include <namemap.h>
#include <spchdom.h>
#include <spchvoc.h>
#include <tagdbin.h>
#include <tagdbout.h>
#include <tagdbt.h>
#include <playrobj.h>

#include <config.h>
#include <cfgdbg.h>

#include <aidebug.h>
#include <aiprutil.h>
#include <aisndtyp.h>

#include <netman.h>

#include <hashpp.h>
#include <hshpptem.h>

// Must be last header
#include <dbmem.h>

// This is for tracking our load/save status...
BOOL g_bSpeechDatabaseLoaded = FALSE;

static IObjectSystem *pObjSys = NULL;
static ILinkManager *pLinkMan = NULL;
static IPropertyManager *pPropMan = NULL;
static ISpeechProperty *pSpeechProperty = NULL;
static ITraitManager *pTraitMan = NULL;
static IRecorder *pRecorder = NULL;

static RelationID voiceRelationID = RELID_NULL;
static IRelation *pVoiceRelation = NULL;


static int schemasNum;
#define SPEECH_SCHEMAS_MAX 10 // max schemas/concept-voice pair
static float schemaScores[SPEECH_SCHEMAS_MAX];

// @TBD (toml 08-03-98): if ais are to communicate through sound propogation, this test will
// have to move deeper and only be used for schemas with no associated semantic value

// min distance at which an AI will speak, squared - this will need
// tweaking
static float kAISpeechMinDist2 = 100.0 * 100.0;

cSpeechDomain g_Domain;
static int g_iNewestTag;
static Label g_NewestTagName;
static cSpeechVoice *g_pCurrentVoice;


// Each voice archetype has an index into this structure.
static cDynArray<cSpeechVoice *> g_VoiceList;

// NOTE: if kCallbackEntryMax is not 1, a crash occurs at the end of a conversation
//   inside SpeechEndCallback, because the first callback causes the speechEndCallbackHash
//   to delete the callback function array, so the second callback ptr is a bullshit ptr - patmc
//#define kCallbackEntryMax 4
#define kCallbackEntryMax 1

struct sCallbackHashEntry : public sHashFastEntry
{
   sCallbackHashEntry(ObjID obj)
      : m_obj(obj)        
   {
      memset(m_aCallbackList, 0, sizeof(m_aCallbackList));
   }

   inline ObjID GetKey()
   {
      return m_obj;
   }

   void AddCB(SpeechCallbackFn pFN)
   {
      int i;

      // only allow each callback to be registered once
      for (i = 0; i < kCallbackEntryMax; ++i)
         if (m_aCallbackList[i] == pFN)
            return;

      for (i = 0; i < kCallbackEntryMax; ++i)
         if (!m_aCallbackList[i]) {
            m_aCallbackList[i] = pFN;
            break;
         }

      Assert_(i < kCallbackEntryMax);
   }

   // This returns FALSE if this entry should be deleted (no callbacks
   // left).  The order of the callbacks may change.
   BOOL RemoveCB(SpeechCallbackFn pFN)
   {
      int i, j;
      for (i = 0; i < kCallbackEntryMax; ++i) {
         if (m_aCallbackList[i] == pFN) {
            if (i == kCallbackEntryMax - 1) {
               m_aCallbackList[kCallbackEntryMax - 1] = 0;
               return TRUE;
            } else {
               // Is the list empty now?
               if (i == 0 && m_aCallbackList[1] == 0)
                  return FALSE;

               // We swap down the last callback in the list.
               for (j = i + 1; j < kCallbackEntryMax; ++j)
                  if (!m_aCallbackList[j])
                     break;
               m_aCallbackList[i] = m_aCallbackList[j - 1];
               m_aCallbackList[j - 1] = 0;
               return TRUE;
            }
         }
      }

      // not found (considered harmless)
      return TRUE;
   }

   // data
   ObjID m_obj;
   SpeechCallbackFn m_aCallbackList[kCallbackEntryMax];
};


// Callback hash tables
static cHashFast<64, ObjID, sCallbackHashEntry> g_speechStartCallbackHash;
static cHashFast<64, ObjID, sCallbackHashEntry> g_speechEndCallbackHash;


//////////////////////////////////////////

void SpeechInstallStartCallback(ObjID speakerID, SpeechCallbackFn callback)
{
   sCallbackHashEntry *pEntry = g_speechStartCallbackHash.Search(speakerID);
   if (!pEntry) {
      pEntry = new sCallbackHashEntry(speakerID);
      g_speechStartCallbackHash.Insert(pEntry);
   }

   pEntry->AddCB(callback);
}

//////////////////////////////////////////

void SpeechUninstallStartCallback(ObjID speakerID, SpeechCallbackFn callback)
{
   sCallbackHashEntry *pEntry = g_speechStartCallbackHash.Search(speakerID);
   if (pEntry)
      if (!pEntry->RemoveCB(callback)) {
         g_speechStartCallbackHash.Remove(speakerID);
         delete pEntry;
      }
}

//////////////////////////////////////////

void SpeechInstallEndCallback(ObjID speakerID, SpeechCallbackFn callback)
{
   sCallbackHashEntry *pEntry = g_speechEndCallbackHash.Search(speakerID);
   if (!pEntry) {
      pEntry = new sCallbackHashEntry(speakerID);
      g_speechEndCallbackHash.Insert(pEntry);
   }

   pEntry->AddCB(callback);
}

//////////////////////////////////////////

void SpeechUninstallEndCallback(ObjID speakerID, SpeechCallbackFn callback)
{
   sCallbackHashEntry *pEntry = g_speechEndCallbackHash.Search(speakerID);
   if (pEntry)
      if (!pEntry->RemoveCB(callback)) {
         g_speechEndCallbackHash.Remove(speakerID);
         delete pEntry;
      }
}

//////////////////////////////////////////

int SpeechVoiceIndexFromName(const Label *pVoiceName)
{
   // get our object...
   ObjID obj = pObjSys->GetObjectNamed(pVoiceName->text);
   int iIndex;

   AssertMsg1(obj != OBJ_NULL,
              "Request for nonexistent voice: %s\n", pVoiceName);

   bool bHasIndex = ObjGetSpeechVoiceIndex(obj, &iIndex);

   AssertMsg1(bHasIndex == TRUE,
              "voice %s has no VoiceIndex.\n", pVoiceName);

   return iIndex;
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   These functions handle connections to the schema system, including
   playing the actual sounds.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

// somewhere, a schema has ended
void SpeechEndCallback(int hSchema, ObjID schemaID, void *data)
{
   sSpeech *pSpeech;

   if (pSpeechProperty->Get((ObjID)data, &pSpeech))
      pSpeech->flags &= ~SPEECH_SPEAKING;

   sCallbackHashEntry *pEntry = g_speechEndCallbackHash.Search((ObjID)data);
   if (pEntry)
      for (int i = 0; i < kCallbackEntryMax; ++i)
         if (pEntry->m_aCallbackList[i])
            pEntry->m_aCallbackList[i]((ObjID)data, hSchema, schemaID);
         else
            break;
}


void SpeechHalt(ObjID AIObjID)
{
   sSpeech *pSpeech;

   if (pSpeechProperty->Get(AIObjID, &pSpeech))
   {
      if (pSpeech->flags & SPEECH_SPEAKING)
         SchemaPlayHalt(pSpeech->hSchemaPlay);
      pSpeechProperty->Delete(AIObjID);
   }
}

// return TRUE if AI is close enough to some player to be heard,
// FALSE otherwise
BOOL SpeechInRange(ObjID AIObjID)
{
#ifdef NEW_NETWORK_ENABLED
   // Check whether *any* player is in range of this AI:
   AutoAppIPtr(NetManager);
   ObjID player;
   Position *pAIPos = ObjPosGet(AIObjID);
   FOR_ALL_PLAYERS(pNetManager, &player) {
      Position *pPlayerPos = ObjPosGet(player);

      if (mx_dist2_vec(&pAIPos->loc.vec, &pPlayerPos->loc.vec)
          < kAISpeechMinDist2)
         return TRUE;
   }
   return FALSE;
#else
   // Non-networked version just worries about the single player:
   Position *pPlayerPos = ObjPosGet(PlayerObject());
   Position *pAIPos = ObjPosGet(AIObjID);

   if (mx_dist2_vec(&pAIPos->loc.vec, &pPlayerPos->loc.vec)
     < kAISpeechMinDist2)
      return TRUE;
   else
      return FALSE;
#endif
}


// find and return the minimum distance from any object linked to the
// given voice to the AI.  FLT_MAX if no object so linked
float SpeakerMinDist(ObjID voiceID, ObjID AIObjID)
{
   ILinkQuery *pQuery = pVoiceRelation->Query(LINKOBJ_WILDCARD, voiceID);
   float minDist = 999999999.0;
   float dist;
   sLink link;

   Position *pObjPos;
   Position *pAIPos = ObjPosGet(AIObjID);

   while (!pQuery->Done())
   {
      pQuery->Link(&link);
      if (!(pTraitMan->IsArchetype(link.source))) {
         pObjPos = ObjPosGet(link.source);
         dist = mx_dist2_vec(&pAIPos->loc.vec, &pObjPos->loc.vec);
         if (dist < minDist)
            minDist = dist;
      }
      pQuery->Next();
   }
   SafeRelease(pQuery);
   return minDist;
}


ObjID SpeechChooseDescendent(ObjID objID, ObjID AIObjID)
{
   ObjID voiceID;
   IObjectQuery *pQuery = pTraitMan->Query(objID, kTraitQueryAllDescendents);
   float maxDist = 0;
   float voiceMinDist;
   ObjID curID;

   if (pQuery->Done())
      // no descendents, just return the current ID
      voiceID = objID;
   else {
      // choose descentdent by finding the voice that is not in use near
      // the AI. If this is not the terminal level, choice will be random
      while (!pQuery->Done()) {
         curID = pQuery->Object();
         voiceMinDist = SpeakerMinDist(curID, AIObjID);
         if (voiceMinDist > maxDist) {
            maxDist = voiceMinDist;
            voiceID = curID;
         }
         pQuery->Next();
      }
      // recurse to find best voice from current choice
      SpeechChooseDescendent(voiceID, AIObjID);
   }
   SafeRelease(pQuery);
   return voiceID;
}


// Get an object's voice, OBJ_NULL if none, first voice if multiple
// create a link to voice if none exists
ObjID SpeechGetVoice(ObjID AIObjID)
{
   ILinkQuery *pQuery;
   ObjID voiceID = OBJ_NULL;
   sLink link;

   pQuery = pLinkMan->Query(AIObjID, LINKOBJ_WILDCARD, voiceRelationID);
   if (!pQuery->Done()) {

      // we've got a link to a voice
      pQuery->Link(&link);
      voiceID = link.dest;
#ifdef DBG_ON
      pQuery->Next();
      if (!pQuery->Done())
         ConfigSpew("SpeechSpew", ("SpeechGetVoice: object %d has more"
                                   " than one voice\n"));
#endif
   }
   SafeRelease(pQuery);

   if (voiceID == OBJ_NULL) {
      Label *pVoiceLabel;

      // check for voice name property
      if (NULL!=(pVoiceLabel = ObjGetSpeechVoice(AIObjID))) {
         voiceID = pObjSys->GetObjectNamed(pVoiceLabel->text);
         if (voiceID != OBJ_NULL) {
            voiceID = SpeechChooseDescendent(voiceID, AIObjID);

            // add a link for next time
            pVoiceRelation->Add(AIObjID, voiceID);
         } else {
            ConfigSpew("SpeechSpew", 
                       ("SpeechGetVoice: voice %s not found for obj %d\n",
                        &(pVoiceLabel->text[0]), AIObjID));
            voiceID = OBJ_NULL;
         }
      } else {
         ConfigSpew("SpeechSpew", 
                    ("SpeechGetVoice: obj %d has no voice property\n",
                     AIObjID));
         voiceID = OBJ_NULL;
      }
   }
   return voiceID;
}


int SpeechSpeak(ObjID SpeakerObjID, const Label *pConcept,
                cTagDBInput *pInput, void *pData)
{
   if (!g_bSpeechDatabaseLoaded)
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: No speech database");
      return SCH_HANDLE_NULL;
   }

   ObjID VoiceObjID = SpeechGetVoice(SpeakerObjID);
   int iConceptIndex = g_Domain.ConceptIndex(pConcept);

   if (iConceptIndex == kNameMapIndexNotFound)
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: Unknown voice");
      return SCH_HANDLE_NULL;
   }

   int iConceptPriority = g_Domain.FindConceptPriority(iConceptIndex);

   ConfigSpew("SpeechSpew", ("Object %d is saying %s\n", SpeakerObjID,
                             pConcept->text));

   int iVoiceIndex;
   if (!ObjGetSpeechVoiceIndex(VoiceObjID, &iVoiceIndex))
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: Unknown voice");
      return SCH_HANDLE_NULL;
   }

   sSpeech *pSpeech;
   sSchemaCallParams sCallParams;
   int iSchemaHandle;

   int iSpeechTime = tm_get_millisec_unrecorded();

   // This is bugger already saying something?
   BOOL bStart = !(pSpeechProperty->Get(SpeakerObjID, &pSpeech)
                && (pSpeech->flags & SPEECH_SPEAKING)
                && pSpeech->m_iPriority >= iConceptPriority);

   RecStreamAddOrExtract(pRecorder, &bStart, sizeof(BOOL), "speech start");

   if (!bStart)
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: Current sound has priority");
      return SCH_HANDLE_NULL;
   }

   cTagDBOutput Output;
   g_VoiceList[iVoiceIndex]->SelectSchemas(pInput, iConceptIndex, &Output);
   ObjID SchemaID = Output.Choose();

   if (SchemaID == OBJ_NULL) 
   {
      ConfigSpew("SpeechSpew", ("Speech: No schemas found!\n"));
      AIWatch(Sound, SpeakerObjID, "Not speaking: No schemas found");
      return SCH_HANDLE_NULL;
   }

   sAISoundType * pSoundType = AIGetSoundType(SpeakerObjID);
   
   if ((!pSoundType || (!pSoundType->type && !pSoundType->szSignal[0])) &&
       !SpeechInRange(SpeakerObjID))
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: Too far from player and sound has no meaning");
      return SCH_HANDLE_NULL;
   }

   // Kill the old one, make a new one
   SpeechHalt(SpeakerObjID);

   pSpeech = SpeechPropCreateAndGet(SpeakerObjID);
   if (!pSpeech)
   {
      AIWatch(Sound, SpeakerObjID, "Not speaking: Failed to create speech property");
      return SCH_HANDLE_NULL;
   }

#ifndef SHIP
   AutoAppIPtr_(EditTools, pTools);
   ConfigSpew("SpeechSpew", ("SpeechSpeakExecute: %s\n", 
                             pTools->ObjName(SchemaID)));
#endif // ~SHIP

   // start our schema
   sCallParams.flags = SCH_SET_SAMPLE | SCH_SET_OBJ | SCH_SET_CALLBACK;
   sCallParams.sampleNum = -1;
   sCallParams.sourceID = SpeakerObjID;
   sCallParams.callback = SpeechEndCallback;

   sCallParams.pData = (void*)SpeakerObjID;

   iSchemaHandle = SchemaIDPlay(SchemaID, &sCallParams, pData);
   pSpeech->hSchemaPlay = iSchemaHandle;

   if (iSchemaHandle != SCH_HANDLE_NULL) 
   {
      pSpeech->flags |= SPEECH_SPEAKING;
      pSpeech->time = iSpeechTime;
      pSpeech->schemaID = SchemaID;
      pSpeech->m_iConceptIndex = iConceptIndex;
      pSpeech->m_iPriority = iConceptPriority;
   }

   pSpeechProperty->Set(SpeakerObjID, pSpeech);

   sCallbackHashEntry *pEntry = g_speechStartCallbackHash.Search(SpeakerObjID);
   if (pEntry)
      for (int i = 0; i < kCallbackEntryMax; ++i)
         if (pEntry->m_aCallbackList[i])
            pEntry->m_aCallbackList[i](SpeakerObjID, iSchemaHandle, SchemaID);
         else
            break;

   return iSchemaHandle;
}


BOOL SpeechIsSpeaking(ObjID SpeakerObjID)
{
   sSpeech *pSpeech;
   return (pSpeechProperty->Get(SpeakerObjID, &pSpeech)
        && (pSpeech->flags & SPEECH_SPEAKING));
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   This section is our loading and saving.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static TagFileTag g_TagFileTag = { "Speech_DB" };
static TagVersion g_TagVersion = { 1, 3 };


// After we load each voice, we have it apply this to all of its data
// to swizzle it to the current ObjIDs.
static void SwizzleTag(sTagDBData *pData)
{
   pData->m_iData = ObjRemapOnLoad(pData->m_iData);
}


// After we've loaded in our binary data we swizzle it to cTag
// indices, generating the necessary tags as we go.
void SpeechLocalToGlobal(cTagDBKey *pKey)
{
   sTagRemap Remap(pKey->m_KeyType, 0, 0, 0);

   if (g_Domain.FindTagFlags(pKey->m_KeyType) & kTagFlagInt)
      g_Domain.TokensLocalToGlobal(&Remap, TRUE);
   else
      for (int i = 0; i < 8 && pKey->m_aEnum[i] != kTagDBKeyEnumUnused; ++i) {
         Remap.m_LocalValue = pKey->m_aEnum[i];
         g_Domain.TokensLocalToGlobal(&Remap, FALSE);
         pKey->m_aEnum[i] = Remap.m_GlobalValue;
      }

   ConfigSpew(("SpeechSpew"),
              ("Swizzled tag %s from %d to %d\n",
               g_Domain.TagName(pKey->m_KeyType)->text,
               Remap.m_LocalType, Remap.m_GlobalType));

   pKey->m_KeyType = Remap.m_GlobalType;
}



// This is the companion function to SpeechNameToTag.  Before we save
// off our database we put all its data in terms of the local mapping
// we'll be saving.
void SpeechGlobalToLocal(cTagDBKey *pKey)
{
   sTagRemap Remap(0, 0, pKey->m_KeyType, 0);
   g_Domain.TokensGlobalToLocal(&Remap, TRUE);

   if (g_Domain.FindTagFlags(Remap.m_LocalType) & kTagFlagInt)
      g_Domain.TokensGlobalToLocal(&Remap, TRUE);
   else
      for (int i = 0; i < 8 && pKey->m_aEnum[i] != kTagDBKeyEnumUnused; ++i) {
         Remap.m_GlobalValue = pKey->m_aEnum[i];
         g_Domain.TokensGlobalToLocal(&Remap, FALSE);
         pKey->m_aEnum[i] = Remap.m_LocalValue;
      }

   pKey->m_KeyType = Remap.m_LocalType;

   ConfigSpew(("SpeechSpew"),
              ("Key %s from %d to %d\n",
               g_Domain.TagName(pKey->m_KeyType)->text,
               Remap.m_GlobalType, Remap.m_LocalType));
}


static void SwizzleDatabases()
{
   int iSize = g_VoiceList.Size();

   for (int i = 0; i < iSize; ++i) {
      g_VoiceList[i]->TransformData(SwizzleTag);
      g_VoiceList[i]->TransformKeys(SpeechLocalToGlobal);
   }
}


static void UnswizzleDatabases()
{
   int iSize = g_VoiceList.Size();

   for (int i = 0; i < iSize; ++i)
      g_VoiceList[i]->TransformKeys(SpeechGlobalToLocal);
}


// We do not save the request registry.  The requests have to be
// rebuilt every time we initialize our app.
static void SpeechLoad(ITagFile *pFile)
{
   TagVersion found_version = g_TagVersion;
   HRESULT result = ITagFile_OpenBlock(pFile, &g_TagFileTag, &found_version);

   if (result == S_OK
    && found_version.major == g_TagVersion.major
    && found_version.minor == g_TagVersion.minor) {
      int i, iTemp;

      g_Domain.Load(pFile);

      ITagFile_Read(pFile, (char *) &iTemp, sizeof(iTemp));
      g_VoiceList.SetSize(iTemp);
      for (i = 0; i < iTemp; ++i) {
         g_VoiceList[i] = new cSpeechVoice();
         g_VoiceList[i]->Load(pFile);
      }
      g_bSpeechDatabaseLoaded = TRUE;
   }

   ITagFile_CloseBlock(pFile);
}


static void SpeechSave(ITagFile *pFile)
{
   if (!g_bSpeechDatabaseLoaded || g_VoiceList.Size() == 0)
      return;

   HRESULT result = ITagFile_OpenBlock(pFile, &g_TagFileTag, &g_TagVersion);

   if (result == S_OK) {
      int i, iTemp;

      g_Domain.Save(pFile);

      iTemp = g_VoiceList.Size();
      ITagFile_Write(pFile, (char *) &iTemp, sizeof(iTemp));
      for (i = 0; i < iTemp; ++i)
         g_VoiceList[i]->Save(pFile);
   }

   ITagFile_CloseBlock(pFile);
}


static void MultiplyWeight(sTagDBData *pData)
{
   pData->m_fWeight *= SchemaSamplesNum(pData->m_iData);
}


void SpeechNotifyTextParseEnd()
{
   for (int i = 0; i < g_VoiceList.Size(); ++i) {
      g_VoiceList[i]->TransformData(MultiplyWeight);
      g_VoiceList[i]->TransformKeys(SpeechLocalToGlobal);
   }

   g_bSpeechDatabaseLoaded = TRUE;
}


// Voice relation
struct sRelationDesc sVoiceDesc =
{
   VOICE_RELATION, kRelationNetworkLocalOnly,
};

struct sRelationDataDesc sVoiceDataDesc = LINK_NO_DATA;


void SpeechBuildDefault(void)
{
   ITraitManager *pTraitMan = AppGetObj(ITraitManager);
   ObjID baseVoiceID;

   // create the base voice
   pTraitMan->CreateBaseArchetype(BASE_VOICE_OBJ, &baseVoiceID);

   SafeRelease(pTraitMan);
}

extern "C" void SpeechInit(void)
{
   SpeechPropsInit();

   if (!pObjSys)
      pObjSys = AppGetObj(IObjectSystem);
   if (!pLinkMan)
      pLinkMan = AppGetObj(ILinkManager);
   if (!pPropMan)
      pPropMan = AppGetObj(IPropertyManager);
   if (!pTraitMan)
      pTraitMan = AppGetObj(ITraitManager);
   if (!pRecorder)
      pRecorder = AppGetObj(IRecorder);
   if (!pSpeechProperty)
      pSpeechProperty
         = (ISpeechProperty*)pPropMan->GetPropertyNamed(PROP_SPEECH);

   // create relations
   pVoiceRelation = CreateStandardRelation(&sVoiceDesc,
                                           &sVoiceDataDesc,
                                           kQCaseSetSourceKnown);
   voiceRelationID = pVoiceRelation->GetID();
}


extern "C" void SpeechTerm(void)
{
   SafeRelease(pObjSys);
   SafeRelease(pLinkMan);
   SafeRelease(pPropMan);
   SafeRelease(pTraitMan);
   SafeRelease(pRecorder);
   SafeRelease(pSpeechProperty);
}


/* Deal with database events--load and save here refer to tag files,
   not the text files we read in to build our databases.

*/
EXTERN void SpeechDatabaseNotify(DispatchData *msg)
{
   msgDatabaseData data;

   data.raw = msg->data;
   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         SpeechDestroy();
         break;

      case kDatabaseDefault:
         SpeechBuildDefault();
         break;

      case kDatabaseSave:
         if (msg->subtype & kObjPartAbstract) {
            UnswizzleDatabases();
            SpeechSave(data.save);
            SwizzleDatabases();
         }
         break;

      case kDatabaseLoad:
         if (msg->subtype & kObjPartAbstract) {
            SpeechLoad(data.load);
         }
         break;

      case kDatabasePostLoad:
         if (msg->subtype & kObjPartAbstract) {
            SpeechBuildDefault();
            SwizzleDatabases();
         }
         break;
   }
}


// Destroy all voice relations
void SpeechVoiceRelationsDestroy(void)
{
   ILinkQuery *pQuery;

   // destroy voice links (AI<->voice)
   pQuery
      = pLinkMan->Query(LINKOBJ_WILDCARD, LINKOBJ_WILDCARD, voiceRelationID);
   while (!pQuery->Done())
   {
      pLinkMan->Remove(pQuery->ID());
      pQuery->Next();
   }
   SafeRelease(pQuery);
}

// Destroy all expression and voice relations
void SpeechRelationsDestroy(void)
{
   SpeechVoiceRelationsDestroy();
}


// clear out all this tag and concept stuff
static void SpeechDatabasesDestroy(void)
{
   int i;

   for (i = 0; i < g_VoiceList.Size(); ++i)
      delete g_VoiceList[i];
   g_VoiceList.SetSize(0);
   g_Domain.Clear();

   g_bSpeechDatabaseLoaded = FALSE;
}


// Destroy all voice data structures and objects (except base archetypes)
void SpeechDestroy(void)
{
   ITraitManager *pTraitMan = AppGetObj(ITraitManager);
   IObjectSystem *pObjSys = AppGetObj(IObjectSystem);
   ObjID baseVoiceID;

   // clean up all relations involving voices or concepts
   SpeechRelationsDestroy();
   SpeechDatabasesDestroy();

   if ((baseVoiceID = pObjSys->GetObjectNamed(BASE_VOICE_OBJ))
    != OBJ_NULL)
   {
      IObjectQuery *pQuery;

      pQuery = pTraitMan->Query(baseVoiceID, kTraitQueryAllDescendents);
      while (!pQuery->Done())
      {
         pObjSys->Destroy(pQuery->Object());
         pQuery->Next();
      }
      SafeRelease(pQuery);
   }
   SafeRelease(pTraitMan);
   SafeRelease(pObjSys);
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   This batch of functions and data structures handles the work exposed
   in Speechglue.h: creation and cross-indexing of tags and concepts,
   and applying them to schemas.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */


extern "C" void SpeechAddConcept(const Label *pConceptName, int iPriority)
{
   ConfigSpew("SpeechSpew", ("SpeechAddConcept: %s %d\n",
                             &pConceptName->text, iPriority));
   g_Domain.AddConcept((Label *) pConceptName, iPriority);
}


extern "C" void SpeechAddTag(const Label *pTagName)
{
   ConfigSpew("SpeechSpew", ("SpeechAddTag: %s\n", &pTagName->text));
   g_Domain.AddTag((Label *) pTagName, kTagFlagEnum);
}


extern "C" void SpeechAddTagValue(const Label *pTagValueName)
{
   ConfigSpew("SpeechSpew", ("SpeechAddTagValue: %s\n", &pTagValueName->text));
   g_Domain.AddValue((Label *) pTagValueName);
}


extern "C" void SpeechAddIntTag(const Label *pTagName)
{
   ConfigSpew("SpeechSpew", ("SpeechAddIntTag: %s\n", &pTagName->text));
   g_iNewestTag = g_Domain.AddTag((Label *) pTagName, kTagFlagInt);
}


extern "C" void SpeechVoiceNew(ObjID VoiceObjID)
{
   ConfigSpew("SpeechSpew", ("SpeechVoiceNew: %d\n", VoiceObjID));

   ObjSetSpeechVoiceIndex(VoiceObjID, g_VoiceList.Size());
   cSpeechVoice *pNewVoice = new cSpeechVoice();
   g_VoiceList.Append(pNewVoice);
}


// By the time we're reading in schemas we have our tags, domains,
// and concepts laid out, and can identify them by name or ID.
extern "C" void SpeechSchemaNewStart(const Label *pSchemaName,
                                     ObjID SchemaObjID,
                                     const Label *pVoiceName,
                                     int iWeight,
                                     const Label *pConceptName)
{
   g_pCurrentVoice = g_VoiceList[SpeechVoiceIndexFromName(pVoiceName)];

   ConfigSpew("SpeechSpew", ("SpeechSchemaNewStart: %s %s %d %s, voice %d\n",
                             &pSchemaName->text, &pVoiceName->text,
                             iWeight, &pConceptName->text,
                             SpeechVoiceIndexFromName(pVoiceName)));

   sTagDBData Data(SchemaObjID, iWeight);
   g_pCurrentVoice->AddDataStart(Data, pConceptName);
}


extern "C" void SpeechSchemaNewAddIntTag(const Label *pTagName,
                                         int iMin, int iMax)
{
   ConfigSpew("SpeechSpew", ("SpeechSchemaNewAddIntTag: %s [%d %d] %d\n",
                             &pTagName->text, iMin, iMax));
   g_pCurrentVoice->AddDataAddTag(pTagName, iMin, iMax);
}


// pEnum is expected to be an array of eight const labels.
extern "C" void SpeechSchemaNewAddEnumTag(const Label *pTagName,
                                          const Label *pEnum)
{
   ConfigSpew("SpeechSpew", ("SpeechSchemaNewAddEnumTag: %s\n",
                             &pTagName->text));
   g_pCurrentVoice->AddDataAddTag(pTagName, pEnum);
}


extern "C" void SpeechSchemaNewFinish()
{
   ConfigSpew("SpeechSpew", ("SpeechSchemaNewFinish\n"));
   g_pCurrentVoice->AddDataFinish();
}
// $Header: r:/t2repos/thief2/src/sound/speech.h,v 1.12 2000/01/31 10:02:57 adurant Exp $
#pragma once

#ifndef __SPEECH_H
#define __SPEECH_H

#include <objtype.h>
#include <osystype.h>
#include <dispatch.h>
#include <tagdbt.h>


// ai-voice relation
#define VOICE_DATA "VoiceData"
#define VOICE_RELATION "VoiceLink"

// This tells the speech system that we have finished reading in a new
// database from our text files.
extern void SpeechNotifyTextParseEnd();

// We export these structures as handles because it saves us
// some swizzling.  The name used for the voice index here is the
// sym name.
extern int SpeechVoiceIndexFromName(Label *pVoiceName);

// choose and say a piece of speech corresponding to concept
// choose a voice if not already chosen

// This version is for when you have a request handy which contains
// all the tags you need.
extern int SpeechSpeak(ObjID SpeakerObjID, const Label *pConcept,
                       cTagDBInput *pInput, void *pData);

extern BOOL SpeechIsSpeaking(ObjID SpeakerObjID);

extern void SpeechHalt(ObjID SpeakerObjID);
      
// set up our initial object archetypes
EXTERN void SpeechBuildDefault(void);

// destroy all voices and concept and tag databases
EXTERN void SpeechDestroy(void);

// swizzling tokens in our databases
EXTERN void SpeechLocalToGlobal(cTagDBKey *pKey);
EXTERN void SpeechGlobalToLocal(cTagDBKey *pKey);

typedef void (*SpeechCallbackFn)(ObjID speakerID, int hSchema, ObjID schemaID);
EXTERN void SpeechInstallStartCallback(ObjID speakerID, SpeechCallbackFn callback);
EXTERN void SpeechUninstallStartCallback(ObjID speakerID, SpeechCallbackFn callback);
EXTERN void SpeechInstallEndCallback(ObjID speakerID, SpeechCallbackFn callback);
EXTERN void SpeechUninstallEndCallback(ObjID speakerID, SpeechCallbackFn callback);

EXTERN BOOL g_bSpeechDatabaseLoaded;

#endif // ~__SPEECH_H
// $Header: r:/t2repos/thief2/src/sound/vocore.cpp,v 1.3 2000/02/02 15:18:05 adurant Exp $

#include <vocore.h>
#include <appagg.h>
#include <aggmemb.h>

#include <property.h>
#include <propbase.h>
#include <propfac_.h>

#include <schprop.h>
#include <schbase.h>
#include <schema.h>

#include <questapi.h>
#include <iobjsys.h>
#include <str.h>

// Include these last
#include <dbmem.h>
#include <initguid.h>
#include <voguid.h>

////////////////////////////////////////////////////////////
// Voice over implementation classes

//------------------------------------------------------------
// cVoiceOverSys agg member implementation
//

class cVoiceOverSys: public cCTDelegating<IVoiceOverSys>,
                     public cCTAggregateMemberControl<kCTU_Default>
{
protected:
   static sRelativeConstraint gConstraints[]; 

public:
   cVoiceOverSys(IUnknown* pOuter)
      :mpInCombat(NULL),mPlaying(SCH_HANDLE_NULL)
   {
      MI_INIT_AGGREGATION_1(pOuter,IVoiceOverSys,kPriorityNormal,gConstraints); 
   }

   ~cVoiceOverSys()
   {
   }; 

protected:
   //----------------------------------------
   // Member vars
   //

   tVOTestFunc mpInCombat; 
   int mPlaying; 

   IObjectSystem* mpObjSys; 
   IQuestData* mpQuest;

   //----------------------------------------
   // Init/Term
   //

   STDMETHOD(Init)()
   {
      mpObjSys = AppGetObj(IObjectSystem); 
      mpQuest = AppGetObj(IQuestData); 
      return S_OK; 
   }

   STDMETHOD(Term)()
   {
      SafeRelease(mpObjSys); 
      SafeRelease(mpQuest); 
      return S_OK; 
   }

   //----------------------------------------
   // Schema callback 
   //
   void OnSchema(int handle, ObjID schema)
   {
      if (handle == mPlaying)
         mPlaying = SCH_HANDLE_NULL; 
   }


   static void SchemaCB(int hSchema, ObjID schemaID, void* pdata)
   {
      cVoiceOverSys* us = (cVoiceOverSys*)pdata; 
      us->OnSchema(hSchema,schemaID); 
   }

   inline cStr SchemaVarName(ObjID schemaID)
   {
      char buf[256]; 
      const char* name = mpObjSys->GetName(schemaID); 
      if (name)
         sprintf(buf,"SCHPLAY_%s",name); 
      else
         sprintf(buf,"SCHPLAYID_%d",schemaID); 

      return buf; 
   }

   //----------------------------------------
   // IVoiceOverSys Methods
   //
   
   STDMETHOD_(int,Play)(int schema)
   {
      if (mPlaying != SCH_HANDLE_NULL)
         return SCH_HANDLE_NULL; 

      sSchemaPlayParams* params = SchemaPlayParamsGet(schema); 

      //Don't crash if it doesn't exist.  
      if (!params) return SCH_HANDLE_NULL;

      if ((params->flags & SCH_PLAY_ONCE) && AlreadyPlayed(schema))
         return SCH_HANDLE_NULL; 

      if ((params->flags & SCH_NO_COMBAT) && mpInCombat && mpInCombat())
         return SCH_HANDLE_NULL; 

      sSchemaCallParams call = g_sDefaultSchemaCallParams; 
      call.flags |= SCH_SET_CALLBACK; 
      call.callback = SchemaCB; 
      call.pData = this; 

      mPlaying = SchemaIDPlay(schema,&call);  

      if (mPlaying != SCH_HANDLE_NULL)
         SetAlreadyPlayed(schema,TRUE); 

      return mPlaying; 
   }

   STDMETHOD_(BOOL,AlreadyPlayed)(int schema)
   {
      return mpQuest->Get(SchemaVarName(schema)); 
   }

   STDMETHOD(SetAlreadyPlayed)(int schema, BOOL played)
   {
      cStr var = SchemaVarName(schema); 
      if (played)
      {
         if (mpQuest->Exists(var))
            mpQuest->Set(var,TRUE); 
         else
            mpQuest->Create(var,TRUE,kQuestDataMission); 
      }
      else
         mpQuest->Delete(var);

      return S_OK; 
   }

   STDMETHOD(SetCombatTest)(tVOTestFunc func)
   {
      mpInCombat = func; 
      return S_OK; 
   }

}; 

F_DECLARE_INTERFACE(IPropertyManager); 


sRelativeConstraint cVoiceOverSys::gConstraints[] =
{
   { kConstrainAfter, &IID_IPropertyManager }, 
   { kNullConstraint },
};

void VoiceOverCreate()
{
   AutoAppIPtr(Unknown); 
   cAutoIPtr<IVoiceOverSys> sys(new cVoiceOverSys(pUnknown)); 
}



// $Header: r:/t2repos/thief2/src/sound/songmiss.h,v 1.2 2000/01/31 10:02:43 adurant Exp $
#pragma once

#ifndef SONGMISS_H
#define SONGMISS_H

////////////////////////////////////////////////////////////
// Mission Song Params
//

typedef struct sMissionSongParams
{
   char songName[32];
} sMissionSongParams;

//
// Init/Term
//
EXTERN void MissionSongInit(); 
EXTERN void MissionSongTerm(); 

//
// Get/Set
//
EXTERN const sMissionSongParams* GetMissionSongParams(void); 
EXTERN void SetMissionSongParams(const sMissionSongParams* params); 


#endif // SONGMISS_H
// $Header: r:/t2repos/thief2/src/sound/songplr.h,v 1.11 2000/02/20 15:12:40 patmac Exp $
#pragma once

#ifndef SONGPLR_H
#define SONGPLR_H

#include <comtools.h>
#include <song.h>
#include <lgsound.h>
#include <storeapi.h>

F_DECLARE_INTERFACE(ISongPlayer);

#ifdef __cplusplus
extern "C" {
#endif

BOOL CreateSongPlayer (ISongPlayer** ppPlayer, ISndMixer* pSndMixer, ISearchPath* pWavPath, IUnknown *pOuter, int songSndGroup);

// ISongPlayer
#undef INTERFACE
#define INTERFACE ISongPlayer

DECLARE_INTERFACE_(ISongPlayer, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetSong)(THIS_ ISong* pSong) PURE;
   STDMETHOD_(void, GetSong)(THIS_ ISong** ppSong) PURE;
   STDMETHOD_(void, UnloadSong)(THIS) PURE;
   STDMETHOD_(BOOL, StartPlaying)(THIS) PURE;
   STDMETHOD_(BOOL, StopPlaying)(THIS) PURE;
   STDMETHOD_(BOOL, PausePlaying)(THIS) PURE;
   STDMETHOD_(BOOL, ResumePlaying)(THIS) PURE;
   STDMETHOD_(void, SetVolume)(THIS_ int vol) PURE;
   STDMETHOD_(int, GetVolume)(THIS) PURE;
   STDMETHOD_(BOOL, SendEvent)(THIS_ const char* pEventString, int proiority) PURE;
   STDMETHOD_(void, SetThemed)(THIS_ BOOL isThemed) PURE;
   STDMETHOD_(BOOL, IsThemed)(THIS) PURE;
   STDMETHOD_(BOOL, SetTheme)(THIS_ const char* pThemeString) PURE;
   STDMETHOD_(void, GetMemento)(THIS_ void **pRetData, int *pRetSize ) PURE;
   STDMETHOD_(BOOL, RestoreMemento)(THIS_ void *pData, int size ) PURE;
};

   /*
#define ISongPlayer_StartPlaying(p, a)                COMCall1(p, StartPlaying, a)
#define ISongPlayer_SendEvent(p, a)                   COMCall1(p, SendEvent, a)
   */

#ifdef __cplusplus
}
#endif

#endif

// $Header: r:/t2repos/thief2/src/sound/songplri.cpp,v 1.17 2000/02/20 15:12:37 patmac Exp $

#include <songplr.h>
#include <songplri.h>
#include <sndsrc.h>
#include <playlist.h>
#include <appagg.h>
#include <storeapi.h>
#include <resapi.h>
#include <sndrstyp.h>
#include <auxsnd.h>
//#include <random.h> Nope... now using the random stuff in cam\src\framewrk
#include <rand.h>
#include <config.h>
#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


#ifndef SHIP
#define SONGPLR_TRACE(x) \
   if( config_is_defined( "songplr_trace" ) ) \
   { \
      mprintf( "In cSongPlayer::" ); \
      mprintf x; \
      mprintf( "\n" ); \
   }
#define SONGPLR_SPEW(x) if(config_is_defined("songplr_spew")) mprintf x
#else
#define SONGPLR_TRACE(x)
#define SONGPLR_SPEW(x)
#endif

//
// @HACK
// LAST MINUTE SHOCK UGLY HACK WARNING.
// The library sample.play() call doesn't return anything, so the usual
// way to deal is to set the sample's data to something and register a
// failure callback which sets a flag.  Unfortunately, the callback is
// per-mixer, not per-sample, so we have to use the damn appsfx-registered
// mixer callback, which expects the data field to be an sfx pointer.  So,
// we set up a structure so that it is physically aligned like an sfx so
// that it will set a field we can use.
//
struct fake_sfx_hack
{
   uint _dummy;
   uint _flags;
};
#define FAKE_SFXFLG_HAPPY       (1<<9)  // happy or not, ie. did i play
// End HACK

//
// Notes:
//
// We store m_pResArray because the playlist apparently does not know how to clean
// up after itself (not sure if this is true...).  If this is fixed, we will no
// longer have to store them here.
//

BOOL CreateSongPlayer (ISongPlayer **ppPlayer, ISndMixer* pSndMixer, ISearchPath* pWavPath, IUnknown *pOuter, int songSndGroup)
{
   *ppPlayer = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppPlayer = new cSongPlayer (pSndMixer, pWavPath, songSndGroup);
   return (*ppPlayer != NULL);
}

#define kSNGPLR_CurrSegGate     0
#define kSNGPLR_NextSegGate     1
#define kSNGPLR_LoopCountGate   2

// This is called at the beginning of each segment.
// Simply passes it on to a member function.
static void _segment_callback(ISndSource* /*pSndSource*/, uint32 *pCBD)
{
   cSongPlayer *pThis;
   long *pTmp;

   // skip first param (arg count), next param is our ptr
   pTmp = (long *) pCBD;
   pThis = (cSongPlayer*) pTmp[1];

   pThis->_DoSegmentCallback();
}

static void _song_end_callback(ISndSample* /*pSample*/, void *pCBD)
{
   cSongPlayer *pThis;

   pThis = (cSongPlayer*) pCBD;
   pThis->_DoSongEndCallback();
}

/*
// called when a sound stops
static void _sfx_end_callback(ISndSample *pSample, void *pCBD)
{
   _sfx *fx = (_sfx *) pCBD;

   if (fx)
      _sfx_cleanup_fx(fx, TRUE);

   pSample->Release();
   chanInUse--;
}
*/

IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSongPlayer, ISongPlayer);

cSongPlayer::cSongPlayer(ISndMixer* pSndMixer, ISearchPath* pWavPath, int songSndGroup)
:  m_pSong(NULL),
   m_pSndSample(NULL),
   m_pSndSrc(NULL),
   m_pResArray(NULL),
   m_pStreamBuffer(NULL),
   m_currPriority(-1),
   m_isPlaying(FALSE),
   m_isThemed(FALSE),
   m_volume(0),
   m_isPaused(FALSE),
   m_lastPriority(-1),
   m_bHaveMemento(FALSE),
   m_soundGroup(songSndGroup)
{
   SONGPLR_TRACE(( "cSongPlayer()" ));

   m_currTheme[0] = '\0';
   pWavPath->AddRef();
   m_pWavPath = pWavPath;
   pSndMixer->AddRef();
   m_pSndMixer = pSndMixer;
   m_lastEvent[0] = '\0';
}

cSongPlayer::~cSongPlayer()
{
   SONGPLR_TRACE(( "~cSongPlayer()" ));

   if (NULL != m_pSndSample)
      m_pSndSample->Stop();

   UnloadSong ();

   SafeRelease (m_pSndMixer);
   SafeRelease (m_pWavPath);
}

STDMETHODIMP_(BOOL)
cSongPlayer::SetSong (ISong* pSong)
{
   SONGPLR_TRACE(( "SetSong(SONG)" ));

   unsigned i;
   ISongSection* pSection;
   ISongSample* pSample;
   sSongSampleInfo sampleInfo;

   // Stop song.  Will automatically unload song at song end callback.
   if (NULL != m_pSndSample)
      m_pSndSample->Stop();

   // Store the song in a member.
   pSong->AddRef();
   m_pSong = pSong;

   // Create the sound playlist/sample/source.
   uint numSegments = m_pSong->CountSections();
   m_pResArray = new IRes* [numSegments];

   AutoAppIPtr(ResMan);

   for (i = 0; i < numSegments; i++)
   {
      m_pSong->GetSection(i, &pSection);
      pSection->GetSample(0, &pSample); // @TBD : Multiple samples (layers).
      pSample->GetSampleInfo (&sampleInfo);
      pSample->Release();
      pSection->Release();

      m_pResArray[i] = pResMan->Bind(sampleInfo.name, RESTYPE_SOUND, m_pWavPath);
   }

   m_pSndSample = CreateSongSoundSource ( m_pSndMixer,
                                       numSegments,
                                       m_pResArray,
                                       &m_pStreamBuffer,
                                       _song_end_callback, // SndEndCallback      endCB,
                                       this, // void                *pEndCBData,
                                       &m_pSndSrc,
                                       _segment_callback,
                                       this);//&this);
   if ( m_pSndSample ) {
      m_pSndSample->SetGroup( m_soundGroup );
   }

   // we are not paused
   m_isPaused = FALSE;

   // Add ref to sound source.  COM conventions would suggest that this should be done internally
   // by createsongsoundsource, but this is not the convention in auxsnd.cpp
   m_pSndSrc->AddRef();

   return TRUE;
}

STDMETHODIMP_(void)
cSongPlayer::GetSong (ISong** ppSong)
{
   SONGPLR_TRACE(( "GetSong()" ));

   // Make alias.
   if (NULL != m_pSong)
      m_pSong->AddRef();
   *ppSong = m_pSong;
}

STDMETHODIMP_(void)
cSongPlayer::UnloadSong()
{
   SONGPLR_TRACE(( "UnloadSong()" ));

   if (! m_pSong)
      return;

   if (NULL != m_pStreamBuffer)
   {
      delete [] m_pStreamBuffer;
      m_pStreamBuffer = NULL;
   }

   uint numSegments = m_pSong->CountSections();
   for (int i = 0; i < numSegments; i++)
   {
      SafeRelease (m_pResArray[i]);
   }
   delete [] m_pResArray;
   m_pResArray = NULL;
   // we are not paused
   m_isPaused = FALSE;

   SafeRelease (m_pSndSrc);
   SafeRelease (m_pSndSample);
   SafeRelease (m_pSong);
}

STDMETHODIMP_(BOOL)
cSongPlayer::StartPlaying()
{
   SONGPLR_TRACE(( "StartPlaying()" ));

   if (NULL == m_pSndSample)
      return FALSE;

   if (m_isPlaying)
      return FALSE;

   // Set gate values.  The CurrSegGate is set to -1 as a debugging measure,
   // as it will be set upon the first segment callback.
   if ( m_bHaveMemento ) {
      // restore song player to save-game state
      m_pSndSrc->SetGate(kSNGPLR_CurrSegGate, m_memento.currSegGate );
      m_pSndSrc->SetGate(kSNGPLR_NextSegGate, m_memento.nextSegGate );
      m_pSndSrc->SetGate(kSNGPLR_LoopCountGate, m_memento.loopCountGate );
      if ( m_memento.lastBranch != ~0 ) {
         m_pSndSrc->BranchToLabel( m_memento.lastBranch );
      }
      // doh! lastEvent & lastTheme stuff may be screwed up, since setting
      //   the theme also generates a "set theme event"
      if ( m_memento.lastTheme[0] != 0 ) {
         SetTheme( m_memento.lastTheme );
      }
      if ( m_memento.lastEvent[0] != 0 ) {
         SendEvent( m_memento.lastEvent, m_memento.lastPriority );
      }
      m_bHaveMemento = FALSE;
   } else {
      m_pSndSrc->SetGate(kSNGPLR_CurrSegGate, ~0);
      m_pSndSrc->SetGate(kSNGPLR_NextSegGate, 0);
      m_pSndSrc->SetGate(kSNGPLR_LoopCountGate, 0);
   }

   m_pSndSample->SetVolume(m_volume);

   // @HACK: SFX faker.
   fake_sfx_hack hackola;
   hackola._dummy = 0;
   hackola._flags = FAKE_SFXFLG_HAPPY;
   m_pSndSample->SetData((long)&hackola);
   m_pSndSample->Play();
   // we are not paused
   m_isPaused = FALSE;

   if( !( hackola._flags & FAKE_SFXFLG_HAPPY ) )
   {
      return FALSE;
   }
   // End HACK

   m_isPlaying = TRUE;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongPlayer::StopPlaying()
{
   SONGPLR_TRACE(( "StopPlaying()" ));

   if (NULL == m_pSndSample)
      return FALSE;

   m_pSndSample->Stop();

   // we are not paused
   m_isPaused = FALSE;

   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongPlayer::PausePlaying()
{
   SONGPLR_TRACE(( "PausePlaying()" ));

   if (NULL == m_pSndSample)
      return FALSE;

   AssertMsg( !m_isPaused, "Redundant pause of song player" );
   m_isPaused = TRUE;

   m_pSndSample->Pause();

   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongPlayer::ResumePlaying()
{
   SONGPLR_TRACE(( "ResumePlaying()" ));

   if (NULL == m_pSndSample)
      return FALSE;

   AssertMsg( m_isPaused, "Redundant resume of song player" );
   m_isPaused = FALSE;

   m_pSndSample->Resume();

   return TRUE;
}

STDMETHODIMP_(void)
cSongPlayer::SetVolume(int vol)
{
   SONGPLR_TRACE(( "SetVolume(%d)", vol ));

   m_volume = vol;

   if (NULL == m_pSndSample)
   {
      return;
   }

   m_pSndSample->SetVolume(vol);
}

STDMETHODIMP_(int)
cSongPlayer::GetVolume()
{
   SONGPLR_TRACE(( "GetVolume()" ));

   return m_volume;
   /*
   if (NULL == m_pSndSample)
   {
      return m_volume;
   }

   return (m_pSndSample->GetVolume());
   */
}

/*
cSongPlayer::SetEndCallback()
{
}
*/

STDMETHODIMP_(BOOL)
cSongPlayer::SendEvent(const char* pEventString, int priority)
{
   SONGPLR_TRACE(( "SendEvent(%s, %d)", pEventString, priority ));

   ISongSection* pSection;
   ISongEvent* pEvent;
   sSongEventInfo eventInfo;
   unsigned numEvents;
   int currSectionIndex;
   BOOL matched = FALSE;

   if (NULL == m_pSong)
   {
      Warning (("cSongPlayer::SendEvent() failed due to NULL m_pSong."));
      return FALSE;
   }

   // Do nothing if lower priority.
   if (priority < m_currPriority)
      return TRUE;

   if ( *pEventString ) {  // don't copy an empty event
      assert( strlen(pEventString) < sizeof(m_lastEvent) );
      // remember the last event recieved
      strcpy( m_lastEvent, pEventString );
      m_lastPriority = priority;
   }

   currSectionIndex = m_pSndSrc->GetGate (kSNGPLR_CurrSegGate);
   if (currSectionIndex == ~0)
   {
      Warning (("cSongPlayer::SendEvent(): Unexpected -1 value for CurrSegGate.\n"));
      return FALSE;
   }
   m_pSong->GetSection(currSectionIndex, &pSection);
   numEvents = pSection->CountEvents();

   // First, check for event in the section.
   for (unsigned i = 0 ; i < numEvents; i++)
   {
      pSection->GetEvent (i, &pEvent);
      pEvent->GetEventInfo (&eventInfo);
      if (! strcmp (eventInfo.eventString, pEventString))
      {
         _HandleEventMatch (pEvent);
         matched = TRUE;
         pEvent->Release();
         break;
      }
      pEvent->Release();
   }
   pSection->Release();

   // Check defaults (song-level events) if no match found.
   if (! matched)
   {
      numEvents = m_pSong->CountEvents();
      for (unsigned i = 0 ; i < numEvents; i++)
      {
         m_pSong->GetEvent (i, &pEvent);
         pEvent->GetEventInfo (&eventInfo);
         if (! strcmp (eventInfo.eventString, pEventString))
         {
            _HandleEventMatch (pEvent);
            pEvent->Release();
            break;
         }
         pEvent->Release();
      }
   }

   return TRUE;
}

STDMETHODIMP_(void)
cSongPlayer::SetThemed(BOOL isThemed)
{
   SONGPLR_TRACE(( "SetThemed(%d)", isThemed ));

   m_isThemed = isThemed;
}

STDMETHODIMP_(BOOL)
cSongPlayer::IsThemed()
{
   SONGPLR_TRACE(( "IsThemed()" ));

   return m_isThemed;
}

STDMETHODIMP_(BOOL)
cSongPlayer::SetTheme(const char* pThemeString)
{
   SONGPLR_TRACE(( "SetTheme(%s)", pThemeString ));
   // Set the theme string.
   strcpy (m_currTheme, pThemeString);

   // Send the event if themed.
   if (m_isThemed)
   {
      // Send the theme event.
      char themeStr[100];
      sprintf (themeStr, "theme %s", m_currTheme);
      SendEvent (themeStr, 0);
   }

   return TRUE;
}

//
// return a data chunk which is the song player state that
//   must be restored when a savegame is loaded
//
STDMETHODIMP_(void)
cSongPlayer::GetMemento( void  **pRetData,
                         int   *pRetSize )
{
   if (!m_pSndSrc)
   {
      *pRetData = 0;
      *pRetSize = 0;
      return;
   }

   m_memento.currSegGate = m_pSndSrc->GetGate( kSNGPLR_CurrSegGate );
   m_memento.nextSegGate = m_pSndSrc->GetGate( kSNGPLR_NextSegGate );
   m_memento.loopCountGate = m_pSndSrc->GetGate( kSNGPLR_LoopCountGate );
   m_memento.lastBranch = m_pSndSrc->GetMostRecentLabel();
   assert( strlen(m_lastEvent) < sizeof(m_memento.lastEvent) );
   strcpy( m_memento.lastEvent, m_lastEvent );
   m_memento.lastPriority = m_lastPriority;
   assert( strlen(m_currTheme) < sizeof(m_memento.lastTheme) );
   strcpy( m_memento.lastTheme, m_currTheme );

   *pRetData = &m_memento;
   *pRetSize = sizeof(sSongPlayerSaveState);
}


// return FALSE if data size mismatch
STDMETHODIMP_(BOOL)
cSongPlayer::RestoreMemento( void  *pData,
                             int   size )
{
   if ( sizeof(m_memento) == size ) {
      // restore the state
      memcpy( &m_memento, pData, size );
      // this flag tells StartPlaying to use the restored state
      m_bHaveMemento = TRUE;
      return TRUE;
   } else {
      return FALSE;
   }
}






void
cSongPlayer::_HandleEventMatch (ISongEvent* pEvent)
{
   SONGPLR_TRACE(( "_HandleEventMatch(EVENT)" ));

   ISongGoto* pGoto;
   sSongGotoInfo gotoInfo;

   // Generate a random number [0..99]
   //int randNum = (int) (RandFloat () * 100.0F);
   int randNum = UnrecordedRand() % 100;
   int totalProbability = 0;
   unsigned numGotos = pEvent->CountGotos();

   for (unsigned i = 0; i < numGotos; i++)
   {
      pEvent->GetGoto (i, &pGoto);
      pGoto->GetGotoInfo (&gotoInfo);
      pGoto->Release();

      totalProbability += gotoInfo.probability;

      // Choose this branch. Set the playlist gate so that it will branch appropriately.
      if (randNum < totalProbability)
      {
         m_pSndSrc->SetGate (kSNGPLR_NextSegGate, gotoInfo.sectionIndex);
         break;
      }
   }
}

void
cSongPlayer::_DoSegmentCallback()
{
   SONGPLR_TRACE(( "_DoSegmentCallback()" ));

   ISongSection* pSection;
   //ISongSample* pSample;
   //sSongSampleInfo sampleInfo;
   sSongSectionInfo sectionInfo;
   int gate;

   // If we get here and the loopcount gate is zero, then we just branched here
   // and need to set up stuff about the segment: the gates and the priority.
   if ( 0 == m_pSndSrc->GetGate(kSNGPLR_LoopCountGate) )
   {
      SONGPLR_SPEW(( "  Loopcount is zero: Resetting gates.\n" ));
      // Reset priority.
      m_currPriority = -1;

      // Update segment gates.
      gate = m_pSndSrc->GetGate(kSNGPLR_NextSegGate);
      m_pSndSrc->SetGate(kSNGPLR_CurrSegGate, gate);        // Move "next" into "current"
      m_pSndSrc->SetGate(kSNGPLR_NextSegGate, gate + 1);    // Default : "next" is next segment in sequence.

      // Reset loop count.
      m_pSong->GetSection(gate, &pSection);
      pSection->GetSectionInfo (&sectionInfo);
      /*
      pSection->GetSample(0, &pSample);
      pSample->GetSampleInfo(&sampleInfo); // @TBD : Move loopcount from sample to segment.
      pSample->Release();
      */
      pSection->Release();

      m_pSndSrc->SetGate(kSNGPLR_LoopCountGate, sectionInfo.loopCount);

      // Send null event to player.
      SendEvent ("", 0);

      // Send theme event if themed.
      if (m_isThemed)
      {
         char themeStr[100];
         sprintf (themeStr, "theme %s", m_currTheme);
         SendEvent (themeStr, 0);
      }
   }
}

void
cSongPlayer::_DoSongEndCallback()
{
   SONGPLR_TRACE(( "_DoSongEndCallback()" ));

   m_isPlaying = FALSE;

   UnloadSong();

   /*
   // Clean up.
   delete [] m_pStreamBuffer;
   m_pStreamBuffer = NULL;

   m_pSndSrc->Release();
   m_pSndSrc = NULL;

   m_pSndSample->Release();
   m_pSndSample = NULL;
   */
}

// $Header: r:/t2repos/thief2/src/sound/songplri.h,v 1.13 2000/02/20 15:12:39 patmac Exp $
#pragma once

#ifndef SONGPLRI_H
#define SONGPLRI_H

#include <comtools.h>
#include <songplr.h>
#include <song.h>
#include <lgsound.h>
#include <sndsrc.h>
#include <storeapi.h>
#include <resapi.h>

// stuff saved by GetMemento
typedef struct {
   int      currSegGate;
   int      nextSegGate;
   int      loopCountGate;
   uint32   lastBranch;
   char     lastEvent[32];
   int      lastPriority;
   char     lastTheme[32];
} sSongPlayerSaveState;

class cSongPlayer : public ISongPlayer
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNAGGREGATABLE();

public:
   cSongPlayer (ISndMixer* pSndMixer, ISearchPath* pWavPath, int soundGroup);
   virtual ~cSongPlayer();
   
   STDMETHOD_(BOOL, SetSong)(THIS_ ISong* pSong);
   STDMETHOD_(void, GetSong)(THIS_ ISong** ppSong);
   STDMETHOD_(void, UnloadSong)(THIS);
   STDMETHOD_(BOOL, StartPlaying)(THIS);
   STDMETHOD_(BOOL, StopPlaying)(THIS);
   STDMETHOD_(BOOL, PausePlaying)(THIS);
   STDMETHOD_(BOOL, ResumePlaying)(THIS);
   STDMETHOD_(void, SetVolume)(THIS_ int vol);
   STDMETHOD_(int, GetVolume)(THIS);
   STDMETHOD_(BOOL, SendEvent)(THIS_ const char* pEventString, int proiority);
   STDMETHOD_(void, SetThemed)(THIS_ BOOL isThemed);
   STDMETHOD_(BOOL, IsThemed)(THIS);
   STDMETHOD_(BOOL, SetTheme)(THIS_ const char* pThemeString);
   STDMETHOD_(void, GetMemento)(THIS_ void **pRetData, int *pRetSize );
   STDMETHOD_(BOOL, RestoreMemento)(THIS_ void *pData, int size );

   void _HandleEventMatch(ISongEvent* pEvent);
   void _DoSegmentCallback();
   void _DoSongEndCallback();

private:
   ISong*         m_pSong;
   ISearchPath*   m_pWavPath;
   ISndMixer*     m_pSndMixer;
   ISndSample*    m_pSndSample;
   ISndSource*    m_pSndSrc;
   IRes**         m_pResArray;
   char*          m_pStreamBuffer;
   int            m_currPriority;
   BOOL           m_isPlaying;
   BOOL           m_isThemed;
   int            m_volume;
   char           m_currTheme[32];
   BOOL           m_isPaused;
   char           m_lastEvent[32];
   int            m_lastPriority;
   sSongPlayerSaveState m_memento;
   BOOL           m_bHaveMemento;
   int            m_soundGroup;
};

#endif
// $Header: r:/t2repos/thief2/src/sound/songutil.cpp,v 1.13 2000/02/29 17:44:44 patmac Exp $

#include <songutil.h>
#include <song.h>
#include <songplr.h>
#include <lgsound.h>
#include <mprintf.h>
#include <appagg.h>
#include <resapi.h>
#include <songmiss.h>
#include <songfile.h>
#include <filevar.h>
#include <dbasemsg.h>

/*
#ifdef EDITOR
#include <songedtr.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 
#endif
*/

//
// Static globals.
//

//static ISong* sgpSong;
//static int sgVolume;
static BOOL sgDisabled;
static ISongPlayer* sgpSongPlayer;
static ISndMixer* sgpSndMixer;
static ISearchPath* sgpWavPath;
static int sgpSoundGroup = 0;

// Filvar stuff for save/load song theme.

// Here's the type of my global 
struct sThemeSaveLoad 
{
   char themeName[32];
};

// Here's my descriptor, which identifies my stuff to the tag file & editor
sFileVarDesc gThemeVarDesc = 
{
   kCampaignVar,        // Where do I get saved?
   "SONGTHEME",         // Tag file tag
   "Song Theme",        // friendly name
   FILEVAR_TYPE(sThemeSaveLoad),  // Type (for editing)
   { 1, 0},             // version
   { 1, 0},             // last valid version 
   //TBD: shouldn't this be NULL for all games ? - patmc
   "shock",             // optional: what game am I in NULL means all 
}; 

// The actual global variable
static cFileVar<sThemeSaveLoad,&gThemeVarDesc> sgThemeSaveLoad; 


// Here's my descriptor, which identifies my stuff to the tag file & editor
static TagVersion SongMementoVersion = {1, 0};
static TagFileTag SongMementoTag = {"SNGMEMENTO"};

//
// Exported functions.
//
void SongUtilInit (ISndMixer* pSndMixer)
{
   //sgpSong = NULL;
   sgpSongPlayer = NULL;
   sgpSndMixer = NULL;
   sgpWavPath = NULL;

   // Set up pSoundPath to point to the sound files
   AutoAppIPtr(ResMan);
   sgpWavPath = pResMan->NewSearchPath();
   if (NULL == sgpWavPath)
   {
      Warning (("SongUtil_Init() could not create a search path.\n"));
      return;
   }
   sgpWavPath->AddPathTrees("snd\\", FALSE);
   sgpWavPath->Ready();

   // Alias the mixer.
   pSndMixer->AddRef();
   sgpSndMixer = pSndMixer;

   // Create the song player.
   CreateSongPlayer (&sgpSongPlayer, sgpSndMixer, sgpWavPath, NULL, sgpSoundGroup);

   sgpSongPlayer->SetThemed (TRUE);

   MissionSongInit();

   sgDisabled = FALSE;
   /*
#ifdef EDITOR
   SongEd_Init (sgpSongPlayer);
#endif // EDITOR
   */
}

void SongUtilShutdown ()
{
   /*
#ifdef EDITOR
   SongEd_Shutdown();
#endif
   */

   MissionSongTerm();

   SafeRelease (sgpSongPlayer);
   SafeRelease (sgpSndMixer);
   SafeRelease (sgpWavPath);
}

void SongUtilDisableMusic ()
{
   if( !sgDisabled )
   {
      sgDisabled = TRUE;
   }
}

void SongUtilEnableMusic ()
{
   if( sgDisabled )
   {
      sgDisabled = FALSE;
   }
}

void SongUtilSetTheme (const char* pThemeStr)
{
   if (!sgpSongPlayer)
      return;

   strcpy( sgThemeSaveLoad.themeName, pThemeStr );

   if( !sgDisabled )
      sgpSongPlayer->SetTheme(pThemeStr);
}

void SongUtilLoad (const char* pFilename)
{
   char extendedFilename[100];
   ISong* pSong;

   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot load song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   strcpy (extendedFilename, pFilename);
   strcat (extendedFilename, ".snc");

   pSong = SongLoad (extendedFilename);
   if (NULL != pSong)
   {
      sgpSongPlayer->SetSong (pSong);
      pSong->Release();
   }
   else
   {
      Warning (("Could not load song \"%s\".\n", extendedFilename));
   }
}

void SongUtilPlay ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot play song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   if( !sgDisabled )
   {
      sgpSongPlayer->StartPlaying();
      sgpSongPlayer->SetTheme( sgThemeSaveLoad.themeName );
   }
}

void SongUtilStop ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot stop song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   if( !sgDisabled )
      sgpSongPlayer->StopPlaying();
}

void SongUtilPause ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot pause song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   if( !sgDisabled )
      sgpSongPlayer->PausePlaying();
}

void SongUtilResume ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot resume song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   if( !sgDisabled )
      sgpSongPlayer->ResumePlaying();
}

void SongUtilSetVolume (int vol)
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot set volume on song.  sgpSongPLayer is NULL.\n"));
      return;
   }

   sgpSongPlayer->SetVolume(vol);
}

int SongUtilGetVolume ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot get volume on song.  sgpSongPLayer is NULL.\n"));
      return 0;
   }

   return ( sgpSongPlayer->GetVolume() );
}

void SongUtilEvent (const char *pEventString)
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot send song event.  sgpSongPlayer is NULL.\n"));
      return;
   }

   if( !sgDisabled )
      sgpSongPlayer->SendEvent(pEventString, 1);
}


/////////////////////////////////////////////////////////////
//
//  MISSION LOAD/SAVE STUFF
//

BOOL
SongUtilLoadMission(ITagFile *file)
{
   TagVersion found_version = SongMementoVersion;
   HRESULT result = ITagFile_OpenBlock( file, &SongMementoTag, &found_version );
   BOOL rv = FALSE;
   void *pBlock;
   int blockSize;

   // Hack! ignore the minor version so both 1.1 & 1.0 will work
   //  1.0 saves are just missing the last event field
   if ( (result == S_OK)
        && (found_version.major == SongMementoVersion.major)
        && (found_version.minor == SongMementoVersion.minor) ) {

      blockSize = ITagFile_BlockSize( file, &SongMementoTag );
      pBlock = Malloc( blockSize );
      ITagFile_Read( file, (char *) pBlock, blockSize );
      ITagFile_CloseBlock(file);

      if ( sgpSongPlayer && !sgDisabled ) {
         sgpSongPlayer->RestoreMemento( pBlock, blockSize );
      }

      Free( pBlock );
   }
   return rv;
}

BOOL
SongUtilSaveMission(ITagFile *file)
{
   HRESULT result;
   BOOL rv = FALSE;
   void *pMemento;
   int  mementoSize;

   if ( sgpSongPlayer == NULL ) {
      return FALSE;
   }
   sgpSongPlayer->GetMemento( &pMemento, &mementoSize );

   if ( mementoSize ) {
      result = ITagFile_OpenBlock(file, &SongMementoTag, &SongMementoVersion);
      if (result == S_OK) {
         ITagFile_Write(file, (char *) pMemento, mementoSize );
         ITagFile_CloseBlock(file);
      }
   }
   return rv;
}


void
SongUtilResetMission()
{
   sgThemeSaveLoad.themeName[0] = 0;
}

void SongUtilSetSoundGroup( int songGroup )
{
   sgpSoundGroup = songGroup;
}

/////////////////////////////////////////////////////////////
// DEBUGGING FUNCTIONS
//

#ifndef SHIP
static void _SongDumpToMono(ISong* pSong);

void SongUtilDumpMono ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot dump song to mono.  sgpSongPlayer is NULL.\n"));
      return;
   }

   ISong* pSong;

   sgpSongPlayer->GetSong (&pSong);
   _SongDumpToMono (pSong);
   SafeRelease (pSong);
}

static void _SongDumpToMono(ISong* pSong)
{
   ISongSection* pSection;
   ISongSample* pSample;
   ISongEvent* pEvent;
   ISongGoto* pGoto;

   sSongInfo songInfo;
   sSongSectionInfo sectionInfo;
   sSongSampleInfo sampleInfo;
   sSongEventInfo eventInfo;
   sSongGotoInfo gotoInfo;

   unsigned sectionCount, sampleCount, eventCount, gotoCount;
   unsigned i, j, k;

   if (NULL == pSong)
   {
      Warning (("Song was NULL in _SongDumpToMono()\n"));
      return;
   }

   // Spew song info.
   pSong->GetSongInfo(&songInfo);
   eventCount = pSong->CountEvents();
   sectionCount = pSong->CountSections();
   mprintf ("Song %s: events = %d, sections = %d.\n", songInfo.id, eventCount, sectionCount);

   // Spew default event info.
   for (i = 0; i < eventCount; i++)
   {
      pSong->GetEvent(i, &pEvent);
      pEvent->GetEventInfo(&eventInfo);
      gotoCount = pEvent->CountGotos();
      mprintf ("  Event \"%s\": flags = %d, gotos = %d.\n",
               eventInfo.eventString, eventInfo.flags, gotoCount);

      // Spew goto info.
      for (k = 0; k < gotoCount; k++)
      {
         pEvent->GetGoto(k, &pGoto);
         pGoto->GetGotoInfo(&gotoInfo);
         pGoto->Release();
         mprintf ("    Goto : sectionIndex = %d, probability = %d.\n",
                  gotoInfo.sectionIndex, gotoInfo.probability);
      }
      pEvent->Release();
   }

   // Spew section info.
   for (i = 0; i < sectionCount; i++)
   {
      pSong->GetSection(i, &pSection);
      pSection->GetSectionInfo(&sectionInfo);
      sampleCount = pSection->CountSamples();
      eventCount = pSection->CountEvents();
      mprintf ("  Section %s: volume = %d, loopCount = %d, samples = %d, events = %d.\n",
               sectionInfo.id, sectionInfo.volume, sectionInfo.loopCount, sampleCount, eventCount);

      // Spew sample info.
      for (j = 0; j < sampleCount; j++)
      {
         pSection->GetSample(j, &pSample);
         pSample->GetSampleInfo(&sampleInfo);
         pSample->Release();
         mprintf ("    Sample \"%s\"\n",//: loopCount = %d, probability = %d.\n",
                  sampleInfo.name);//, sampleInfo.loopCount, sampleInfo.probability);
      }

      // Spew event info.
      for (j = 0; j < eventCount; j++)
      {
         pSection->GetEvent(j, &pEvent);
         pEvent->GetEventInfo(&eventInfo);
         gotoCount = pEvent->CountGotos();
         mprintf ("    Event \"%s\": flags = %d, gotos = %d.\n",
                  eventInfo.eventString, eventInfo.flags, gotoCount);

         // Spew goto info.
         for (k = 0; k < gotoCount; k++)
         {
            pEvent->GetGoto(k, &pGoto);
            pGoto->GetGotoInfo(&gotoInfo);
            pGoto->Release();
            mprintf ("      Goto : sectionIndex = %d, probability = %d.\n",
                     gotoInfo.sectionIndex, gotoInfo.probability);
         }
         pEvent->Release();
      }
      pSection->Release();
   }
}
#endif

// $Header: r:/t2repos/thief2/src/sound/songutil.h,v 1.10 2000/02/20 15:12:42 patmac Exp $
#pragma once

//
// Songutil is basically a quick and dirty top level song system
// API.  It manages the control over a single song.
//

#ifndef SONGUTIL_H
#define SONGUTIL_H

#include <lgsound.h>
#include <tagfile.h>

#ifdef __cplusplus
extern "C" {
#endif

void SongUtilInit (ISndMixer* pSndMixer);
void SongUtilShutdown ();
void SongUtilDisableMusic ();
void SongUtilEnableMusic ();
void SongUtilSetTheme (const char* pThemeStr);
void SongUtilLoad (const char *pFilename);
void SongUtilPlay ();
void SongUtilStop ();
void SongUtilPause ();
void SongUtilResume ();
void SongUtilSetVolume (int vol);
int SongUtilGetVolume ();
void SongUtilEvent (const char* pEventString);

BOOL SongUtilSaveMission(ITagFile *file);
BOOL SongUtilLoadMission(ITagFile *file);
void SongUtilResetMission();

void SongUtilDumpMono();

void SongUtilSetSoundGroup( int songGroup );

#ifdef __cplusplus
}
#endif

#endif
// $Header: r:/t2repos/thief2/src/sound/spchbase.h,v 1.3 2000/01/31 10:02:48 adurant Exp $
#pragma once

#ifndef __SPCHBASE_H
#define __SPCHBASE_H

// speech flags
#define SPEECH_SPEAKING 0x0001 // AI is currently speaking

// Attached to an AI, indicates current or last speech schema status
typedef struct sSpeech
{
   int flags;   
   long time;       // time at which schema started/stopped
   ObjID schemaID;  // schema we're speaking or last spoke
   int m_iConceptIndex; // within domain
   int m_iPriority; // of our current concept
   int hSchemaPlay; // handle to schema playing
} sSpeech;

#endif
// $Header: r:/t2repos/thief2/src/sound/spchdom.cpp,v 1.4 1998/10/05 17:28:05 mahk Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchdom.cpp

   A cSpeechDomain manages the names and values for our speech selection
   database.  It used to be a crude name space, but by this point we
   could easily replace it with a handful of global containers.

   The advantage of keeping it around is that we can provide specific
   validation and mono spew when we find inconsistencies in the scehema
   text files.  Besides which, it's easier than getting rid of it.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <spchdom.h>
#include <ctag.h>


// Must be last header 
#include <dbmem.h>


// In debug builds, cNameMap::AddName has an assertion to prevent
// duplicate entries.
int cSpeechDomain::AddConcept(Label *pName, int iPriority)
{
   int iIndex = m_Concept.AddName(pName);

   m_ConceptPriority.InsertAtIndex(iPriority, iIndex);
   return iIndex;
}


// We don't allow no duplicate tags, neither.
int cSpeechDomain::AddTag(Label *pName, int iFlags)
{
   int iIndex = m_Tag.AddName(pName);

   m_TagFlags.InsertAtIndex(iFlags, iIndex);
   return iIndex;
}


// Tag values are the one area in which we tolerate collisions.
int cSpeechDomain::AddValue(Label *pName)
{
   int iNameIndex = m_Value.IDFromName(pName);

   if (iNameIndex == kNameMapIndexNotFound)
      iNameIndex = m_Value.AddName(pName);

   return iNameIndex;
}


int cSpeechDomain::ConceptIndex(const Label *pName)
{
   int rv = m_Concept.IDFromName(pName);

#ifndef SHIP
   if (rv == kNameMapIndexNotFound)
      Warning(("cSpeechDomain::ConceptIndex: Concept not found: %s\n",
              pName->text));
#endif // ~SHIP

   return rv;
}


int cSpeechDomain::TagIndex(const Label *pName)
{
   int rv = m_Tag.IDFromName(pName);

#ifndef SHIP
   if (rv == kNameMapIndexNotFound)
      Warning(("cSpeechDomain::TagIndex: Tag not found: %s\n", pName->text));
#endif // ~SHIP

   return rv;
}


int cSpeechDomain::ValueIndex(const Label *pName)
{
   int rv = m_Value.IDFromName(pName);

#ifndef SHIP
   if (rv == kNameMapIndexNotFound)
      Warning(("cSpeechDomain::ValueIndex: Value not found: %s\n",
               pName->text));
#endif // ~SHIP

   return rv;
}


void cSpeechDomain::Load(ITagFile *pFile)
{
   int iTemp;
   int *piTemp;

   m_Concept.Load(pFile);
   m_Tag.Load(pFile);
   m_Value.Load(pFile);

   ITagFile_Read(pFile, (char *) &iTemp, sizeof(iTemp));
   m_ConceptPriority.SetSize(iTemp);
   piTemp = m_ConceptPriority.AsPointer();
   ITagFile_Read(pFile, (char *) piTemp, iTemp * sizeof(piTemp[0]));

   ITagFile_Read(pFile, (char *) &iTemp, sizeof(iTemp));
   m_TagFlags.SetSize(iTemp);
   piTemp = m_TagFlags.AsPointer();
   ITagFile_Read(pFile, (char *) piTemp, iTemp * sizeof(piTemp[0]));
}


void cSpeechDomain::Save(ITagFile *pFile)
{
   int iTemp;
   int *piTemp;

   m_Concept.Save(pFile);
   m_Tag.Save(pFile);
   m_Value.Save(pFile);

   iTemp = m_ConceptPriority.Size();
   piTemp = m_ConceptPriority.AsPointer();
   ITagFile_Write(pFile, (char *) &iTemp, sizeof(iTemp));
   ITagFile_Write(pFile, (char *) piTemp, iTemp * sizeof(piTemp[0]));

   iTemp = m_TagFlags.Size();
   piTemp = m_TagFlags.AsPointer();
   ITagFile_Write(pFile, (char *) &iTemp, sizeof(iTemp));
   ITagFile_Write(pFile, (char *) piTemp, iTemp * sizeof(piTemp[0]));
}


void cSpeechDomain::Clear()
{
   m_Concept.Clear();
   m_Tag.Clear();
   m_Value.Clear();
   m_Remap.Clear();

   m_ConceptPriority.SetSize(0);
   m_TagFlags.SetSize(0);
}

// $Header: r:/t2repos/thief2/src/sound/spchdom.h,v 1.4 2000/01/31 10:02:49 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   spchdom.h

   A domain is a collection of concepts plus a collection of tags,
   where each tag has zero or more ordered values.

   Each concept, each tag, and each tag/value pair which goes into
   a domain is assigned an integer which is unique to that domain.
   You can toss these into the domain in any order, and then query
   the domain to get the integers back.  So it's a specialized
   name database.

   For each concept, we also keep track of an integer priority.
   A higher-priority concept may interrupt a lower one.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _SPCHDOM_H_
#define _SPCHDOM_H_


#include <lgassert.h>
#include <dynarray.h>

#include <tagfile.h>
#include <spcht.h>
#include <tagremap.h>
#include <namemap.h>


class cSpeechDomain
{
public:
   cSpeechDomain()
      : m_Remap(&m_Tag, &m_Value)
   {
   }

   ~cSpeechDomain()
   {
      Clear();
   }

   // Each of these returns a handle for the thing being added.
   int AddConcept(Label *pName, int iPriority);
   int AddTag(Label *pName, int iFlags);
   int AddValue(Label *pName);

   // Each of these looks up data entered above.
   int ConceptIndex(const Label *pName);
   int TagIndex(const Label *pName);
   int ValueIndex(const Label *pName);

   // swizzling between our local tokenization and cTags
   void TokensLocalToGlobal(sTagRemap *pRemap, BOOL bTypeOnly)
   {
      if (pRemap->m_LocalType == kNameMapIndexNotFound) {
         mprintf("Speech token not found.\n");
         return;
      }

      if (!m_Remap.LocalToGlobal(pRemap, bTypeOnly))
         if (bTypeOnly)
            mprintf("Unable to remap integer tag \n",
                    TagName(pRemap->m_LocalType)->text);
         else
            mprintf("Unable to remap tag  \n",
                    TagName(pRemap->m_LocalType)->text,
                    ValueName(pRemap->m_LocalValue)->text);
   }

   void TokensGlobalToLocal(sTagRemap *pRemap, BOOL bTypeOnly)
   {
      m_Remap.GlobalToLocal(pRemap, bTypeOnly);
   }

   Label *TagName(int iIndex)
   {
      return m_Tag.NameFromID(iIndex);
   }

   Label *ValueName(int iIndex)
   {
      return m_Value.NameFromID(iIndex);
   }

   Label *ConceptName(int iIndex)
   {
      return m_Concept.NameFromID(iIndex);
   }

   int NumConcepts()
   {
      return m_Concept.Size();
   }

   int NumTags()
   {
      return m_Tag.Size();
   }

   int FindConceptPriority(int iConceptIndex)
   {
      return m_ConceptPriority[iConceptIndex];
   }

   int FindTagFlags(int iTagIndex)
   {
      if (iTagIndex == kNameMapIndexNotFound) {
         mprintf("Speech token not found for finding flags.\n");
         return 0;
      }

      return m_TagFlags[iTagIndex];
   }

   void Load(ITagFile *pFile);
   void Save(ITagFile *pFile);
   void Clear();

protected:
   cNameMap m_Concept;
   cNameMap m_Tag;
   cNameMap m_Value;
   cTagRemapper m_Remap;

   cDynArray<int> m_ConceptPriority;
   cDynArray<int> m_TagFlags;
};

#endif // ~_SPCHDOM_H_

// $Header: r:/t2repos/thief2/src/sound/spchglue.h,v 1.3 2000/01/31 10:02:50 adurant Exp $
#pragma once

/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\
   spchglue.h

   The schema file parsing is in C, and the tag database system is in
   C++.  So here's where we reconcile them, by exposing parts of
   speech.cpp which we otherwise would not see.

   SpeechDatabaseNotify, SpeechInit and SpeechTerm also appear here
   since they're called from schloop.c.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */


#ifndef _SPCHGLUE_H_
#define _SPCHGLUE_H_


#include <objtype.h>
#include <dispatch.h>


// base objects for hierarchy
#define BASE_VOICE_OBJ "Voice"

// app-level flow control
EXTERN void SpeechDatabaseNotify(DispatchData *msg);
EXTERN void SpeechInit(void);
EXTERN void SpeechTerm(void);

EXTERN void SpeechAddConcept(const Label *pConceptName, int iPriority);

EXTERN void SpeechAddTag(const Label *pTagName);
EXTERN void SpeechAddTagValue(const Label *pValueName);

EXTERN void SpeechAddIntTag(const Label *pTagName);

// This should be called after the appropriate archetype has been
// created.  It adds the VoiceIndex property to the object.
EXTERN void SpeechVoiceNew(ObjID VoiceObject);

// These three functions amount to an iterator.
EXTERN void SpeechSchemaNewStart(const Label *pSchemaName,
                                 ObjID SchemaObjID,
                                 const Label *pVoiceName,
                                 int iWeight, const Label *pConceptName);
EXTERN void SpeechSchemaNewAddEnumTag(const Label *pTagName,
                                      const Label *pEnum);
EXTERN void SpeechSchemaNewAddIntTag(const Label *pTagName,
                                     int iMin, int iMax);
EXTERN void SpeechSchemaNewFinish(void);

#endif // ~_SPCHGLUE_H_
// $Header: r:/t2repos/thief2/src/sound/spchprop.cpp,v 1.10 1998/11/21 14:21:40 MROWLEY Exp $

#include <timer.h>

#include <propbase.h>
#include <propface.h>
#include <propert_.h>
#include <dataops_.h>
#include <prophash.h>

#include <sdesbase.h>
#include <sdesc.h>

#include <spchprop.h>
#include <spchbase.h>

// Must be last header
#include <dbmem.h>

// Speech property

// structure descriptors
static sFieldDesc SpeechFields[] = 
{
   {"flags", kFieldTypeInt, FieldLocation(sSpeech, flags),
    kFieldFlagNotEdit}, 
   {"time", kFieldTypeInt, FieldLocation(sSpeech, time),
    kFieldFlagNotEdit}, 
   {"schemaID", kFieldTypeInt, FieldLocation(sSpeech, schemaID),
    kFieldFlagNotEdit}, 
   {"concept", kFieldTypeInt, FieldLocation(sSpeech, m_iConceptIndex),
    kFieldFlagNotEdit}, 
   {"schema handle", kFieldTypeInt, FieldLocation(sSpeech, hSchemaPlay),
    kFieldFlagNotEdit}, 
};

static sStructDesc SpeechStructDesc = StructDescBuild(sSpeech, kStructFlagNone, SpeechFields);

static ISpeechProperty *pSpeechProperty;

struct sSpeechProp : public sSpeech
{
   sSpeechProp()
   {
      memset(this,0,sizeof(*this));
      time = tm_get_millisec_unrecorded(); 
      m_iConceptIndex = -1;
      hSchemaPlay = -1;
   }

   sSpeechProp(const sSpeechProp& other)
   {
      *this = other; 
   }
};


class cSpeechOps : public cClassDataOps<sSpeechProp>
{
   
}; 

class cSpeechStore : public cHashPropertyStore<cSpeechOps>
{
   
}; 

class cSpeechProperty: public cSpecificProperty<ISpeechProperty, &IID_ISpeechProperty, sSpeech*, cSpeechStore>
{
   typedef cSpecificProperty<ISpeechProperty, &IID_ISpeechProperty, sSpeech*, cSpeechStore> cParent; 

public:

   cSpeechProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      
   }

   STANDARD_DESCRIBE_TYPE(sSpeech); 

   
   

};

static sPropertyDesc sSpeechDesc = 
{
   PROP_SPEECH, kPropertyTransient, NULL,
   0, 0, { "Speech", "Current Speech" },
   kPropertyChangeLocally, // net_flags
};


sSpeech *SpeechPropCreateAndGet(ObjID objID)
{
   sSpeech *pSpeech; 

   pSpeechProperty->Create(objID);
   if (!pSpeechProperty->Get(objID, &pSpeech))
   {
      Warning(("SpeechPropCreateAndGet: can't create speech property\n"));
      return NULL;
   }
   return pSpeech;
}

void SpeechPropInit()
{
   StructDescRegister(&SpeechStructDesc);

   pSpeechProperty = new cSpeechProperty(&sSpeechDesc); 
}

// Speech last played property
IIntProperty *g_pPropSpeechNextPlay;

static sPropertyDesc SpeechNextPlayDesc = 
{
   PROP_SPEECH_NEXT_PLAY, kPropertyTransient, NULL,
   0, 0, { "Speech", "Last Played" },
   kPropertyChangeLocally, // net_flags
};

void SpeechNextPlayPropInit(void)
{
   g_pPropSpeechNextPlay = CreateIntProperty(&SpeechNextPlayDesc, kPropertyImplDense);
}

// get last time speech played, -1 if never played
int SpeechNextPlayGet(ObjID objID)
{
   int NextPlay = -1;

   g_pPropSpeechNextPlay->Get(objID, &NextPlay);
   return NextPlay;
}

// Voice property
ILabelProperty *g_pPropSpeechVoice;

static sPropertyDesc SpeechVoiceDesc = 
{
   PROP_SPEECH_VOICE, 0, NULL,
   0, 0, { "Speech", "Voice" },
};

void SpeechVoicePropInit(void)
{
   g_pPropSpeechVoice = CreateLabelProperty(&SpeechVoiceDesc, kPropertyImplDense);
}

// get voice
Label *ObjGetSpeechVoice(ObjID objID)
{
   Label *voiceLabel = NULL;

   g_pPropSpeechVoice->Get(objID, &voiceLabel);
   return voiceLabel;
}

// Speech pause properties
IIntProperty *g_pPropSpeechPauseMin;

static sPropertyDesc speechPauseMinDesc = 
{
   PROP_SPEECH_PAUSE_MIN, 0, NULL,
   0, 0, { "Speech", "Pause Min" },
};

void SpeechPauseMinPropInit(void)
{
   g_pPropSpeechPauseMin = CreateIntProperty(&speechPauseMinDesc, kPropertyImplDense);
}

// get last time speech played, -1 if never played
int SpeechPauseMinGet(ObjID objID)
{
   int PauseMin = -1;

   g_pPropSpeechPauseMin->Get(objID, &PauseMin);
   return PauseMin;
}

IIntProperty *g_pPropSpeechPauseMax;

static sPropertyDesc speechPauseMaxDesc = 
{
   PROP_SPEECH_PAUSE_MAX, 0, NULL,
   0, 0, { "Speech", "Pause Max" },
};

void SpeechPauseMaxPropInit(void)
{
   g_pPropSpeechPauseMax = CreateIntProperty(&speechPauseMaxDesc, kPropertyImplDense);
}

// get last time speech played, -1 if never played
int SpeechPauseMaxGet(ObjID objID)
{
   int PauseMax = -1;

   g_pPropSpeechPauseMax->Get(objID, &PauseMax);
   return PauseMax;
}


static sPropertyDesc VoiceIndexDesc = 
{
   PROP_VOICE_INDEX_NAME, 0, NULL,
   0, 0, { "Speech", "Voice Index" },
};

IIntProperty* g_pPropSpeechVoiceIndex = NULL;
#define VOICE_INDEX_PROP_IMPL kPropertyImplSparseHash

static void VoiceIndexPropInit(void)
{
   g_pPropSpeechVoiceIndex = CreateIntProperty(&VoiceIndexDesc,
                                               VOICE_INDEX_PROP_IMPL);
}

extern "C" void ObjSetSpeechVoiceIndex(ObjID obj, int iIndex)
{
   g_pPropSpeechVoiceIndex->Set(obj, iIndex);
}

extern "C" BOOL ObjGetSpeechVoiceIndex(ObjID obj, int *iIndex)
{
   if (g_pPropSpeechVoiceIndex->Get(obj, iIndex))
      return TRUE;
   return FALSE;
}


void SpeechPropsInit(void)
{
   SpeechPropInit();
   SpeechNextPlayPropInit();
   SpeechVoicePropInit();
   SpeechPauseMinPropInit();
   SpeechPauseMaxPropInit();
   VoiceIndexPropInit();
}

// $Header: r:/t2repos/thief2/src/sound/sndprop.h,v 1.4 2000/01/31 10:02:37 adurant Exp $
// Properties that go on objects to trigger sounds (schemas)
#pragma once

#ifndef __SNDPROP_H
#define __SNDPROP_H

#include <propface.h>

// Collision with arrow schema property
#define PROP_COLLIDE_WITH_ARROW_SND "CSArrow"
EXTERN ILabelProperty *gPropCollideWithArrowSnd;
EXTERN void CollideWithArrowSndPropInit(void);
EXTERN Label *CollideWithArrowSndGet(ObjID objID);
#define COLLISION_SCHEMA_SET(objID, schemaID) PROPERTY_SET(gPropCollideWithArrowSnd, (objID), (schemaID))

// What collide property do I look for property?
#define PROP_COLLIDE_SND_PROPERTY "CSProperty"
EXTERN ILabelProperty *gPropCollideSndProperty;
EXTERN void CollideSndPropertyPropInit(void);
EXTERN Label *CollideSndPropertyGet(ObjID objID);
#define COLLISION_SND_PROPERTY_SET(objID, schemaID) PROPERTY_SET(gPropCollideSndProperty, (objID), (schemaID))

// Collision with projectile schema property
#define PROP_COLLIDE_WITH_PROJECTILE_SND "CSProjectile"
EXTERN ILabelProperty *gPropCollideWithProjectileSnd;
EXTERN void CollideWithProjectileSndPropInit(void);
EXTERN Label *CollideWithProjectileSndGet(ObjID objID);
#define COLLISION_PROJECTILE_SET(objID, schemaID) PROPERTY_SET(gPropCollideWithProjectileSnd, (objID), (schemaID))

EXTERN void SoundPropsInit(void);
EXTERN void SoundPropsClose(void);

#endif
// $Header: r:/t2repos/thief2/src/sound/song.h,v 1.5 2000/01/31 10:02:38 adurant Exp $
#pragma once

//
// Song interface
//
// A Song is a fairly simple hierarchical collection of sections, samples, events,
// and gotos. These objects are basically holders for data and, in the case of songs,
// sections, and events, nodes within the hierarchy of data.  In fact, each COM
// interface has one get and one set method for storing and retrieving a structure
// which contains the interesting data for that node.  This was a design decision
// intended to avoid cluttering the interface with many get and set methods.
//
// Basically, a song serves as a binary representation of a parsed song
// file.  However, the interface presented here knows nothing about files or
// file formats: the lex/yacc parser uses this interface to build the song
// from a file.  Once parsed, a song can be queried for information by,
// for instance, a song player.
//
// ----------------------
//
// DEFINITIONS:
//
// Song: Root of the hierarchy.
// Section: A period of time when one or more samples is playing.
// Sample: .Wav data.
// Event: Currently a text string, these are the events being listened for during
//        playback of a section.
// Goto: A branch which deviates from the regular path of samples playing.  By
//       default
//
// ----------------------
//
// CONVENTIONS:
//
// Reference counting: Any time an object is added or retrieved to/from the hierarchy,
// the reference count of the added object is increased.  For instance,
// pSong->AddSection(pSection) or pSong->GetSection(n, &pSection) will increase the
// reference count of pSection.  Note: this implies that a copy of the section is not
// made in either case and the caller must be aware that it is a shared object.
//
// The info structures stored within the objects ARE copied in their get/set methods,
// as the structures are considered "primitives" and are small.
//

#ifndef SONG_H
#define SONG_H

#include <comtools.h>

F_DECLARE_INTERFACE(ISong);
F_DECLARE_INTERFACE(ISongSection);
F_DECLARE_INTERFACE(ISongSample);
F_DECLARE_INTERFACE(ISongEvent);
F_DECLARE_INTERFACE(ISongGoto);

#ifdef __cplusplus
extern "C" {
#endif

BOOL CreateSong (ISong **ppSong, IUnknown *pOuter);
BOOL CreateSongSection (ISongSection **ppSection, IUnknown *pOuter);
BOOL CreateSongSample (ISongSample **ppSample, IUnknown *pOuter);
BOOL CreateSongEvent (ISongEvent **ppEvent, IUnknown *pOuter);
BOOL CreateSongGoto (ISongGoto **ppGoto, IUnknown *pOuter);


#define kSONG_MaxStringLen 32

// Flags
#define kSONG_EventFlagImmediate  0x00000001

// Song interface data structures.
typedef struct sSongInfo
{
   char id [kSONG_MaxStringLen];
} sSongInfo;

typedef struct sSongSectionInfo
{
   char id [kSONG_MaxStringLen];
   int volume;
   int loopCount;
} sSongSectionInfo;

typedef struct sSongSampleInfo
{
   char name [kSONG_MaxStringLen];
   //int loopCount;
   //int probability;
} sSongSampleInfo;

typedef struct sSongEventInfo
{
   char eventString [kSONG_MaxStringLen];
   unsigned flags;
} sSongEventInfo;

typedef struct sSongGotoInfo
{
   int sectionIndex;
   int probability;
} sSongGotoInfo;


// ISong
#undef INTERFACE
#define INTERFACE ISong

DECLARE_INTERFACE_(ISong, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetSongInfo)(THIS_ sSongInfo* pSongInfo) PURE;
   STDMETHOD_(BOOL, GetSongInfo)(THIS_ sSongInfo* ppSongInfo) PURE;

   STDMETHOD_(BOOL, AddSection)(THIS_ ISongSection* pSection) PURE;
   STDMETHOD_(unsigned, CountSections) (THIS) PURE;
   STDMETHOD_(BOOL, SetSection)(THIS_ unsigned index, ISongSection* pSection) PURE;
   STDMETHOD_(BOOL, GetSection)(THIS_ unsigned index, ISongSection** ppSection) PURE;

   STDMETHOD_(BOOL, AddEvent)(THIS_ ISongEvent* pEvent) PURE;
   STDMETHOD_(unsigned, CountEvents)(THIS) PURE;
   STDMETHOD_(BOOL, GetEvent)(THIS_ unsigned index, ISongEvent** ppEvent) PURE;
};

#define ISong_SetSongInfo(p, a)                       COMCall1(p, SetSongInfo, a)
#define ISong_GetSongInfo(p, a)                       COMCall1(p, GetSongInfo, a)
#define ISong_AddSection(p, a)                        COMCall1(p, AddSection, a)
#define ISong_CountSections(p)                        COMCall0(p, CountSections)
#define ISong_SetSection(p, a, b)                     COMCall2(p, SetSection, a, b)
#define ISong_GetSection(p, a, b)                     COMCall2(p, GetSection, a, b)
#define ISong_AddEvent(p, a)                          COMCall1(p, AddEvent, a)
#define ISong_CountEvents(p)                          COMCall0(p, CountEvents)
#define ISong_GetEvent(p, a, b)                       COMCall2(p, GetEvent, a, b)
#define ISong_Release(p)                              COMCall0(p, Release)

// ISongSection
#undef INTERFACE
#define INTERFACE ISongSection

DECLARE_INTERFACE_(ISongSection, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetSectionInfo)(THIS_ sSongSectionInfo* pSectionInfo) PURE;
   STDMETHOD_(BOOL, GetSectionInfo)(THIS_ sSongSectionInfo* pSectionInfo) PURE;
   
   STDMETHOD_(BOOL, AddSample)(THIS_ ISongSample* pSample) PURE;
   STDMETHOD_(unsigned, CountSamples)(THIS) PURE;
   STDMETHOD_(BOOL, GetSample)(THIS_ unsigned index, ISongSample** ppSample) PURE;

   STDMETHOD_(BOOL, AddEvent)(THIS_ ISongEvent* pEvent) PURE;
   STDMETHOD_(unsigned, CountEvents)(THIS) PURE;
   STDMETHOD_(BOOL, GetEvent)(THIS_ unsigned index, ISongEvent** ppEvent) PURE;
};

#define ISongSection_SetSectionInfo(p, a)             COMCall1(p, SetSectionInfo, a)
#define ISongSection_GetSectionInfo(p, a)             COMCall1(p, GetSectionInfo, a)
#define ISongSection_AddSample(p, a)                  COMCall1(p, AddSample, a)
#define ISongSection_CountSamples(p)                  COMCall0(p, CountSamples)
#define ISongSection_GetSample(p, a, b)               COMCall2(p, GetSample, a)
#define ISongSection_AddEvent(p, a)                   COMCall1(p, AddEvent, a)
#define ISongSection_CountEvents(p)                   COMCall0(p, CountEvents)
#define ISongSection_GetEvent(p, a, b)                COMCall2(p, GetEvent, a)
#define ISongSection_Release(p)                       COMCall0(p, Release)


// ISongSample
#undef INTERFACE
#define INTERFACE ISongSample

DECLARE_INTERFACE_(ISongSample, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetSampleInfo)(THIS_ sSongSampleInfo* pSampleInfo) PURE;
   STDMETHOD_(BOOL, GetSampleInfo)(THIS_ sSongSampleInfo* pSampleInfo) PURE;
};

#define ISongSample_SetSampleInfo(p, a)               COMCall1(p, SetSampleInfo, a)
#define ISongSample_GetSampleInfo(p, a)               COMCall1(p, GetSampleInfo, a)
#define ISongSample_Release(p)                        COMCall0(p, Release)


// ISongEvent
#undef INTERFACE
#define INTERFACE ISongEvent

DECLARE_INTERFACE_(ISongEvent, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetEventInfo)(THIS_ sSongEventInfo* pEventInfo) PURE;
   STDMETHOD_(BOOL, GetEventInfo)(THIS_ sSongEventInfo* pEventInfo) PURE;

   STDMETHOD_(BOOL, AddGoto)(THIS_ ISongGoto* pGoto) PURE;
   STDMETHOD_(unsigned, CountGotos)(THIS) PURE;
   STDMETHOD_(BOOL, GetGoto)(THIS_ unsigned index, ISongGoto** ppGoto) PURE;
};

#define ISongEvent_SetEventInfo(p, a)                 COMCall1(p, SetEventInfo, a)
#define ISongEvent_GetEventInfo(p, a)                 COMCall1(p, GetEventInfo, a)
#define ISongEvent_AddGoto(p, a)                      COMCall1(p, AddGoto, a)
#define ISongEvent_CountGotos(p)                      COMCall0(p, CountGotos)
#define ISongEvent_GetGoto(p, a, b)                   COMCall2(p, GetGoto, a, b)
#define ISongEvent_Release(p)                         COMCall0(p, Release)


// ISongGoto
#undef INTERFACE
#define INTERFACE ISongGoto

DECLARE_INTERFACE_(ISongGoto, IUnknown)
{
   // Comtools macro to declare IUnknown methods
   DECLARE_UNKNOWN_PURE();

   STDMETHOD_(BOOL, SetGotoInfo)(THIS_ sSongGotoInfo* pGotoInfo) PURE;
   STDMETHOD_(BOOL, GetGotoInfo)(THIS_ sSongGotoInfo* pGotoInfo) PURE;
};

#define ISongGoto_SetGotoInfo(p, a)                   COMCall1(p, SetGotoInfo, a)
#define ISongGoto_GetGotoInfo(p, a)                   COMCall1(p, GetGotoInfo, a)
#define ISongGoto_Release(p)                          COMCall0(p, Release)


#ifdef __cplusplus
}
#endif

#endif
// $Header: r:/t2repos/thief2/src/sound/songedtr.cpp,v 1.4 2000/02/19 12:37:15 toml Exp $

#include <songedtr.h>
#include <song.h>
#include <songplr.h>
#include <songutil.h>

#include <command.h>
#include <songfile.h>
#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//
// Compiled into editor builds only: no need for #ifdef EDITOR.
//

extern "C" {
BOOL SongYaccParse (char* songFile, ISong **ppSong);
}

static void _CmdRebuildSongs ();
//static void _CmdParseLoadSong (char* pFilename);
static void _CmdLoadSong (char* pFilename);
static void _CmdPlaySong ();
static void _CmdStopSong ();
//static void _CmdUnloadSong ();
static void _CmdSongEvent (char* pEventString);
#ifndef SHIP
static void _CmdSongDumpMono ();
#endif

//static void _SongDumpToMono(ISong* pSong);
static void _SongParseAndSave (char* filename);
static void _SongSetupCommands();

//
// Static globals.
//
static Command sgCommands[] =
{
   { "rebuild_songs", FUNC_VOID, _CmdRebuildSongs, "Reparse all songs into compiled format", HK_ALL },
   //{ "parseload_song", FUNC_STRING, _CmdParseLoadSong, "Load a song song by parsing it.", HK_ALL },
   { "load_song", FUNC_STRING, _CmdLoadSong, "Load a song", HK_ALL },
   { "play_song", FUNC_VOID, _CmdPlaySong, "Play the loaded song", HK_ALL},
   { "stop_song", FUNC_VOID, _CmdStopSong, "Stop the currently playing song", HK_ALL},
   //{ "unload_song", FUNC_VOID, _CmdUnloadSong, "Unload song.", HK_ALL},
   { "song_event", FUNC_STRING, _CmdSongEvent, "Send an event to the currently playing song", HK_ALL},
#ifndef SHIP
   { "song_dumpmono", FUNC_VOID, _CmdSongDumpMono, "Dump info about current song to mono", HK_ALL}
#endif
};

//ISong* sgpSong;
//static ISongPlayer* sgpSongPlayer;

//ISndMixer* sgpSndMixer;
//ISearchPath* sgpWavPath;

// Init/Shutdown
BOOL SongEd_Init ()//ISongPlayer* pSongPlayer)
{
   _SongSetupCommands();

   /*
   if (NULL == pSongPlayer)
   {
      Warning (("pSongPlayer was NULL in SongEd_Init.\n"));
      return FALSE;
   }

   // Make an alias of the player.
   pSongPlayer->AddRef();
   sgpSongPlayer = pSongPlayer;
   */

   return TRUE;
}

void SongEd_Shutdown ()
{
   //SafeRelease(sgpSongPlayer);
}

//
// Command callbacks.
//

static void _CmdRebuildSongs ()
{
   SongFilesLoadFromDir("songsrc", "*.sns", _SongParseAndSave);
}

/*
static void _CmdParseLoadSong (char* pFilename)
{
  
   SafeRelease(sgpSong);

   SongYaccParse (pFilename, &sgpSong);
   _SongDumpToMono (sgpSong);
  
}
*/

static void _CmdLoadSong (char* pFilename)
{
   SongUtilLoad (pFilename);
   /*
   char extendedFilename[100];
   ISong* pSong;

   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot load song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   strcpy (extendedFilename, pFilename);
   strcat (extendedFilename, ".snc");

   pSong = SongLoad (extendedFilename);
   if (NULL != pSong)
   {
      sgpSongPlayer->SetSong (pSong);
      pSong->Release();
   }
   else
   {
      Warning (("Could not load song \"%s\".\n", extendedFilename));
   }
   */
}

static void _CmdPlaySong ()
{
   SongUtilPlay();
   /*
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot play song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   sgpSongPlayer->StartPlaying();
   */
}

static void _CmdStopSong ()
{
   SongUtilStop();
   /*
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot stop song.  sgpSongPlayer is NULL.\n"));
      return;
   }

   // @TBD : Implement.
   //   Warning (("_CmdStopSong() not implemented."));
   sgpSongPlayer->StopPlaying();
   */
}

/*
static void _CmdUnloadSong ()
{
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot unload song.  sgpSongPlayer is NULL.\n"));
      return;
   }
   // @TBD : Either implement or get rid of this.
   Warning (("_CmdUnloadSong() not implemented."));
}
*/

static void _CmdSongEvent (char* pEventString)
{
   SongUtilEvent (pEventString);
   /*
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot send song event.  sgpSongPlayer is NULL.\n"));
      return;
   }

   sgpSongPlayer->SendEvent(pEventString, 1);
   */
}

#ifndef SHIP
static void _CmdSongDumpMono ()
{
   SongUtilDumpMono ();
   /*
   if (NULL == sgpSongPlayer)
   {
      Warning (("Cannot dump song to mono.  sgpSongPlayer is NULL.\n"));
      return;
   }

   ISong* pSong;

   sgpSongPlayer->GetSong (&pSong);
   _SongDumpToMono (pSong);
   SafeRelease (pSong);
   */
}
#endif

//
//
//

static void _SongSetupCommands()
{
   static sbCommandsSetup;

   if (! sbCommandsSetup)
   {
      COMMANDS(sgCommands, HK_ALL);
      sbCommandsSetup = TRUE;
   }
}

static void _SongParseAndSave (char* filename)
{
   ISong* pSong;
   BOOL isOK;
   char outFilename[100];
   int nopathIndex, len, dotIndex, i;

   isOK = SongYaccParse (filename, &pSong);
   
   if (isOK)
   {
      // String hacking in progress...
      // Pull out path of filename.
      // Find last backslash.
      nopathIndex = 0;
      len = strlen (filename);   
      for (i = 0; i < len; i++)
         if (filename[i] == '\\')
            nopathIndex = i + 1;
      sprintf(outFilename, "song\\%s", &(filename[nopathIndex]));
      // Change extension...
      len = strlen (outFilename);
      // Note: Default to appending extension if no dot found.
      dotIndex = len;
      // Find last dot in filename.
      for (i = 0; i < len; i++)
         if (outFilename[i] == '.')
            dotIndex = i;
      // Append new extension where old one was.
      outFilename[dotIndex] = '\0';
      strcat (outFilename, ".snc"); // snc = "SoNg, Compiled"

      // Save and release the song.
      SongSave (pSong, outFilename);
      pSong->Release();
   }
   else
   {
      Warning (("Failed to parse %s.\n", filename));
   }
}
// $Header: r:/t2repos/thief2/src/sound/songedtr.h,v 1.3 2000/01/31 10:02:39 adurant Exp $
#pragma once

#ifndef SONGEDTR_H
#define SONGEDTR_H

#include <songplr.h>

BOOL SongEd_Init ();//ISongPlayer* pSongPlayer);
void SongEd_Shutdown ();

#endif
// $Header: r:/t2repos/thief2/src/sound/songfile.cpp,v 1.2 1999/05/12 18:16:31 mwhite Exp $

// (MRW : Stolen from schfile.cpp)

#include <song.h>
#include <songfile.h>
#include <findhack.h>  // all the abstracted lg_find stuff
#include <hashset.h>
#include <hshsttem.h>
#include <str.h>
#include <datapath.h>
#include <config.h>
#include <cfgdbg.h>
#include <appagg.h>
#include <resapi.h>
#include <storeapi.h>
#include <binrstyp.h>

// Must be last header 
#include <dbmem.h>

#define SONG_FILEVERSION 1

#ifdef EDITOR
#define SONGFWRITE(f, x) fwrite (&(x), sizeof(x), 1, (f))
#endif // EDITOR

//#define SONGFREAD(f, x) fread (&(x), sizeof(x), 1, (f))
#define SONGREAD(p, x) { memcpy (&x, p, sizeof(x)); p += sizeof(x); }

//
// Everything but load (binary) is editor-only
//
#ifdef EDITOR

typedef struct sSongFile
{
   cStr fileName;
   cStr pathName;
} sSongFile;

class cSongFileNameHash: public cStrHashSet<sSongFile *>
{
private:
   tHashSetKey GetKey(tHashSetNode node) const;
};

tHashSetKey cSongFileNameHash::GetKey(tHashSetNode node) const
{
   return (tHashSetKey)((const char*)(((sSongFile*)node)->fileName));
}

static cSongFileNameHash fileNameHash;


static void SongFilesGet(const char *pszDataPath, const char *pszWhat)
{
   Datapath sDatapath;
   DatapathDir *pDatapathDir;
   char *pszFileName;
   sSongFile *pSongFile;

   DatapathClear(&sDatapath);
   DatapathAdd(&sDatapath, (char*)pszDataPath);
   pDatapathDir = DatapathOpenDir(&sDatapath, (char*)pszWhat, DP_SCREEN_DOT);
   while (NULL!=(pszFileName = DatapathReadDir(pDatapathDir)))
   {
      pSongFile = new sSongFile;
      pSongFile->fileName = pszFileName;
      (pSongFile->fileName).MakeLower();
      if (!fileNameHash.Search((const char*)(pSongFile->fileName)))
      {
         pSongFile->pathName = pszDataPath;
         fileNameHash.Insert(pSongFile);
      }
      else
         delete pSongFile;
   }
   DatapathCloseDir(pDatapathDir);
   DatapathFree(&sDatapath);
}

static void SongFilesRead(fSongRead readFunc)
{
   cStr fullName;
   sSongFile *pSongFile;
   tHashSetHandle handle;

   pSongFile = (sSongFile*)(fileNameHash.GetFirst(handle));
   while (pSongFile != NULL)
   {
      fullName.FmtStr("%s\\%s", (const char*)(pSongFile->pathName), 
                      (const char*)(pSongFile->fileName));
      fileNameHash.Remove(pSongFile);
      delete pSongFile;
      ConfigSpew("SongFiles", ("Loading file %s\n", (const char*)fullName));
      (*readFunc)((char*)((const char*)fullName));
      pSongFile = (sSongFile*)fileNameHash.GetFirst(handle);
   }
}


// read all files from res path and local dir that match "what" string
void SongFilesLoadFromDir(const char *where, const char *what, fSongRead readFunc)
{
   static char szDataPath[PATH_MAX];
   cStr resSongPath;

   // open stuff in your current dir
   resSongPath.FmtStr(".\\%s",where);
   SongFilesGet((const char*)resSongPath, what);

   // get stuff from res path
   if (config_get_raw("song_source_path", szDataPath, sizeof(szDataPath)))
   {
      resSongPath.FmtStr("%s\\%s", szDataPath, where);
      SongFilesGet((const char*)resSongPath, what);
   }
   // read it all
   SongFilesRead(readFunc);
}

//
// Song save/load
//
// These might be nicer if the objects themselves knew about how to save themselves.
// As it is, modifications to the binary format must be carefully matched in the
// SongSave and SongLoad.
void SongSave (ISong* pSong, char* filename)
{
   FILE* fp;

   ISongEvent* pEvent;
   ISongSection* pSection;
   ISongSample* pSample;
   ISongGoto* pGoto;

   sSongInfo songInfo;
   sSongEventInfo eventInfo;
   sSongSectionInfo sectionInfo;
   sSongSampleInfo sampleInfo;
   sSongGotoInfo gotoInfo;

   long fileVersion;

   unsigned count1, count2, count3, i, j, k;

   // Open file for writing.
   fp = fopen (filename, "wb");
   if (NULL == fp)
   {
      Warning (("Failure opening song file \"%s\" for writing.\n", filename));
      return;
   }

   // Write version number.
   fileVersion = SONG_FILEVERSION;
   SONGFWRITE (fp, fileVersion);

   // Write songInfo.
   pSong->GetSongInfo (&songInfo);
   SONGFWRITE (fp, songInfo);

   // Write events.
   count1 = pSong->CountEvents();
   SONGFWRITE (fp, count1);
   for (i = 0; i < count1; i++)
   {
      // Write event info.
      pSong->GetEvent(i, &pEvent);
      pEvent->GetEventInfo(&eventInfo);
      SONGFWRITE (fp, eventInfo);
      
      // Write gotos.
      count2 = pEvent->CountGotos();
      SONGFWRITE (fp, count2);
      for (j = 0; j < count2; j++)
      {
         // Write goto info.
         pEvent->GetGoto(j, &pGoto);
         pGoto->GetGotoInfo(&gotoInfo);
         SONGFWRITE (fp, gotoInfo);
         pGoto->Release();
      }
      pEvent->Release();
   }

   // Write sections.
   count1 = pSong->CountSections();
   SONGFWRITE (fp, count1);
   for (i = 0; i < count1; i++)
   {
      // Write section info.
      pSong->GetSection(i, &pSection);
      pSection->GetSectionInfo(&sectionInfo);
      SONGFWRITE (fp, sectionInfo);
      
      // Write samples.
      count2 = pSection->CountSamples();
      SONGFWRITE (fp, count2);
      for (j = 0; j < count2; j++)
      {
         // Write sample info.
         pSection->GetSample(j, &pSample);
         pSample->GetSampleInfo(&sampleInfo);
         SONGFWRITE (fp, sampleInfo);
         pSample->Release();
      }

      // Write Events.
      count2 = pSection->CountEvents();
      SONGFWRITE (fp, count2);
      for (j = 0; j < count2; j++)
      {
         // Write event info.
         pSection->GetEvent(j, &pEvent);
         pEvent->GetEventInfo(&eventInfo);
         SONGFWRITE (fp, eventInfo);
         
         // Write gotos.
         count3 = pEvent->CountGotos();
         SONGFWRITE (fp, count3);
         for (k = 0; k < count3; k++)
         {
            pEvent->GetGoto(k, &pGoto);
            pGoto->GetGotoInfo(&gotoInfo);
            SONGFWRITE (fp, gotoInfo);
            pGoto->Release();
         }
         pEvent->Release();
      }
      pSection->Release();
   }

   fclose (fp);
}
#endif // EDITOR

ISong* SongLoad (char* filename)
{
   // SongLoad loads a .snc file into memory using namedres and then
   // fits it into our data structures.
   ISearchPath* pSncPath;
   IRes* pRes;
   char *pData, *pDataStart;

   ISong* pSong;
   ISongEvent* pEvent;
   ISongSection* pSection;
   ISongSample* pSample;
   ISongGoto* pGoto;

   sSongInfo songInfo;
   sSongEventInfo eventInfo;
   sSongSectionInfo sectionInfo;
   sSongSampleInfo sampleInfo;
   sSongGotoInfo gotoInfo;

   long fileVersion;

   unsigned count1, count2, count3, i, j, k;

   //
   // Set up pSoundPath to point to the sound files
   //
   AutoAppIPtr(ResMan);
   pSncPath = pResMan->NewSearchPath();
   pSncPath->AddPathTrees("song\\", FALSE);
   pSncPath->Ready();

   pRes = pResMan->Bind (filename, RESTYPE_BINARY, pSncPath);
   if (NULL == pRes)
   {
      Warning (("Song \"%s\" not found.\n", filename));
      pSncPath->Release();
      return NULL;
   }

   pDataStart = (char*) pRes->Lock();
   pData = pDataStart;

   // Read version.
   SONGREAD (pData, fileVersion);
   // Simple version control : warn if not the expected version.
   if (fileVersion != SONG_FILEVERSION)
   {
      Warning (("Loading song \"%s\", file version is %d, expecting %d.\n",
                filename, fileVersion, (long) SONG_FILEVERSION));
   }

   // Read song.
   SONGREAD (pData, songInfo);
   CreateSong (&pSong, NULL);
   pSong->SetSongInfo(&songInfo);

   // Read events.
   SONGREAD (pData, count1);
   for (i = 0; i < count1; i++)
   {
      // Read event info.
      SONGREAD (pData, eventInfo);
      CreateSongEvent (&pEvent, NULL);
      pEvent->SetEventInfo(&eventInfo);

      // Read gotos.
      SONGREAD (pData, count2);
      for (j = 0; j < count2; j++)
      {
         // Read goto info.
         SONGREAD (pData, gotoInfo);
         CreateSongGoto (&pGoto, NULL);
         pGoto->SetGotoInfo(&gotoInfo);

         pEvent->AddGoto(pGoto);
         pGoto->Release();
      }
      pSong->AddEvent(pEvent);
      pEvent->Release();
   }

   // Read sections.
   SONGREAD (pData, count1);
   for (i = 0; i < count1; i++)
   {
      // Read section info.
      SONGREAD (pData, sectionInfo);
      CreateSongSection (&pSection, NULL);
      pSection->SetSectionInfo(&sectionInfo);

      // Read samples.
      SONGREAD (pData, count2);
      for (j = 0; j < count2; j++)
      {
         // Read sample info.
         SONGREAD (pData, sampleInfo);
         CreateSongSample (&pSample, NULL);
         pSample->SetSampleInfo(&sampleInfo);
         
         pSection->AddSample(pSample);
         pSample->Release();
      }

      // Read events.
      SONGREAD (pData, count2);
      for (j = 0; j < count2; j++)
      {
         // Read event info.
         SONGREAD (pData, eventInfo);
         CreateSongEvent (&pEvent, NULL);
         pEvent->SetEventInfo(&eventInfo);

         // Read gotos.
         SONGREAD (pData, count3);
         for (k = 0; k < count3; k++)
         {
            // Read goto info.
            SONGREAD (pData, gotoInfo);
            CreateSongGoto (&pGoto, NULL);
            pGoto->SetGotoInfo(&gotoInfo);

            pEvent->AddGoto(pGoto);
            pGoto->Release();
         }
         pSection->AddEvent(pEvent);
         pEvent->Release();
      }

      pSong->AddSection(pSection);
      pSection->Release();
   }

   pRes->Unlock();
   pRes->Release();
   pSncPath->Release();

   return pSong;
}
// $Header: r:/t2repos/thief2/src/sound/songfile.h,v 1.2 2000/01/31 10:02:40 adurant Exp $
#pragma once

// (MRW : Stolen from schfile.h)

#ifndef __SONGFILE_H
#define __SONGFILE_H

#include <song.h>

#ifdef EDITOR

// function for reading a schema file
typedef void (*fSongRead)(char *filename);

// read all files from res path and local dir that match "what" string
void SongFilesLoadFromDir(const char *where, const char *what, fSongRead readFunc);

void SongSave (ISong* pSong, char* filename);
#endif // EDITOR

ISong* SongLoad (char* filename);

#endif // Songfile_h
// $Header: r:/t2repos/thief2/src/sound/songi.cpp,v 1.5 2000/02/19 12:37:16 toml Exp $

#include <lg.h>
#include <song.h>
#include <songi.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// Factory methods for creating SongParser objects.
BOOL CreateSong (ISong **ppSong, IUnknown *pOuter)
{
   *ppSong = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppSong = new cSong;
   return (*ppSong != NULL);
}

BOOL CreateSongSection (ISongSection **ppSection, IUnknown *pOuter)
{
   *ppSection = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppSection = new cSongSection;
   return (*ppSection != NULL);
}

BOOL CreateSongSample (ISongSample **ppSample, IUnknown *pOuter)
{
   *ppSample = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppSample = new cSongSample;
   return (*ppSample != NULL);
}

BOOL CreateSongEvent (ISongEvent **ppEvent, IUnknown *pOuter)
{
   *ppEvent = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppEvent = new cSongEvent;
   return (*ppEvent != NULL);
}

BOOL CreateSongGoto (ISongGoto **ppGoto, IUnknown *pOuter)
{
   *ppGoto = NULL;
   if( pOuter != NULL )
      return FALSE;

   *ppGoto = new cSongGoto;
   return (*ppGoto != NULL);
}


//
// cSong
//
IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSong, ISong);

cSong::cSong ()
{
   m_songInfo.id[0] = '\0';
}

cSong::~cSong ()
{
   // Have to call Release() on each thing I contain.
   unsigned count, i;
   count = m_sections.Size();
   for (i = 0; i < count; i++)
      m_sections[i]->Release();

   count = m_events.Size();
   for (i = 0; i < count; i++)
      m_events[i]->Release();
}

STDMETHODIMP_(BOOL)
cSong::SetSongInfo (sSongInfo* pSongInfo)
{
   m_songInfo = *pSongInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSong::GetSongInfo (sSongInfo* pSongInfo)
{
   *pSongInfo = m_songInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSong::AddSection (ISongSection* pSection)
{
   pSection->AddRef();
   m_sections.Append(pSection);
   return TRUE;
}

STDMETHODIMP_(unsigned)
cSong::CountSections ()
{
   return m_sections.Size();
}

STDMETHODIMP_(BOOL)
cSong::SetSection (unsigned index, ISongSection* pSection)
{
   Assert_ (index < m_sections.Size());

   // Release any existing section.
   SafeRelease (m_sections[index]);

   // Assign new.
   pSection->AddRef();
   m_sections[index] = pSection;

   return TRUE;
}

STDMETHODIMP_(BOOL)
cSong::GetSection (unsigned index, ISongSection** ppSection)
{
   Assert_ (index < m_sections.Size());

   ISongSection* pSection = m_sections[index];
   pSection->AddRef();
   *ppSection = pSection;

   return TRUE;
}

STDMETHODIMP_(BOOL)
cSong::AddEvent (ISongEvent* pEvent)
{
   pEvent->AddRef();
   m_events.Append(pEvent);
   return TRUE;
}

STDMETHODIMP_(unsigned)
cSong::CountEvents ()
{
   return m_events.Size();
}

STDMETHODIMP_(BOOL)
cSong::GetEvent (unsigned index, ISongEvent** ppEvent)
{
   Assert_ (index < m_events.Size());

   ISongEvent* pEvent = m_events[index];
   pEvent->AddRef();
   *ppEvent = pEvent;

   return TRUE;
}

//
// cSongSection
//
IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSongSection, ISongSection);

cSongSection::cSongSection ()
{
   m_sectionInfo.id[0] = '\0';
   m_sectionInfo.volume = 0;
   m_sectionInfo.loopCount = 1;
}

cSongSection::~cSongSection ()
{
   // Have to call Release() on each thing I contain.
   unsigned count, i;

   count = m_samples.Size();
   for (i = 0; i < count; i++)
      m_samples[i]->Release();

   count = m_events.Size();
   for (i = 0; i < count; i++)
      m_events[i]->Release();
}

STDMETHODIMP_(BOOL)
cSongSection::SetSectionInfo (sSongSectionInfo* pSectionInfo)
{
   m_sectionInfo = *pSectionInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongSection::GetSectionInfo (sSongSectionInfo* pSectionInfo)
{
   *pSectionInfo = m_sectionInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongSection::AddSample (ISongSample* pSample)
{
   pSample->AddRef();
   m_samples.Append(pSample);
   return TRUE;
}

STDMETHODIMP_(unsigned)
cSongSection::CountSamples ()
{
   return m_samples.Size();
}

STDMETHODIMP_(BOOL)
cSongSection::GetSample (unsigned index, ISongSample** ppSample)
{
   Assert_ (index < m_samples.Size());

   ISongSample* pSample = m_samples[index];
   pSample->AddRef();
   *ppSample = pSample;

   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongSection::AddEvent (ISongEvent* pEvent)
{
   pEvent->AddRef();
   m_events.Append(pEvent);
   return TRUE;
}

STDMETHODIMP_(unsigned)
cSongSection::CountEvents ()
{
   return m_events.Size();
}

STDMETHODIMP_(BOOL)
cSongSection::GetEvent (unsigned index, ISongEvent** ppEvent)
{
   Assert_ (index < m_events.Size());

   ISongEvent* pEvent = m_events[index];
   pEvent->AddRef();
   *ppEvent = pEvent;

   return TRUE;
}


//
// cSongSample
//
IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSongSample, ISongSample);

cSongSample::cSongSample ()
{
   m_sampleInfo.name[0] = '\0';
   //m_sampleInfo.loopCount = 1;
   //m_sampleInfo.probability = 100;
}

cSongSample::~cSongSample ()
{
}

STDMETHODIMP_(BOOL)
cSongSample::SetSampleInfo (sSongSampleInfo* pSampleInfo)
{
   m_sampleInfo = *pSampleInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongSample::GetSampleInfo (sSongSampleInfo* pSampleInfo)
{
   *pSampleInfo = m_sampleInfo;
   return TRUE;
}


//
// cSongEvent
//
IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSongEvent, ISongEvent);

cSongEvent::cSongEvent ()
{
   m_eventInfo.eventString[0] = '\0';
   m_eventInfo.flags = 0;
}

cSongEvent::~cSongEvent ()
{
   // Have to call Release() on each thing I contain.
   unsigned count, i;

   count = m_gotos.Size();
   for (i = 0; i < count; i++)
      m_gotos[i]->Release();
}

STDMETHODIMP_(BOOL)
cSongEvent::SetEventInfo (sSongEventInfo* pEventInfo)
{
   m_eventInfo = *pEventInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongEvent::GetEventInfo (sSongEventInfo* pEventInfo)
{
   *pEventInfo = m_eventInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongEvent::AddGoto (ISongGoto* pGoto)
{
   pGoto->AddRef();
   m_gotos.Append(pGoto);
   return TRUE;
}

STDMETHODIMP_(unsigned)
cSongEvent::CountGotos ()
{
   return m_gotos.Size();
}

STDMETHODIMP_(BOOL)
cSongEvent::GetGoto (unsigned index, ISongGoto** ppGoto)
{
   Assert_ (index < m_gotos.Size());

   ISongGoto* pGoto = m_gotos[index];
   pGoto->AddRef();
   *ppGoto = pGoto;

   return TRUE;
}


//
// cSongGoto
//
IMPLEMENT_UNAGGREGATABLE_SELF_DELETE(cSongGoto, ISongGoto);

cSongGoto::cSongGoto()
{
   m_gotoInfo.sectionIndex = -1;
   m_gotoInfo.probability = 100;
}

cSongGoto::~cSongGoto()
{
}

STDMETHODIMP_(BOOL)
cSongGoto::SetGotoInfo (sSongGotoInfo* pGotoInfo)
{
   m_gotoInfo = *pGotoInfo;
   return TRUE;
}

STDMETHODIMP_(BOOL)
cSongGoto::GetGotoInfo (sSongGotoInfo* pGotoInfo)
{
   *pGotoInfo = m_gotoInfo;
   return TRUE;
}

// $Header: r:/t2repos/thief2/src/sound/songi.h,v 1.5 2000/01/31 10:02:41 adurant Exp $
#pragma once

#ifndef SONGI_H
#define SONGI_H

#include <comtools.h>
#include <song.h>
#include <dynarray.h>
#include <songid.h>

class cSong : public ISong
{
   DECLARE_UNAGGREGATABLE();

public:
   cSong();
   virtual ~cSong();

   STDMETHOD_(BOOL, SetSongInfo)(THIS_ sSongInfo* pSongInfo);
   STDMETHOD_(BOOL, GetSongInfo)(THIS_ sSongInfo* ppSongInfo);

   STDMETHOD_(BOOL, AddSection)(THIS_ ISongSection* pSection);
   STDMETHOD_(unsigned, CountSections) (THIS);
   STDMETHOD_(BOOL, SetSection)(THIS_ unsigned index, ISongSection* pSection);
   STDMETHOD_(BOOL, GetSection)(THIS_ unsigned index, ISongSection** ppSection);

   STDMETHOD_(BOOL, AddEvent)(THIS_ ISongEvent* pEvent);
   STDMETHOD_(unsigned, CountEvents)(THIS);
   STDMETHOD_(BOOL, GetEvent)(THIS_ unsigned index, ISongEvent** ppEvent);

private:
   sSongInfo                        m_songInfo;
   cDynArray <ISongSection*>        m_sections;
   cDynArray <ISongEvent*>          m_events;
};

class cSongSection : public ISongSection
{
   DECLARE_UNAGGREGATABLE();

public:
   cSongSection();
   virtual ~cSongSection();

   STDMETHOD_(BOOL, SetSectionInfo)(THIS_ sSongSectionInfo* pSectionInfo);
   STDMETHOD_(BOOL, GetSectionInfo)(THIS_ sSongSectionInfo* pSectionInfo);
   
   STDMETHOD_(BOOL, AddSample)(THIS_ ISongSample* pSample);
   STDMETHOD_(unsigned, CountSamples)(THIS);
   STDMETHOD_(BOOL, GetSample)(THIS_ unsigned index, ISongSample** ppSample);

   STDMETHOD_(BOOL, AddEvent)(THIS_ ISongEvent* pEvent);
   STDMETHOD_(unsigned, CountEvents)(THIS);
   STDMETHOD_(BOOL, GetEvent)(THIS_ unsigned index, ISongEvent** ppEvent);

private:
   sSongSectionInfo                 m_sectionInfo;
   cDynArray <ISongSample*>         m_samples;
   cDynArray <ISongEvent*>          m_events;
};

class cSongSample : public ISongSample
{
   DECLARE_UNAGGREGATABLE();

public:
   cSongSample();
   virtual ~cSongSample();

   STDMETHOD_(BOOL, SetSampleInfo)(THIS_ sSongSampleInfo* pSampleInfo);
   STDMETHOD_(BOOL, GetSampleInfo)(THIS_ sSongSampleInfo* pSampleInfo);

private:
   sSongSampleInfo                  m_sampleInfo;
};

class cSongEvent : public ISongEvent
{
   DECLARE_UNAGGREGATABLE();

public:
   cSongEvent();
   virtual ~cSongEvent();

   STDMETHOD_(BOOL, SetEventInfo)(THIS_ sSongEventInfo* pEventInfo);
   STDMETHOD_(BOOL, GetEventInfo)(THIS_ sSongEventInfo* pEventInfo);

   STDMETHOD_(BOOL, AddGoto)(THIS_ ISongGoto* pGoto);
   STDMETHOD_(unsigned, CountGotos)(THIS);
   STDMETHOD_(BOOL, GetGoto)(THIS_ unsigned index, ISongGoto** ppGoto);

private:
   sSongEventInfo                   m_eventInfo;
   cDynArray <ISongGoto*>           m_gotos;
};

class cSongGoto : public ISongGoto
{
   DECLARE_UNAGGREGATABLE();

public:
   cSongGoto();
   virtual ~cSongGoto();

   STDMETHOD_(BOOL, SetGotoInfo)(THIS_ sSongGotoInfo* pGotoInfo);
   STDMETHOD_(BOOL, GetGotoInfo)(THIS_ sSongGotoInfo* pGotoInfo);

private:
   sSongGotoInfo                    m_gotoInfo;
};

#endif

// $Header: r:/t2repos/thief2/src/sound/songid.cpp,v 1.3 2000/02/19 12:37:18 toml Exp $

#include <comtools.h>
#include <initguid.h>

#include <songid.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// $Header: r:/t2repos/thief2/src/sound/songid.h,v 1.4 2000/01/31 10:02:42 adurant Exp $
#pragma once

#ifndef SONGID_H
#define SONGID_H

DEFINE_LG_GUID(IID_ISong, 0x259);
DEFINE_LG_GUID(IID_ISongSection, 0x25a);
DEFINE_LG_GUID(IID_ISongSample, 0x25b);
DEFINE_LG_GUID(IID_ISongEvent, 0x25c);
DEFINE_LG_GUID(IID_ISongGoto, 0x25d);

DEFINE_LG_GUID(IID_ISongPlayer, 0x26a);

#endif
// $Header: r:/t2repos/thief2/src/sound/songmiss.cpp,v 1.1 1999/04/26 15:17:30 mwhite Exp $

#include <songmiss.h>
#include <appagg.h>
#include <filevar.h>
//#include <palmgr.h>
#include <resapi.h>
//#include <palrstyp.h>
#include <respaths.h>
//#include <palette.h>

#include <sdestool.h>
#include <sdesbase.h>

#include <config.h>
//#include <csg.h>

// must be last header
#include <dbmem.h>

////////////////////////////////////////////////////////////
// Misc Song Params
//


// Here's my descriptor, which identifies my stuff to the tag file & editor
sFileVarDesc gSongParamsDesc = 
{
   kMissionVar,         // Where do I get saved?
   "SONGPARAMS",        // Tag file tag
   "Song Parameters",   // friendly name
   FILEVAR_TYPE(sMissionSongParams),  // Type (for editing)
   { 1, 0},             // version
   { 1, 0},             // last valid version 
}; 


// The actual global variable
class cSongParams : public cFileVar<sMissionSongParams,&gSongParamsDesc> 
{
public: 

   // Silly assignment operator 
   cSongParams& operator =(const sMissionSongParams& v) { *(sMissionSongParams*)this = v; return *this; }; 


   void Update()
   {
#ifdef EDITOR
      //      global_ambient = ambient_light*256.0;
#endif
      //pal_set(); 
   }

   void Reset()
   {
      //pal_res[0] = '\0'; 
   }
};

static cSongParams gSongParams;

//------------------------------------------------------------
// SDESC 
//

static sFieldDesc param_field[] = 
{
   { "Song Name", kFieldTypeString, FieldLocation(sMissionSongParams,songName), },
};


static sStructDesc param_sdesc = StructDescBuild(sMissionSongParams,kStructFlagNone,param_field);


//------------------------------------------------------------
// API
// 

void MissionSongInit(void)
{
   AutoAppIPtr_(StructDescTools,pTools); 
   pTools->Register(&param_sdesc);
}

void MissionSongTerm(void)
{
}


//----------------------------------------


const sMissionSongParams* GetMissionSongParams(void)
{
   return &gSongParams; 
}


void SetMissionSongParams(const sMissionSongParams* params)
{
   gSongParams = *params; 
   gSongParams.Update(); 
}
/* n:\bin\yacc -l -D schtok.h -o sound\schyacc.c schema.y */
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#endif
/*
 * Portable way of defining ANSI C prototypes
 */
#ifndef YY_ARGS
#if __STDC__
#define YY_ARGS(x)	x
#else
#define YY_ARGS(x)	()
#endif
#endif

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;

#endif

typedef union {
   char *strval;
   int  ival;
   float fval;
} YYSTYPE;
#define SCHEMA	257
#define FLAGS	258
#define VOLUME	259
#define DELAY	260
#define PAN	261
#define PRIORITY	262
#define FADE	263
#define ARCHETYPE	264
#define FREQ	265
#define IDENT	266
#define STRING	267
#define INT	268
#define FLOAT	269
#define INCLUDE	270
#define DEFINE	271
#define MONO_LOOP	272
#define POLY_LOOP	273
#define CONCEPT	274
#define VOICE	275
#define LPAREN	276
#define RPAREN	277
#define EQUAL	278
#define COLON	279
#define TAG	280
#define TAG_INT	281
#define SCHEMA_VOICE	282
#define MESSAGE	283
#define AUDIO_CLASS	284
#define PAN_RANGE	285
#define NO_REPEAT	286
#define NO_CACHE	287
#define STREAM	288
#define LOOP_COUNT	289
#define ENV_TAG_REQUIRED	290
#define ENV_TAG	291
#define NO_COMBAT	292
#define PLAY_ONCE	293
#define NET_AMBIENT	294
#define LOCAL_SPATIAL	295

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#include <mprintf.h>

#include <appagg.h>
#include <iobjsys.h>
#include <property.h>
#include <traitman.h>
#include <propman.h>
#include <linkman.h>
#include <linktype.h>
#include <relation.h>
#include <label.h>

#include <schbase.h>
#include <inctab.h>
#include <schprop.h>
#include <spchprop.h>
#include <schdb.h>
#include <schsamps.h>
#include <spchglue.h>
#include <esndglue.h>


#define FILE_NAME_LEN 100

/*
  Include file stuff
*/
extern void IncParseFile(char *fileName);
extern void SchemaParseFile(char *fileName, int (*parseFn)());

// current schema label
static struct Label schemaLabel;

// current schema ObjID
ObjID g_SchemaID;

// schema archetype
static ObjID baseSchemaID;

// schema parameters
static schemaParamsSet;
static sSchemaPlayParams schemaPlayParams;
static ISchemaPlayParamsProperty *pPropSchemaPlayParams;

// priority
static bool schemaPrioritySet;
static int schemaPriority;

static IObjectSystem *pObjSys;
static ITraitManager *pTraitMan;

// current archetype
static ObjID archID;

// sample information
#define SCHEMA_SAMPLES_MAX     20      // max samples/schema
#define SAMPLE_NAME_LEN 20      // max sample file name length
static char sampleNames[SCHEMA_SAMPLES_MAX][SAMPLE_NAME_LEN];
static uchar sampleFreqs[SCHEMA_SAMPLES_MAX];
static char *pSampleNames[SCHEMA_SAMPLES_MAX];
static uchar sampleFreq;
static int samplesNum = 0;
static BOOL freqSet;

// loop info
static sSchemaLoopParams loopParams;
static BOOL loopSet;

// voice
static ObjID baseVoiceID;

static int voicesNum;
#define VOICES_MAX 20
static ObjID voices[VOICES_MAX];

// messages
static struct Label msgType;
static BOOL msgSet;

// tag creation
#define kMaxTagValues 32
static int g_iNumTagValues;
static Label g_aTagValueLabel[kMaxTagValues];

// adding tags to schemas
static int g_iNumTagsAdded;
static Label g_aTagNameLabel[kMaxTagValues];
static int g_aTagMinInt[kMaxTagValues];
static int g_aTagMaxInt[kMaxTagValues];
static Label g_aTagEnumLabel[kMaxTagValues][8]; // 8 is a hard limit in tagdb
static BOOL g_aTagNumEnums[kMaxTagValues];      // 0 indicates an int tag


#define min(x,y) ((x)<(y)?(x):(y))

#define yyerror printf

// zero all the stuff telling us whether things have been set
void SchemaDataReset(void)
{
   sSchemaPlayParams *pSchemaPlayParams;
   int i, j, k;

   samplesNum = 0;
   schemaParamsSet = FALSE;
   schemaPrioritySet = FALSE;
   loopSet = FALSE;
   loopParams.flags = 0;
   msgSet = FALSE;
   voicesNum = 0;

   // get and copy the default parameters from the base schema
   pSchemaPlayParams = SchemaPlayParamsGet(baseSchemaID);
   schemaPlayParams = *pSchemaPlayParams;
}


void TagReset(void)
{
   int i, j;

   g_iNumTagsAdded = 0;
   for (i = 0; i < kMaxTagValues; ++i) {
      g_aTagNumEnums[i] = 0;
      for (j = 0; j < 8; ++j)
         g_aTagEnumLabel[i][j].text[0] = '\0';
   }
}


void VoiceDataReset(void)
{
   archID = OBJ_NULL;
}


// This copies pString into pLabel, truncating to 16 characters
// including the terminal 0.  If the string is longer than that we
// never tell anyone.
static void MakeLabel(Label *pLabel, char *pString)
{
   strncpy((char*)pLabel, pString, 15);
   pLabel->text[15] = '\0';
}


#define FreeString(ident) { free(ident); ident = NULL; }

extern int yychar, yyerrflag;
extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_strval, YY_t_ival, YY_t_fval
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&00: %01 &00",  0},
	{ "%01: %02",  0},
	{ "%02: %03",  0},
	{ "%02: %02 %03",  0},
	{ "%03: %04",  0},
	{ "%03: %05",  0},
	{ "%03: %06",  0},
	{ "%03: %07",  0},
	{ "%03: %08",  0},
	{ "%03: %09",  0},
	{ "%03: %10",  0},
	{ "%03: %11",  0},
	{ "%03: %12",  0},
	{ "%04: &15 &12",  0},
	{ "%07: &19 &11 &13",  0},
	{ "%06: &20 &11 %13",  0},
	{ "%13: %14",  0},
	{ "%13: %15",  0},
	{ "%14: %16",  0},
	{ "%14: %16 %14",  0},
	{ "%16: %17",  0},
	{ "%05: &02 &11 %18 %19",  0},
	{ "%18: %15",  0},
	{ "%18: %20",  0},
	{ "%20: %21",  0},
	{ "%20: %20 %21",  0},
	{ "%21: %22",  0},
	{ "%21: %23",  0},
	{ "%21: %24",  0},
	{ "%21: %25",  0},
	{ "%21: %26",  0},
	{ "%21: %27",  0},
	{ "%21: %28",  0},
	{ "%21: %29",  0},
	{ "%21: %17",  0},
	{ "%21: %30",  0},
	{ "%21: %31",  0},
	{ "%21: %32",  0},
	{ "%21: %33",  0},
	{ "%21: %34",  0},
	{ "%21: %35",  0},
	{ "%21: %36",  0},
	{ "%21: %37",  0},
	{ "%21: %38",  0},
	{ "%21: %39",  0},
	{ "%21: %40",  0},
	{ "%22: &03 &13",  0},
	{ "%34: &31",  0},
	{ "%37: &37",  0},
	{ "%38: &38",  0},
	{ "%39: &39",  0},
	{ "%40: &40",  0},
	{ "%33: &32",  0},
	{ "%35: &33",  0},
	{ "%23: &04 &13",  0},
	{ "%24: &05 &13",  0},
	{ "%25: &06 &13",  0},
	{ "%26: &30 &13",  0},
	{ "%27: &07 &13",  0},
	{ "%28: &08 &13",  0},
	{ "%17: &09 &11",  0},
	{ "%30: &17 &13 &13",  0},
	{ "%31: &18 &13 &13 &13",  0},
	{ "%36: &34 &13",  0},
	{ "%29: &29 &11",  0},
	{ "%32: &28 &11",  0},
	{ "%10: &25 &11 %41",  0},
	{ "%41: %15",  0},
	{ "%41: %42",  0},
	{ "%42: %43",  0},
	{ "%42: %43 %42",  0},
	{ "%43: &11",  0},
	{ "%11: &26 &11",  0},
	{ "%12: &35 &11",  0},
	{ "%08: &27 &11 &13 &11 %44",  0},
	{ "%44: %15",  0},
	{ "%44: %45",  0},
	{ "%45: %46",  0},
	{ "%45: %46 %45",  0},
	{ "%46: %47",  0},
	{ "%46: %48",  0},
	{ "%46: %49",  0},
	{ "%47: &21 &11 &22",  0},
	{ "%48: &21 &11 &13 &13 &22",  0},
	{ "%49: &21 &11 %50 %51 &22",  0},
	{ "%51: %15",  0},
	{ "%51: %52",  0},
	{ "%52: %50",  0},
	{ "%52: %50 %52",  0},
	{ "%50: &11",  0},
	{ "%09: &36 %44",  0},
	{ "%19: %15",  0},
	{ "%19: %53",  0},
	{ "%53: %54",  0},
	{ "%53: %54 %53",  0},
	{ "%54: &11 %55 %56",  0},
	{ "%55: %57",  0},
	{ "%55: %15",  0},
	{ "%57: &12",  0},
	{ "%56: %58",  0},
	{ "%56: %15",  0},
	{ "%58: &10 &13",  0},
	{ "%15:",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "SCHEMA",  257,  0},
	{ "FLAGS",  258,  0},
	{ "VOLUME",  259,  0},
	{ "DELAY",  260,  0},
	{ "PAN",  261,  0},
	{ "PRIORITY",  262,  0},
	{ "FADE",  263,  0},
	{ "ARCHETYPE",  264,  0},
	{ "FREQ",  265,  0},
	{ "IDENT",  266,  1},
	{ "STRING",  267,  1},
	{ "INT",  268,  2},
	{ "FLOAT",  269,  3},
	{ "INCLUDE",  270,  0},
	{ "DEFINE",  271,  0},
	{ "MONO_LOOP",  272,  0},
	{ "POLY_LOOP",  273,  0},
	{ "CONCEPT",  274,  0},
	{ "VOICE",  275,  0},
	{ "LPAREN",  276,  0},
	{ "RPAREN",  277,  0},
	{ "EQUAL",  278,  0},
	{ "COLON",  279,  0},
	{ "TAG",  280,  0},
	{ "TAG_INT",  281,  0},
	{ "SCHEMA_VOICE",  282,  0},
	{ "MESSAGE",  283,  0},
	{ "AUDIO_CLASS",  284,  0},
	{ "PAN_RANGE",  285,  0},
	{ "NO_REPEAT",  286,  0},
	{ "NO_CACHE",  287,  0},
	{ "STREAM",  288,  0},
	{ "LOOP_COUNT",  289,  0},
	{ "ENV_TAG_REQUIRED",  290,  0},
	{ "ENV_TAG",  291,  0},
	{ "NO_COMBAT",  292,  0},
	{ "PLAY_ONCE",  293,  0},
	{ "NET_AMBIENT",  294,  0},
	{ "LOCAL_SPATIAL",  295,  0}

};
#endif
static short yydef[] = {

	  97,  104,   -1,  100,   97,   97,   97,  101,  102,   97, 
	 103,   -5,   97,   97,   98,   99,   97
};
static short yyex[] = {

	   0,    0,   -1,    1,  277,   97,   -1,    1
};
static short yyact[] = {

	 -46,  -43,  -44,  -45,  -47,  -48,  -50,  -49,   -1,  291, 
	 290,  282,  281,  280,  275,  274,  270,  257,  -42,  276, 
	 -41,  266,  -61,  266,  -62,  266,   -5,  266,   -6,  266, 
	  -7,  266,  -40,  266,  -88,  267,  -39,  266,  -38,  268, 
	 -63,  266,  -25,  -26,  -27,  -28,  -30,  -31,  -32,  -33, 
	 -34,  -37,  -36,  -29,  -83,  -78,  -77,  -35,  -82,  -81, 
	 -80,  -79,  295,  294,  293,  292,  289,  288,  287,  286, 
	 285,  284,  283,  273,  272,  264,  263,  262,  261,  260, 
	 259,  258,  -32,  264,  -87,  268,  -56,  -24,  -59,  277, 
	 268,  266,  -13,  266,  -65,  266,  -66,  266,  -67,  268, 
	 -23,  268,  -22,  268,  -70,  266,  -71,  268,  -72,  268, 
	 -73,  268,  -74,  268,  -75,  268,  -76,  268,  -84,  268, 
	 -14,  266,  -56,  266,  -20,  268,  -19,  268,  -69,  268, 
	 -53,  267,  -57,  277,  -58,  277,  -68,  268,  -18,  265, 
	 -52,  268,   -1
};
static short yypact[] = {

	  19,    9,   36,   19,   41,   62,   83,   41,   62,  121, 
	  83,  123,   19,  131,  121,  123,  139,  141,  137,  135, 
	 133,  129,  127,  125,  119,  117,  115,  113,  111,  109, 
	 107,  105,  103,  101,   99,   97,   95,   93,   89,   85, 
	  39,   37,   35,   33,   31,   29,   27,   25,   23,   21,    9
};
static short yygo[] = {

	  -3,   -2,  -90,  -89,    1,  -91,  -92,  -93,  -94,  -95, 
	 -96,  -97,  -98,  -99,  -86, -102, -100,   10, -127, -104, 
	-101, -139, -136, -143, -145, -130,   16,   13,   11,    9, 
	   6,    5,    4,  -11, -103, -103, -115,   10,    6,  -10, 
	 -85,   -9, -106, -105,    8, -107, -108, -109, -110, -111, 
	-112, -113, -114, -116, -117, -118, -119, -120, -121, -122, 
	-123, -124, -125, -126,  -64, -129, -128,    7,   -8,  -60, 
	 -55,   12, -132, -131,    3,   -4, -133, -134, -135,  -12, 
	 -16,   38,  -21, -138, -137,   15, -141, -140,   14,  -15, 
	 -17,  -54, -142, -144,   -1
};
static short yypgo[] = {

	   0,    0,    0,   93,   92,   89,   10,   80,   78,   77, 
	  76,    9,   13,   12,   68,   11,   55,   52,   59,   54, 
	  53,   36,   51,   50,   49,   48,   47,   46,   58,   56, 
	  63,   62,   61,   60,   57,   45,    6,    7,    8,    5, 
	   1,    1,    3,    3,    3,    3,    3,    3,    3,    3, 
	   3,   14,   14,   16,   33,   39,   41,   41,   43,   43, 
	  43,   43,   43,   43,   43,   43,   43,   43,   43,   43, 
	  43,   43,   43,   43,   43,   43,   43,   43,   64,   64, 
	  66,   70,   70,   73,   75,   75,   75,   82,   82,   84, 
	  40,   40,   87,   90,   90,   91,   91,   25,   87,   84, 
	  73,   66,   39,   16,    0,    0
};
static short yyrlen[] = {

	   0,    0,    0,    2,    1,    3,    2,    1,    5,    5, 
	   3,    5,    2,    2,    1,    3,    2,    2,    2,    4, 
	   3,    2,    2,    2,    2,    2,    2,    2,    1,    1, 
	   1,    1,    1,    1,    1,    2,    4,    3,    3,    2, 
	   1,    2,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    2,    1,    1,    1,    2,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   2,    1,    1,    2,    1,    1,    1,    1,    1,    2, 
	   1,    1,    2,    1,    1,    1,    1,    0,    1,    1, 
	   1,    1,    1,    1,    1,    2
};
#define YYS0	50
#define YYDELTA	48
#define YYNPACT	51
#define YYNDEF	17

#define YYr103	0
#define YYr104	1
#define YYr105	2
#define YYr101	3
#define YYr98	4
#define YYr95	5
#define YYr90	6
#define YYr89	7
#define YYr84	8
#define YYr83	9
#define YYr82	10
#define YYr74	11
#define YYr73	12
#define YYr72	13
#define YYr71	14
#define YYr66	15
#define YYr65	16
#define YYr64	17
#define YYr63	18
#define YYr62	19
#define YYr61	20
#define YYr60	21
#define YYr59	22
#define YYr58	23
#define YYr57	24
#define YYr56	25
#define YYr55	26
#define YYr54	27
#define YYr53	28
#define YYr52	29
#define YYr51	30
#define YYr50	31
#define YYr49	32
#define YYr48	33
#define YYr47	34
#define YYr46	35
#define YYr21	36
#define YYr15	37
#define YYr14	38
#define YYr13	39
#define YYrACCEPT	YYr103
#define YYrERROR	YYr104
#define YYrLR2	YYr105
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"file",
	"statements",
	"statement",
	"include",
	"schema",
	"voice",
	"concept",
	"schema_voice",
	"env_tag",
	"tag",
	"tag_int",
	"env_tag_required",
	"opt_voice_params",
	"voice_params",
	"null",
	"voice_param",
	"archetype",
	"opt_schema_params",
	"opt_samples",
	"schema_params",
	"schema_param",
	"flags",
	"volume",
	"delay",
	"pan",
	"pan_range",
	"priority",
	"fade",
	"audioclass",
	"monoloop",
	"polyloop",
	"message",
	"no_cache",
	"no_repeat",
	"stream",
	"loopcount",
	"no_combat",
	"play_once",
	"net_ambient",
	"local_spatial",
	"opt_tag_states",
	"tag_states",
	"tag_state",
	"opt_schema_tags",
	"schema_tags",
	"schema_tag",
	"schema_tag_empty",
	"schema_tag_int",
	"schema_tag_enum",
	"schema_arg",
	"schema_args",
	"schema_arg_list",
	"samples",
	"sample",
	"opt_text",
	"opt_freq",
	"text",
	"freq",
	0
};
short yyrmap[] = {

	 103,  104,  105,  101,   98,   95,   90,   89,   84,   83, 
	  82,   74,   73,   72,   71,   66,   65,   64,   63,   62, 
	  61,   60,   59,   58,   57,   56,   55,   54,   53,   52, 
	  51,   50,   49,   48,   47,   46,   21,   15,   14,   13, 
	   2,    3,    4,    5,    6,    7,    8,    9,   10,   11, 
	  12,   16,   17,   19,   20,   22,   24,   25,   26,   27, 
	  28,   29,   30,   31,   32,   33,   34,   35,   36,   37, 
	  38,   39,   40,   41,   42,   43,   44,   45,   67,   68, 
	  70,   75,   76,   78,   79,   80,   81,   85,   86,   88, 
	  91,   92,   94,   96,   97,   99,  100,  102,   93,   87, 
	  77,   69,   23,   18,    1,    0
};
short yysmap[] = {

	   1,   20,   21,   27,   33,   34,   35,   43,   88,   90, 
	  92,   98,  101,  117,  118,  123,  134,  140,  129,  127, 
	 126,  107,  106,   99,   66,   58,   57,   56,   55,   54, 
	  53,   52,   51,   50,   49,   48,   47,   41,   39,   36, 
	  30,   23,    9,    8,    7,    6,    5,    4,    3,    2, 
	   0,  144,  131,  143,   22,   97,  137,  138,  100,  128, 
	  31,   32,   42,   46,  103,  104,  105,  139,  130,  108, 
	 109,  110,  111,  112,  113,  114,   59,   60,   61,   62, 
	  63,   64,   65,  115,  121,   95,   96,   37,   19,   38, 
	  18,   17,   16,   15,   14,   13,   12,   11,   10,   94, 
	  93,  122,   91,   89,   87,  116,   86,   85,   84,   83, 
	  82,   81,   80,   79,   78,   77,   76,   75,   74,   73, 
	  72,   71,   70,   69,   68,   67,   45,   44,  102,   29, 
	  28,   40,   26,   25,   24,  125,  124,  136,  120,  119, 
	 135,  133,  132,  142,  141
};
int yyntoken = 41;
int yynvar = 59;
int yynstate = 145;
int yynrule = 106;
#endif

#if YYDEBUG
/*
 * Package up YACC context for tracing
 */
typedef struct yyTraceItems_tag {
	int	state, lookahead, errflag, done;
	int	rule, npop;
	short	* states;
	int	nstates;
	YYSTYPE * values;
	int	nvalues;
	short	* types;
} yyTraceItems;
#endif


/*
 * Copyright 1985, 1990 by Mortice Kern Systems Inc.  All rights reserved.
 * 
 * Automaton to interpret LALR(1) tables.
 *
 * Macros:
 *	yyclearin - clear the lookahead token.
 *	yyerrok - forgive a pending error
 *	YYERROR - simulate an error
 *	YYACCEPT - halt and return 0
 *	YYABORT - halt and return 1
 *	YYRETURN(value) - halt and return value.  You should use this
 *		instead of return(value).
 *	YYREAD - ensure yychar contains a lookahead token by reading
 *		one if it does not.  See also YYSYNC.
 *	YYRECOVERING - 1 if syntax error detected and not recovered
 *		yet; otherwise, 0.
 *
 * Preprocessor flags:
 *	YYDEBUG - includes debug code if 1.  The parser will print
 *		 a travelogue of the parse if this is defined as 1
 *		 and yydebug is non-zero.
 *		yacc -t sets YYDEBUG to 1, but not yydebug.
 *	YYTRACE - turn on YYDEBUG, and undefine default trace functions
 *		so that the interactive functions in 'ytrack.c' will
 *		be used.
 *	YYSSIZE - size of state and value stacks (default 150).
 *	YYSTATIC - By default, the state stack is an automatic array.
 *		If this is defined, the stack will be static.
 *		In either case, the value stack is static.
 *	YYALLOC - Dynamically allocate both the state and value stacks
 *		by calling malloc() and free().
 *	YYSYNC - if defined, yacc guarantees to fetch a lookahead token
 *		before any action, even if it doesnt need it for a decision.
 *		If YYSYNC is defined, YYREAD will never be necessary unless
 *		the user explicitly sets yychar = -1
 *
 * Copyright (c) 1983, by the University of Waterloo
 */
/*
 * Prototypes
 */

extern int yylex YY_ARGS((void));

#if YYDEBUG

#include <stdlib.h>		/* common prototypes */
#include <string.h>

extern char *	yyValue YY_ARGS((YYSTYPE, int));	/* print yylval */
extern void yyShowState YY_ARGS((yyTraceItems *));
extern void yyShowReduce YY_ARGS((yyTraceItems *));
extern void yyShowGoto YY_ARGS((yyTraceItems *));
extern void yyShowShift YY_ARGS((yyTraceItems *));
extern void yyShowErrRecovery YY_ARGS((yyTraceItems *));
extern void yyShowErrDiscard YY_ARGS((yyTraceItems *));

extern void yyShowRead YY_ARGS((int));
#endif

/*
 * If YYDEBUG defined and yydebug set,
 * tracing functions will be called at appropriate times in yyparse()
 * Pass state of YACC parse, as filled into yyTraceItems yyx
 * If yyx.done is set by the tracing function, yyparse() will terminate
 * with a return value of -1
 */
#define YY_TRACE(fn) { \
	yyx.state = yystate; yyx.lookahead = yychar; yyx.errflag =yyerrflag; \
	yyx.states = yys+1; yyx.nstates = yyps-yys; \
	yyx.values = yyv+1; yyx.nvalues = yypv-yyv; \
	yyx.types = yytypev+1; yyx.done = 0; \
	yyx.rule = yyi; yyx.npop = yyj; \
	fn(&yyx); \
	if (yyx.done) YYRETURN(-1); }

#ifndef I18N
#define	gettext(x)	x
#endif

#ifndef YYSSIZE
# define YYSSIZE	150
#endif

#define YYERROR		goto yyerrlabel
#define yyerrok		yyerrflag = 0
#if YYDEBUG
#define yyclearin	{ if (yydebug) yyShowRead(-1); yychar = -1; }
#else
#define yyclearin	yychar = -1
#endif
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRECOVERING()	(yyerrflag != 0)
#ifdef YYALLOC
# define YYRETURN(val)	{ retval = (val); goto yyReturn; }
#else
# define YYRETURN(val)	return(val)
#endif
#if YYDEBUG
/* The if..else makes this macro behave exactly like a statement */
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0)			\
				yychar = 0;				\
			if (yydebug)					\
				yyShowRead(yychar);			\
		} else
#else
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0)			\
				yychar = 0;				\
		} else
#endif

#define YYERRCODE	256		/* value of `error' */
#define	YYQYYP	yyq[yyq-yyp]

YYSTYPE	yyval;				/* $ */
YYSTYPE	*yypvt;				/* $n */
YYSTYPE	yylval;				/* yylex() sets this */

int	yychar,				/* current token */
	yyerrflag,			/* error flag */
	yynerrs;			/* error count */

#if YYDEBUG
int yydebug = 0;		/* debug if this flag is set */
extern char	*yysvar[];	/* table of non-terminals (aka 'variables') */
extern yyNamedType yyTokenTypes[];	/* table of terminals & their types */
extern short	yyrmap[], yysmap[];	/* map internal rule/states */
extern int	yynstate, yynvar, yyntoken, yynrule;

extern int	yyGetType YY_ARGS((int));	/* token type */
extern char	*yyptok YY_ARGS((int));	/* printable token string */
extern int	yyExpandName YY_ARGS((int, int, char *, int));
				  /* expand yyRules[] or yyStates[] */
static char *	yygetState YY_ARGS((int));

#define yyassert(condition, msg, arg) \
	if (!(condition)) { \
		printf(gettext("\nyacc bug: ")); \
		printf(msg, arg); \
		YYABORT; }
#else /* !YYDEBUG */
#define yyassert(condition, msg, arg)
#endif

extern FILE *yyin;

extern void YyParseFile(char *schemaFile);

void SchemaYaccParse(char *schemaFile)
{
   int i;

   Label baseSchemaLabel = {BASE_SCHEMA_OBJ};
   Label baseVoiceLabel = {BASE_VOICE_OBJ};
   IPropertyManager *pPropMan = AppGetObj(IPropertyManager);
   ILinkManager *pLinkMan = AppGetObj(ILinkManager);
   sSchemaPlayParams *pSchemaPlayParams;

   if (!pObjSys)
      pObjSys = AppGetObj(IObjectSystem);
   if (!pTraitMan)
      pTraitMan = AppGetObj(ITraitManager);
   baseSchemaID = IObjectSystem_GetObjectNamed(pObjSys, &baseSchemaLabel);
   baseVoiceID = IObjectSystem_GetObjectNamed(pObjSys, &baseVoiceLabel);

   if (pSchemaPlayParams = SchemaPlayParamsGet(baseSchemaID))
      schemaPlayParams = *pSchemaPlayParams;

   SchemaDataReset();
   VoiceDataReset();
   freqSet = FALSE;

   // setup names table for sample creation
   for (i=0; i<SCHEMA_SAMPLES_MAX; i++)
      pSampleNames[i] = &sampleNames[i][0];

   IncTabsInit();

//   SpeechExpressionDatabaseBuild();

   YyParseFile(schemaFile);

   IncTabsShutdown();

//   SpeechExpressionDatabaseDestroy();

   SafeRelease(pPropMan);
   SafeRelease(pLinkMan);
   SafeRelease(pObjSys);
   SafeRelease(pTraitMan);
}

yyparse()
{
	register short		yyi, *yyp;	/* for table lookup */
	register short		*yyps;		/* top of state stack */
	register short		yystate;	/* current state */
	register YYSTYPE	*yypv;		/* top of value stack */
	register short		*yyq;
	register int		yyj;
#if YYDEBUG
	yyTraceItems	yyx;			/* trace block */
	short	* yytp;
	int	yyruletype = 0;
#endif
#ifdef YYSTATIC
	static short	yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];
#if YYDEBUG
	static short	yytypev[YYSSIZE+1];	/* type assignments */
#endif
#else /* ! YYSTATIC */
#ifdef YYALLOC
	YYSTYPE *yyv;
	short	*yys;
#if YYDEBUG
	short	*yytypev;
#endif
	YYSTYPE save_yylval;
	YYSTYPE save_yyval;
	YYSTYPE *save_yypvt;
	int save_yychar, save_yyerrflag, save_yynerrs;
	int retval;
#else
	short		yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];	/* historically static */
#if YYDEBUG
	short	yytypev[YYSSIZE+1];		/* mirror type table */
#endif
#endif /* ! YYALLOC */
#endif /* ! YYSTATIC */


#ifdef YYALLOC
	yys = (short *) malloc((YYSSIZE + 1) * sizeof(short));
	yyv = (YYSTYPE *) malloc((YYSSIZE + 1) * sizeof(YYSTYPE));
#if YYDEBUG
	yytypev = (short *) malloc((YYSSIZE+1) * sizeof(short));
#endif
	if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
		|| yytypev == (short *) 0
#endif
	) {
		yyerror("Not enough space for parser stacks");
		return 1;
	}
	save_yylval = yylval;
	save_yyval = yyval;
	save_yypvt = yypvt;
	save_yychar = yychar;
	save_yyerrflag = yyerrflag;
	save_yynerrs = yynerrs;
#endif

	yynerrs = 0;
	yyerrflag = 0;
	yyclearin;
	yyps = yys;
	yypv = yyv;
	*yyps = yystate = YYS0;		/* start state */
#if YYDEBUG
	yytp = yytypev;
	yyi = yyj = 0;			/* silence compiler warnings */
#endif

yyStack:
	yyassert((unsigned)yystate < yynstate, gettext("state %d\n"), yystate);
	if (++yyps > &yys[YYSSIZE]) {
		yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	*++yytp = yyruletype;	/* ... and type */

	if (yydebug)
		YY_TRACE(yyShowState)
#endif

	/*
	 *	Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	YYREAD;
#endif
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			YYREAD;
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~YYQYYP;
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;	/* stack what yylex() set */
				yyclearin;		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

		if (yystate >= sizeof yydef /sizeof yydef[0])
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */
			/* Search exception table */
			yyassert((unsigned)~yyi < sizeof yyex/sizeof yyex[0],
				gettext("exception %d\n"), yystate);
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			YYREAD;
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
			yyassert(yyi >= 0,
				 gettext("Ex table not reduce %d\n"), yyi);
		}
	}

	yyassert((unsigned)yyi < yynrule, gettext("reduce %d\n"), yyi);
	yyj = yyrlen[yyi];
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowReduce)
	yytp -= yyj;
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	yyruletype = yyRules[yyrmap[yyi]].type;
#endif

	switch (yyi) {		/* perform semantic action */
		
case YYr13: {	/* include :  INCLUDE STRING */

   IncParseFile(yypvt[0].strval);
   FreeString(yypvt[0].strval);

} break;

case YYr14: {	/* concept :  CONCEPT IDENT INT */

   Label ConceptLabel;

   MakeLabel(&ConceptLabel, yypvt[-1].strval);
   SpeechAddConcept(&ConceptLabel, yypvt[0].ival);
   FreeString(yypvt[-1].strval);

} break;

case YYr15: {	/* voice :  VOICE IDENT opt_voice_params */

   ObjID voiceID;
   const char* name = yypvt[-1].strval; 

   voiceID = IObjectSystem_GetObjectNamed(pObjSys, name);
   if (voiceID == OBJ_NULL)
   {
      if (archID == OBJ_NULL)
         voiceID = ITraitManager_CreateArchetype(pTraitMan, name,
                                                 baseVoiceID);
      else
         voiceID = ITraitManager_CreateArchetype(pTraitMan, name,
                                                 archID);
   } else
      mprintf("Voice has existing object name: %s\n", name);

   // @TODO: This creates voice objects even for voices which are
   // just placeholders in the object hierarchy.  Should we create
   // these structures on demand instead?
   SpeechVoiceNew(voiceID);

   VoiceDataReset();
   FreeString(yypvt[-1].strval);

} break;

case YYr21: {	/* schema :  SCHEMA IDENT opt_schema_params opt_samples */

   ObjID objID;
   int i, j;

   MakeLabel(&schemaLabel, yypvt[-2].strval);
   if (archID == OBJ_NULL)
      objID = SchemaCreate(&schemaLabel, baseSchemaID);
   else {
      objID = SchemaCreate(&schemaLabel, archID);
      archID = OBJ_NULL;
   }

   if (objID != OBJ_NULL) {
      g_SchemaID = objID;

      if (samplesNum > 0) {
         // make sure we clear existing samples if were replacing the schema
         SchemaSamplesDestroy(objID);
         SchemaSamplesCreate(objID, samplesNum, pSampleNames, sampleFreqs);
      }
      // set the playback parameters if defined
      if (schemaParamsSet)
         SCHEMA_PLAY_PARAMS_SET(objID, &schemaPlayParams);
      if (schemaPrioritySet)
         SCHEMA_PRIORITY_SET(objID, schemaPriority);
      if (loopSet)
         SCHEMA_LOOP_PARAMS_SET(objID, &loopParams);
      if (msgSet)
         SCHEMA_MESSAGE_SET(objID, &msgType);
   }

   SchemaDataReset();
   FreeString(yypvt[-2].strval);

} break;

case YYr46: {	/* flags :  FLAGS INT */

   schemaPlayParams.flags = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr47: {	/* no_repeat :  NO_REPEAT */

   schemaPlayParams.flags |= SCH_NO_REPEAT;
   schemaParamsSet = TRUE;

} break;

case YYr48: {	/* no_combat :  NO_COMBAT */

   schemaPlayParams.flags |= SCH_NO_COMBAT;
   schemaParamsSet = TRUE;

} break;

case YYr49: {	/* play_once :  PLAY_ONCE */

   schemaPlayParams.flags |= SCH_PLAY_ONCE;
   schemaParamsSet = TRUE;

} break;

case YYr50: {	/* net_ambient :  NET_AMBIENT */

   schemaPlayParams.flags |= SCH_NET_AMBIENT;
   schemaParamsSet = TRUE;

} break;

case YYr51: {	/* local_spatial :  LOCAL_SPATIAL */

   schemaPlayParams.flags |= SCH_LOC_SPATIAL;
   schemaParamsSet = TRUE;

} break;

case YYr52: {	/* no_cache :  NO_CACHE */

   schemaPlayParams.flags |= SCH_NO_CACHE;
   schemaParamsSet = TRUE;

} break;

case YYr53: {	/* stream :  STREAM */

   schemaPlayParams.flags |= SCH_STREAM;
   schemaParamsSet = TRUE;

} break;

case YYr54: {	/* volume :  VOLUME INT */

   schemaPlayParams.volume = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr55: {	/* delay :  DELAY INT */

   schemaPlayParams.initialDelay = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr56: {	/* pan :  PAN INT */

   schemaPlayParams.flags &= ~SCH_PAN_RANGE;
   schemaPlayParams.flags |= SCH_PAN_POS;
   schemaPlayParams.pan = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr57: {	/* pan_range :  PAN_RANGE INT */

   schemaPlayParams.flags &= ~SCH_PAN_POS;
   schemaPlayParams.flags |= SCH_PAN_RANGE;
   schemaPlayParams.pan = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr58: {	/* priority :  PRIORITY INT */

   schemaPriority = yypvt[0].ival;
   schemaPrioritySet = TRUE;

} break;

case YYr59: {	/* fade :  FADE INT */

   schemaPlayParams.fade = yypvt[0].ival;
   schemaParamsSet = TRUE;

} break;

case YYr60: {	/* archetype :  ARCHETYPE IDENT */

   Label label;
   sSchemaPlayParams *pArchParams, *pDefaultParams;

   MakeLabel(&label, yypvt[0].strval);
   archID = IObjectSystem_GetObjectNamed(pObjSys, &label);
   if (archID == OBJ_NULL)
      Warning(("Unknown archetype %s\n", yypvt[0].strval));
   if (((pArchParams = SchemaPlayParamsGet(archID)) != NULL) &&
      ((pDefaultParams = SchemaPlayParamsGet(baseSchemaID)) != NULL))
   {
      if (schemaPlayParams.flags == pDefaultParams->flags)
         schemaPlayParams.flags = pArchParams->flags;
      if (schemaPlayParams.volume == pDefaultParams->volume)
         schemaPlayParams.volume = pArchParams->volume;
      if (schemaPlayParams.pan == pDefaultParams->pan)
         schemaPlayParams.pan = pArchParams->pan;
      if (schemaPlayParams.initialDelay == pDefaultParams->initialDelay)
         schemaPlayParams.initialDelay = pArchParams->initialDelay;
      if (schemaPlayParams.fade == pDefaultParams->fade)
         schemaPlayParams.fade = pArchParams->fade;
   }
   FreeString(yypvt[0].strval);

} break;

case YYr61: {	/* monoloop :  MONO_LOOP INT INT */

   loopSet = TRUE;
   loopParams.flags &= ~SCHEMA_LOOP_POLY;
   loopParams.maxSamples = 1;
   loopParams.intervalMin = yypvt[-1].ival;
   loopParams.intervalMax = yypvt[0].ival;

} break;

case YYr62: {	/* polyloop :  POLY_LOOP INT INT INT */

   loopSet = TRUE;
   loopParams.flags |= SCHEMA_LOOP_POLY;
   loopParams.maxSamples = yypvt[-2].ival;
   loopParams.intervalMin = yypvt[-1].ival;
   loopParams.intervalMax = yypvt[0].ival;

} break;

case YYr63: {	/* loopcount :  LOOP_COUNT INT */

   loopParams.flags |= SCHEMA_LOOP_COUNT;
   loopParams.count = yypvt[0].ival;

} break;

case YYr64: {	/* audioclass :  AUDIO_CLASS IDENT */

   // @NOTE: this must be in the same order as in schbase.h
   // @NOTE: Max is 16.
   static char *classes[]={"noise","speech","ambient","music","metaui",                   // Originial Thief classes.
                           "player_feet","other_feet","collisions","weapons","monsters"}; // Additional Shock classes.
   bool ok=FALSE;
   int i;

   if (isdigit(yypvt[0].strval[0]))
   {
      int val=yypvt[0].strval[0]-'0';
      schemaPlayParams.flags |= ((val+1)<<SCH_CLASS_SHIFT);
      schemaParamsSet = TRUE;
      ok=TRUE;
   }
   else
      for (i=0; i<sizeof(classes)/sizeof(classes[0]); i++)
      {
         if (stricmp(yypvt[0].strval,classes[i])==0)
         {
            schemaPlayParams.flags |= ((i+1)<<SCH_CLASS_SHIFT);
            schemaParamsSet = TRUE;
            ok=TRUE;
            break;
         }
      }
   if (!ok)
      Warning(("Hey! %s isnt a valid audio class\n",yypvt[0].strval));
   FreeString(yypvt[0].strval);

} break;

case YYr65: {	/* message :  MESSAGE IDENT */

   msgSet = TRUE;
   strncpy(&(msgType.text[0]), yypvt[0].strval, 15);
   msgType.text[15] = '\0';
   FreeString(yypvt[0].strval);

} break;

case YYr66: {	/* tag :  TAG IDENT opt_tag_states */

   int i;
   Label TagNameLabel;

   MakeLabel(&TagNameLabel, yypvt[-1].strval);
   SpeechAddTag(&TagNameLabel);
   for (i = 0; i < g_iNumTagValues; ++i)
      SpeechAddTagValue(&g_aTagValueLabel[i]);

   g_iNumTagValues = 0;
   FreeString(yypvt[-1].strval);

} break;

case YYr71: {	/* tag_state :  IDENT */

   if (g_iNumTagValues == (kMaxTagValues - 1)) {
      mprintf("Hey!  Trying to have more than %d states for one tag.\n",
              kMaxTagValues);
      return 1;
   }

   MakeLabel(&g_aTagValueLabel[g_iNumTagValues], yypvt[0].strval);
   ++g_iNumTagValues;

   FreeString(yypvt[0].strval);

} break;

case YYr72: {	/* tag_int :  TAG_INT IDENT */

   Label TagNameLabel;

   MakeLabel(&TagNameLabel, yypvt[0].strval);
   SpeechAddIntTag(&TagNameLabel);
   FreeString(yypvt[0].strval);

} break;

case YYr73: {	/* env_tag_required :  ENV_TAG_REQUIRED IDENT */

   int i;
   Label TagNameLabel;

   MakeLabel(&TagNameLabel, yypvt[0].strval);
   ESndSetTagRequired(&TagNameLabel);

   FreeString(yypvt[0].strval);

} break;

case YYr74: {	/* schema_voice :  SCHEMA_VOICE IDENT INT IDENT opt_schema_tags */

   Label VoiceLabel, ConceptLabel;
   int i;
   int iWeight = yypvt[-2].ival;

   MakeLabel(&VoiceLabel, yypvt[-3].strval);
   MakeLabel(&ConceptLabel, yypvt[-1].strval);

   SpeechSchemaNewStart(&schemaLabel, g_SchemaID, &VoiceLabel, iWeight,
                        &ConceptLabel);

   for (i = 0; i < g_iNumTagsAdded; ++i) {
      if (g_aTagNumEnums[i])
         SpeechSchemaNewAddEnumTag(&g_aTagNameLabel[i],
                                   &g_aTagEnumLabel[i]);
      else
         SpeechSchemaNewAddIntTag(&g_aTagNameLabel[i],
                                  g_aTagMinInt[i],
                                  g_aTagMaxInt[i]);
   }
   SpeechSchemaNewFinish();

   TagReset();

   FreeString(yypvt[-3].strval);
   FreeString(yypvt[-1].strval);

} break;

case YYr82: {	/* schema_tag_empty :  LPAREN IDENT RPAREN */

   MakeLabel(&g_aTagNameLabel[g_iNumTagsAdded], yypvt[-1].strval);
   g_aTagMinInt[g_iNumTagsAdded] = 0;
   g_aTagMaxInt[g_iNumTagsAdded] = 0xffffffff;
   ++g_iNumTagsAdded;

   FreeString(yypvt[-1].strval);

} break;

case YYr83: {	/* schema_tag_int :  LPAREN IDENT INT INT RPAREN */

   MakeLabel(&g_aTagNameLabel[g_iNumTagsAdded], yypvt[-3].strval);
   g_aTagMinInt[g_iNumTagsAdded] = yypvt[-2].ival;
   g_aTagMaxInt[g_iNumTagsAdded] = yypvt[-1].ival;
   ++g_iNumTagsAdded;

   FreeString(yypvt[-3].strval);

} break;

case YYr84: {	/* schema_tag_enum :  LPAREN IDENT schema_arg schema_args RPAREN */

   MakeLabel(&g_aTagNameLabel[g_iNumTagsAdded], yypvt[-3].strval);
   ++g_iNumTagsAdded;

   FreeString(yypvt[-3].strval);

} break;

case YYr89: {	/* schema_arg :  IDENT */

   if (g_aTagNumEnums[g_iNumTagsAdded] == 8) {
      Warning(("More than eight enums for a schema tag: %s.\n", yypvt[0].strval));
   } else {
      MakeLabel(&g_aTagEnumLabel[g_iNumTagsAdded]
                                [g_aTagNumEnums[g_iNumTagsAdded]], yypvt[0].strval);
      ++g_aTagNumEnums[g_iNumTagsAdded];
   }

   FreeString(yypvt[0].strval);

} break;

case YYr90: {	/* env_tag :  ENV_TAG opt_schema_tags */

   int i;

   ESndSchemaNewStart(&schemaLabel, g_SchemaID);

   for (i = 0; i < g_iNumTagsAdded; ++i) {
      if (g_aTagNumEnums[i])
         ESndSchemaNewAddEnumTag(&g_aTagNameLabel[i],
                                 &g_aTagEnumLabel[i]);
      else
         ESndSchemaNewAddIntTag(&g_aTagNameLabel[i],
                                g_aTagMinInt[i],
                                g_aTagMaxInt[i]);
   }
   ESndSchemaNewFinish();

   TagReset();

} break;

case YYr95: {	/* sample :  IDENT opt_text opt_freq */

   if (samplesNum<SCHEMA_SAMPLES_MAX)
   {
      int nameLen = min(strlen(yypvt[-2].strval), SAMPLE_NAME_LEN-1);
      strncpy(sampleNames[samplesNum], yypvt[-2].strval, nameLen);
      sampleNames[samplesNum][nameLen] = '\0';
      if (freqSet)
      {
         sampleFreqs[samplesNum] = sampleFreq;
         freqSet = FALSE;
      }
      else
         sampleFreqs[samplesNum] = SAMPLE_DEFAULT_FREQ;
      samplesNum++;
   }
   else
      Warning(("Sample %s, too many samples for schema\n", yypvt[-2].strval));

   FreeString(yypvt[-2].strval);

} break;

case YYr98: {	/* text :  STRING */


} break;

case YYr101: {	/* freq :  FREQ INT */

   sampleFreq = (uchar)yypvt[0].ival;
   freqSet = TRUE;

} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}

	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)
		;

	yystate = ~(yyi == *--yyp? YYQYYP: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
/*
#pragma used yyerrlabel
 */
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--;
		yypv--;
#if YYDEBUG
		yytp--;
#endif
	}

yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > yys; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
			if (*yyps >= sizeof yypact/sizeof yypact[0])
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);

			if (YYERRCODE == yyp[-1]) {
				yystate = ~YYQYYP;
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > yys+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin;
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

#ifdef YYALLOC
yyReturn:
	yylval = save_yylval;
	yyval = save_yyval;
	yypvt = save_yypvt;
	yychar = save_yychar;
	yyerrflag = save_yyerrflag;
	yynerrs = save_yynerrs;
	free((char *)yys);
	free((char *)yyv);
	return(retval);
#endif
}

		
#if YYDEBUG
/*
 * Return type of token
 */
int
yyGetType(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}
/*
 * Print a token legibly.
 */
char *
yyptok(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}

/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE
static FILE *yyStatesFile = (FILE *) 0;
static char yyReadBuf[YYMAX_READ+1];

static char *
yygetState(num)
int num;
{
	int	size;

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(yyStates[num+1] - yyStates[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - yyStates[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, yyStates[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yyExpandName(num, isrule, buf, len)
int num, isrule;
char * buf;
int len;
{
	int	i, n, cnt, type;
	char	* endp, * cp;
	char	*s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yyShowState(tp)
yyTraceItems * tp;
{
	short * p;
	YYSTYPE * q;

	printf(
	    gettext("state %d (%d), char %s (%d)\n"),
	      yysmap[tp->state], tp->state,
	      yyptok(tp->lookahead), tp->lookahead);
}
/*
 * show results of reduction
 */
void
yyShowReduce(tp)
yyTraceItems * tp;
{
	printf("reduce %d (%d), pops %d (%d)\n",
		yyrmap[tp->rule], tp->rule,
		tp->states[tp->nstates - tp->npop],
		yysmap[tp->states[tp->nstates - tp->npop]]);
}
void
yyShowRead(val)
int val;
{
	printf(gettext("read %s (%d)\n"), yyptok(val), val);
}
void
yyShowGoto(tp)
yyTraceItems * tp;
{
	printf(gettext("goto %d (%d)\n"), yysmap[tp->state], tp->state);
}
void
yyShowShift(tp)
yyTraceItems * tp;
{
	printf(gettext("shift %d (%d)\n"), yysmap[tp->state], tp->state);
}
void
yyShowErrRecovery(tp)
yyTraceItems * tp;
{
	short	* top = tp->states + tp->nstates - 1;

	printf(
	gettext("Error recovery pops state %d (%d), uncovers %d (%d)\n"),
		yysmap[*top], *top, yysmap[*(top-1)], *(top-1));
}
void
yyShowErrDiscard(tp)
yyTraceItems * tp;
{
	printf(gettext("Error recovery discards %s (%d), "),
		yyptok(tp->lookahead), tp->lookahead);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
// $Header: r:/t2repos/thief2/src/sound/schyacc.h,v 1.2 2000/01/31 10:01:37 adurant Exp $
#pragma once

#ifndef __SCHYACC_H
#define __SCHYACC_H

EXTERN void SchemaYaccParse(char *schemaFile);
EXTERN void SchemaYaccCount(char *schemaFile, int *schemaCount, 
                            int *sampleCount, int *sampleCharCount);
#endif
// $Header: r:/t2repos/thief2/src/sound/sndapp.h,v 1.2 2000/01/31 10:01:38 adurant Exp $
#pragma once

#ifndef __SNDAPP_H
#define __SNDAPP_H

EXTERN void LGAPI sndSysCreate(void);
DEFINE_LG_GUID(IID_Snd, 0x37);

#endif // __SNDAPP_H


// $Header: r:/t2repos/thief2/src/sound/sndgen.cpp,v 1.31 2000/03/05 18:37:46 adurant Exp $

//#define PROFILE_ON

#include <appagg.h>

#include <portal.h>
#include <wrdbrend.h>

#include <propguid.h>

#include <sndgen.h>
#include <sndprop.h>

#include <iobjsys.h>

#include <propman.h>
#include <property.h>
#include <propface.h>
#include <propbase.h>
#include <objpos.h>

#include <schbase.h>
#include <schema.h>

#include <collprop.h>
#include <objmedia.h>
#include <physapi.h>
#include <texprop.h>
#include <locobase.h>
#include <timings.h>
#include <esnd.h>
#include <textarch.h>

// Must be last header 
#include <dbmem.h>


#define COLLISION_SOUND_PROP_NAME_MAX 20

DECLARE_TIMER(FFALL_PCALL, Average);
DECLARE_TIMER(FFALL_PCALL_SOUND, Average);
DECLARE_TIMER(WSWING_PCALL, Average);
DECLARE_TIMER(WCHARGE_PCALL, Average);
DECLARE_TIMER(WSEARCH_PCALL, Average);


static IObjectSystem *pObjSys = NULL;
static IPropertyManager *pPropMan = NULL;

// play sound for object-object collision
void CollisionSoundObjects(ObjID obj1ID, ObjID obj2ID, int collisionResult, float mag)
{
   int coll_type_1;
   int coll_type_2;

   ObjGetCollisionType(obj1ID, &coll_type_1);
   ObjGetCollisionType(obj2ID, &coll_type_2);

   sSchemaCallParams schema_params;
   memset(&schema_params, 0, sizeof(sSchemaCallParams));

   schema_params.flags = SCH_ADD_VOLUME;

   if (!(coll_type_1 & COLLISION_FULL_SOUND) &&
       !(coll_type_2 & COLLISION_FULL_SOUND))
   {
      if (mag > 3000)
         schema_params.volume = 0;
      else
      {
         schema_params.volume = -(3000 - mag);

         if (schema_params.volume < -2500)
            schema_params.volume = -2500;
      }
   }
   else
      schema_params.volume = 0;

   cTagSet Event("Event Collision"); 
   ESndPlayLoc(&Event,obj1ID,obj2ID,&ObjPosGet(obj1ID)->loc.vec,&schema_params); 
}      // @TODO: shouldnt we have a way to override these too? (dc)

// hey, this is all a hack and will change
// play a footstep appropriate to the AI and the texture he's on

// ideally this would use feet_editor too, but that needs
//   a better way to know if in editor or not, so we will wait
//   for real simstate control
EXTERN bool foot_sounds;

//
// @HACK: This has been moved from physics.c so I can get rid of that file.  
//
static int GetTxtIdNearAndUnder(const mxs_vector *pos, const Location *old_loc, mxs_vector *snd_loc)
{
   mxs_vector ray_start, ray_end, delta;
   Location   ray_source, ray_dest, ray_hit;
   int  poly_id, txt_id;

   txt_id = -1;

   mx_copy_vec(&ray_start, (mxs_vector *)pos);
   mx_mk_vec(&delta, 0, 0, -10);
   mx_add_vec(&ray_end, &ray_start, &delta);

   MakeHintedLocationFromVector(&ray_source, &ray_start, (Location *)old_loc);
   MakeHintedLocationFromVector(&ray_dest, &ray_end, (Location *) old_loc);

   if (!PortalRaycast(&ray_source, &ray_dest, &ray_hit, 0))
   {
      if (ray_source.vec.z != ray_hit.vec.z)
      {
         poly_id = PortalRaycastFindPolygon();
         txt_id = WR_CELL(PortalRaycastCell)->render_list[poly_id].texture_id;
      }
      else
         Warning(("GetTxtIdNearAndUnder: out of level?\n"));

      *snd_loc = ray_hit.vec;
      snd_loc->z += 0.2;
   }

   return txt_id;
}

void FootfallSound(const ObjID objID, const mxs_vector *footPos)
{
   AUTO_TIMER(FFALL_PCALL);
   int textureType;

   mxs_vector snd_loc;

   // @TODO: make AIs have better media states
   if (PhysObjInWater(objID))
      return;
   if ((textureType = GetTxtIdNearAndUnder(footPos, &(ObjPosGet(objID)->loc), &snd_loc)) != -1)
   {
      cTagSet Event("Event Footstep");
      ESndPlayLoc(&Event,objID,GetTextureObj(textureType),&snd_loc);
   }
   else
      Warning(("Can't find texture type for AI (%d) footfall at (%g, %g, %g)\n", objID, footPos->x, footPos->y, footPos->z));
}

void WeaponSwingSound(const ObjID objID, const mxs_vector *weaponPos)
{
   AUTO_TIMER(WSWING_PCALL);

   if (PhysObjInWater(objID))
      return;
   cTagSet Event("Event WeaponSwing");
   ESndPlayLoc(&Event, objID, OBJ_NULL, weaponPos);
}

void WeaponChargeSound(const ObjID objID, const mxs_vector *weaponPos)
{
   AUTO_TIMER(WCHARGE_PCALL);

   if (PhysObjInWater(objID))
      return;
   cTagSet Event("Event WeaponCharge");
   ESndPlayLoc(&Event, objID, OBJ_NULL, weaponPos);
}

void SearchSound(const ObjID objID, const mxs_vector *searchPos)
{
   AUTO_TIMER(SEARCH_PCALL);

   if (PhysObjInWater(objID))
      return;
   cTagSet Event("Event Search");
   ESndPlayLoc(&Event, objID, OBJ_NULL, searchPos);
}

void SoundGenInit(void)
{
   if (pPropMan == NULL)
      pPropMan = AppGetObj(IPropertyManager);
   if (pObjSys == NULL)
      pObjSys = AppGetObj(IObjectSystem);
}

void SoundGenShutdown(void)
{
   SafeRelease(pPropMan);
   SafeRelease(pObjSys);
}
// $Header: r:/t2repos/thief2/src/sound/sndgen.h,v 1.10 2000/03/05 18:37:43 adurant Exp $

#pragma once
#ifndef __SNDGEN_H
#define __SNDGEN_H

#include <objtype.h>
#include <propface.h>
#include <matrixs.h>

EXTERN void CollisionSoundObjects(ObjID obj1ID, ObjID obj2ID, int collisionResult, float mag);
EXTERN void FootfallSound(const ObjID objID, const mxs_vector *footPos);
EXTERN void WeaponChargeSound(const ObjID objID, const mxs_vector *weaponPos);
EXTERN void WeaponSwingSound(const ObjID objID, const mxs_vector *weaponPos);
EXTERN void SearchSound(const ObjID objID, const mxs_vector *searchPos);
EXTERN void SoundGenInit(void);
EXTERN void SoundGenShutdown(void);



#endif


///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psnd.cpp,v 1.49 2000/03/22 19:02:42 patmac Exp $
//
// Sound propagation functions
//

//#define PROFILE_ON

#include <lg.h>
#include <config.h>
#include <cfgdbg.h>
#include <timings.h>
#include <mprintf.h>

#include <playrobj.h>
#include <objpos.h>
#include <objedit.h>
#include <appsfx.h>
#include <schprop.h>
#include <iobjnet.h>
#include <netman.h>
#include <lazyagg.h>

#include <hashpp.h>
#include <hshpptem.h>

#include <roomsys.h>
#include <rooms.h>
#include <psnd.h>
#include <psndapi.h>

#include <rendprop.h>

#include <sndnet.h>
#include <sndframe.h>

// Must be last header
#include <dbmem.h>

static LazyAggMember(IObjectNetworking) gpObjNet;
static LazyAggMember(IObjectSystem)     gpObjSys;
static LazyAggMember(INetManager)       gpNetMan;

DECLARE_TIMER(GenSnd, Average);
DECLARE_TIMER(GenSndObj, Average);
DECLARE_TIMER(GenSndVec, Average);
DECLARE_TIMER(GenSndStatic, Average);

////////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER
template cSoundBlockingTable;
#endif

////////////////////////////////////////////////////////////////////////////////

cPropSnd  *g_pPropSnd = NULL;
int        g_SndWatchHandle = -1;

// TBD : Set actual values.
// TBD : Should be in module more closely related to the types themselves?
// TBD : Maybe make function to initialize with (possibly dynamic) values.
int gSoundTypeCaps[] = { 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };

////////////////////////////////////////////////////////////////////////////////

#ifndef SHIP
int num_sounds = 0;
int num_too_far = 0;
#endif

cPropSnd::cPropSnd()
{
   m_SoundInstance = &m_SoundInstHigh;

   for (int i=0; i<kMaxActiveSounds; i++)
      m_SoundList[i] = NULL;

   m_SoundBlockingTable.Clear();

   m_NoSound = config_is_defined("no_sound");

}

////////////////////////////////////////

cPropSnd::~cPropSnd()
{
   SoundHaltAll();

   while (AreSounds())
   {
      #ifndef SHIP
      if (config_is_defined("SoundSpew"))
         mprintf("Waiting for active sounds to finish\n");
      #endif
   }

   m_SoundBlockingTable.Clear();

   #ifndef SHIP
   if (config_is_defined("too_far_sound_count") && (num_sounds > 0))
      mprintf("%d sounds generated, %d too far away (%g%%)\n", num_sounds, num_too_far, 
              100.0 * (float)num_too_far / (float)num_sounds);
   #endif
}

////////////////////////////////////////

//
// These two functions initialize the sound instance, propagate the sound,
// and return a handle, which is the address of the list of sounds that the
// player hears (if the sound is audible to the player)
//

int cPropSnd::GenerateSound(ObjID objID, ObjID schemaID, const char *sampleName, float atten_factor, 
                            sfx_parm *parms, int flags, void *data)
{
   int handle;

   if (ObjPosGet(objID) == NULL)
   {
      Warning(("GenerateSound::Attempt to play on obj w/o position (%s)!\n",ObjEditName(objID)));
      return kPSndFail;
   }

   if (ShouldPlaySound(parms, flags, TRUE, objID))
   {
      // I'm not generating a Warning here because we expect some things (like AI projectiles) 
      // to actually do this. 
      if (!ObjHasRefs(objID))
         return kPSndFail;

      if ((handle = GetSoundHandle()) == -1)
      {
         Warning(("No free handles for GenerateSound\n"));
         return kPSndFail;
      }
  
      return GenerateSoundHandle(handle, objID, schemaID, sampleName, atten_factor, 
                                 parms, kGSF_WantHandle | flags, data);
   }
   else
   {
#ifndef SHIP
      if (config_is_defined("SoundGhostSpew"))
      {
         mprintf("Failing to play %s,\n", sampleName);
         mprintf("  parms->flag = 0x%x\n", parms->flag);
         mprintf("  flags = 0x%x\n", flags);
#ifdef NEW_NETWORK_ENABLED
         mprintf("  proxy(%d) = %d\n", objID, gpObjNet->ObjIsProxy(objID));
#endif
      }
#endif
      return kPSndFail;
   }
}


int cPropSnd::GenerateSoundHandle(int handle, ObjID objID, ObjID schemaID, const char *sampleName, 
                                  float atten_factor, sfx_parm *parms, int flags, void *data)
{
   AUTO_TIMER(GenSnd);
   AUTO_TIMER(GenSndObj);

   AutoAppIPtr_(ObjectSystem, pObjSys);

   if (!pObjSys->Exists(objID))
   {
#ifndef SHIP
      mprintf("WARNING: Attempt to play sound %s on nonexistant object %d!\n", sampleName, objID);
#endif
      return kPSndFail;
   }

   cRoom *start_room = g_pRooms->GetObjRoom(objID);

   // Deal with starting outside the room database
   if (start_room == NULL)
   {
      #ifndef SHIP
      if (!config_is_defined("QuietSoundRooms"))
         mprintf("\"%s\" on %s (%g %g %g) not in room!\n",
                 sampleName, ObjWarnName(objID), ObjPosGet(objID)->loc.vec.x, 
                 ObjPosGet(objID)->loc.vec.y, ObjPosGet(objID)->loc.vec.z);
      #endif

      return kPSndFail;
   }

   // we could point this at a low-definition version, if we ever cared, which we don't
   m_SoundInstance = &m_SoundInstHigh;

   // @TODO: need some way to say whether this is the inital sound or not!

   int init_flags = kSIF_OnObject | ((flags & kGSF_NetSent) ? kSIF_NetSent : kSIF_None) |
                                    ((flags & kGSF_Networked) ? kSIF_Networked : kSIF_None) |
                                    ((flags & kGSF_ForcePlay) ? kSIF_ForcePlay : kSIF_None);

   // Init the sound instance
   m_SoundInstance->Init(handle, objID, ObjPosGet(objID)->loc.vec, schemaID, sampleName, 
                         init_flags, atten_factor, parms, data);

   #ifndef SHIP
   if (config_is_defined("too_far_sound_count"))
   {
      float dist = 0;
      config_get_float("too_far_sound_count", &dist);

      if (mx_dist_vec(&ObjPosGet(PlayerObject())->loc.vec, &ObjPosGet(objID)->loc.vec) > dist)
         num_too_far++;
      num_sounds++;
   }
   #endif

   // Do the propagation
   m_PropAgent.SetFunctions(m_SoundInstance);
   m_PropAgent.PropagateBF(ObjPosGet(objID)->loc.vec, g_pRooms->GetObjRoom(objID));

   if ((flags & kGSF_WantHandle) && !m_NoSound)
   {
      cPlayerSoundList* pPlayerList = GeneratePlayerSoundList(handle);
      if (pPlayerList == NULL)
      {
         #ifndef SHIP
         if (config_is_defined("SoundFullSpew"))
            mprintf("GenSoundHandle: %s on %s failed to propagate to the player\n",
                    sampleName, ObjWarnName(objID));
         #endif            

         // Make a cSoundInfo and defer it, if we're a looped sample
         if (parms->flag & SFXFLG_LOOP)
         {
            cPlayerSoundList *pPlayerSoundList = new cPlayerSoundList;
            cSoundInfo *pSoundInfo = new cSoundInfo;

            pPlayerSoundList->Append(pSoundInfo);

            pPlayerSoundList->SchemaCallback = parms->end_callback;
            pPlayerSoundList->SchemaUserData = parms->user_data;

            parms->distance = -1;
            parms->end_callback = EndSampleCallback;
            parms->user_data = (void *)handle;

            // TODO : Fill with real values?
            parms->pri = 128;

            pSoundInfo->SchemaID = schemaID;
            pSoundInfo->SrcObject = objID;
            pSoundInfo->SrcPoint = ObjPosGet(objID)->loc.vec;
            pSoundInfo->Object = PlayerObject();
            strncpy (pSoundInfo->SampleName, sampleName, 16);
            pSoundInfo->AppsfxParms = *parms;
            pSoundInfo->AttenFactor = atten_factor;

            pSoundInfo->flags |= kSIF_OnObject|kSIF_Deferred;
            pSoundInfo->Handle = handle;

            RegisterSound(handle, pPlayerSoundList);

            #ifndef SHIP
            if (config_is_defined("SoundFullSpew"))
               mprintf("  looping sample, so deferred (handle %d)\n", handle);
            #endif
            
            return handle;
         }
         else
         {
            #ifndef SHIP
            if (config_is_defined("SoundFullSpew"))
               mprintf("  non-looping sample, so failing\n");
            #endif
   
            return kPSndFail;
         }
      }

      #ifndef SHIP
      if (config_is_defined("SoundSpew"))
         mprintf( "Playing object sound on %s.\n", ObjWarnName(objID) );
      #endif

      SNDFrameAddObj( objID );

      m_SoundInstance->SetupPlayerSoundListCallbacks(pPlayerList);

      switch (Prioritize(pPlayerList))
      {
         case PRIORITY_RES_OK:
            if (!m_SoundInstance->PlaySoundList(pPlayerList))
            {
               delete pPlayerList->Remove(pPlayerList->GetFirst());
               delete pPlayerList;
               return kPSndFail;
            }
            break;
         case PRIORITY_RES_DEFERRED:
            if (pPlayerList->GetFirst())
               pPlayerList->GetFirst()->flags |= kSIF_Deferred;
            break;
         case PRIORITY_RES_FAIL:
            delete pPlayerList->Remove(pPlayerList->GetFirst());
            delete pPlayerList;
            return kPSndFail;
      }

      RegisterSound(handle, pPlayerList);

      return handle;
   }
   else
   {
      if (flags & kGSF_WantHandle)
         return kPSndFail;
      else
         return handle;
   }
}

int cPropSnd::GenerateSound(mxs_vector &vec, ObjID src_obj, ObjID schemaID, const char *sampleName, 
                            float atten_factor,sfx_parm *parms, int flags, void *data)
{
   int handle;

   if (ShouldPlaySound(parms, flags, FALSE, src_obj))
   {
      if ((handle = GetSoundHandle()) == -1)
      {
         Warning(("No free handles for GenerateSound\n"));
         return kPSndFail;
      }

      return GenerateSoundHandle(handle, vec, src_obj, schemaID, sampleName, atten_factor, 
                                 parms, kGSF_WantHandle | flags, data);
   }
   else
   {
#ifndef SHIP
      if (config_is_defined("SoundGhostSpew"))
      {
         mprintf("Failing to play %s,\n", sampleName);
         mprintf("  parms->flag = 0x%x\n", parms->flag);
         mprintf("  flags = 0x%x\n", flags);
         mprintf("  exists(%d) = %d, defaulthost = %d\n", src_obj, gpObjSys->Exists(src_obj), 
                 gpNetMan->AmDefaultHost());
#ifdef NEW_NETWORK_ENABLED
         mprintf("  proxy(%d) = %d\n", src_obj, gpObjNet->ObjIsProxy(src_obj));
#endif
      }
#endif
      return kPSndFail;
   }
} 

int cPropSnd::GenerateSoundHandle(int handle, mxs_vector &vec, ObjID src_obj, ObjID schemaID, 
                                  const char *sampleName, float atten_factor,
                                  sfx_parm *parms, int flags, void *data)
{
   AUTO_TIMER(GenSnd);
   AUTO_TIMER(GenSndVec);

   cRoom *start_room = g_pRooms->GetObjRoom(src_obj);

   if ((start_room == NULL) || (!start_room->PointInside(vec)))
      start_room = g_pRooms->RoomFromPoint(vec);

   // Deal with starting outside the room database
   if (start_room == NULL)
   {
      #ifndef SHIP
      if (!config_is_defined("QuietSoundRooms"))
         mprintf("\"%s\" on %s (vec %g %g %g) not in room!\n",
                 sampleName, ObjWarnName(src_obj), vec.x, vec.y, vec.z);
      #endif

      return kPSndFail;
   }

   m_SoundInstance = &m_SoundInstHigh;

   int init_flags = kSIF_None | ((flags & kGSF_NetSent) ? kSIF_NetSent : kSIF_None) |
                                ((flags & kGSF_Networked) ? kSIF_Networked : kSIF_None) |
                                ((flags & kGSF_ForcePlay) ? kSIF_ForcePlay : kSIF_None);

   // Init sound instance
   m_SoundInstance->Init(handle, src_obj, vec, schemaID, sampleName, init_flags, atten_factor, parms, data);

   #ifndef SHIP
   if (config_is_defined("too_far_sound_count"))
   {
      float dist = 0;
      config_get_float("too_far_sound_count", &dist);

      if (mx_dist_vec(&ObjPosGet(PlayerObject())->loc.vec, &vec) > dist)
         num_too_far++;
      num_sounds++;
   }
   #endif

   // Do the propagation
   m_PropAgent.SetFunctions(m_SoundInstance);
   m_PropAgent.PropagateBF(vec, start_room);

   if ((flags & kGSF_WantHandle) && !m_NoSound)
   {
      cPlayerSoundList* pPlayerList = GeneratePlayerSoundList(handle);
      if (pPlayerList == NULL)
      {
         #ifndef SHIP
         if (config_is_defined("SoundFullSpew"))
            mprintf("GenSoundHandle: %s on %s failed to propagate to the player\n",
                    sampleName, ObjWarnName(src_obj));
         #endif            

         // Make a cSoundInfo and defer it, if we're a looped sample
         if (parms->flag & SFXFLG_LOOP)
         {
            cPlayerSoundList *pPlayerSoundList = new cPlayerSoundList;
            cSoundInfo *pSoundInfo = new cSoundInfo;

            pPlayerSoundList->Append(pSoundInfo);

            pPlayerSoundList->SchemaCallback = parms->end_callback;
            pPlayerSoundList->SchemaUserData = parms->user_data;

            parms->distance = -1;
            parms->end_callback = EndSampleCallback;
            parms->user_data = (void *)handle;

            // TODO : Fill with real values?
            parms->pri = 128;

            pSoundInfo->SrcObject = src_obj;
            pSoundInfo->SrcPoint = vec;
            pSoundInfo->Object = PlayerObject();
            strncpy (pSoundInfo->SampleName, sampleName, 16);
            pSoundInfo->AppsfxParms = *parms;

            pSoundInfo->flags |= kSIF_Deferred;
            pSoundInfo->Handle = handle;

            RegisterSound(handle, pPlayerSoundList);

            #ifndef SHIP
            if (config_is_defined("SoundSpew"))
               mprintf("  looping sample, so deferred (handle %d)\n", handle);
            #endif
            
            return handle;
         }
         else
         {
            #ifndef SHIP
            if (config_is_defined("SoundFullSpew"))
               mprintf("  non-looping sample, so failing\n");
            #endif
   
            return kPSndFail;
         }

         return kPSndFail;
      }

      m_SoundInstance->SetupPlayerSoundListCallbacks(pPlayerList);
      
      #ifndef SHIP
      if (config_is_defined("SoundSpew"))
         mprintf( "Playing vector sound on %s.\n", ObjWarnName(src_obj) );
      #endif

      SNDFrameAddObj( src_obj );

      switch (Prioritize (pPlayerList))
      {
         case PRIORITY_RES_OK:
            if (!(m_SoundInstance->PlaySoundList(pPlayerList)))
            {
               delete pPlayerList->Remove(pPlayerList->GetFirst());
               delete pPlayerList;
               return kPSndFail;
            }
            break;
         case PRIORITY_RES_DEFERRED:
            if (pPlayerList->GetFirst())
               pPlayerList->GetFirst()->flags |= kSIF_Deferred;
            break;
         case PRIORITY_RES_FAIL:
            delete pPlayerList->Remove(pPlayerList->GetFirst());
            delete pPlayerList;
            return kPSndFail;
      }

      RegisterSound (handle, pPlayerList);  

      return handle;
   }
   else
   {
      if (flags & kGSF_WantHandle)
         return kPSndFail;
      else
         return handle;
   }
}

int cPropSnd::GenerateSound(const char *sampleName, sfx_parm *parms)
{
   AUTO_TIMER(GenSnd);
   AUTO_TIMER(GenSndStatic);

   cPlayerSoundList *pPlayerList;
   cSoundInfo       *pSoundInfo;

   int handle;

   if ((handle = GetSoundHandle()) == -1)
   {
      Warning(("No free handles for GenerateSound\n"));
      return kPSndFail;
   }

#ifdef NEW_NETWORK_ENABLED
   if (parms->flag & SFXFLG_NET_AMB)
   {
      // Tell the other players to play this sound
      SoundNetGenerateSound(handle, 
                            sampleName,
                            parms);
   }
#endif

   // Create a dummy sound list, so we can be part of the psnd world
   pPlayerList = new cPlayerSoundList;
   pSoundInfo = new cSoundInfo;

   pPlayerList->Append(pSoundInfo);

   pPlayerList->SchemaCallback = parms->end_callback;
   pPlayerList->SchemaUserData = parms->user_data;

   parms->distance = -1;
   parms->end_callback = EndSampleCallback;
   parms->user_data = (void *)handle;

   pSoundInfo->Object = PlayerObject();
   pSoundInfo->Handle = handle;

   strncpy (pSoundInfo->SampleName, sampleName, 16);
   pSoundInfo->AppsfxParms = *parms;

   pSoundInfo->flags |= kSIF_Static;

   switch (Prioritize(pPlayerList))
   {
      case PRIORITY_RES_OK:
         pSoundInfo->SFXHandle = SFX_Play_Raw(SFX_STATIC, parms, (char *)sampleName);

         if (pSoundInfo->SFXHandle == SFX_NO_HND)
         {
            Warning(("\"%s\" failed to play\n", sampleName));

            delete pPlayerList->Remove(pSoundInfo);
            delete pPlayerList;
            return kPSndFail;
         }
         else
         {
            // Find unused active sound object
            m_SoundInstance->AddActiveSound(pSoundInfo);

            #ifndef SHIP
            if (config_is_defined("SoundSpew"))
               mprintf(" \"%s\" is statically started (handle = %d, sfxhandle = %d)\n", sampleName, handle, pSoundInfo->SFXHandle);
            #endif
         }
         break;
      case PRIORITY_RES_DEFERRED:
         pSoundInfo->flags |= kSIF_Deferred;
         break;
      case PRIORITY_RES_FAIL:
         delete pPlayerList->Remove(pSoundInfo);
         delete pPlayerList;
         return kPSndFail;
   }

   RegisterSound(handle, pPlayerList);

   return handle;
}

////////////////////////////////////////////////////////////////////////////////

void cPropSnd::SoundHalt(int handle)
{
   cPlayerSoundList *pPlayerList;
   cSoundInfo       *pSoundInfo;

   if (m_NoSound)
      return;

   // Make sure the handle is valid
   if((pPlayerList = GetSound(handle)) == NULL)
   {
      Warning (("Called SoundHalt with handle %d, which is NULL\n", handle));
#ifndef SHIP
      SpewSounds();
#endif
      return;
   }

#ifdef NEW_NETWORK_ENABLED
   SoundNetHalt(handle);
#endif
   
   // Tell the sample to stop playing
   pSoundInfo = pPlayerList->GetFirst();

   if (pSoundInfo->flags & kSIF_Deferred)
   {
      // Spoof an end sample callback to schema
      if (pPlayerList->SchemaCallback != NULL)
         pPlayerList->SchemaCallback(handle, pPlayerList->SchemaUserData);

      // We're deferred, so we're not really playing, so just clean up
      delete pPlayerList->Remove(pSoundInfo);
      delete pPlayerList;

      RemoveSound(handle);
   }
   else
      SFX_Kill_Hnd(pSoundInfo->SFXHandle);
}

////////////////////////////////////////

void cPropSnd::SoundHaltObj(ObjID objID)
{
   cDynArray<int> handleKillList;
   sSoundInfo *pSoundInfo;
   int i;

   for (i=0; i<kMaxActiveSounds; i++)
   {
      if (m_SoundList[i])
      {
         pSoundInfo = m_SoundList[i]->GetFirst();

         if ((pSoundInfo->SrcObject == objID) && (pSoundInfo->flags & kSIF_OnObject))
            handleKillList.Append(m_SoundList[i]->GetFirst()->Handle);
      }
   }

   for (i=0; i<handleKillList.Size(); i++)
      SoundHalt(handleKillList[i]);
}

////////////////////////////////////////

void cPropSnd::SoundHaltAll()
{
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_SoundList[i] != NULL)
         SoundHalt(i);
   }
}

////////////////////////////////////////

BOOL cPropSnd::AreSounds()
{
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_SoundList[i] != NULL)
         return TRUE;
   }

   return FALSE;
}

////////////////////////////////////////////////////////////////////////////////

int cPropSnd::GetSoundHandle()
{
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_SoundList[i] == NULL)
         return i;
   }

   return -1;
}

////////////////////////////////////////

int cPropSnd::FindSound(cPlayerSoundList *pSoundList)
{
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_SoundList[i] == pSoundList)
         return i;
   }

   return -1;
}

////////////////////////////////////////////////////////////////////////////////

void cPropSnd::BlockAdjacentRooms(short roomID1, short roomID2, mxs_real factor)
{
   if ((roomID1 > g_pRooms->GetNumRooms()) || (roomID2 > g_pRooms->GetNumRooms()))
      return;

   cRoom *pRoom1 = g_pRooms->GetRoom(roomID1);
   cRoom *pRoom2 = g_pRooms->GetRoom(roomID2);
   short  r1, r2;
   int  i, j;

   for (i=0; i<pRoom1->GetNumPortals(); i++)
   {
      for (j=0; j<pRoom2->GetNumPortals(); j++)
      {
         r1 = pRoom1->GetPortal(i)->GetFarRoom()->GetRoomID();
         r2 = pRoom2->GetPortal(j)->GetFarRoom()->GetRoomID();

         if (r1 == r2)
         {
            if (factor >= 0)
            {
               SetBlockingFactor(roomID1, r1, factor, FALSE);
               SetBlockingFactor(roomID2, r1, factor, FALSE);
            }
            else
            {
               RemoveBlockingFactor(roomID1, r1, FALSE);
               RemoveBlockingFactor(roomID2, r1, FALSE);
            }
         }
      }
   }
}

////////////////////////////////////////

void cPropSnd::SetBlockingFactor(short roomID1, short roomID2, mxs_real factor, BOOL blockAdjacent)
{
   long key;

   if (blockAdjacent)
      BlockAdjacentRooms(roomID1, roomID2, factor);

   key = roomID1 << 16 | roomID2;
   m_SoundBlockingTable.Set(key, factor);

   key = roomID2 << 16 | roomID1;
   m_SoundBlockingTable.Set(key, factor);
}

////////////////////////////////////////

void cPropSnd::RemoveBlockingFactor(short roomID1, short roomID2, BOOL blockAdjacent)
{
   long key;

   if (blockAdjacent)
      BlockAdjacentRooms(roomID1, roomID2, -1);

   key = roomID1 << 16 | roomID2;
   m_SoundBlockingTable.Delete(key);

   key = roomID2 << 16 | roomID1;
   m_SoundBlockingTable.Delete(key);
}

////////////////////////////////////////

mxs_real cPropSnd::GetBlockingFactor(short roomID1, short roomID2)
{
   long     key;
   mxs_real value;

   key = roomID1 << 16 | roomID2;
   if (m_SoundBlockingTable.Lookup(key, &value))
      return value;
   else
      return 0.0;
}

/////////////////////////////////////////

BOOL cPropSnd::ShouldPlaySound(const sfx_parm *pParms, int flags, BOOL onObject, ObjID srcObject) const
{
#ifdef NEW_NETWORK_ENABLED
   // Always want to play:
   // - a sound that's non-networked
   // - a sound a network message has told us to play
   // - a sound that we've been forced to play
   if ((pParms->flag & SFXFLG_NO_NET) || 
       (flags & kGSF_Networked) || 
       (flags & kGSF_ForcePlay))
      return TRUE;

   if (onObject)
   {
      // Object based sounds are played if we own the object or 
      // the object is local only (== !Proxy)
      return !gpObjNet->ObjIsProxy(srcObject);
   }
   else
   {
      // Vector based sounds are played if the object exists and
      // we own it or it's local only (== !Proxy), or if the object doesn't exist and we're the
      // default host
      return ((srcObject == OBJ_NULL || !gpObjSys->Exists(srcObject)) && gpNetMan->AmDefaultHost()) ||
              (gpObjSys->Exists(srcObject) && !gpObjNet->ObjIsProxy(srcObject));
   }
#else
   // TBD - is this the right thing for no-network? patmc
   return TRUE;
#endif
}

/////////////////////////////////////////

BOOL cPropSnd::ShouldNetworkSound(const sfx_parm *pParms, int flags, BOOL onObject, ObjID srcObject) const
{
#ifdef NEW_NETWORK_ENABLED
   // Never want to network:
   // - a sound we've already networked
   // - a sound that a network message has caused us to play
   // - a sound that is marked as non-networked
   // - a sound from a LocalOnly object
   if ((flags & kSIF_NetSent) ||
       (flags & kSIF_Networked) ||
       (pParms->flag & SFXFLG_NO_NET) ||
       (gpObjSys->Exists(srcObject) && gpObjNet->ObjLocalOnly(srcObject)))
      return FALSE;

   // After that initial filter, always network sounds that we've
   // been forced to play 
   if (flags & kSIF_ForcePlay)
      return TRUE;

   if (onObject)
   {
      // Object-based sounds are networked if we own the object
      return gpObjNet->ObjHostedHere(srcObject);
   }
   else
   {
      // Vector based sounds are networked if the object exists and we own it,
      // or it doesn't exist be we're the default host
      return ((gpObjSys->Exists(srcObject) && gpObjNet->ObjHostedHere(srcObject))) ||
             (((srcObject == OBJ_NULL) || !gpObjSys->Exists(srcObject)) && gpNetMan->AmDefaultHost());
   }
#else
   return FALSE;
#endif
}

/////////////////////////////////////////


// Prioritize determines the prioritized status of a sound that
// would like to be played.  If the new sound bumps an existing
// sound, then it does the bumping.

PrioritizationResult cPropSnd::Prioritize(const cPlayerSoundList* pPlayerList)
{
   const cSoundInfo *pSoundInfo = pPlayerList->GetFirst();
   int thisPri, bumpPri;
   PrioritizationResult retVal  = PRIORITY_RES_OK;
   uchar thisSoundType          = pSoundInfo->AppsfxParms.group;
   uchar thisSoundPriority      = pSoundInfo->AppsfxParms.pri;

   // Check for cap on type.
   bool typeCapReached = TypeCapReached (thisSoundType);

   // Check for any available channels.
   bool channelAvail = SFX_IsChannelAvail();

   #ifndef SHIP
   if (config_is_defined("SoundListSpew"))
   {
      mprintf(" channel avail = %d\n", SFX_IsChannelAvail());
      mprintf(" %d channels playing\n", SFX_Channel_Count());
      SpewSounds();
   }
   #endif

   // Basic concept: Fail if either we have reached the cap or if channels are full
   // and our priority is too low to matter.  We're OK if we haven't reached cap and
   // a channel is avail.  Bump another channel and return OK if we haven't reached
   // the cap and there is a lower priority sound playing.
   if ((!channelAvail) || typeCapReached)
   {
      // Select a bump candidate pased on the existing channels' effective priorities.
      // Notice that if both occur (i.e. !channelAvail && typeCapReached), we use
      // typeCapReached as candidate seletor.  This should guarantee that we never
      // exceed type caps.
      cPlayerSoundList* pBumpCandidate;
      if (typeCapReached)
      {
         #ifndef SHIP
         if (config_is_defined("SoundPriSpew"))
            mprintf("SoundPri: Type cap reached on type %d\n", thisSoundType);
         #endif

         pBumpCandidate = LowestPrioritySoundOfType(thisSoundType, &bumpPri);
      }
      else
      {
         #ifndef SHIP
         if (config_is_defined("SoundPriSpew"))
            mprintf("SoundPri: No channels available\n");
         #endif

         pBumpCandidate = LowestPrioritySound(&bumpPri);
      }

      // Under no conditions should pBumpCandidate be NULL at this point.
      AssertMsg (pBumpCandidate != NULL, "In PSound, Prioritize() Could not find a bump candidate.");

      // Calculate this sound's priority.
      thisPri = EffectivePriority(pPlayerList);

      #ifndef SHIP
      if (config_is_defined("SoundPriSpew"))
         mprintf("SoundPri: New sound priority: %d, bump candidate priority: %d\n", thisPri, bumpPri);
      #endif

      // If this sound is lower or equal priority, we either fail or defer, depending on
      // the type of sound.  This is so that schema is informed or faked
      // properly.
      if (thisPri <= bumpPri)
      {
         if (pSoundInfo->AppsfxParms.flag & SFXFLG_LOOP)
         {
            #ifndef SHIP
            if (config_is_defined("SoundPriSpew"))
               mprintf("SoundPri: New < Candidate: Deferring %s (handle %d).\n", pSoundInfo->SampleName, pSoundInfo->Handle);
            #endif

            retVal = PRIORITY_RES_DEFERRED;
         }
         else
         {
            #ifndef SHIP
            if (config_is_defined("SoundPriSpew"))
               mprintf("SoundPri: New < Candidate: Failing new non-looping sound.\n");
            #endif

            retVal = PRIORITY_RES_FAIL;
         }
      }
      else
      {
         // If it's a sample-looped sound, we have to bump and defer.
         if (pBumpCandidate->GetFirst()->AppsfxParms.flag & SFXFLG_LOOP)
         {
            #ifndef SHIP
            if (config_is_defined("SoundPriSpew"))
               mprintf("SoundPri: Bumping %s (sfxhandle %d) onto deferred list\n", 
                       pBumpCandidate->GetFirst()->SampleName, 
                       pBumpCandidate->GetFirst()->SFXHandle);
            #endif

            BumpActiveSound(pBumpCandidate);
            Assert_(pBumpCandidate->GetFirst()->SFXHandle == -1);
         }
         // All other (non sample-looped) sounds can just get bumped.
         else
         {
            #ifndef SHIP
            if (config_is_defined("SoundPriSpew"))
               mprintf("SoundPri: Bumping %s (sfxhandle %d)\n", 
                       pBumpCandidate->GetFirst()->SampleName,
                       pBumpCandidate->GetFirst()->SFXHandle);
            #endif

            SFX_Kill_Hnd(pBumpCandidate->GetFirst()->SFXHandle);
         }
      }
   }

   return retVal;
}

///////////////////////////////////////

BOOL cPropSnd::TypeCapReached(uchar type)
{
   cPlayerSoundList *pSoundList;
   int soundTypeCount = 0;

   // Count sounds that have the same category.
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      pSoundList = GetSound(i);

      if (pSoundList && !(pSoundList->GetFirst()->flags & kSIF_Deferred) &&
          (m_SoundList[i]->GetFirst()->AppsfxParms.group == type))
         soundTypeCount++;
   }

#ifndef SHIP
   Assert_((type >= 0) && (type < (sizeof(gSoundTypeCaps)) / (sizeof(gSoundTypeCaps[0]))));

   if (soundTypeCount > gSoundTypeCaps[type])
   {
      if (config_is_defined("SoundPriSpew"))
         Warning (("Prioritization: Sound type max has been exceeded on type %d\n", (int) type));
      type = 0;
   }
#endif

   // Check against sound type caps.
   return (soundTypeCount > gSoundTypeCaps[type]);
}

///////////////////////////////////////

cPlayerSoundList* cPropSnd::LowestPrioritySoundOfType (uchar type, int* itsEffectivePriority)
{
   cPlayerSoundList* retVal = NULL;
   int iterEffectivePriority;

   // Loop through all sounds.
   for ( int i=0; i<kMaxActiveSounds; i++ )
   {
      // Only look for sounds which match this one's type.
      if ( m_SoundList[i] != NULL )
      {
         cSoundInfo* pSoundInfo = m_SoundList[i]->GetFirst();
         if ( (!(pSoundInfo->flags & kSIF_Deferred)) &&
              (pSoundInfo->AppsfxParms.group == type) )
         {
            // Calculate the iterator sound's effective priority.
            iterEffectivePriority = EffectivePriority (m_SoundList[i]);
         
            // If it's the first one found, then it's the lowest.
            if (retVal == NULL)
            {
               retVal = m_SoundList[i];
               *itsEffectivePriority = iterEffectivePriority;
            }
            // Compare against previous lowest and replace if it's lower.
            else if (iterEffectivePriority < *itsEffectivePriority)
            {
               retVal = m_SoundList[i];
               *itsEffectivePriority = iterEffectivePriority;
            }
         }
      }
   }

   return retVal;
}

////////////////////////////////////////

cPlayerSoundList* cPropSnd::LowestPrioritySound (int* itsEffectivePriority)
{
   cPlayerSoundList* retVal = NULL;
   int iterEffectivePriority;

   // Loop through all sounds.
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if ( m_SoundList[i] != NULL )
      {
         cSoundInfo* pSoundInfo = m_SoundList[i]->GetFirst();
         if ( !(pSoundInfo->flags & kSIF_Deferred))
         {
            // Calculate the iterator sound's effective priority.
            iterEffectivePriority = EffectivePriority (m_SoundList[i]);
      
            // If it's the first one found, then it's the lowest.
            if (retVal == NULL)
            {
               retVal = m_SoundList[i];
               *itsEffectivePriority = iterEffectivePriority;
            }
            // Compare against previous lowest and replace if it's lower.
            else if (iterEffectivePriority < *itsEffectivePriority)
            {
               retVal = m_SoundList[i];
               *itsEffectivePriority = iterEffectivePriority;
            }
         }
      }
   }
   return retVal;
}

////////////////////////////////////////

// This is the algorithm for combining whatever it is about a sound that determines
// its effective (i.e. net) priority value.  Currently based on effective volume and
// schema priority value.

int cPropSnd::EffectivePriority(const cPlayerSoundList* pPlayerList)
{
   const cSoundInfo *pSoundInfo = pPlayerList->GetFirst();
   int retVal;

   int priority = pSoundInfo->AppsfxParms.pri;
   int volume = pSoundInfo->Volume;

   // Do tests for bad values of volume and / or priority
   if (priority < 0)
   {
      Warning(("Prioritization : Given a priority of %d, Out of range [0..255].", priority));
      priority = 0;
   }

   if ((volume < -10000) || (volume > 0))
   {
      Warning (("Prioritization : Given a volume of %d, Out of range [-10000..0].", (int) pSoundInfo->Volume));
      volume = -5000;
   }

   // Prioritization function:
   //
   // Effective priority is (mathematically) a function of 2 variables : schema priority
   // and effective volume.  Upon discussion with Eric the sound guy, it makes sense for
   // this function to yield guaranteed max and min effective priorities from maximum and
   // minimum schema priorities, respectively.  If the schema priority is not one of these,
   // it can approach, but never reach, either max or min.  "Normal" (or middle) schema
   // priority, is linear with volume, yielding a range from a notch above absolute
   // minimum to a notch below maximum.  Lower than normal schema priority gives a function
   // that is linear with volume, but ranging from a notch above minimum to some value in
   // middle, scalar with the schema priority.  Higher than normal schema priority gives a function
   // linear with volume, ranging from somewhere in the middle to a notch below maximum.
   // This results in a function of two variables that is continuous over both dimensions
   // except for when schema priority is max or min.
   // Summarily:
   //   ep(p, v)=       max_ep if p == max_p
   //                   min_ep if p == min_p
   //                   m(p)*v + b(p) // (eq. for a line as a function of p)
   //
   float fNormalizedEP;
   float fMinPri, fPriRange;

   // Force max or min.
   if (priority == SCH_PRIORITY_MAX)
      return EFF_PRI_MAX;
   if (priority == SCH_PRIORITY_MIN)
      return EFF_PRI_MIN;

   // Normal priority is purely linear with volume.
   if (priority == SCH_PRIORITY_NORMAL)
      // Simple linear with volume.
      fNormalizedEP = ((float) (volume + 10000)) * ( 1.0F / 10000.0F ); // Normalize to [0..1]
   else
   {
      // Smaller slope for non-normal priority.
      if (priority < SCH_PRIORITY_NORMAL)
      {
         fMinPri = 0.0F;
         fPriRange = (float)priority / (float) SCH_PRIORITY_NORMAL;
      }
      else
      {
         fMinPri = ((float)priority - (float) SCH_PRIORITY_NORMAL) / (float) SCH_PRIORITY_NORMAL;
         fPriRange = 1.0 - fMinPri;
      }

      fNormalizedEP = ((float) (volume + 10000)) * (1.0F / 10000.0F) *            // Normalize to [0..1]
                       fPriRange +                                                              // Find spot on ramp.
                       fMinPri;                                                                 // Add base of ramp.
   }

   // Adjust to discrete values.
   retVal = (int) ( fNormalizedEP *
                    (float) (EFF_PRI_MAX - EFF_PRI_MIN) +                                     // Scale to full range.
                    (float) EFF_PRI_MIN );                                                    // Add in base level.

   // Clip to range (MIN..MAX)
   if (retVal >= EFF_PRI_MAX)
      retVal = EFF_PRI_MAX - 1;
   else if (retVal <= EFF_PRI_MIN)
      retVal = EFF_PRI_MIN + 1;

   return retVal;
}

////////////////////////////////////////

void cPropSnd::BumpActiveSound(cPlayerSoundList *pPlayerList)
{
   m_SoundInstance->BumpActiveSound(pPlayerList);
}

////////////////////////////////////////

#ifndef SHIP
void cPropSnd::SpewActiveSounds()
{
   Assert_(m_SoundInstance);
   char buff[256];

   mprintf("Sound List:\n");

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      cPlayerSoundList *pPlayerList;

      if ((pPlayerList = GetSound(i)) != NULL)
      {
         cSoundInfo *pSoundInfo = pPlayerList->GetFirst();

         sprintf(buff, " [%2d] %13s  sfxhandle %2d  obj %4d  group %2d  dist %5g  %s", i, 
                 pSoundInfo->SampleName, pSoundInfo->SFXHandle, 
                 pSoundInfo->SrcObject, pSoundInfo->AppsfxParms.group, pSoundInfo->Distance,
                 pSoundInfo->flags & kSIF_Deferred ? "(deferred)" : "");
         mprintf("%s\n", buff);
      }
   }
}
#endif

//////////////////////////////////////////////////////////////////////////////

// $Header: r:/t2repos/thief2/src/sound/sndloop.cpp,v 1.27 2000/02/28 17:28:28 toml Exp $

#include <lg.h>
#include <loopapi.h>

// messages I get
#include <dispatch.h>
#include <dispbase.h>
#include <loopmsg.h>
#include <dbasemsg.h>

#include <iobjsys.h>
#include <objtype.h>
#include <objdef.h>
#include <objnotif.h>
#include <appagg.h>
#include <simdef.h>
#include <simman.h>
#include <dspchdef.h>

// loops i use
#include <ailoop.h>
#include <objloop.h>
#include <schloop.h>
#include <simloop.h>
#include <sndloop.h>

// Actual stuff I need to do my thing
#include <gamemode.h>
#include <camera.h>
#include <physapi.h> //for camera related stuff ugh.
#include <matrixs.h>
#include <simstate.h>
#include <simflags.h>
#include <playrobj.h>
#include <appsfx.h>
#include <sndapp.h>
#include <sndprop.h>
#include <sndgen.h>
#include <psndapi.h>
#include <ambprop.h>
#include <ambient.h>
#include <schema.h>
#include <config.h>
#include <sndscrp_.h>
#include <songutil.h>
#include <songmiss.h>
#include <sndframe.h>

#include <dbmem.h>

/////////////////////////////////////////////////////////////
// SOUND LOOP CLIENT
////////////////////////////////////////////////////////////

//////////////////
// CONSTANTS
//
// These are just here to separate out boiler-plate code and leave it untouched
//

#define MY_GUID   LOOPID_Sound
extern int sfx_use_channels;

// My context data
typedef void Context;
// My state
typedef struct _StateRecord
{
   Context* context; // a pointer to the context data I got.
   // State fields go here
} StateRecord;

BOOL sgInGameMode = FALSE;

//////////////////////////////////////////////////////////////
// Forward declarations
//

//static void init_sim_msg();

static void _SongStart();
static void _SongStop();
static void _SongPause();
static void _SongResume();

////////////////////////////////////////
//
// Database message handler
//
static void db_message(DispatchData * msg)
{
   msgDatabaseData data;

   data.raw = msg->data;

   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         SchemaHaltAll();
         SFX_KillAll(SFX_mode_game);
         AmbientReset();
         ScriptSoundReset();
         SongUtilResetMission();
         break;

      case kDatabaseLoad:  // postload not load?
         if (msg->subtype & kDBMission)
         {
            AmbientLoad(data.load);
            ScriptSoundLoad(data.load);
            SongUtilLoadMission(data.load);
         }
         break;

      case kDatabasePostLoad:
#ifdef OLD_WAY
         if ((msg->subtype & kFiletypeAll)==0)
            ScriptSoundPostLoad();  // secret post post post load
#endif
         break;

      case kDatabaseSave:
         if (msg->subtype & kDBMission)
         {
            AmbientSave(data.save);
            ScriptSoundSave(data.save);
            SongUtilSaveMission(data.load);
         }
         break;
   }
}

////////////////////////////////////////
// Frame update
//

static void do_frame(void)
{
   mxs_vector pos;
   mxs_angvec ang;
   Camera* cam = PlayerCamera();

   // some camera modes (REMOTE_CAM and VIEW_CAM) are normally achieved
   // in play through a remote viewing system.  Player sound should propagate
   // to the player object, not the remote camera object.  If we were doing
   // this in the best way, sounds would propagate to BOTH (ugh), but for
   // Thief 2 purposes we only want to player object, so that's all for now.
   // AMSD
   if (((CameraGetMode(cam) == REMOTE_CAM) || (CameraGetMode(cam) == VIEW_CAM))
       && (PhysObjHasPhysics(PlayerObject())))
     {
       PhysGetModRotation(PlayerObject(),&ang);
       PhysGetModLocation(PlayerObject(),&pos);
     }
   else
     CameraGetLocation(PlayerCamera(), &pos, &ang);
   AmbientRunFrame(&pos);
   if (SimStateCheckFlags(kSimSound))
      SFX_Frame(&pos,&ang);
}

////////////////////////////////////////
//
// Object message handler
//

#pragma off(unreferenced)
static void obj_message(ObjID obj, eObjNotifyMsg msg, void *data)
{
   switch (msg)
   {
      case kObjNotifyDelete:
         SoundHaltObj(obj);
         break;
   }
}
#pragma on(unreferenced)

static void init_obj_message(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem);
   sObjListenerDesc desc = { obj_message, NULL };
   IObjectSystem_Listen(pObjSys,&desc);
   SafeRelease(pObjSys);
}

////////////////////////////////////////
//
// LOOP/DISPATCH callback
// Here's where we do the dirty work.
//

#pragma off(unreferenced)
static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   // useful stuff for most clients
   eLoopMessageResult result = kLoopDispatchContinue;
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;
   BOOL wasInGameMode;

   info.raw = hdata;

   switch(msg)
   {
      case kMsgDatabase:
         db_message(info.dispatch);
         break;

      case kMsgEnterMode:
      case kMsgResumeMode:
         // If we switch to game mode, start the music.
         wasInGameMode = sgInGameMode;
         sgInGameMode = IsEqualGUID(*info.mode->to.pID,LOOPID_GameMode);
         if ( !(wasInGameMode) && sgInGameMode )
         {
            if ( msg == kMsgEnterMode ) {
               _SongStart();
            } else {
               _SongResume();
            }
         }
         break;

      case kMsgExitMode:
      case kMsgSuspendMode:
         if ( sgInGameMode )
         {
            sgInGameMode = FALSE;
            if ( msg == kMsgExitMode ) {
               _SongStop();
            } else {
               _SongPause();
            }
         }
         break;

      case kMsgNormalFrame:
         if (SimStateCheckFlags(kSimSound)) {
            do_frame();
            // the schema frame needs to be here in order to make the
            // recording of callbacks work properly
            SchemaFrame();
         }
         break;
         
      case kMsgEndFrame:
      {
         if (SimStateCheckFlags(kSimSound)) 
            SNDFrameNextFrame();
         break;
      }

      case kMsgAppInit:
      {
         int vol;
         SFXInit();
         //         init_sim_msg();
         SoundPropsInit();
         SoundGenInit();
         ScriptSoundInit();
         AmbSoundPropInit();
         init_obj_message();
         SNDFrameInit();

         if (config_get_int("master_volume",&vol))
            SFX_SetMasterVolume(vol);
      }
      break;

      case kMsgAppTerm:
      {
         int vol = SFX_GetMasterVolume();
         config_set_int("master_volume",vol);
         config_set_int("sfx_channels",SFX_GetNumChannels());

         SNDFrameTerm();
         SoundPropsClose();
         SFXClose();
         SoundGenShutdown();
         ScriptSoundTerm();
      }
      break;

      case kMsgEnd:
         Free(state);
         break;
   }
   return result;
}

////////////////////////////////////////////////////////////
//
// Loop client factory function.
//

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   // allocate space for our state, and fill out the fields
   state = (StateRecord*)Malloc(sizeof(StateRecord));
   state->context = (Context*)data;

   return CreateSimpleLoopClient(_LoopFunc,state,pDesc);
}
#pragma on(unreferenced)

///////////////
// DESCRIPTOR
//



sLoopClientDesc SoundLoopClientDesc =
{
   &MY_GUID,                           // GUID
   "Sound Client",                     // NAME
   kPriorityNormal,                    // PRIORITY
   kMsgEnd | kMsgsMode | kMsgsFrameMid | kMsgEndFrame | kMsgDatabase | kMsgsAppOuter,// INTERESTS

   kLCF_Callback,
   _CreateClient,

   NO_LC_DATA,

   {
      {kConstrainAfter, &LOOPID_SimFinish, kMsgsFrame},
      {kConstrainAfter, &LOOPID_ObjSys, kMsgsFrame},

      // We want to handle frame messages before systems which would
      // be affected by sound end callbacks.

      // well, to be fair, we want after actually, so we can fixup names, though
      // woo woo, do we need a new loop client, that would suck
      {kConstrainBefore, &LOOPID_Schema, kMsgDatabase},
      {kConstrainBefore, &LOOPID_AI, kMsgDatabase},
      {kConstrainBefore, &LOOPID_ObjSys, kMsgDatabase},
      {kNullConstraint} // terminator
   }
};


static void _SongStart ()
{
   const sMissionSongParams* pSongParams = GetMissionSongParams();
   if ( '\0' != pSongParams->songName[0] )
   {
      SongUtilLoad (pSongParams->songName);
      SongUtilPlay();
   }
}

static void _SongStop ()
{
   SongUtilStop();
}

static void
_SongPause( void )
{
   SongUtilPause();
}

static void
_SongResume( void )
{
   SongUtilResume();
}


////////////////////////////////////////////////////////////
// SIM LISTENER
//

/* Old way.. Now based on mode change.
static void sim_msg (const struct sDispatchMsg* msg, const struct sDispatchListenerDesc* dummy )
{
   const sMissionSongParams* pSongParams;

   switch (msg->kind)
   {
      case kSimInit:
      case kSimResume:
         pSongParams = GetMissionSongParams();
         if ( '\0' != pSongParams->songName[0] )
         {
            SongUtilLoad (pSongParams->songName);
            SongUtilPlay();
         }
         break;

      case kSimTerm:
      case kSimSuspend:
         SongUtilStop();
         break;
   }
}

static struct sDispatchListenerDesc sim_listen =
{
   &MY_GUID,                                            // my guid
   kSimInit|kSimResume|kSimTerm|kSimSuspend,            // interests
   sim_msg
};

static void init_sim_msg()
{
   AutoAppIPtr(SimManager);
   pSimManager->Listen(&sim_listen);
}
*/
// $Header: r:/t2repos/thief2/src/sound/sndframe.cpp,v 1.2 2000/02/28 17:28:27 toml Exp $

#include <sndframe.h>

#include <dynarray.h>
#include <dbmem.h>

// Simple implementation:
// Because number of sounds started in each frame is small, we
// have a dynarray of all objid's which started sounds in a frame.
// When testing for existence of one ObjID, we simply linear search.

// Because there's no one time when a sound is initiated 
static cDynArray<ObjID> sgObjs[2];
static int  sg_iCurrentTracking = 0;

void SNDFrameInit()
{
   sg_iCurrentTracking = 0;
   sgObjs[0].SetSize(0);
   sgObjs[1].SetSize(0);
}

void SNDFrameTerm()
{
   sgObjs[0].SetSize(0);
   sgObjs[1].SetSize(0);
}

void SNDFrameNextFrame()
{
   sg_iCurrentTracking = 1 - sg_iCurrentTracking;
   sgObjs[sg_iCurrentTracking].SetSize(0);
}

void SNDFrameAddObj( ObjID objID )
{
   sgObjs[sg_iCurrentTracking].Append( objID );
}

BOOL SNDFramePlayedObj( ObjID objID )
{
   cDynArray<ObjID> & arr = sgObjs[1 - sg_iCurrentTracking];
   int arrSize = arr.Size();

   for( int iObj = 0; iObj < arrSize; iObj++ )
   {
      if( arr[ iObj ] == objID )
         return TRUE;
   }

   return FALSE;
}
// $Header: r:/t2repos/thief2/src/sound/sndloop.h,v 1.3 2000/01/31 10:02:35 adurant Exp $
#pragma once
#ifndef __SNDLOOP_H
#define __SNDLOOP_H

// Loop client GUID
DEFINE_LG_GUID(LOOPID_Sound, 0x44);
EXTERN struct sLoopClientDesc SoundLoopClientDesc;

//
// KEEP THIS FILE RELATIVELY CLEAR OF JUNK!  DO NOT PUT YOUR SYSTEM'S API HERE! 
// DO NOT INCLUDE OTHER HEADER FILES FROM THIS FILE!
//

 
#endif // __SNDLOOP_H
// $Header: r:/t2repos/thief2/src/sound/sndnet.cpp,v 1.10 1999/08/05 18:25:03 Justin Exp $
//
// This file deals with broadcasting sounds that occur in the simulation.
// It is really only intended for use with psnd, with which it is fairly
// closely coupled.
//
// The underlying notion is that, when a sound gets to psnd, that checks
// whether the sound should be networked. If so, then it uses this module
// to broadcast the sound to everyone else. This makes sure that, on the
// client machines, networking is suppressed.
//
// We have one minor hideousness: there are two versions of most of
// these messages, a "normal" version and a "small" version. This is due
// to the fact that sfx_parm is pretty large, but usually just full of
// default values, so we usually try to just send the few interesting
// values. We only send the full structure when something looks
// non-default.
//

#include <lg.h>
#include <netmsg.h>
#include <config.h>
#include <objedit.h>

#include <hashpp.h>
#include <hshpptem.h>
#include <dwordset.h>

#include <sndnet.h>
#include <psndapi.h>

// We re-derive some numbers from the schema system, rather than
// transmitting them:
#include <schbase.h>
#include <schsamps.h>
#include <schprop.h>

// Must be last:
#include <dbmem.h>

//////////////////////////////
//
// UTILITIES and STRUCTURES
//

//////////
//
// Map from remote sound handles to local ones
//
// In this mapping, the remote handle is assumed to be the "host", who
// owns this sound; the local one is a "client", which should halt when 
// the host does.
//

// An "owned sound". We compress this into 32 bits for convenience:
typedef int tOwnedSndHandle;
static inline tOwnedSndHandle OwnHandle(uint owner, uint handle)
{
   return (owner << 16) + handle;
}

// The hash table from host sound handles to local ones:
typedef cHashTable<tOwnedSndHandle, int, cHashFunctions> tSoundHandleHash;
static tSoundHandleHash HandleMap;
// The table to keep track of which sounds are "clients":
static cDWORDSet ClientSet;

// The method that gets called when a local sound finishes:
static void soundNetEndCallback(int localHandle, void *pClientData)
{
   tOwnedSndHandle ownHandle = (tOwnedSndHandle) pClientData;
   // Remove this entry from the map table:
   HandleMap.Delete(ownHandle);
   ClientSet.Delete(localHandle);
}

// Add an entry to the mapping. If there isn't actually a local sound,
// don't bother.
static void soundNetAddMapping(int remoteHandle, int localHandle, ObjID owner)
{
   if (localHandle != kPSndFail) {
      tOwnedSndHandle ownHandle = OwnHandle(owner, remoteHandle);
      HandleMap.Set(ownHandle, localHandle);
      ClientSet.Add(localHandle);
   }
}

//////////
//
// Simplified sfx_parm, for networking
//

// A cut-down version of sfx_parm, with only the stuff we want to network:
typedef struct {
   int    pan;       // using standard sndlib pan (-10k to 10k)
   ushort flag;      // flag overrides, not all are app setable
   uchar  pri;       // priority for the sound
   uchar  group;     // what group the sound effect goes into
   int    gain;      // currently in snd.lib decibel format, maybe not a good idea
   int    delay;     // initial delay
   ulong  fade;      // fade in and out time
   int    radius;    // forced sound radius
   int    distance;  // distance to sound origination point (-1 == straight line)
   int    num_loops; // 
} sfx_net_parm;      //    since we really want local vol overrides? who knows
// 32


// An even smaller version of sfx_parm, for the typical case with
// mostly defaults:
typedef struct {
   uchar  group;
   uchar  pad;
   ushort flag;
   short gain;
   short radius;
} sfx_small_net_parm;
// 8

// Copy parms into the appropriate network version. Returns TRUE iff
// we should use the full net_parm, or FALSE iff we should use the
// small_net_parm.
// @TBD: is it *ever* reasonable for gain, radius, or distance to have
// a non-short value?
BOOL fillNetParms(sfx_parm *parm, 
                  sfx_net_parm *net_parm,
                  sfx_small_net_parm *small_net_parm)
{
   if ((parm->pan != 0) ||
       (parm->pri != 128) || // Why 128? I dunno, but it seems normal
       (parm->gain != ((short) parm->gain)) ||
       (parm->fade != 0) ||
       (parm->radius != ((short) parm->radius)) ||
       (parm->num_loops != 0))
   {
      // Okay, it's not a complete ordinary parm, so use the full struct:
      net_parm->pan = parm->pan;
      net_parm->flag = parm->flag;
      net_parm->pri = parm->pri;
      net_parm->group = parm->group;
      net_parm->gain = parm->gain;
      net_parm->delay = parm->delay;
      net_parm->fade = parm->fade;
      net_parm->radius = parm->radius;
      net_parm->distance = parm->distance;
      net_parm->num_loops = parm->num_loops;

      /*
      mprintf("sfx_net_parm: %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n",
              parm->pan,
              parm->flag,
              parm->pri,
              parm->group,
              parm->gain,
              parm->delay,
              parm->fade,
              parm->radius,
              parm->distance,
              parm->num_loops);
      */

      return TRUE;
   } else {
      // It's boring and normal, so just use the cut-down version:
      small_net_parm->group = parm->group;
      small_net_parm->flag = parm->flag;
      small_net_parm->gain = parm->gain;
      small_net_parm->radius = parm->radius;
      return FALSE;
   }
}

// Copy parms from the network version:
void fillParms(sfx_parm *parm, sfx_net_parm *net_parm)
{
   // Copy the relevant fields:
   parm->pan = net_parm->pan;
   parm->flag = net_parm->flag;
   parm->pri = net_parm->pri;
   parm->group = net_parm->group;
   parm->gain = net_parm->gain;
   parm->delay = net_parm->delay;
   parm->fade = net_parm->fade;
   parm->radius = net_parm->radius;
   parm->distance = net_parm->distance;
   parm->num_loops = net_parm->num_loops;

   // NULL out the fields we don't use on the client side:
   parm->loop_callback = NULL;
   parm->user_data = NULL;
   parm->pSndSource = NULL;

   // And set the local-relevant ones:
   parm->end_callback = soundNetEndCallback;
}

// Fill parms from the small version:
void fillParmsSmall(sfx_parm *parm, sfx_small_net_parm *net_parm)
{
   // Copy the relevant fields:
   parm->pan = 0;
   parm->flag = net_parm->flag;
   parm->pri = 128;
   parm->group = net_parm->group;
   parm->gain = net_parm->gain;
   parm->delay = 0;
   parm->fade = 0;
   parm->radius = net_parm->radius;
   parm->distance = -1;
   parm->num_loops = 0;

   // NULL out the fields we don't use on the client side:
   parm->loop_callback = NULL;
   parm->user_data = NULL;
   parm->pSndSource = NULL;

   // And set the local-relevant ones:
   parm->end_callback = soundNetEndCallback;
}

//////////////////////////////
//
// THE MESSAGES
//
// ASSUMPTIONS:
// -- The attenuation factor is taken directly from the schema, and
//    doesn't need to be transmitted.
// -- The sampleNums within a schema are statically determined, and
//    identical on all machines, so we can transmit the sample number
//    in lieu of the sample's name.
// -- The delay parm is taken directly from the schema, and doesn't
//    need to be transmitted.
// -- The distance parm is garbage at this point, and doesn't need
//    to be transmitted.
//

//////////
//
// A sound attached to a specific object
//

static cNetMsg *g_pSoundObjMsg = NULL;
static cNetMsg *g_pSmallSoundObjMsg = NULL;

static void makeSoundObj(int handle,
                         ObjID objID, 
                         ObjID schemaID, 
                         uchar sampleNum,
                         sfx_parm *parm,
                         ObjID owner)
{
   parm->flag |= SFXFLG_NO_NET;
   parm->user_data = (void *) OwnHandle(owner, handle);
   sSchemaPlayParams *pPlayParams = SchemaPlayParamsGet(schemaID);
   if (pPlayParams == NULL) {
      // Weird, but we're not going to try to network this one...
      Warning(("Networked schema without playParams!\n"));
      return;
   }
   parm->delay = pPlayParams->initialDelay;
   const char *sampleName = SchemaSampleGet(schemaID, sampleNum);
   // Re-derive the attenuation factor, rather than transmitting it,
   // since it's simply based on the schema:
   float atten_factor = SchemaAttFacGet(schemaID);

#ifndef SHIP
   if (config_is_defined("SoundSpew"))
   {
      mprintf("SndNet: playing %s\n", sampleName);
   }
#endif

   // Play the sound, and record it:
   int localHandle = GenerateSoundObj(objID,
                                      schemaID,
                                      sampleName,
                                      atten_factor,
                                      parm, TRUE,
                                      NULL);
   soundNetAddMapping(handle, localHandle, owner);
}

static void handleSoundObj(int handle,
                           ObjID objID, 
                           ObjID schemaID, 
                           uchar sampleNum,
                           sfx_net_parm *net_parms,
                           ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParms(&parm, net_parms);
   makeSoundObj(handle, objID, schemaID, sampleNum, &parm, owner);
}

static void handleSmallSoundObj(int handle,
                                ObjID objID, 
                                ObjID schemaID, 
                                uchar sampleNum,
                                sfx_small_net_parm *net_parms,
                                ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParmsSmall(&parm, net_parms);
   makeSoundObj(handle, objID, schemaID, sampleNum, &parm, owner);
}

static sNetMsgDesc sSoundObjDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "SoundObj",
   "Object-attached sound",
   NULL,
   handleSoundObj,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_GlobalObjID, kNMPF_None, "Object"},
    {kNMPT_ObjID, kNMPF_None, "Schema"},
    {kNMPT_UByte, kNMPF_None, "Sample number"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_net_parm)},
    {kNMPT_End}}
};

static sNetMsgDesc sSmallSoundObjDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "SmSoundObj",
   "Simple Object-attached sound",
   NULL,
   handleSmallSoundObj,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_GlobalObjID, kNMPF_None, "Object"},
    {kNMPT_ObjID, kNMPF_None, "Schema"},
    {kNMPT_UByte, kNMPF_None, "Sample number"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_small_net_parm)},
    {kNMPT_End}}
};

EXTERN int SchemaGetCurrSample();

void SoundNetGenerateSoundObj(int handle,
                              ObjID objID, 
                              ObjID schemaID, 
                              const char *sampleName, 
                              float atten_factor, 
                              sfx_parm *parms)
{
   sfx_net_parm net_parms;
   sfx_small_net_parm small_parms;

   // Actually get the sample index from the schema system
   int sampleNum = SchemaSampleGetNamed(schemaID, sampleName);
   AssertMsg2(sampleNum >= 0, "Bad sample index for schema %s, name %s", 
              ObjWarnName(schemaID), sampleName);

   // Confirm that we don't need to transmit the attenuation factor:
   AssertMsg1(atten_factor == SchemaAttFacGet(schemaID),
              "SoundObj: Attenuation factor doesn't match schema %d!",
              schemaID);
   // Confirm that we don't need to transmit the delay:
   sSchemaPlayParams *pPlayParams = SchemaPlayParamsGet(schemaID);
   if (pPlayParams == NULL) {
      // Weird, but we're not going to try to network this one...
      Warning(("Networked schema without playParams!\n"));
      return;
   }
   AssertMsg1(parms->delay == pPlayParams->initialDelay,
              "SoundObj: Delay doesn't match schema %d!",
              schemaID);

   if (fillNetParms(parms, &net_parms, &small_parms)) {
      g_pSoundObjMsg->Send(OBJ_NULL, handle, objID, schemaID,
                           sampleNum, &net_parms);
   } else {
      g_pSmallSoundObjMsg->Send(OBJ_NULL, handle, objID, schemaID,
                                sampleNum, &small_parms);
   }
}

//////////
//
// A sound with a vector
//

static cNetMsg *g_pSoundVecMsg = NULL;
static cNetMsg *g_pSmallSoundVecMsg = NULL;

static void makeSoundVec(int handle,
                         mxs_vector *vec,
                         ObjID schemaID, 
                         uchar sampleNum,
                         sfx_parm *parm,
                         ObjID owner)
{
   parm->flag |= SFXFLG_NO_NET;
   parm->user_data = (void *) OwnHandle(owner, handle);
   sSchemaPlayParams *pPlayParams = SchemaPlayParamsGet(schemaID);
   if (pPlayParams == NULL) {
      // Weird, but we're not going to try to network this one...
      Warning(("Networked schema without playParams!\n"));
      return;
   }
   parm->delay = pPlayParams->initialDelay;
   const char *sampleName = SchemaSampleGet(schemaID, sampleNum);
   // Re-derive the attenuation factor, rather than transmitting it,
   // since it's simply based on the schema:
   float atten_factor = SchemaAttFacGet(schemaID);

#ifndef SHIP
   if (config_is_defined("SoundSpew"))
   {
      mprintf("SndNet: playing %s\n", sampleName);
   }
#endif

   // Play the sound, and record it:
   int localHandle = GenerateSoundVec(vec,
                                      OBJ_NULL,
                                      schemaID,
                                      sampleName,
                                      atten_factor,
                                      parm, TRUE,
                                      NULL);
   soundNetAddMapping(handle, localHandle, owner);
}

static void handleSoundVec(int handle,
                           mxs_vector *vec,
                           ObjID schemaID, 
                           uchar sampleNum,
                           sfx_net_parm *net_parms,
                           ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParms(&parm, net_parms);
   makeSoundVec(handle, vec, schemaID, sampleNum, &parm, owner);
}

static void handleSmallSoundVec(int handle,
                                mxs_vector *vec,
                                ObjID schemaID, 
                                uchar sampleNum,
                                sfx_small_net_parm *net_parms,
                                ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParmsSmall(&parm, net_parms);
   makeSoundVec(handle, vec, schemaID, sampleNum, &parm, owner);
}

static sNetMsgDesc sSoundVecDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "SoundVec",
   "Vector-attached sound",
   NULL,
   handleSoundVec,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_Vector, kNMPF_None, "Vector"},
    {kNMPT_ObjID, kNMPF_None, "Schema"},
    {kNMPT_UByte, kNMPF_None, "Sample number"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_net_parm)},
    {kNMPT_End}}
};

static sNetMsgDesc sSmallSoundVecDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "SmSoundVec",
   "Simple Vector-attached sound",
   NULL,
   handleSmallSoundVec,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_Vector, kNMPF_None, "Vector"},
    {kNMPT_ObjID, kNMPF_None, "Schema"},
    {kNMPT_UByte, kNMPF_None, "Sample number"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_small_net_parm)},
    {kNMPT_End}}
};

void SoundNetGenerateSoundVec(int handle,
                              mxs_vector *vec,
                              ObjID schemaID, 
                              const char *sampleName, 
                              float atten_factor, 
                              sfx_parm *parms)
{
   sfx_net_parm net_parms;
   sfx_small_net_parm small_parms;

   // Actually get the sample index from the schema system
   int sampleNum = SchemaSampleGetNamed(schemaID, sampleName);
   AssertMsg2(sampleNum >= 0, "Bad sample index for schema %s, name %s", 
              ObjWarnName(schemaID), sampleName);

   // Confirm that we don't need to transmit the attenuation factor:
   AssertMsg1(atten_factor == SchemaAttFacGet(schemaID),
              "SoundVec: Attenuation factor doesn't match schema %d!",
              schemaID);
   // Confirm that we don't need to transmit the delay:
   sSchemaPlayParams *pPlayParams = SchemaPlayParamsGet(schemaID);
   if (pPlayParams == NULL) {
      // Weird, but we're not going to try to network this one...
      Warning(("Networked schema without playParams!\n"));
      return;
   }
   AssertMsg1(parms->delay == pPlayParams->initialDelay,
              "SoundVec: Delay doesn't match schema %d!",
              schemaID);

   if (fillNetParms(parms, &net_parms, &small_parms)) {
      g_pSoundVecMsg->Send(OBJ_NULL, handle, vec, schemaID,
                           sampleNum, &net_parms);
   } else {
      g_pSmallSoundVecMsg->Send(OBJ_NULL, handle, vec, schemaID,
                                sampleNum, &small_parms);
   }
}

//////////
//
// A plain sound (usually not networked, but sometimes)
//

static cNetMsg *g_pSoundMsg = NULL;
static cNetMsg *g_pSmallSoundMsg = NULL;

static void makeSound(int handle,
                      const char *sampleName, 
                      sfx_parm *parm,
                      ObjID owner)
{
   parm->flag ^= SFXFLG_NET_AMB;
   parm->user_data = (void *) OwnHandle(owner, handle);

   // Play the sound, and record it:
   int localHandle = GenerateSound(sampleName, parm);
   soundNetAddMapping(handle, localHandle, owner);
}

static void handleSound(int handle,
                        const char *sampleName, 
                        sfx_net_parm *net_parms,
                        ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParms(&parm, net_parms);
   makeSound(handle, sampleName, &parm, owner);
}

static void handleSmallSound(int handle,
                             const char *sampleName, 
                             sfx_small_net_parm *net_parms,
                             ObjID owner)
{
   // Set up for the sound:
   sfx_parm parm;
   fillParmsSmall(&parm, net_parms);
   makeSound(handle, sampleName, &parm, owner);
}

static sNetMsgDesc sSoundDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "Sound",
   "Plain sound",
   NULL,
   handleSound,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_String, kNMPF_None, "Sample name"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_net_parm)},
    {kNMPT_End}}
};

static sNetMsgDesc sSmallSoundDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "SmSound",
   "Simple Plain sound",
   NULL,
   handleSmallSound,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_String, kNMPF_None, "Sample name"},
    {kNMPT_Block, kNMPF_None, "SFX Parms", sizeof(sfx_small_net_parm)},
    {kNMPT_End}}
};

void SoundNetGenerateSound(int handle,
                           const char *sampleName, 
                           sfx_parm *parms)
{
   sfx_net_parm net_parms;
   sfx_small_net_parm small_parms;
   if (fillNetParms(parms, &net_parms, &small_parms)) {
      g_pSoundMsg->Send(OBJ_NULL, handle, sampleName, &net_parms);
   } else {
      g_pSmallSoundMsg->Send(OBJ_NULL, handle, sampleName, &small_parms);
   }
}

//////////
//
// Stop a sound prematurely
//

static cNetMsg *g_pSoundHaltMsg = NULL;

static void handleSoundHalt(int handle, ObjID owner)
{
   int localHandle;
   tOwnedSndHandle ownHandle = OwnHandle(owner, handle);
   if (HandleMap.Lookup(ownHandle, &localHandle)) {
      SoundHalt(localHandle);
      HandleMap.Delete(ownHandle);
      ClientSet.Delete(localHandle);
   }
}

static sNetMsgDesc sSoundHaltDesc =
{
   kNMF_Broadcast | kNMF_AppendSenderID,
   "HaltSound",
   "Halt Sound",
   NULL,
   handleSoundHalt,
   {{kNMPT_Int, kNMPF_None, "Handle"},
    {kNMPT_End}}
};

void SoundNetHalt(int handle)
{
   // If we have a mapping for this sound, then we don't own it, so we'd
   // better not tell others to shut it down.
   if (!ClientSet.InSet(handle)) {
      g_pSoundHaltMsg->Send(OBJ_NULL, handle);
   }
}


//////////////////////////////
//
// STARTUP and SHUTDOWN
//

// Prepare the sound-related network msgs
void SoundNetInit()
{
   g_pSoundObjMsg = new cNetMsg(&sSoundObjDesc);
   g_pSmallSoundObjMsg = new cNetMsg(&sSmallSoundObjDesc);
   g_pSoundVecMsg = new cNetMsg(&sSoundVecDesc);
   g_pSmallSoundVecMsg = new cNetMsg(&sSmallSoundVecDesc);
   g_pSoundMsg = new cNetMsg(&sSoundDesc);
   g_pSmallSoundMsg = new cNetMsg(&sSmallSoundDesc);
   g_pSoundHaltMsg = new cNetMsg(&sSoundHaltDesc);
}

// Delete the messages
void SoundNetTerm()
{
   delete g_pSoundObjMsg;
   delete g_pSmallSoundObjMsg;
   delete g_pSoundVecMsg;
   delete g_pSmallSoundVecMsg;
   delete g_pSoundMsg;
   delete g_pSmallSoundMsg;
   delete g_pSoundHaltMsg;
}
// $Header: r:/t2repos/thief2/src/sound/sndnet.h,v 1.5 2000/01/31 10:02:36 adurant Exp $
#pragma once

#ifndef _SNDNET_H
#define _SNDNET_H

#include <lg.h>
#include <matrix.h>
#include <objtype.h>
#include <appsfx.h>

EXTERN void SoundNetInit();
EXTERN void SoundNetTerm();

// Routines for broadcasting various kinds of sounds.
// Sound attached to an object:
EXTERN void SoundNetGenerateSoundObj(int handle,
                                     ObjID objID, 
                                     ObjID schemaID, 
                                     const char *sampleName, 
                                     float atten_factor, 
                                     sfx_parm *parms);

// Sound at a specified location:
EXTERN void SoundNetGenerateSoundVec(int handle, 
                                     mxs_vector *vec,
                                     ObjID schemaID, 
                                     const char *sampleName, 
                                     float atten_factor, 
                                     sfx_parm *parms);

// Ambient sounds:
EXTERN void SoundNetGenerateSound(int handle, 
                                  const char *sampleName,
                                  sfx_parm *parms);

// Stop a sound:
EXTERN void SoundNetHalt(int handle);

#endif // !_SNDNET_H
// $Header: r:/t2repos/thief2/src/sound/sndprop.cpp,v 1.4 1999/12/01 20:12:22 BFarquha Exp $
// Collision schema properties

#include <sndprop.h>
#include <propbase.h>

// Must be last header
#include <dbmem.h>


// Collide with arrow sound
ILabelProperty *pPropCollideWithArrowSnd;

static sPropertyDesc CollideWithArrowSndDesc =
{
   PROP_COLLIDE_WITH_ARROW_SND, 0,
};

void CollideWithArrowSndPropertyInit(void)
{
   pPropCollideWithArrowSnd = CreateLabelProperty(&CollideWithArrowSndDesc, kPropertyImplDense);
}

// get collision sound
Label *CollideWithArrowSndGet(ObjID objID)
{
   Label *pCollideWithArrowSndLabel = NULL;

   pPropCollideWithArrowSnd->Get(objID, &pCollideWithArrowSndLabel);
   return pCollideWithArrowSndLabel;
}

// Collide with projectile sound
ILabelProperty *pPropCollideWithProjectileSnd;

static sPropertyDesc CollideWithProjectileSndDesc =
{
   PROP_COLLIDE_WITH_PROJECTILE_SND, 0,
};

void CollideWithProjectileSndPropertyInit(void)
{
   pPropCollideWithProjectileSnd = CreateLabelProperty(&CollideWithProjectileSndDesc, kPropertyImplDense);
}

// get collision sound
Label *CollideWithProjectileSndGet(ObjID objID)
{
   Label *pCollideWithProjectileSndLabel = NULL;

   pPropCollideWithProjectileSnd->Get(objID, &pCollideWithProjectileSndLabel);
   return pCollideWithProjectileSndLabel;
}

// Hey, it's a property that's a property name!
ILabelProperty *pPropCollideSndProperty;

static sPropertyDesc CollideSndPropertyDesc =
{
   PROP_COLLIDE_SND_PROPERTY, 0,
};

void CollideSndPropertyPropertyInit(void)
{
   pPropCollideSndProperty = CreateLabelProperty(&CollideSndPropertyDesc, kPropertyImplDense);
}

Label *CollideSndPropertyGet(ObjID objID)
{
   Label *pCollideSndPropertyLabel = NULL;

   pPropCollideSndProperty->Get(objID, &pCollideSndPropertyLabel);
   return pCollideSndPropertyLabel;
}


void SoundPropsInit(void)
{
   CollideWithArrowSndPropertyInit();
   CollideWithProjectileSndPropertyInit();
   CollideSndPropertyPropertyInit();
}

void SoundPropsClose(void)
{
   SafeRelease(pPropCollideWithArrowSnd);
   SafeRelease(pPropCollideWithProjectileSnd);
   SafeRelease(pPropCollideSndProperty);
}
// $Header: r:/t2repos/thief2/src/sound/schfile.h,v 1.2 2000/01/29 13:41:51 adurant Exp $
#pragma once

#ifndef __SCHFILE_H
#define __SCHFILE_H

// function for reading a schema file
typedef void (*fSchemaRead)(char *filename);

// read all files from res path and local dir that match "what" string
void SchemaFilesLoadFromDir(const char *where, const char *what, fSchemaRead readFunc);


#endif // Schfile_h

// $Header: r:/t2repos/thief2/src/sound/schloop.c,v 1.16 2000/02/19 12:37:12 toml Exp $

#include <lg.h>
#include <loopapi.h>

#include <dispbase.h>
#include <loopmsg.h>

#include <schloop.h>

#include <ailoop.h>
#include <objloop.h>
#include <osysbase.h>
#include <dbasemsg.h>
#include <schema.h>
#include <schdb.h>
#include <schsamps.h>
#include <spchglue.h>
#include <esndglue.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


//////////////////
// CONSTANTS
//
// These are just here to separate out boiler-plate code and leave it untouched
//

#define MY_GUID LOOPID_Schema

// My context data
typedef void Context;

// My state
typedef struct _StateRecord
{
   Context* context; // a pointer to the context data I got.
   // State fields go here
} StateRecord;


////////////////////////////////////////
//
// LOOP/DISPATCH callback
// Here's where we do the dirty work.
//

#pragma off(unreferenced)
static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   eLoopMessageResult result = kLoopDispatchContinue;
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;

   info.raw = hdata;

   switch(msg)
   {
      case kMsgEnterMode:
         break;
      case kMsgExitMode:
         break;

      case kMsgNormalFrame:
         // the schema frame is in sndloop for recording purposes
         break;

      case kMsgDatabase:
         SchemaDatabaseNotify(info.dispatch);
         SpeechDatabaseNotify(info.dispatch);
         ESndDatabaseNotify(info.dispatch);
         break;

      case kMsgSuspendMode:
         break;
      case kMsgResumeMode:
         break;
      case kMsgEnd:
         Free(state);
         break;

      case kMsgAppInit:
         SchemaInit();
         SpeechInit();
         SchemaSamplesInit();
         ESndInit();
         break;

      case kMsgAppTerm:
         SchemaSamplesShutdown();
         SchemaShutdown();
         SpeechTerm();
         ESndTerm();
         break;
   }
   return result;
}

////////////////////////////////////////////////////////////
//
// Loop client factory function.
//

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   // allocate space for our state, and fill out the fields
   state = (StateRecord*)Malloc(sizeof(StateRecord));
   state->context = (Context*)data;

   return CreateSimpleLoopClient(_LoopFunc,state,pDesc);
}
#pragma on(unreferenced)

///////////////
// DESCRIPTOR
//

sLoopClientDesc SchemaLoopClientDesc =
{
   &MY_GUID,                           // GUID
   "Schema Client",                    // NAME
   kPriorityNormal,                    // PRIORITY
   kMsgEnd | kMsgDatabase | kMsgsMode | kMsgsFrameMid | kMsgsAppOuter,  // INTERESTS

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,

   {
      {kConstrainAfter, &LOOPID_ObjSys, kMsgDatabase},
      {kConstrainAfter, &LOOPID_AI, kMsgDatabase},
      {kNullConstraint} // terminator
   }
};

// $Header: r:/t2repos/thief2/src/sound/schloop.h,v 1.3 2000/01/29 13:41:53 adurant Exp $
#pragma once
#ifndef __SCHLOOP_H
#define __SCHLOOP_H

// Loop client GUID
DEFINE_LG_GUID(LOOPID_Schema, 0x97);

//
// Loop Client Factory Descriptor
EXTERN struct sLoopClientDesc SchemaLoopClientDesc;

//
// KEEP THIS FILE RELATIVELY CLEAR OF JUNK!  DO NOT PUT YOUR SYSTEM'S API HERE! 
// DO NOT INCLUDE OTHER HEADER FILES FROM THIS FILE!
//

 
#endif // __SCHLOOP_H
// $Header: r:/t2repos/thief2/src/sound/schmsg.cpp,v 1.6 1998/10/05 17:27:45 mahk Exp $

#include <lgassert.h>
extern "C"
{
#include <matrix.h>
}

#include <appsfx.h>
#include <schmsg.h>
#if AI_TODO
//include <aipool.h>
//include <aiext.h>
#endif
#include <schbase.h>


// Must be last header 
#include <dbmem.h>


// ignore all messages at volume less than this (at recipient)
// we probably want to decrease this
#define SCHEMA_MSG_MIN_VOLUME -5000

void SchemaMsgPropagate(sSchemaMsg *pMsg)
{
#if AI_TODO
   cAI *pAI;
   int volume;
   float dist;
   mxs_vector aiLoc;

   Assert_(pMsg != NULL);

   if (g_pAIPool->GetFirstAI(pAI))
   {
      do
      {
         AIGetAILocation(pAI, &aiLoc);
         dist = mx_dist_vec(&aiLoc, (mxs_vector*)(&pMsg->sourceLoc));
         if ((volume = SFX_Attenuate(pMsg->volume, dist))>SCHEMA_MSG_MIN_VOLUME)
            AINotifyAboutSound(pAI, pMsg, volume);
      }
      while (g_pAIPool->GetNextAI(pAI));
   }
#endif
}




// $Header: r:/t2repos/thief2/src/sound/schmsg.h,v 1.2 2000/01/29 13:41:54 adurant Exp $
#pragma once

#ifndef __SCHMSG_H
#define __SCHMSG_H

#include <schtype.h>

// Propagate a message originating from a given location and object (can be OBJ_NULL)
void SchemaMsgPropagate(sSchemaMsg *pMsg);

#endif
// $Header: r:/t2repos/thief2/src/sound/schprop.cpp,v 1.19 1999/04/24 15:47:56 Justin Exp $

#include <property.h>
#include <propbase.h>
#include <propface.h>
#include <propert_.h>
#include <dataops_.h>
#include <prophash.h>
#include <sdesc.h>
#include <sdestype.h>
#include <sdesbase.h>

#include <schbase.h>
#include <schprop.h>

#include <tag.h>
#include <tagbase.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////
// Schema play parameters property

// This listener is only being used to try to catch a particular
// error, in which the base schema's volume is set to 0x10040.
#ifndef SHIP
static void LGAPI PlayParamsListener(sPropertyListenMsg * msg,
                                     PropListenerData data)
{
   if (!msg->value.ptrval)
      return;

   sSchemaPlayParams *pParams = (sSchemaPlayParams *) msg->value.ptrval;

   // creation
   if (msg->type & kListenPropSet) {
      AssertMsg1(pParams->volume <= 0,
                 "Schema volume should be negative, but we have one at %d",
                 pParams->volume);
   }
}
#endif // ~SHIP

ISchemaPlayParamsProperty *g_schemaPlayParamsProperty;

static const char* flag_names[] = 
{
   "Retrigger",
   "Pan position",
   "Pan Range",
   "No Repeate",  
   "No Cache",
   "Stream",
   "Play Once",
   "No Combat", 
   "Net Ambient",
   "Local Spatial",
   "","",  // 6 unused bits
   "","","","",
   "Noise",
   "Speech",
   "Ambient",
   "Music",
   "MetaUI",
}; 

#define NUM_FLAGS (sizeof(flag_names)/sizeof(flag_names[0]))

static sFieldDesc SchemaPlayParamsFields[] = 
{
   {"Flags", kFieldTypeBits, FieldLocation(sSchemaPlayParams, flags), kFieldFlagNone, 0, NUM_FLAGS, NUM_FLAGS, flag_names},
   {"Volume", kFieldTypeInt, FieldLocation(sSchemaPlayParams, volume),},
   {"Initial Delay", kFieldTypeShort, FieldLocation(sSchemaPlayParams, initialDelay),},
   {"Pan", kFieldTypeInt, FieldLocation(sSchemaPlayParams, pan),},
   {"Fade", kFieldTypeInt, FieldLocation(sSchemaPlayParams, fade),},
};

static sStructDesc SchemaPlayParamsStructDesc = 
   StructDescBuild(sSchemaPlayParams, kStructFlagNone, SchemaPlayParamsFields);

class cSchemaPlayOps : public cClassDataOps<sSchemaPlayParams>
{
   
}; 

class cSchemaPlayStore: public cHashPropertyStore<cSchemaPlayOps>
{
}; 

class cSchemaPlayProp : public cSpecificProperty<ISchemaPlayParamsProperty,&IID_ISchemaPlayParamsProperty,sSchemaPlayParams*, cSchemaPlayStore>
{
   typedef cSpecificProperty<ISchemaPlayParamsProperty,&IID_ISchemaPlayParamsProperty,sSchemaPlayParams*, cSchemaPlayStore> cParent; 

public:
   cSchemaPlayProp(const sPropertyDesc* desc)
      : cParent(desc)
   {
   }

   STANDARD_DESCRIBE_TYPE(sSchemaPlayParams); 

};


static sPropertyDesc schemaPlayParamsDesc = 
{
   PROP_SCHEMA_PLAY_PARAMS, 0, NULL, 0, 0, { "Schema", "Play Params" },
};

void SchemaPlayParamsPropertyInit()
{
   StructDescRegister(&SchemaPlayParamsStructDesc);

   g_schemaPlayParamsProperty
      = new cSchemaPlayProp(&schemaPlayParamsDesc);
#ifndef SHIP
   g_schemaPlayParamsProperty->Listen(kListenPropSet, 
                                      PlayParamsListener, NULL);
#endif // ~SHIP
}

sSchemaPlayParams *SchemaPlayParamsGet(ObjID objID)
{
   sSchemaPlayParams *pParams;

   if (g_schemaPlayParamsProperty->Get(objID, &pParams))
      return pParams;
   return NULL;
}

////////////////////////////////
// Schema loop parameters property

ISchemaLoopParamsProperty *g_schemaLoopParamsProperty;

static sFieldDesc SchemaLoopParamsFields[] = 
{
   {"Flags", kFieldTypeBits, FieldLocation(sSchemaLoopParams, flags),},
   {"Max Samples", kFieldTypeInt, FieldLocation(sSchemaLoopParams, maxSamples),},
   {"Interval Min", kFieldTypeInt, FieldLocation(sSchemaLoopParams, intervalMin),},
   {"Interval Max", kFieldTypeInt, FieldLocation(sSchemaLoopParams, intervalMax),},
};

static sStructDesc SchemaLoopParamsStructDesc = 
   StructDescBuild(sSchemaLoopParams, kStructFlagNone, SchemaLoopParamsFields);

class cSchLoopOps : public cClassDataOps<sSchemaLoopParams>
{
}; 

class cSchLoopStore : public cHashPropertyStore<cSchLoopOps>
{
   
};

class cSchemaLoopProp : public cSpecificProperty<ISchemaLoopParamsProperty,&IID_ISchemaLoopParamsProperty, sSchemaLoopParams*, cSchLoopStore>
{
   typedef cSpecificProperty<ISchemaLoopParamsProperty,&IID_ISchemaLoopParamsProperty, sSchemaLoopParams*, cSchLoopStore> cParent; 

public:
   cSchemaLoopProp(const sPropertyDesc* desc)
      : cParent(desc)
   {
   }; 

   STANDARD_DESCRIBE_TYPE(sSchemaLoopParams); 

}; 

static sPropertyDesc schemaLoopParamsDesc = 
{
   PROP_SCHEMA_LOOP_PARAMS, 0, NULL, 0, 0, { "Schema", "Loop Params" },
};

void SchemaLoopParamsPropertyInit()
{
   StructDescRegister(&SchemaLoopParamsStructDesc);

   g_schemaLoopParamsProperty = new cSchemaLoopProp(&schemaLoopParamsDesc);
}

sSchemaLoopParams *SchemaLoopParamsGet(ObjID objID)
{
   sSchemaLoopParams *pParams;

   if (g_schemaLoopParamsProperty->Get(objID, &pParams))
      return pParams;
   return NULL;
}

////////////////////////////////
// Schema priority property
IIntProperty *g_pPropSchemaPriority;

static sPropertyDesc SchemaPriorityDesc = 
{
   PROP_SCHEMA_PRIORITY, 0, NULL, 0, 0, { "Schema", "Priority" },
};

#define SCHEMA_PRIORITY_IMPL kPropertyImplDense

void SchemaPriorityPropertyInit(void)
{
   g_pPropSchemaPriority = CreateIntProperty(&SchemaPriorityDesc, SCHEMA_PRIORITY_IMPL);
}

int SchemaPriorityGet(ObjID objID)
{
   int pri = SCH_PRIORITY_NORMAL;
   g_pPropSchemaPriority->Get(objID, &pri);
   return pri;
}

////////////////////////////////
// Schema messages 

ILabelProperty *g_pPropSchemaMessage;

static sPropertyDesc SchemaMessageDesc = 
{
   PROP_SCHEMA_MESSAGE, 0, NULL, 0, 0, { "Schema", "Message" },
};

void SchemaMessagePropertyInit(void)
{
   g_pPropSchemaMessage = CreateLabelProperty(&SchemaMessageDesc, kPropertyImplDense);
}

// get voice
Label *SchemaMessageGet(ObjID objID)
{
   Label *pMessage;

   if (g_pPropSchemaMessage->Get(objID, &pMessage))
      return pMessage;
   else
      return NULL;
}

////////////////////////////////
// Schema "action" sounds 

ILabelProperty *g_pPropSchemaActionSnd;

static sPropertyDesc SchemaActionSndDesc = 
{
   PROP_SCHEMA_ACTION_SND, 0, NULL, 0, 0, { "Schema", "Action" },
};

void SchemaActionSndPropertyInit(void)
{
   g_pPropSchemaActionSnd = CreateLabelProperty(&SchemaActionSndDesc, kPropertyImplDense);
}

Label *SchemaActionSndGet(ObjID objID)
{
   Label *pActionSnd;

   if (g_pPropSchemaActionSnd->Get(objID, &pActionSnd))
      return pActionSnd;
   else
      return NULL;
}

////////////////////////////////
// Schema attenuation factor
IFloatProperty *g_pPropSchemaAttFac;

static sPropertyDesc SchemaAttenuationDesc = 
{
   PROP_SCHEMA_ATTFAC, 0, NULL, 0, 0, { "Schema", "Attenuation Factor" },
};

#define SCHEMA_ATTFAC_IMPL kPropertyImplVerySparse

void SchemaAttFacPropertyInit(void)
{
   g_pPropSchemaAttFac = CreateFloatProperty(&SchemaAttenuationDesc, SCHEMA_PRIORITY_IMPL);
}

float SchemaAttFacGet(ObjID objID)
{
   float fac = 1.0;
   g_pPropSchemaAttFac->Get(objID, &fac);
   return fac;
}

// Schema LastSample property
IIntProperty *g_pPropSchemaLastSample;

static sPropertyDesc SchemaLastSampleDesc = 
{
   PROP_SCHEMA_LAST_SAMPLE, kPropertyTransient,
   NULL, 0, 0, { "Schema", "Last Sample" },
   kPropertyChangeLocally,
};

#define SCHEMA_LAST_SAMPLE_IMPL kPropertyImplDense

void SchemaLastSamplePropertyInit(void)
{
   g_pPropSchemaLastSample = CreateIntProperty(&SchemaLastSampleDesc, SCHEMA_LAST_SAMPLE_IMPL);
}

int SchemaLastSampleGet(ObjID objID)
{
   int lastSample = -1;
   g_pPropSchemaLastSample->Get(objID, &lastSample);
   return lastSample;
}

// Initialize all schema properties
void SchemaPropsInit(void)
{
   SchemaLoopParamsPropertyInit();
   SchemaPlayParamsPropertyInit();
   SchemaPriorityPropertyInit();
   SchemaMessagePropertyInit();
   SchemaActionSndPropertyInit();
   SchemaLastSamplePropertyInit();
   SchemaAttFacPropertyInit();
}

void SchemaPropsTerm(void)
{
   SafeRelease(g_pPropSchemaAttFac);
   SafeRelease(g_pPropSchemaLastSample);
   SafeRelease(g_schemaPlayParamsProperty);
   SafeRelease(g_schemaLoopParamsProperty);
   SafeRelease(g_pPropSchemaPriority);
   SafeRelease(g_pPropSchemaMessage);
   SafeRelease(g_pPropSchemaActionSnd);
}
// $Header: r:/t2repos/thief2/src/sound/schprop.h,v 1.13 2000/01/29 13:41:55 adurant Exp $
// Properties that go on schema objects
#pragma once

#ifndef __SCHPROP_H
#define __SCHPROP_H

#include <propface.h>
#include <schtype.h>
#include <tagtype.h>

#undef INTERFACE
#define INTERFACE ISchemaPlayParamsProperty
DECLARE_PROPERTY_INTERFACE(ISchemaPlayParamsProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(sSchemaPlayParams*); 
}; 

#define PROP_SCHEMA_PLAY_PARAMS "SchPlayParams"

EXTERN ISchemaPlayParamsProperty *g_schemaPlayParamsProperty;

EXTERN void SchemaPlayParamsPropertyInit();
EXTERN sSchemaPlayParams *SchemaPlayParamsGet(ObjID objID);
#define SCHEMA_PLAY_PARAMS_SET(objID, pParams) \
   PROPERTY_SET(g_schemaPlayParamsProperty, objID, (sSchemaPlayParams*)pParams)
#define SCHEMA_PLAY_PARAMS_DELETE(objID) \
   IProperty_Delete(g_schemaPlayParamsProperty, objID)

#undef INTERFACE
#define INTERFACE ISchemaLoopParamsProperty
DECLARE_PROPERTY_INTERFACE(ISchemaLoopParamsProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(sSchemaLoopParams*); 
}; 

#define PROP_SCHEMA_LOOP_PARAMS "SchLoopParams"

EXTERN ISchemaLoopParamsProperty *g_schemaLoopParamsProperty;

EXTERN void SchemaLoopParamsPropertyInit();
EXTERN sSchemaLoopParams *SchemaLoopParamsGet(ObjID objID);
#define SCHEMA_LOOP_PARAMS_SET(objID, pParams) \
   PROPERTY_SET(g_schemaLoopParamsProperty, objID, (sSchemaLoopParams*)pParams)
#define SCHEMA_LOOP_PARAMS_DELETE(objID) \
   IProperty_Delete(g_schemaLoopParamsProperty, objID)

// Priority
EXTERN IIntProperty *g_pPropSchemaPriority;

#define SCH_PRIORITY_MIN 0
#define SCH_PRIORITY_NORMAL 128
#define SCH_PRIORITY_MAX 255

#define PROP_SCHEMA_PRIORITY "SchPriority"
EXTERN void SchemaPriorityPropInit(void);
EXTERN int SchemaPriorityGet(ObjID objID);
#define SCHEMA_PRIORITY_SET(objID, priority) \
   PROPERTY_SET(g_pPropSchemaPriority, objID, priority)
#define SCHEMA_PRIORITY_DELETE(objID) \
   IProperty_Delete(g_pPropSchemaPriority, objID)

// Sound messages
#define PROP_SCHEMA_MESSAGE "SchMsg"

// Schema message property
EXTERN ILabelProperty *g_pPropSchemaMessage;

EXTERN void SchemaMessagePropertyInit(void);
EXTERN Label *SchemaMessageGet(ObjID objID);
#define SCHEMA_MESSAGE_SET(objID, msg) \
   PROPERTY_SET(g_pPropSchemaMessage, objID, msg)
#define SCHEMA_MESSAGE_DELETE(objID)  \
   IProperty_Delete(g_pPropSchemaMessage, objID)

// "Action" sounds
#define PROP_SCHEMA_ACTION_SND "SchActionSnd"
EXTERN ILabelProperty *g_pPropSchemaActionSnd;
//EXTERN ILabelProperty *gPropSchemaActionSnd;
EXTERN void SchemaActionSndPropertyInit(void);
EXTERN Label *SchemaActionSndGet(ObjID objID);
#define SCHEMA_ACTION_SND_SET(objID, msg) \
   PROPERTY_SET(g_pPropSchemaActionSnd, objID, msg)
#define SCHEMA_ACTION_SND_DELETE(objID)  \
   IProperty_Delete(g_pPropSchemaActionSnd, objID)

// Last sample property
EXTERN IIntProperty *g_pPropSchemaLastSample;

#define PROP_SCHEMA_LAST_SAMPLE "SchLastSample"
EXTERN void SchemaLastSamplePropInit(void);
EXTERN int SchemaLastSampleGet(ObjID objID);
#define SCHEMA_LAST_SAMPLE_SET(objID, LastSample) \
   PROPERTY_SET(g_pPropSchemaLastSample, objID, LastSample)
#define SCHEMA_LAST_SAMPLE_DELETE(objID) \
   IProperty_Delete(g_pPropSchemaLastSample, objID)

// attenuation factor property
#define PROP_SCHEMA_ATTFAC "SchAttFac"
EXTERN IFloatProperty *g_pPropSchemaAttFac;
EXTERN float SchemaAttFacGet(ObjID objID);

// Initialize all schema properties
EXTERN void SchemaPropsInit(void);
EXTERN void SchemaPropsTerm(void);  // hey, lets clean up too, odd, i realize

#endif


// $Header: r:/t2repos/thief2/src/sound/schsamps.cpp,v 1.14 1999/06/22 21:17:45 ccarollo Exp $
// Schema sample name and frequency storage

#include <lg.h>
#include <cfgdbg.h>

// data structures
#include <dynarray.h>
#include <str.h>
#include <hashpp.h>
#include <hshpptem.h>

#include <vernum.h>

#include <schsamps.h>

// for destroying things when we load bad data
#include <speech.h>
#include <schdb.h>

// Must be last header
#include <dbmem.h>

// Schema sample class
// contains n samples and frequencies for a given schema
// Must initialize with number of samples

// TODO: Should replace dynarrays below with a static array
typedef cDynArray<cStr*> cStringArray;
typedef cDynArray<uchar> cFreqArray;

class cSchemaSamples
{
public:
   cSchemaSamples(int n);
   ~cSchemaSamples();
   const cStr &GetSample(int n) const;
   int GetSampleIndex(const char *name) const;
   const uchar *GetFreqs() const;
   int GetNum() const;
   void Set(int n, const char *pszSample, uchar freq);
   void Write(ITagFile *pFile); // write to an already open tag file
private:
   int num;
   cStringArray sampleArray;
   cFreqArray freqArray;
};

cSchemaSamples::cSchemaSamples(int n)
{
   int i;

   num = n;
   sampleArray.SetSize(n);
   freqArray.SetSize(n);
   for (i=0; i<n; i++)
   {
      sampleArray[i] = new cStr;
      freqArray[i] = 0;
   }
}

cSchemaSamples::~cSchemaSamples()
{
   int i;

   for (i=0; i<num; i++)
      delete sampleArray[i];
}

inline const cStr &cSchemaSamples::GetSample(int n) const
{
   return *(sampleArray[n]);
}

inline int cSchemaSamples::GetSampleIndex(const char *name) const
{
   for (int i=0; i<num; i++)
   {
      if (strcmp(((const char *)(*(sampleArray[i]))), name) == 0)
         return i;
   }
   return -1;
}

inline const uchar *cSchemaSamples::GetFreqs() const
{
   return &(freqArray[0]);
}

inline int cSchemaSamples::GetNum() const
{
   return num;
}

inline void cSchemaSamples::Set(int n, const char *pszSample, uchar freq)
{
   *(sampleArray[n]) = pszSample;
   freqArray[n] = freq;
}

void cSchemaSamples::Write(ITagFile *pFile)
{
   int i;
   cStr *pStr;

   pFile->Write((char*)&num, sizeof(int));
   for (i=0; i<num; i++)
   {
      int strLen;

      pStr = sampleArray[i];
      strLen = pStr->GetLength();
      pFile->Write((char*)(&strLen), sizeof(int));
      pFile->Write(*pStr, sizeof(char)*pStr->GetLength());
      pFile->Write((char*)&(freqArray[i]), sizeof(uchar));
   }
}

// Hash table for storing ObjID to schema sample structure mapping
typedef cHashTableFunctions<ObjID> sampleHashFunctions;
typedef cHashTable<ObjID, cSchemaSamples*, sampleHashFunctions> SchemaSampleHash;

static SchemaSampleHash *pSchemaSampleHash = NULL;

// Get a schema sample name, NULL if doesn't exist
const char *SchemaSampleGet(ObjID objID, int num)
{
   cSchemaSamples *pSchemaSamples;

   if (pSchemaSampleHash->Lookup(objID, &pSchemaSamples))
      return (const char *)(pSchemaSamples->GetSample(num));
   return NULL;
}

int SchemaSampleGetNamed(ObjID objID, const char *name)
{
   cSchemaSamples *pSchemaSamples;

   if (pSchemaSampleHash->Lookup(objID, &pSchemaSamples))
      return pSchemaSamples->GetSampleIndex(name);
   return -1;
}

// Get frequency array for schema, NULL if none
const uchar *SchemaFreqsGet(ObjID objID)
{
   cSchemaSamples *pSchemaSamples;

   if (pSchemaSampleHash->Lookup(objID, &pSchemaSamples))
      return pSchemaSamples->GetFreqs();
   return NULL;
}

// Get number of samples, 0 if schema not existant
int SchemaSamplesNum(ObjID objID)
{
   cSchemaSamples *pSchemaSamples;

   if (pSchemaSampleHash->Lookup(objID, &pSchemaSamples))
      return pSchemaSamples->GetNum();
   return 0;
}

// Create schema samples
BOOL SchemaSamplesCreate(ObjID objID, int num, const char **ppSampleName,
                         const uchar *pFreq)
{
   int i;
   cSchemaSamples *pSchemaSamples;

   ConfigSpew("SchemaSamples", ("Creating %d samples for schema %d\n", num, objID));
   if ((pSchemaSamples = new cSchemaSamples(num)) == NULL)
   {
      Warning(("SchemaSamplesCreate: can't create schema samples\n"));
      return FALSE;
   }
   pSchemaSampleHash->Set(objID, pSchemaSamples);
   for (i=0; i<num; i++)
      pSchemaSamples->Set(i, ppSampleName[i], pFreq[i]);
   return TRUE;
}

// Destroy samples for schema
void SchemaSamplesDestroy(ObjID objID)
{
   cSchemaSamples *pSchemaSamples;

   if (pSchemaSampleHash->Lookup(objID, &pSchemaSamples))
   {
      pSchemaSampleHash->Delete(objID);
      delete pSchemaSamples;
   }
}

// Clear all schema samples
void SchemaSamplesClear(void)
{
   SchemaSampleHash::cIter iter;

   iter = pSchemaSampleHash->Iter();
   while (!iter.Done())
   {
      pSchemaSampleHash->Delete(iter.Key());
      delete (cSchemaSamples*)(iter.Value());
      iter.Next();
   }
}

void SchemaSamplesInit(void)
{
   if (pSchemaSampleHash == NULL)
      pSchemaSampleHash = new SchemaSampleHash;
   else
      SchemaSamplesClear();
   Assert_(pSchemaSampleHash != NULL);
}

void SchemaSamplesShutdown(void)
{
   SchemaSamplesClear();
   delete pSchemaSampleHash;
}

static TagFileTag sSchemaSamplesTag = {"SchSamp"};
static TagVersion sSchemaSamplesVersion = {1, 0};

static BOOL SchemaSamplesOpenForReading(ITagFile *pFile)
{
   TagVersion sVersion = sSchemaSamplesVersion;

   if (SUCCEEDED(pFile->OpenBlock(&sSchemaSamplesTag, &sVersion)))
   {
      if ((sVersion.major != sSchemaSamplesVersion.major) ||
          (sVersion.minor != sSchemaSamplesVersion.minor))
      {
         pFile->CloseBlock();
         Warning(("SchemaSamplesOpenFile: file contains old data, not loaded\n"));
         Warning(("You should destroy all schemas with destroy_schemas\n"));
         Warning(("Then reload with load_schemas\n"));
         return FALSE;
      }
      return TRUE;
   }
   else
      return FALSE;
}

// Load sample info from tag file
void SchemaSamplesRead(ITagFile *pFile)
{
   int i;

   if (SchemaSamplesOpenForReading(pFile))
   {
      ObjID objID;
      cSchemaSamples *pSchemaSamples;
      int num;
      uchar freq;
      int strLen;
      cStr strBuffer;

      SchemaSamplesClear();
      while (pFile->Read((char*)&objID, sizeof(objID)))
      {
         pFile->Read((char*)&num, sizeof(int));
         pSchemaSamples = new cSchemaSamples(num);
         for (i=0; i<num; i++)
         {
            pFile->Read((char*)&strLen, sizeof(int));
            pFile->Read(strBuffer.GetBufferSetLength(strLen+1),
                        strLen*sizeof(char));
            strBuffer[strLen] = '\0';
            pFile->Read((char*)&freq, sizeof(uchar));
            pSchemaSamples->Set(i, (const char*)strBuffer, freq);
         }
         pSchemaSampleHash->Set(objID, pSchemaSamples);
      }
   }
}

// Save sample info to tag file
void SchemaSamplesWrite(ITagFile *pFile)
{
   SchemaSampleHash::cIter iter;
   TagVersion sVersion = sSchemaSamplesVersion;

   if (SUCCEEDED(pFile->OpenBlock(&sSchemaSamplesTag, &sVersion)))
   {
      iter = pSchemaSampleHash->Iter();
      while (!iter.Done())
      {
         pFile->Write((char*)&(iter.Key()), sizeof(iter.Key()));
         ((cSchemaSamples*)(iter.Value()))->Write(pFile);
         iter.Next();
      }
      pFile->CloseBlock();
   }
}



// $Header: r:/t2repos/thief2/src/sound/schsamps.h,v 1.5 2000/01/29 13:41:56 adurant Exp $
// Schema sample name storage
#pragma once

#ifndef SCHSAMPS_H
#define SCHSAMPS_H

#include <objtype.h>
#include <tagfile.h>

#define SAMPLE_DEFAULT_FREQ 1

// Create the samples for a schema
EXTERN BOOL SchemaSamplesCreate(ObjID objID, int num, 
                                const char **pSampleName, 
                                const uchar *freq);
// Get the nth sample for a schema
EXTERN const char *SchemaSampleGet(ObjID objID, int num);
// Get the index of the sample that matches this string
EXTERN int SchemaSampleGetNamed(ObjID objID, const char *name);
// Get array of frequencies
EXTERN const uchar *SchemaFreqsGet(ObjID objID);
// Get number of samples
EXTERN int SchemaSamplesNum(ObjID objID);

// Destroy samples for a particular schema
EXTERN void SchemaSamplesDestroy(ObjID objID);

EXTERN void SchemaSamplesShutdown();
EXTERN void SchemaSamplesInit();
// Destroy all schema samples stored
EXTERN void SchemaSamplesClear();

EXTERN void SchemaSamplesRead(ITagFile *pFile);
EXTERN void SchemaSamplesWrite(ITagFile *pFile);

#endif




#pragma once
typedef union {
   char *strval;
   int  ival;
   float fval;
} YYSTYPE;
#define SCHEMA	257
#define FLAGS	258
#define VOLUME	259
#define DELAY	260
#define PAN	261
#define PRIORITY	262
#define FADE	263
#define ARCHETYPE	264
#define FREQ	265
#define IDENT	266
#define STRING	267
#define INT	268
#define FLOAT	269
#define INCLUDE	270
#define DEFINE	271
#define MONO_LOOP	272
#define POLY_LOOP	273
#define CONCEPT	274
#define VOICE	275
#define LPAREN	276
#define RPAREN	277
#define EQUAL	278
#define COLON	279
#define TAG	280
#define TAG_INT	281
#define SCHEMA_VOICE	282
#define MESSAGE	283
#define AUDIO_CLASS	284
#define PAN_RANGE	285
#define NO_REPEAT	286
#define NO_CACHE	287
#define STREAM	288
#define LOOP_COUNT	289
#define ENV_TAG_REQUIRED	290
#define ENV_TAG	291
#define NO_COMBAT	292
#define PLAY_ONCE	293
#define NET_AMBIENT	294
#define LOCAL_SPATIAL	295
extern YYSTYPE yylval;
// $Header: r:/t2repos/thief2/src/sound/schtype.h,v 1.6 2000/01/29 13:41:58 adurant Exp $
// Schema basic type definitions
#pragma once

#ifndef SCHTYPE__H
#define SCHTYPE__H

#define SCH_HANDLE_NULL NULL
#define SCH_RANDOM_SAMPLE (-1)

typedef struct sSchemaPlayParams sSchemaPlayParams;
typedef struct sSchemaLoopParams sSchemaLoopParams;
typedef struct sSchemaCallParams sSchemaCallParams;
typedef struct sSchemaMsg sSchemaMsg;

#endif






// $Header: r:/t2repos/thief2/src/sound/schbase.h,v 1.25 2000/03/22 17:56:59 patmac Exp $
// Schema internal type definitions
#pragma once

#ifndef SCHBASE__H
#define SCHBASE__H

#include <objtype.h>
#include <label.h>
#include <matrixs.h>

#define SCHEMAS_MAX     100
#define SAMPLES_MAX     200
#define AVG_SAMPLE_NAME_LEN     10

#define SCH_PLAY_RETRIGGER (1<<0) // Does schema restart when multi-plays?
#define SCH_PAN_POS        (1<<1) // Fixed pan position described
#define SCH_PAN_RANGE      (1<<2) // Fixed pan within range described
#define SCH_NO_REPEAT      (1<<3) // Don't repeat last sample (if possible)

#define SCH_NO_CACHE       (1<<4) // dont cache this, we are unlikely to want it again
#define SCH_STREAM         (1<<5) // stream this off, dont load it all at once
#define SCH_PLAY_ONCE      (1<<6) // This is intended to be played only once.
#define SCH_NO_COMBAT      (1<<7) // This is not intended to be played in combat
#define SCH_NET_AMBIENT    (1<<8) // This ambient should be networked
#define SCH_LOC_SPATIAL    (1<<9) // This spatial sound should be local-only

#define SCH_CLASS_SHIFT    (16)
#define SCH_CLASS_MASK     (0x0F << SCH_CLASS_SHIFT)

typedef struct sSchemaPlayParams
{
   uint flags;
   int volume;        // nominal volume (-10k to -1)
   int pan;           // pan position or range if flag set (-10k to 10k)
   int initialDelay;  // before we start sample
   int fade;          // fade in/out in msec
} sSchemaPlayParams;  

#define SCHEMA_LOOP_POLY 0x01        // polyphonous
#define SCHEMA_LOOP_COUNT 0x02       // only loop n times

typedef struct sSchemaLoopParams
{
   uchar flags;
   uchar maxSamples;
   ushort count;        // number of times to loop
   ushort intervalMin;
   ushort intervalMax;
} sSchemaLoopParams;

typedef void (*SchemaCallback)(int hSchema, ObjID schemaID, void *pData);

// which fields to pay attention to
#define SCH_SET_VOLUME    0x0001 // exlusive with add, overrides it if both
#define SCH_ADD_VOLUME    0x0002
#define SCH_SCALE_VOLUME  0x0004
#define SCH_RADIUS_VOLUME 0x0008
#define SCH_SET_SAMPLE    0x0010
#define SCH_SET_OBJ       0x0020  // exclusive with loc, overrides it if both
#define SCH_SET_LOC       0x0040
#define SCH_SET_CALLBACK  0x0080
#define SCH_SET_MSG_DATA  0x0100
#define SCH_SET_MSG       0x0200
#define SCH_SET_LOOP_CALLBACK 0x0400
#define SCH_SHARP_ATTEN   0x0800
#define SCH_NETWORK       0x1000  // broadcast this ambient sound
#define SCH_NO_NETWORK    0x2000  // don't broadcast this spatial sound
#define SCH_FORCE_PLAY    0x4000

// Parameters provided to schema play functions
typedef struct sSchemaCallParams
{
   int flags;           // which fields are set
   int sampleNum;       // particular sample to play
   ObjID sourceID; 
   mxs_vector *pSourceLoc; 
   int volume;          // override/add to schema volume
   SchemaCallback callback; // callback when schema ends
   SchemaCallback loop_callback;
   void *pData;         // user data for callback
   Label *pMsg;         
   long msgData[3];     // data attached to schema message
} sSchemaCallParams;

// for when you only want to modify one call parameter
extern sSchemaCallParams g_sDefaultSchemaCallParams;

#define SCHEMA_MSG_DATA_SIZE 3 // big enough for an mxs_vector

// schema -> AI messages
typedef struct sSchemaMsg
{
   Label msgType;
   int volume;
   ObjID sourceID; 
   mxs_vector sourceLoc;
   long data[SCHEMA_MSG_DATA_SIZE]; 
} sSchemaMsg;


// these sound schema types must be in the same order as those in schema.y

typedef enum {
   kSchemaTypeNone,           // Originial Thief classes.
   kSchemaTypeNoise,
   kSchemaTypeSpeech,
   kSchemaTypeAmbient,
   kSchemaTypeMusic,
   kSchemaTypeMetaUI,
   kSchemaTypePlayerFeet,     // Additional Shock classes.
   kSchemaTypeOtherFeet,
   kSchemaTypeCollisions,
   kSchemaTypeWeapons,
   kSchemaTypeMonsters
} eSchemaType;

#define kNumSchemaTypes 16

#endif


// $Header: r:/t2repos/thief2/src/sound/schdb.h,v 1.5 2000/01/29 13:41:48 adurant Exp $
#pragma once

#ifndef __SCHDB_H
#define __SCHDB_H

#include <iobjsys.h>
#include <dispatch.h>

#define BASE_SCHEMA_OBJ "Schema"

// load all speech, archetype and schema files
EXTERN void SchemaFilesLoadAll(void);
// load all schema files matching "what" string
EXTERN void SchemaFilesLoad(const char *what);
EXTERN ObjID SchemaCreate(Label *pSchemaLabel, ObjID arch);
EXTERN void SchemaDatabaseNotify(DispatchData *msg);
EXTERN void SchemasDestroy(void);
EXTERN BOOL ObjIsSchema(ObjID objID);

#endif

//////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psndinst.cpp,v 1.79 2000/03/23 18:33:20 patmac Exp $
//
// Sound propagation functions
//

//#define PROFILE_ON

//#define PSI_TIMING
//#define FSP_TIMING

#include <lg.h>
#include <r3d.h>
#include <2d.h>

#include <math.h>

#include <config.h>
#include <cfgdbg.h>
#include <timings.h>
#include <objedit.h>

#include <matrixs.h>
#include <objpos.h>
#include <rendprop.h>  // SetRenderType & ObjSetHasRefs
#include <playrobj.h>
#include <ged_line.h>
#include <physapi.h>
#include <ghostmvr.h>

#include <comtools.h>
#include <iobjsys.h>
#include <osysbase.h>
#include <appagg.h>
#include <appsfx.h>
#include <schema.h>
#include <schbase.h>
#include <objmedia.h>
#include <iobjnet.h>
#include <sndnet.h>

#include <hashpp.h>
#include <hshpptem.h>

#include <roomsys.h>
#include <room.h>
#include <rooms.h>
#include <roomutil.h>
#include <doorprop.h>

#include <psnd.h>
#include <psndinst.h>

#include <aiapi.h>

#include <roomprop.h>

#include <mprintf.h>

// Must be last header
#include <dbmem.h>


DECLARE_TIMER(SFX_Play, Average);

////////////////////////////////////////////////////////////////////////////////

#ifdef _MSC_VER
template cSoundInfoTable;
template cSoundPropTable;
#endif

////////////////////////////////////////////////////////////////////////////////

const mxs_real kMaxPathDifference = 10.0;
const mxs_real kSoundConstant = 0.5;

////////////////////////////////////////////////////////////////////////////////

cPropSndInst::cPropSndInst()
 : m_nActiveSoundObjects(0)
{
   m_InfoTable.Clear();
   m_InfoList.SetSize(0);

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      m_ActiveObject[i] = OBJ_NULL;
      m_ActiveSound[i] = NULL;
   }

   m_deferredHaltList.SetSize(0);

   #ifndef SHIP
   m_DrawSoundPath = FALSE;
   #endif

   m_pAIManager = AppGetObj(IAIManager);
}

////////////////////////////////////////

cPropSndInst::~cPropSndInst()
{
   AutoAppIPtr_(ObjectSystem, pObjSys);

   ClearSoundInfo();

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveObject[i] != OBJ_NULL)
      {
         if (pObjSys->Exists(m_ActiveObject[i]))
            pObjSys->Destroy(m_ActiveObject[i]);
         m_ActiveObject[i] = OBJ_NULL;
      }
      m_ActiveSound[i] = NULL;
   }
   SafeRelease(m_pAIManager);

   m_deferredHaltList.SetSize(0);
}

////////////////////////////////////////

void cPropSndInst::Init(int handle, ObjID objID, const mxs_vector &loc, ObjID schemaID,
                        const char *sampleName, int flags, float atten_factor, sfx_parm *parms, void *data)
{
   AutoAppIPtr(ObjectSystem);

   m_SrcObject  = objID;
   m_SampleName = sampleName;
   m_pParms     = parms;
   m_Data       = data;
   m_Handle     = handle;
   m_SchemaID   = schemaID;
   m_Flags      = flags;

   m_attenFactor = atten_factor;

#ifndef SHIP
   m_SoundSpew       = config_is_defined("SoundSpew");
   m_SoundGhostSpew  = config_is_defined("SoundGhostSpew");
   m_SoundFullSpew   = config_is_defined("SoundFullSpew");
   m_SoundFullAISpew = config_is_defined("SoundFullAISpew");
   m_SoundHearSpew   = config_is_defined("SoundHearSpew");
   m_SoundPathSpew   = config_is_defined("SoundPathSpew");
#endif

   mx_copy_vec(&m_SrcPoint, (mxs_vector *) &loc);

   if (parms->radius > 0)
   {
      m_MaxDistance = parms->radius;
      m_ScaleDistance = SFX_MaxDist(parms->gain);
   }
   else
   {
      m_MaxDistance   = SFX_MaxDist(parms->gain) * atten_factor;
      m_ScaleDistance = parms->radius;
   }

   sDoorProp *pDoorProp;

   if ((pDoorProp = GetDoorProperty(objID)) != NULL)
   {
      m_roomNoBlock1 = pDoorProp->room1;
      m_roomNoBlock2 = pDoorProp->room2;
   }
   else
   {
      m_roomNoBlock1 = -1;
      m_roomNoBlock2 = -1;
   }

   // Make sure we have reserved our active sound objects
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveObject[i] == OBJ_NULL)
      {
         m_ActiveObject[i] = pObjectSystem->Create(ROOT_ARCHETYPE, kObjectConcrete);

         pObjectSystem->SetObjTransience(m_ActiveObject[i], TRUE);
         ObjSetRenderType(m_ActiveObject[i], kRenderNotAtAll);
         ObjSetHasRefs(m_ActiveObject[i], FALSE);
      }
   }
}

////////////////////////////////////////

void cPropSndInst::Cleanup()
{
   AutoAppIPtr_(ObjectSystem, pObjSys);

   // Order all sounds to halt
   g_pPropSnd->SoundHaltAll();

   // Destroy all active sounds
   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveObject[i] != OBJ_NULL)
      {
         if (pObjSys->Exists(m_ActiveObject[i]))
            pObjSys->Destroy(m_ActiveObject[i]);
         m_ActiveObject[i] = OBJ_NULL;
      }
   }
}

////////////////////////////////////////

// Keep in mind that the only reason this is a list is because when schema
// asks for a sound to be played it may result in it being played in several
// locations if the sound has taken multiple paths to the player.  Because
// we merge the sound down to one pretty much immediately, we're almost always
// dealing with a one-element list, which isn't much of a list at all, really.

cPlayerSoundList *cPropSndInst::GeneratePlayerSoundList(int handle)
{
   cPlayerSoundList *pPlayerList = NULL;
   cPlayerSoundList *pCurPlayerList = NULL;
   cSoundInfo       *pSoundInfo;
   cSoundInfo       *pSoundInfoNext;

   // Get the player's sound list
   if (PlayerObjectExists() && m_InfoTable.Lookup(PlayerObject(), (cSoundInfoList **)&pPlayerList))
   {
      // Allocate list for current sound
      pCurPlayerList = new cPlayerSoundList;

#if 0
      mprintf("Waiting sounds:\n");
      pSoundInfo = pPlayerList->GetFirst();
      while (pSoundInfo)
      {
         mprintf("  [%d] %s\n", pSoundInfo->Handle, pSoundInfo->SampleName);
         pSoundInfo = pSoundInfo->GetNext();
      }
#endif

      // Pull out all the current sounds
      pSoundInfo = pPlayerList->GetFirst();
      while (pSoundInfo != NULL)
      {
         pSoundInfoNext = pSoundInfo->GetNext();

         if (pSoundInfo->Handle == handle)
         {
            pPlayerList->Remove(pSoundInfo);
            pCurPlayerList->Append(pSoundInfo);
         }

         pSoundInfo = pSoundInfoNext;
      }

      // Test for no sounds
      pSoundInfo = pCurPlayerList->GetFirst();
      if (pSoundInfo != NULL)
      {
         // Merge our sounds down to just one
         MergeSounds(pCurPlayerList);

         pSoundInfo = pCurPlayerList->GetFirst();

         #ifndef SHIP
         if (m_SoundSpew)
         {
            mprintf(" [Player] hears \"%s\" at %g %g %g (%d dist) flags %x\n", pSoundInfo->SampleName,
                    pSoundInfo->Position.x, pSoundInfo->Position.y, pSoundInfo->Position.z,
                    (int)pSoundInfo->Distance, pSoundInfo->flags);
         }
         #endif
      }
      else
      {
         delete pCurPlayerList;
         pCurPlayerList = NULL;
      }
   }

   return pCurPlayerList;
}

//////////////////////////////////////

void cPropSndInst::SetupPlayerSoundListCallbacks(cPlayerSoundList *pCurPlayerList)
{
   cSoundInfo* pSoundInfo = pCurPlayerList->GetFirst();

   // Make copy of schema info we're interested in
   pCurPlayerList->SchemaCallback = m_pParms->end_callback;
   pCurPlayerList->SchemaLoopCallback = m_pParms->loop_callback;
   pCurPlayerList->SchemaUserData = m_pParms->user_data;

   Assert_(pCurPlayerList->SchemaCallback != EndSampleCallback);

   // Point our params to us
   pSoundInfo->AppsfxParms.end_callback  = EndSampleCallback;
   pSoundInfo->AppsfxParms.loop_callback  = LoopSampleCallback;
   pSoundInfo->AppsfxParms.user_data = (void *) (pSoundInfo->Handle);
   //   pSoundInfo->AppsfxParms.user_data = (void *)handle;
}

//////////////////////////////////////////

BOOL cPropSndInst::PlaySoundList(cPlayerSoundList *pCurPlayerList)
{
   BOOL retVal = TRUE;
   cSoundInfo *pSoundInfo = pCurPlayerList->GetFirst();

   // Determine if this is an active sound
   if (ActiveSound(pSoundInfo) && (m_nActiveSoundObjects < kMaxActiveSounds))
   {
      #ifndef SHIP
      if (m_SoundSpew)
         mprintf("    becomes active sound\n");
      #endif

      // Find unused active sound object
      for (int j=0; j<kMaxActiveSounds && (m_ActiveSound[j] != NULL); j++);

      AssertMsg(j != kMaxActiveSounds, "Unable to find available active sound object");

      // Point the sound struct at its active sound object
      pSoundInfo->flags &= ~kSIF_Deferred;
      pSoundInfo->ActiveObject = m_ActiveObject[j];
      m_ActiveSound[j] = pSoundInfo;
      m_nActiveSoundObjects++;

      // Position the object
      ObjTranslate(pSoundInfo->ActiveObject, &pSoundInfo->Position);
      pSoundInfo->AppsfxParms.distance = (int)(pSoundInfo->Distance + 0.5);

      AUTO_TIMER(SFX_Play);

      // Play sound on object
      pSoundInfo->SFXHandle = SFX_Play_Obj(SFX_3D, &pSoundInfo->AppsfxParms,
                                           pSoundInfo->SampleName, pSoundInfo->ActiveObject);
   }
   else
   {
      pSoundInfo->AppsfxParms.distance = (int)(pSoundInfo->Distance + 0.5);

      AUTO_TIMER(SFX_Play);

      // Fire and forget
      pSoundInfo->SFXHandle = SFX_Play_Vec(SFX_3D, &pSoundInfo->AppsfxParms,
                                           pSoundInfo->SampleName, &pSoundInfo->Position);
   }

   // With pioritization, this should never fail, but just in case
   if (pSoundInfo->SFXHandle == SFX_NO_HND)
   {
#ifndef SHIP
      mprintf("\"%s\" on %s failed to play!\n", pSoundInfo->SampleName, ObjWarnName(pSoundInfo->SrcObject));
#endif

      // Clear from active sound list
      if (pSoundInfo->ActiveObject != OBJ_NULL)
         EndActiveSound(pSoundInfo);

      retVal = FALSE;

      #ifndef SHIP
      if (m_SoundSpew)
         mprintf("    Yikes, couldn't play!\n");
      #endif
   }
   else
   {
      #ifndef SHIP
      if (m_SoundSpew)
         mprintf("    handle = %d, sfxhandle = %d\n", pSoundInfo->Handle, pSoundInfo->SFXHandle);
      #endif
   }

   return retVal;
}


////////////////////////////////////////

void EndSampleCallback(int hSound, void *data)
{
   cPlayerSoundList *pPlayerSoundList;
   cSoundInfo       *pSoundInfo;
   int handle = (int)data;

   if (g_pPropSnd == NULL)
      return;

   pPlayerSoundList = g_pPropSnd->GetSound(handle);

   if (pPlayerSoundList == NULL)
   {
#ifndef SHIP
      mprintf("End sample %d, unable to find handle (hSound = %d)\n", handle, hSound);
#endif
      return;
   }

   // Get the sound info for the sample
   pSoundInfo = pPlayerSoundList->GetFirst();

   AssertMsg(pSoundInfo != NULL, "Empty sound list?");
   AssertMsg(pSoundInfo->GetNext() == NULL, "Multiple sounds in list?");
   AssertMsg3(pSoundInfo->SFXHandle == hSound, "Invalid handle for ended sample %s (sfx = %d, hnd = %d)",
              pSoundInfo->SampleName, pSoundInfo->SFXHandle, hSound);

   // If bumping a sound, do nothing
   if (pSoundInfo->flags & kSIF_Intercept)
   {
      pSoundInfo->SFXHandle = SFX_NO_HND;
      pSoundInfo->flags &= ~kSIF_Intercept;
      return;
   }

   #ifndef SHIP
   if (config_is_defined("SoundSpew"))
      mprintf("Sample %s ended (handle %d, sfxhandle = %d)\n", pSoundInfo->SampleName, hSound, pSoundInfo->SFXHandle);
   #endif

   // If it's an active sound inform that it's being deleted
   if (!(pSoundInfo->flags & kSIF_Deferred))
       g_pPropSnd->EndActiveSound(pSoundInfo);

   // Callback to schema system
   if ( pPlayerSoundList->SchemaCallback != NULL )
      pPlayerSoundList->SchemaCallback(handle, pPlayerSoundList->SchemaUserData);

   // Delete it
   delete pPlayerSoundList->Remove(pSoundInfo);

   // Delete the list
   delete pPlayerSoundList;

   g_pPropSnd->RemoveSound(handle);
}


////////////////////////////////////////

void LoopSampleCallback(int hSound, void *data)
{
   cPlayerSoundList *pPlayerSoundList;
   cSoundInfo       *pSoundInfo;
   int handle = (int)data;

   if (g_pPropSnd == NULL)
      return;

   pPlayerSoundList = g_pPropSnd->GetSound(handle);

   if (pPlayerSoundList == NULL)
   {
      Warning(("Loop sample %d, unable to find handle\n", handle));
      return;
   }

   // Get the sound info for the sample
   pSoundInfo = pPlayerSoundList->GetFirst();

   #ifndef SHIP
   if (config_is_defined("SoundFullSpew"))
      mprintf("Sample looped (handle %d, sfxhandle = %d)\n", hSound,
              pSoundInfo->SFXHandle);
   #endif

   AssertMsg(pSoundInfo != NULL, "Empty sound list?");
   AssertMsg(pSoundInfo->GetNext() == NULL, "Multiple sounds in list?");
   AssertMsg3(pSoundInfo->SFXHandle == hSound,
              "Invalid handle for looped sample %s (sfx = %d, hnd = %d)",
              pSoundInfo->SampleName, pSoundInfo->SFXHandle, hSound);

   // Callback to schema system
   if (pPlayerSoundList->SchemaLoopCallback != NULL)
      pPlayerSoundList->SchemaLoopCallback(handle, pPlayerSoundList->SchemaUserData);
}

////////////////////////////////////////

void cPropSndInst::ApplySoundInfo()
{
   cDynArray<int> handleProcessedList;

   cSoundInfoList *pSoundInfoList;
   cSoundInfo     *pSoundInfo;

   UpdateActiveSounds();
   UpdateDeferredSounds();

   // Always do the player first, so the sound will be on the sound list when it
   // gets to the other players -- that way, they'll be able to set NetSent on it
   // if necessary.

   if (PlayerObjectExists() && (m_InfoTable.Lookup(PlayerObject(), &pSoundInfoList)))
   {
      ResolveActiveSounds(PlayerObject());
      ResolveDeferredSounds(PlayerObject());
   }

   for (int i=0; i<m_InfoList.Size(); i++)
   {
      // already done the player
      if (m_InfoList[i] == PlayerObject())
         continue;

      if (m_InfoTable.Lookup(m_InfoList[i], &pSoundInfoList))
      {
         pSoundInfo = pSoundInfoList->GetFirst();
         while (pSoundInfo != NULL)
         {
            // @HACK: cache this property somewhere
            if (GetPropertyNamed("AI")->IsRelevant(pSoundInfo->Object))
            {
               // AI HOOKUP HERE
               //
               // The pSoundInfo is the thing that you want to look at, the
               // structure is defined in psndinfo.h.  m_InfoList[i] is the
               // AI that is currently hearing the sound.
               //
               if (m_pAIManager)
                  m_pAIManager->NotifySound(pSoundInfo);

               #ifndef SHIP
               if (m_SoundFullAISpew && (pSoundInfo->SrcObject != pSoundInfo->Object))
               {
                  mprintf(" [%d] hears \"%s\" (%d) at %g %g %g (%d dist)\n", m_InfoList[i],
                          pSoundInfo->SampleName, pSoundInfo->SchemaID,
                          pSoundInfo->Position.x, pSoundInfo->Position.y, pSoundInfo->Position.z,
                          (int)pSoundInfo->Distance);
               }
               #endif
            }
            else
            if ((GetGhostType(pSoundInfo->Object) & kGhostListenTypes) == kGhostListenTypes)
            {
               int j;

               #ifndef SHIP
               //if (m_SoundGhostSpew)
               //   mprintf(" Ghost %d hears %s (flags %x)\n", pSoundInfo->Object, pSoundInfo->SampleName,
               //           pSoundInfo->flags);
               #endif

               if (g_pPropSnd->ShouldNetworkSound(&pSoundInfo->AppsfxParms, pSoundInfo->flags,
                                                  pSoundInfo->flags & kSIF_OnObject, pSoundInfo->SrcObject))
               {
                  BOOL found = FALSE;

                  // See if we've already dealt with this sound this frame, and ignore it if so.
                  // We may validly have duplicates if we've both generated and re-propagated
                  // before we get to this code, which happens fairly often when the sound is nearby.
                  for (j=0; j<handleProcessedList.Size(); j++)
                  {
                     if (handleProcessedList[j] == pSoundInfo->Handle)
                     {
                        found = TRUE;
                        break;
                     }
                  }

                  if (!found)
                  {
                     handleProcessedList.Append(pSoundInfo->Handle);

                     #ifndef SHIP
                     if (m_SoundGhostSpew)
                     {
                        mprintf(" [%d] remote, so playing \"%s\" remotely (handle %d)\n",
                                pSoundInfo->Object, pSoundInfo->SampleName, pSoundInfo->Handle);
                     }
                     #endif

                     // Tell other players to play this sound
                     if (pSoundInfo->flags & kSIF_OnObject)
                     {
                        SoundNetGenerateSoundObj(pSoundInfo->Handle, pSoundInfo->SrcObject, pSoundInfo->SchemaID,
                                                 pSoundInfo->SampleName, pSoundInfo->AttenFactor,
                                                 &pSoundInfo->AppsfxParms);
                     }
                     else
                     {
                        SoundNetGenerateSoundVec(pSoundInfo->Handle, &pSoundInfo->SrcPoint,
                                                 pSoundInfo->SchemaID, pSoundInfo->SampleName,
                                                 pSoundInfo->AttenFactor, &pSoundInfo->AppsfxParms);
                     }

                     // We want to make sure that we only send this sound message once, even if
                     // we're re-propagating it.
                     // There are a number of cases that need to be dealt with:
                     //
                     // - Oneshot, out of range of the player: Should propagate a single time
                     //   only, and then fail to play.  No reprop to be dealt with.
                     //
                     // - Oneshot, in range of the player: Will become an active sound and reprop
                     //   fairly often until the sample ends.  We send the sound message immediately.
                     //
                     // - Looping, out of range of the player: Will drop onto the deferred list and
                     //   be propagated regularly.  As soon as it's in range of any player, it's
                     //   broadcast to everyone.  It will then either play or be deferred on the
                     //   remote machines.  In either case, the host machine is done with it.
                     //
                     // - Looping, in range of the player: Sent immediately to everyone.  They will
                     //   either play it if it's in range, or defer it.  Again, the host machine is
                     //   done with it.
                     //
                     // All of these cases are simply handled by marking each locally-generated sound,
                     // whether deferred or not, as being NetSent when they're broadcast to the remote
                     // machines.  I believe that will cause the proper behavior everywhere.

                  }
                  else
                  {
                     #ifndef SHIP
                     if (m_SoundGhostSpew)
                        mprintf("  dup sound, not sending\n");
                     #endif
                  }
               }

               // Look through all sounds we're keeping track of, and mark them as NetSent, so
               // when they're reprop'ed, they know to set the flag.

               cPlayerSoundList *pPlayerSoundList;
               cSoundInfo       *pSound;

               for (j=0; j<kMaxActiveSounds; j++)
               {
                  if ((pPlayerSoundList = g_pPropSnd->GetSound(j)) != NULL)
                  {
                     pSound = pPlayerSoundList->GetFirst();
                     if (pSound->Handle == pSoundInfo->Handle)
                        pSound->flags |= kSIF_NetSent;
                  }
               }

            }

            delete pSoundInfoList->Remove(pSoundInfo);
            pSoundInfo = pSoundInfoList->GetFirst();
         }

         delete pSoundInfoList;
         m_InfoTable.Delete(m_InfoList[i]);

         m_InfoList.DeleteItem(i);

         i--;
      }
   }
}

////////////////////////////////////////

void cPropSndInst::ClearSoundInfo()
{
   cSoundInfoList *pSoundInfoList;
   cSoundInfo     *pSoundInfo;

   for (int i=0; i<m_InfoList.Size(); i++)
   {
      if (m_InfoTable.Lookup(m_InfoList[i], &pSoundInfoList))
      {
         pSoundInfo = pSoundInfoList->GetFirst();
         while (pSoundInfo != NULL)
         {
            pSoundInfoList->Remove(pSoundInfo);
            delete pSoundInfo;
            pSoundInfo = pSoundInfoList->GetFirst();
         }
         delete pSoundInfoList;
      }
   }

   m_InfoTable.Clear();
   m_InfoList.SetSize(0);
}

////////////////////////////////////////////////////////////////////////////////

void cPropSndInst::AddActiveSound(cSoundInfo *pSoundInfo)
{
// @OBB: i removed an ifndef SHIP, since we need to set J for below
   for (int j=0; j<kMaxActiveSounds && (m_ActiveSound[j] != NULL); j++);

   AssertMsg(j != kMaxActiveSounds, "Unable to find available active sound object");

   // Point the sound struct at its active sound object
   pSoundInfo->flags &= ~kSIF_Deferred;
   m_ActiveSound[j] = pSoundInfo;
   m_nActiveSoundObjects++;
}

void cPropSndInst::EndActiveSound(cSoundInfo *pActiveSound)
{
   cPlayerSoundList *pPlayerList;
   cSoundInfo       *pPlayerSoundInfo;
   cSoundInfo       *pPlayerSoundInfoNext;
   int i, j;

   // Find it in array
   for (i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveSound[i] == pActiveSound)
         break;
   }

   if (i != kMaxActiveSounds)
   {
      // Remove soundinfo from player list, just in case it's there
      if (PlayerObjectExists() && m_InfoTable.Lookup(PlayerObject(), (cSoundInfoList **)&pPlayerList))
      {
         pPlayerSoundInfo = pPlayerList->GetFirst();
         while (pPlayerSoundInfo != NULL)
         {
            pPlayerSoundInfoNext = pPlayerSoundInfo->GetNext();

            if (pPlayerSoundInfo->Handle == m_ActiveSound[i]->Handle)
               delete pPlayerList->Remove(pPlayerSoundInfo);

            pPlayerSoundInfo = pPlayerSoundInfoNext;
         }

         // If the player list is empty, delete it
         if (pPlayerList->GetFirst() == NULL)
         {
            delete pPlayerList;
            m_InfoTable.Delete(PlayerObject());

            for (j=0; j<m_InfoList.Size(); j++)
            {
               if (m_InfoList[j] == PlayerObject())
                  break;
            }

            if (j != m_InfoList.Size())
               m_InfoList.DeleteItem(j);
            else
               Warning(("EndActiveSound::player list empty, couldn't find in infolist\n"));
         }
      }

      // Clear pointer and decrement count
      m_ActiveSound[i] = NULL;
      m_nActiveSoundObjects--;
   }
   else
      Warning(("Unable to find active sound to end\n"));
}

////////////////////////////////////////////////////////////////////////////////

void cPropSndInst::BumpActiveSound(cPlayerSoundList *pPlayerList)
{
   cSoundInfo* pSoundInfo = pPlayerList->GetFirst();

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveSound[i] == pPlayerList->GetFirst())
      {
         // Set our "intercept" flag on this sample
         pSoundInfo->flags |= kSIF_Intercept;
         SFX_Kill_Hnd(pSoundInfo->SFXHandle);

         // Since we're taking it off the active list, make sure it's on the main list
         BOOL found = FALSE;
         for (int j=0; j<kMaxActiveSounds && !found; j++)
            found = (g_pPropSnd->GetSound(j) == pPlayerList);

         AssertMsg2(found, "Attempt to bump %s (handle %d), but not on SoundList!",
                    pSoundInfo->SampleName, pSoundInfo->Handle);

         // And clear off active list
         pSoundInfo->FramesUntilUpdate = kDeferredUpdateFrequency;
         pSoundInfo->ActiveObject = OBJ_NULL;
         pSoundInfo->flags |= kSIF_Deferred;

         #ifndef SHIP
         if (m_SoundSpew)
            mprintf("Bumping \"%s\" (handle %d) onto deferred list\n",
                    pSoundInfo->SampleName, pSoundInfo->Handle);
         #endif

         m_ActiveSound[i] = NULL;
         m_nActiveSoundObjects--;

         return;
      }
   }

   CriticalMsg2("Attempt to bump sound %s (handle %d), but not on ActiveList!",
                pSoundInfo->SampleName, pSoundInfo->Handle);
}

////////////////////////////////////////////////////////////////////////////////

BOOL cPropSndInst::MergeSounds(cSoundInfoList *pSoundInfoList)
{
   cSoundInfo *pSoundInfo;
   cSoundInfo *pSoundInfoNext;
   cSoundInfo *pMergeSoundInfo;
   mxs_real    min_dist;
   mxs_vector  glob;
   mxs_matrix  locframe;
   mxs_vector  sum_locdelta;
   mxs_real    weight_accum = 0;

   pSoundInfo = pSoundInfoList->GetFirst();

   // If empty or just one, don't merge
   if ((pSoundInfo == NULL) || (pSoundInfo->GetNext() == NULL))
      return FALSE;

   // Find the smallest distance
   min_dist = pSoundInfo->Distance;
   while (pSoundInfo != NULL)
   {
      if (pSoundInfo->Distance < min_dist)
         min_dist = pSoundInfo->Distance;
       pSoundInfo = pSoundInfo->GetNext();
   }

   // Weed out too-far sounds
   pSoundInfo = pSoundInfoList->GetFirst();
   while (pSoundInfo != NULL)
   {
      pSoundInfoNext = pSoundInfo->GetNext();

      if (pSoundInfo->Distance > (min_dist + kMaxPathDifference))
         delete pSoundInfoList->Remove(pSoundInfo);

      pSoundInfo = pSoundInfoNext;
   }

   // Point back to start and bail if down to only one
   pSoundInfo = pSoundInfoList->GetFirst();
   if (pSoundInfo->GetNext() == NULL)
      return FALSE;

   // Make new sound structure
   pMergeSoundInfo = new cSoundInfo(*pSoundInfo);

   #ifndef SHIP
   if (m_SoundFullSpew)
      mprintf("Merging sounds from %s\n", ObjWarnName(pSoundInfo->SrcObject));
   #endif

   // Set up for merge
   mx_ang2mat(&locframe, &ObjPosGet(PlayerObject())->fac);

   mx_zero_vec(&sum_locdelta);

   while (pSoundInfo != NULL)
   {
      mxs_vector locdelta;
      mxs_vector delta;
      mxs_real   weight;

      // Weight factor is square of amout from max path difference
      weight = min_dist + kMaxPathDifference - pSoundInfo->Distance;
      weight = weight * weight;

      if (weight == 0)
         weight = 0.5;

      // Get vector to sound
      mx_sub_vec(&delta, &pSoundInfo->Position, &ObjPosGet(PlayerObject())->loc.vec);
      if (mx_mag2_vec(&delta) > 0.0001)
         mx_normeq_vec(&delta);

      // Put in head-relative coords
      mx_mat_mul_vec(&locdelta, &locframe, &delta);

      // Flatten and re-normalize
      locdelta.z = 0;
      if (mx_mag2_vec(&locdelta) > 0.0001)
         mx_normeq_vec(&locdelta);

      // Scale by weight
      mx_scale_addeq_vec(&sum_locdelta, &locdelta, weight);

      // Accumulate for later divide
      weight_accum += weight;

      // Bye bye
      delete pSoundInfoList->Remove(pSoundInfo);
      pSoundInfo = pSoundInfoList->GetFirst();
   }

   pMergeSoundInfo->Distance = min_dist;

   // Average back down
   AssertMsg(weight_accum > 0, "Negative accumulated sound weight?");
   mx_scaleeq_vec(&sum_locdelta, 1 / weight_accum);

   // And place far enough away that a frame's worth of movement is irrelevant
   if (mx_mag2_vec(&sum_locdelta) > 0.0001)
      mx_normeq_vec(&sum_locdelta);
   mx_scaleeq_vec(&sum_locdelta, 100);

   // Convert back to world coords
   mx_inveq_mat(&locframe);
   mx_mat_mul_vec(&glob, &locframe, &sum_locdelta);
   mx_addeq_vec(&glob, &ObjPosGet(PlayerObject())->loc.vec);

   mx_copy_vec(&pMergeSoundInfo->Position, &glob);

   pSoundInfoList->Append(pMergeSoundInfo);

   return TRUE;
}

////////////////////////////////////////////////////////////////////////////////

// This function is called once per frame.  It repropagates any active sounds that
// are ready to be repropagated.

void cPropSndInst::UpdateActiveSounds()
{
   cPlayerSoundList *pPlayerList;
   cSoundInfo       *pSoundInfo;

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if ((m_ActiveSound[i] != NULL) && !(m_ActiveSound[i]->flags & kSIF_Static))
      {
         if (--m_ActiveSound[i]->FramesUntilUpdate <= 0)
         {
            pSoundInfo = m_ActiveSound[i];

            pSoundInfo->flags &= ~kSIF_HasBeenUpdated;

            #ifndef SHIP
            if (m_SoundFullSpew)
            {
               mprintf("Re-propagating \"%s\"", pSoundInfo->SampleName);
               if (pSoundInfo->flags & kSIF_OnObject)
                  mprintf(" from %s", ObjWarnName(pSoundInfo->SrcObject));
               mprintf(" flags %x\n", pSoundInfo->flags);
            }
            #endif

            // Remove the sound to be re-propagated from the object list
            if (PlayerObjectExists() &&
                m_InfoTable.Lookup(PlayerObject(), (cSoundInfoList **)&pPlayerList))
            {
               cSoundInfo *pPlayerSoundInfo;
               cSoundInfo *pPlayerSoundInfoNext;

               pPlayerSoundInfo = pPlayerList->GetFirst();
               while (pPlayerSoundInfo != NULL)
               {
                  pPlayerSoundInfoNext = pPlayerSoundInfo->GetNext();

                  Assert_(pPlayerSoundInfo != pSoundInfo);

                  if (pPlayerSoundInfo->Handle == pSoundInfo->Handle)
                     delete pPlayerList->Remove(pPlayerSoundInfo);

                  pPlayerSoundInfo = pPlayerSoundInfoNext;
               }
            }

            int gen_flags = ((pSoundInfo->flags & kSIF_Networked) ? kGSF_Networked : kGSF_None) |
                            ((pSoundInfo->flags & kSIF_NetSent) ? kGSF_NetSent : kGSF_None);

            // Re-propagate sound
            if (pSoundInfo->flags & kSIF_OnObject)
            {
               g_pPropSnd->GenerateSoundHandle(pSoundInfo->Handle,
                                               pSoundInfo->SrcObject,
                                               pSoundInfo->SchemaID,
                                               pSoundInfo->SampleName,
                                               pSoundInfo->AttenFactor,
                                               &pSoundInfo->AppsfxParms,
                                               gen_flags, pSoundInfo->Data);
            }
            else
            {
               g_pPropSnd->GenerateSoundHandle(pSoundInfo->Handle,
                                               pSoundInfo->SrcPoint,
                                               pSoundInfo->SrcObject,
                                               pSoundInfo->SchemaID,
                                               pSoundInfo->SampleName,
                                               pSoundInfo->AttenFactor,
                                               &pSoundInfo->AppsfxParms,
                                               gen_flags, pSoundInfo->Data);
            }

            mxs_real min_dist = mx_dist_vec(&ObjPosGet(PlayerObject())->loc.vec,
                                            &ObjPosGet(pSoundInfo->ActiveObject)->loc.vec);

            if (pSoundInfo->flags & kSIF_OnObject)
            {
               if (ObjPosGet(pSoundInfo->SrcObject) != NULL)
               {
                  mxs_real new_dist = mx_dist_vec(&ObjPosGet(PlayerObject())->loc.vec,
                                                  &ObjPosGet(pSoundInfo->SrcObject)->loc.vec);
                  if (new_dist < min_dist)
                     min_dist = new_dist;
               }
            }
            else
            {
               mxs_real new_dist = mx_dist_vec(&ObjPosGet(PlayerObject())->loc.vec,
                                               &pSoundInfo->SrcPoint);

               if (new_dist < min_dist)
                  min_dist = new_dist;
            }

            pSoundInfo->FramesUntilUpdate = min_dist / 10.0;

            if (pSoundInfo->FramesUntilUpdate > kMinUpdateFrequency)
               pSoundInfo->FramesUntilUpdate = kMinUpdateFrequency;

            if (pSoundInfo->FramesUntilUpdate < kMaxUpdateFrequency)
               pSoundInfo->FramesUntilUpdate = kMaxUpdateFrequency;

            #ifndef SHIP
            if (m_SoundFullSpew)
               mprintf("fuu = %d (for handle %d)\n", pSoundInfo->FramesUntilUpdate, pSoundInfo->Handle);
            #endif
         }
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

void cPropSndInst::UpdateDeferredSounds()
{
   cPlayerSoundList *pPlayerSoundList;
   cSoundInfo       *pDeferredSound;

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      // Grab any sound in this slot
      if ((pPlayerSoundList = g_pPropSnd->GetSound(i)) != NULL)
      {
         pDeferredSound = pPlayerSoundList->GetFirst();

         // Only deal with deferred sounds here
         if (pDeferredSound->flags & kSIF_Deferred)
         {
            if (--pDeferredSound->FramesUntilUpdate <= 0)
            {
               pDeferredSound->flags &= ~kSIF_HasBeenUpdated;

               if (pDeferredSound->flags & kSIF_Static)
               {
                  // We don't re-propagate statics, they're always good
                  if (PlayerObjectExists())
                  {
                     #ifndef SHIP
                     if (m_SoundFullSpew)
                        mprintf("Re-triggering deferred static \"%s\"\n", pDeferredSound->SampleName);
                     #endif

                     cPlayerSoundList *pPlayerList;

                     // Create a new sound list if there isn't one waiting
                     if (!m_InfoTable.Lookup(PlayerObject(), (cSoundInfoList **)&pPlayerList))
                        pPlayerList = new cPlayerSoundList;

                     pPlayerList->SchemaCallback = pPlayerSoundList->SchemaCallback;
                     pPlayerList->SchemaLoopCallback = pPlayerSoundList->SchemaLoopCallback;
                     pPlayerList->SchemaUserData = pPlayerList->SchemaUserData;

                     cSoundInfo *pNewSoundInfo = new cSoundInfo;

                     pNewSoundInfo->flags = pDeferredSound->flags;
                     pNewSoundInfo->Object = PlayerObject();
                     pNewSoundInfo->Handle = pDeferredSound->Handle;

                     strncpy(pNewSoundInfo->SampleName, pDeferredSound->SampleName, 16);
                     pNewSoundInfo->AppsfxParms = pDeferredSound->AppsfxParms;

                     pPlayerList->Append(pNewSoundInfo);
                  }
               }
               else
               {
                  #ifndef SHIP
                  if (m_SoundFullSpew)
                  {
                     mprintf("Re-propagating deferred \"%s\"", pDeferredSound->SampleName);
                     if (pDeferredSound->flags & kSIF_OnObject)
                        mprintf(" from %s\n", ObjWarnName(pDeferredSound->SrcObject));
                     else
                        mprintf("\n");
                  }
                  #endif

                  int gen_flags = ((pDeferredSound->flags & kSIF_Networked) ? kGSF_Networked : kGSF_None) |
                                  ((pDeferredSound->flags & kSIF_NetSent) ? kGSF_NetSent : kGSF_None);

                  // Re-propagate sound
                  if (pDeferredSound->flags & kSIF_OnObject)
                  {
                     g_pPropSnd->GenerateSoundHandle(pDeferredSound->Handle,
                                                     pDeferredSound->SrcObject,
                                                     pDeferredSound->SchemaID,
                                                     pDeferredSound->SampleName,
                                                     pDeferredSound->AttenFactor,
                                                     &pDeferredSound->AppsfxParms,
                                                     gen_flags, pDeferredSound->Data);
                  }
                  else
                  {
                     g_pPropSnd->GenerateSoundHandle(pDeferredSound->Handle,
                                                     pDeferredSound->SrcPoint,
                                                     pDeferredSound->SrcObject,
                                                     pDeferredSound->SchemaID,
                                                     pDeferredSound->SampleName,
                                                     pDeferredSound->AttenFactor,
                                                     &pDeferredSound->AppsfxParms,
                                                     gen_flags, pDeferredSound->Data);
                  }
               }

               pDeferredSound->FramesUntilUpdate = kDeferredUpdateFrequency;
            }
         }
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

BOOL cPropSndInst::ActiveSound(cSoundInfo *pSoundInfo)
{
   // @TODO: Heuristic for whether this sound should be updated each frame

   return TRUE;
}

////////////////////////////////////////////////////////////////////////////////

// This function is called once per frame for the player object after repropagation.
// It updates 3D location for active sounds.

void cPropSndInst::ResolveActiveSounds(ObjID hearingObj)
{
   cSoundInfoList *pSoundInfoList;
   cSoundInfoList AccumList;
   cSoundInfo *pActiveSound;
   cSoundInfo *pSoundInfo;
   cSoundInfo *pSoundInfoNext;
   int i;

   for (i=0; i<kMaxActiveSounds; i++)
   {
      if ((m_ActiveSound[i] != NULL) && !(m_ActiveSound[i]->flags & kSIF_Static))
      {
         // Because bumping a sound could screw with m_InfoTable, we look
         // this up every pass through the loop, so be sure we have a fresh
         // pointer.
         if (m_InfoTable.Lookup(hearingObj, &pSoundInfoList))
         {
            pActiveSound = m_ActiveSound[i];

            AssertMsg(AccumList.GetFirst() == NULL, "Sound accumulator not empty on resolve start?");
            AssertMsg(!(pActiveSound->flags & kSIF_Deferred), "Deferred sound on active list!");

            // If our sound is ready to be updated
            if (!(pActiveSound->flags & kSIF_HasBeenUpdated))
            {
               pActiveSound->flags |= kSIF_HasBeenUpdated;

               // Find the objects in the list with the same handle
               pSoundInfo = pSoundInfoList->GetFirst();
               while (pSoundInfo != NULL)
               {
                  pSoundInfoNext = pSoundInfo->GetNext();

                  // Ignore any deferred sounds
                  if (!(pSoundInfo->flags & kSIF_Deferred))
                  {
                     if (pActiveSound->Handle == pSoundInfo->Handle)
                     {
                        pSoundInfoList->Remove(pSoundInfo);
                        AccumList.Append(pSoundInfo);
                     }
                  }

                  pSoundInfo = pSoundInfoNext;
               }

               if (AccumList.GetFirst() != NULL)
               {
                  // Merge all sounds from that object into one
                  MergeSounds(&AccumList);
                  pSoundInfo = AccumList.GetFirst();

                  // Update the virtual sound's position
                  ObjTranslate(pActiveSound->ActiveObject, &pSoundInfo->Position);

                  if ( SFX_Use_Occlusion(pActiveSound->SFXHandle) ) {
                     // EAX Occlusion is available to model attenuation due to closed doors, so
                     //   pass the real distance and the blocking factor
                     SFX_Slam_Dist_BF(pActiveSound->SFXHandle, (int)(pSoundInfo->RealDistance + 0.5),
                                      pSoundInfo->BlockingFactor, FALSE);
                  } else {
                     // pass the munged distance which combines real distance and blocking factor
                     SFX_Slam_Dist(pActiveSound->SFXHandle, (int)(pSoundInfo->Distance + 0.5), FALSE);
                  }

                  pActiveSound->Distance = pSoundInfo->Distance;
                  // Note: SFX_Attenuate does NOT reuqire an SFX channel.
                  pActiveSound->Volume = SFX_Attenuate(pActiveSound->AppsfxParms.gain, pActiveSound->Distance);

                  #ifndef SHIP
                  if (m_SoundFullSpew)
                     mprintf("   Handle %d (%s, on %s) is slammed to %d dist\n",
                             pActiveSound->Handle, pActiveSound->SampleName, ObjWarnName(pActiveSound->SrcObject),
                             (int)(pSoundInfo->Distance + 0.5));
                  #endif

                  // And remove it from the list
                  delete AccumList.Remove(pSoundInfo);
               }
               else
               {
                  // The sound doesn't appear on on our sound list, so it must have
                  // gone out of range.

                  #ifndef SHIP
                  if (m_SoundSpew)
                     mprintf("\"%s\" (handle %d) out of range, either bumping or killing\n",
                             pActiveSound->SampleName, pActiveSound->Handle);
                  #endif

                  // Find our sound list
                  cPlayerSoundList *pSoundList;
                  BOOL found = FALSE;

                  for (int j=0; j<kMaxActiveSounds; j++)
                  {
                     if ((pSoundList = g_pPropSnd->GetSound(j)) != NULL)
                     {
                        if (pSoundList->GetFirst() == pActiveSound)
                        {
                           found = TRUE;
                           break;
                        }
                     }
                  }

                  if (found)
                  {
                     // Either kill the sound or move it onto the deferred list
                     if (pActiveSound->AppsfxParms.flag & SFXFLG_LOOP)
                        BumpActiveSound(pSoundList);
                     else
                        SFX_Kill_Hnd(pActiveSound->SFXHandle);
                  }
                  else
                  {
                     Warning(("Missing active sound \"%s\" (handle %d) is not on the sound list",
                              pActiveSound->SampleName, pActiveSound->Handle));
                  }
               }
            }
         }
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

void cPropSndInst::ResolveDeferredSounds(ObjID hearingObj)
{
   cPlayerSoundList *pPlayerSoundList;
   cSoundInfoList *pSoundInfoList;
   cSoundInfoList AccumList;
   cSoundInfo *pDeferredSound;
   cSoundInfo *pSoundInfo;
   cSoundInfo *pSoundInfoNext;
   int i;

   for (i=0; i<kMaxActiveSounds; i++)
   {
      AssertMsg(AccumList.GetFirst() == NULL, "Sound accumulator not empty on resolve start?");

      // Grab any sound in this slot
      if ((pPlayerSoundList = g_pPropSnd->GetSound(i)) != NULL)
      {
         pDeferredSound = pPlayerSoundList->GetFirst();

         // Only deal with deferred sounds here
         if (pDeferredSound->flags & kSIF_Deferred)
         {
            // Only deal with sounds that have been repropagated, but not updated
            if (!(pDeferredSound->flags & kSIF_HasBeenUpdated))
            {
               pDeferredSound->flags |= kSIF_HasBeenUpdated;

               // Because bumping a sound could screw with m_InfoTable, we look
               // this up every pass through the loop, so be sure we have a fresh
               // pointer.
               if (m_InfoTable.Lookup(hearingObj, &pSoundInfoList))
               {
                  // Find the objects in the list with the same handle
                  pSoundInfo = pSoundInfoList->GetFirst();
                  while (pSoundInfo != NULL)
                  {
                     pSoundInfoNext = pSoundInfo->GetNext();

                     if (pDeferredSound->Handle == pSoundInfo->Handle)
                     {
                        pSoundInfoList->Remove(pSoundInfo);
                        AccumList.Append(pSoundInfo);
                     }

                     pSoundInfo = pSoundInfoNext;
                  }

                  if (AccumList.GetFirst() != NULL)
                  {
                     // Merge all sounds from that object into one
                     MergeSounds(&AccumList);
                     pSoundInfo = AccumList.Remove(AccumList.GetFirst());

                     pSoundInfo->flags |= kSIF_Deferred;
                     pSoundInfo->SFXHandle = -1;

                     delete pPlayerSoundList->Remove(pPlayerSoundList->GetFirst());
                     pPlayerSoundList->Append(pSoundInfo);

                     // Try to start up the sound again
                     if (g_pPropSnd->Prioritize(pPlayerSoundList) == PRIORITY_RES_OK)
                     {
                        #ifndef SHIP
                        if (m_SoundSpew)
                           mprintf("Restarting \"%s\" (handle %d)\n",
                                   pSoundInfo->SampleName, pSoundInfo->Handle);
                        #endif

                        if (pSoundInfo->flags & kSIF_Static)
                        {
                           pSoundInfo->SFXHandle = SFX_Play_Raw(SFX_STATIC, &pSoundInfo->AppsfxParms, pSoundInfo->SampleName);

                           for (int j=0; j<kMaxActiveSounds && (m_ActiveSound[j] != NULL); j++);

                           if (pSoundInfo->SFXHandle != SFX_NO_HND)
                           {
                              #ifndef SHIP
                              if (m_SoundSpew)
                                 mprintf("  static restart succeeded\n");
                              #endif

                              pSoundInfo->flags &= ~kSIF_Deferred;
                              m_ActiveSound[j] = pSoundInfo;
                              m_nActiveSoundObjects++;
                           }
                        }
                        else
                        {
                           if (!PlaySoundList(pPlayerSoundList))
                           {
                              pSoundInfo->flags |= kSIF_Deferred;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
}

////////////////////////////////////////////////////////////////////////////////

#ifndef SHIP
void cPropSndInst::DrawActiveSounds()
{
   int ocol = gr_get_fcolor();
   r3s_point pt;
   cSoundInfo *pSoundInfo;

   for (int i=0; i<kMaxActiveSounds; i++)
   {
      if ((pSoundInfo = m_ActiveSound[i]) == NULL)
         continue;

      r3_start_block();
      r3_transform_block(1, &pt, &ObjPosGet(pSoundInfo->ActiveObject)->loc.vec);
      r3_end_block();

      if (pt.ccodes == 0)
      {
         gr_set_fcolor(241);
         g2_circle(pt.grp.sx, pt.grp.sy, fix_div(4, grd_bm.w));
         gr_set_fcolor(0);
         g2_circle(pt.grp.sx, pt.grp.sy, fix_div(5, grd_bm.w));
         g2_circle(pt.grp.sx, pt.grp.sy, fix_div(3, grd_bm.w));
      }
   }

   gr_set_fcolor(ocol);
}

void cPropSndInst::SpewActiveSounds()
{
   static char buff[256];
   int i;

   mprintf("\nACTIVE SOUND LIST\n");
   for (i=0; i<kMaxActiveSounds; i++)
   {
      if (m_ActiveSound[i] == NULL)
         mprintf(" [%d] - FREE -\n", i);
      else
      {
         sprintf(buff, " [%d] %13s   handle %2d   obj %3d   dist %5g", i,
                 m_ActiveSound[i]->SampleName, m_ActiveSound[i]->Handle,
                 m_ActiveSound[i]->SrcObject, m_ActiveSound[i]->Distance);
         mprintf("%s\n", buff);
      }
   }
}
#endif

////////////////////////////////////////////////////////////////////////////////

DECLARE_TIMER(FSP_Total, Average);
DECLARE_TIMER(FSP_PathResolve, Average);
DECLARE_TIMER(FSP_DistDirCalc, Average);

#define MAX_PORTALS 64
#define MAX_INLINE_DIST_SQ 25.0

void cPropSndInst::BackCastPath(sAnchorPt *anchor_list, cRoomPortal **portal_list, int i, const mxs_vector &L, const mxs_vector &src_pt)
{
   mxs_vector proj_pt;
   mxs_vector dir;
   int j, k;

   // Now we need to cast backward, to see if we lifted the last
   // anchor point off its corner.  This is kind of nasty.

   // Find last anchor, and the one before it
   int last_proj_portal = -1;
   int last_anchor = -1;

   BOOL can_raycast;

   mxs_vector head_pt = L;
   mxs_vector last_anchor_pt;

   for (j=i-1; j>=0; j--)
   {
      if (anchor_list[j].valid)
      {
         if (last_proj_portal < 0)
            last_proj_portal = j;
         else
            if (last_anchor < 0)
            {
               last_anchor = j;
               break;
            }
      }
   }

   // If we found a single portal, use the source object
   if (last_anchor < 0)
      last_anchor_pt = src_pt;
   else
      last_anchor_pt = anchor_list[last_anchor].pos;

   for (j=i-1; j>=0; j--)
   {
      if ((j == last_proj_portal) || (last_proj_portal == -1))
         mx_sub_vec(&dir, &last_anchor_pt, &head_pt);
      else
         mx_sub_vec(&dir, &anchor_list[last_proj_portal].pos, &head_pt);

      can_raycast = portal_list[j]->Raycast(head_pt, dir);

      // If we generate a new anchor point, add to active list,
      // and move head_pt.
      if (!can_raycast)
      {
         portal_list[j]->GetRaycastProj(head_pt, dir, &proj_pt);

         // New anchor point, add to list, and move head_pt
         if (!anchor_list[j].valid)
         {
            anchor_list[j].pos = head_pt = proj_pt;
            anchor_list[j].valid = TRUE;
         }
         else
         // We either moved last_proj_portal's point, or hit it
         {
            Assert_(j == last_proj_portal);

            if (mx_dist2_vec(&anchor_list[j].pos, &proj_pt) < MAX_INLINE_DIST_SQ)
            {
               // We hit it, so we're done backing up
               return;
            }
            else
            {
               // We missed it, so update the position, update head_pt,
               // and keep going.
               anchor_list[j].pos = head_pt = proj_pt;

               // Update last_anchor and last_proj_portal
               last_proj_portal = last_anchor;

               last_anchor = -1;
               for (k=last_proj_portal-1; k>=0; k--)
               {
                  if (anchor_list[k].valid)
                  {
                     last_anchor = k;
                     break;
                  }
               }

               if (last_anchor < 0)
                  last_anchor_pt = src_pt;
               else
                  last_anchor_pt = anchor_list[last_anchor].pos;
            }
         }
      }
      else
      // If we can now raycast through the portal of the adjacent
      // anchor, we've lifted it off.
      if (anchor_list[j].valid)
      {
         Assert_(j == last_proj_portal);

         anchor_list[j].valid = FALSE;

         // If this was the only portal, we're done
         if (last_anchor < 0)
            return;

         // Update last_anchor and last_proj_portal
         last_proj_portal = last_anchor;

         last_anchor = -1;
         for (k=last_proj_portal-1; k>=0; k--)
         {
            if (anchor_list[k].valid)
            {
               last_anchor = k;
               break;
            }
         }

         if (last_anchor < 0)
            last_anchor_pt = src_pt;
         else
            last_anchor_pt = anchor_list[last_anchor].pos;
      }
   }
}

////////////////////////////////////////

#ifndef SHIP
static int hear_count = 0;
static int hear_depth_accum = 0;
static int min_depth = 1000;
static int max_depth = 0;
#endif

void cPropSndInst::FindSoundPath(const mxs_vector &src_pt, const mxs_vector &hear_pt, const cBFRoomInfo *room_table, int end_room,
                                 mxs_real *dist, mxs_vector *position, mxs_real *realDist, mxs_real *blockingFactor)
{
   #ifdef FSP_TIMING
   AUTO_TIMER(FSP_Total);

   TIMER_Start(FSP_PathResolve);
   #endif

   static cRoomPortal *portal_list[MAX_PORTALS];
   static sAnchorPt anchor_list[MAX_PORTALS];

   int portal_list_size = 0;

   mxs_vector L;
   mxs_vector H;
   mxs_vector dir;
   mxs_vector proj_pt;
   int i;

   // Initialization
   memset(anchor_list, 0, sizeof(sAnchorPt) * MAX_PORTALS);

   int cur_room = end_room;
   int prev_portal;

   float blocking = 1.0;
   static int prev_room;
   const cRoom *pTheRoom;
   float fTransmission;

   pTheRoom = g_pRooms->GetRoom(cur_room);

   // Get transmission property for current room
   if (g_pLoudRoomProperty->Get(pTheRoom->GetObjID(), &fTransmission))
      blocking *= fTransmission;

   // Count portals and accumulate blocking
   while (room_table[cur_room].GetPreviousPortal() >= 0)
   {
      prev_room = room_table[cur_room].GetPreviousRoom();

      if (((cur_room != m_roomNoBlock1)  || (prev_room != m_roomNoBlock2)) &&
          ((prev_room != m_roomNoBlock1) || (cur_room != m_roomNoBlock2)))
      {
         pTheRoom = g_pRooms->GetRoom(room_table[cur_room].GetPreviousRoom());

         // Get transmission property for adjacent room
         if (g_pLoudRoomProperty->Get(pTheRoom->GetObjID(), &fTransmission))
            blocking *= fTransmission;

         blocking *= (1.0 - g_pPropSnd->GetBlockingFactor(cur_room, room_table[cur_room].GetPreviousRoom()));
      }

      portal_list_size++;
      cur_room = room_table[cur_room].GetPreviousRoom();
   }

   AssertMsg1(portal_list_size < MAX_PORTALS, "FindSoundPath: too many portals (%d)", portal_list_size);

   #ifndef SHIP
   if (m_SoundHearSpew)
   {
      int room_count = portal_list_size + 1;

      hear_count++;
      hear_depth_accum += room_count;
      if (room_count < min_depth)
         min_depth = room_count;
      if (room_count > max_depth)
         max_depth = room_count;

      mprintf(" avg depth = %g\n", ((float)hear_depth_accum) / ((float)hear_count));
      mprintf(" min depth = %d\n", min_depth);
      mprintf(" max depth = %d\n", max_depth);
      mprintf("\n");
   }
   #endif

   // Fill in portal list, backward, so it's in the right direction for us
   for (i=1; end_room >= 0; end_room = room_table[end_room].GetPreviousRoom())
   {
      prev_portal = room_table[end_room].GetPreviousPortal();

      if (prev_portal >= 0)
      {
         portal_list[portal_list_size - i] = g_pRooms->GetRoom(end_room)->GetPortal(prev_portal);
         i++;
      }
   }

   L = src_pt;

   for (i=0; i<portal_list_size; i++)
   {
      // Cast from our L point through the current portal to the center
      // of the next portal
      if ((i + 1) == portal_list_size)
        H = hear_pt;
      else
        H = portal_list[i+1]->GetCenter();

      mx_sub_vec(&dir, &H, &L);

      if (!portal_list[i]->Raycast(L, dir))
      {
         // Failed raycast, so project onto portal edge
         portal_list[i]->GetRaycastProj(L, dir, &proj_pt);

         // Add to anchor list
         anchor_list[i].pos = proj_pt;
         anchor_list[i].valid = TRUE;

         // Move L to the new anchor point
         L = proj_pt;

         BackCastPath(anchor_list, portal_list, i, L, src_pt);
      }
   }

   BackCastPath(anchor_list, portal_list, i, hear_pt, src_pt);

   #ifdef FSP_TIMING
   TIMER_MarkStop(FSP_PathResolve);
   TIMER_Start(FSP_DistDirCalc);
   #endif

   // Add up segment distances
   int last_anchor = -1;

   #ifndef SHIP
   if (m_SoundPathSpew)
      mprintf("start = %g %g %g\n", src_pt.x, src_pt.y, src_pt.z);
   #endif

   *dist = 0.0;
   for (i=0; i<portal_list_size; i++)
   {
      if (anchor_list[i].valid)
      {
         #ifndef SHIP
         if (m_SoundPathSpew)
            mprintf("anchor[%d] = %g %g %g\n", i, anchor_list[i].pos.x, anchor_list[i].pos.y, anchor_list[i].pos.z);
         #endif

         if (last_anchor < 0)
            *dist += mx_dist_vec(&src_pt, &anchor_list[i].pos);
         else
            *dist += mx_dist_vec(&anchor_list[last_anchor].pos, &anchor_list[i].pos);

         last_anchor = i;
      }
   }

   #ifndef SHIP
   if (m_SoundPathSpew)
   {
      mprintf("end = %g %g %g\n", hear_pt.x, hear_pt.y, hear_pt.z);
      mprintf("\n");
   }
   #endif

   #ifndef SHIP
   #ifdef EDITOR
   if (PlayerObjectExists() && m_DrawSoundPath &&
       (ObjPosGet(PlayerObject())->loc.vec.x == hear_pt.x) &&
       (ObjPosGet(PlayerObject())->loc.vec.y == hear_pt.y))
   {
      ged_line_load_channel = LINE_CH_SOUND;

      mxs_vector from = src_pt;

      for (i=0; i<portal_list_size; i++)
      {
         if (anchor_list[i].valid)
         {
            gedLineAddRGB(&from, &anchor_list[i].pos, LINE_FLG_DIR, 255, 255, 0);
            from = anchor_list[i].pos;
         }
      }

      gedLineAddRGB(&from, &hear_pt, LINE_FLG_DIR, 255, 255, 0);
   }
   #endif
   #endif

   if (last_anchor < 0)
   {
      *dist += mx_dist_vec(&src_pt, &hear_pt);
      *position = src_pt;
   }
   else
   {
      *dist += mx_dist_vec(&anchor_list[last_anchor].pos, &hear_pt);
      *position = anchor_list[last_anchor].pos;
   }

   *realDist = *dist;
   blocking = 1.0 - blocking;
   // blocking of 0 means no blocking, 1 means completely blocked

   if (*dist < m_MaxDistance)
      *dist += (m_MaxDistance - *dist) * blocking;

   *blockingFactor = blocking;

   #ifdef FSP_TIMING
   TIMER_MarkStop(FSP_DistDirCalc);
   #endif
}

////////////////////////////////////////////////////////////////////////////////

DECLARE_TIMER(PSI_EnterCallback, Average);
DECLARE_TIMER(PSI_PortalsCallback, Average);

#define  sq(x)  ((x)*(x))

BOOL cPropSndInstHigh::EnterCallback(const cRoom *room, const cRoomPortal *enterPortal,
                                     const mxs_vector &enterPt, mxs_real dist)
{
   #ifdef PSI_TIMING
   AUTO_TIMER(PSI_EnterCallback);
   #endif

   if (dist > m_MaxDistance)
      return FALSE;

   cSoundInfoList *pSoundInfoList;
   cSoundInfo     *pSoundInfo;
   mxs_vector      objPos;
   const ObjID    *obj_list;
   int             num_objs;

   mxs_real        obj_dist, blocking_factor, real_dist, old_obj_dist;
   mxs_vector      speaker_pos;

   // Get the list of applicable objects
   room->GetObjList(&obj_list, &num_objs, g_SndWatchHandle);

   // For each object in the room
   while (num_objs--)
   {
      if (PlayerObjectExists() && (*obj_list == PlayerObject()))
         PhysGetSubModLocation(*obj_list, PLAYER_HEAD, &objPos);
      else
         objPos = ObjPosGet(*obj_list)->loc.vec;

      // @TODO: make this lo-res for AIs
      FindSoundPath(m_SrcPoint, objPos, m_RoomPropAgent->GetRoomBrushInfo(), room->GetRoomID(), &obj_dist, &speaker_pos, &real_dist, &blocking_factor);

      if (PortalsCallback(NULL, NULL, obj_dist) < 0)
         goto next_high_sound;

      old_obj_dist = obj_dist;
      if (m_ScaleDistance > 0)
      {
         if (m_pParms->flag & SFXFLG_SHARP)
         {
            mxs_real scale_pct = obj_dist / m_MaxDistance;
            obj_dist = pow(scale_pct, 4) * m_ScaleDistance;
         }
         else
            obj_dist = (obj_dist / m_MaxDistance) * m_ScaleDistance;
      }

      obj_dist /= m_attenFactor;

      real_dist *= (obj_dist / old_obj_dist);

      if (PlayerObjectExists() &&
          (*obj_list == PlayerObject()) &&
          (PhysGetObjMediaState(*obj_list) == kMS_Liquid_Submerged))
      {
         if (m_ScaleDistance > 0)
            obj_dist += (m_ScaleDistance - obj_dist) * 0.5;
         else
            obj_dist += (m_MaxDistance - obj_dist) * 0.5;
      }

      // Create the sound structure
      pSoundInfo = new cSoundInfo;

      strcpy(pSoundInfo->SampleName, m_SampleName);
      pSoundInfo->SchemaID = m_SchemaID;
      pSoundInfo->SrcObject = m_SrcObject;
      pSoundInfo->Object = *obj_list;
      pSoundInfo->Handle = m_Handle;
      pSoundInfo->flags = kSIF_HasBeenUpdated | m_Flags;
      pSoundInfo->ActiveObject = OBJ_NULL;
      pSoundInfo->FramesUntilUpdate = 1;
      pSoundInfo->AppsfxParms = *m_pParms;
      pSoundInfo->Data = m_Data;
      pSoundInfo->AttenFactor = m_attenFactor;

      pSoundInfo->SrcPoint = m_SrcPoint;

      pSoundInfo->Distance = obj_dist;
      pSoundInfo->Volume = SFX_Attenuate(m_pParms->gain, pSoundInfo->Distance);
      pSoundInfo->BlockingFactor = blocking_factor;
      pSoundInfo->RealDistance = real_dist;

      // Extrapolate speaker_pos
      if (PlayerObjectExists() && (*obj_list == PlayerObject()))
      {
         mxs_vector snd_dir;

         mx_sub_vec(&snd_dir, &speaker_pos, &objPos);
         if (mx_mag2_vec(&snd_dir) > 0.0001)
            mx_normeq_vec(&snd_dir);
         mx_scale_add_vec(&pSoundInfo->Position, &objPos, &snd_dir, obj_dist);
      }
      else
         pSoundInfo->Position = speaker_pos;

      // Get the sound list for the object
      if (!m_InfoTable.Lookup(*obj_list, &pSoundInfoList))
      {
         // Allocate a new sound list
         if (PlayerObjectExists() && (*obj_list == PlayerObject()))
            pSoundInfoList = new cPlayerSoundList;
         else
            pSoundInfoList = new cSoundInfoList;

         // Mark the object as hearing a sound
         m_InfoList.Append(*obj_list);
      }

      // Add sound structure to list
      pSoundInfoList->Append(pSoundInfo);

      // @TBD: Need to re-hash here always?
      m_InfoTable.Set(*obj_list, pSoundInfoList);

next_high_sound:
      obj_list++;
   }

   return TRUE;
}

////////////////////////////////////////

void cPropSndInstHigh::ExitCallback(const cRoom *room)
{
}

////////////////////////////////////////

mxs_real cPropSndInstHigh::PortalsCallback(const cRoomPortal *enterPortal,
                                           const cRoomPortal *exitPortal, mxs_real dist)
{
   #ifdef PSI_TIMING
   AUTO_TIMER(PSI_PortalsCallback);
   #endif

   short room1;
   short room2;

   // Adjust distance for blocked exit portal
   if (exitPortal != NULL)
   {
      room1 = exitPortal->GetNearRoom()->GetRoomID();
      room2 = exitPortal->GetFarRoom()->GetRoomID();

      if (((room1 != m_roomNoBlock1) || (room2 != m_roomNoBlock2)) &&
          ((room2 != m_roomNoBlock1) || (room1 != m_roomNoBlock2)))
      {
         if (dist > m_MaxDistance)
            return -1.0;

         dist += (m_MaxDistance - dist) *
            g_pPropSnd->GetBlockingFactor(exitPortal->GetNearRoom()->GetRoomID(),
                                          exitPortal->GetFarRoom()->GetRoomID());
      }
   }

   if (dist > m_MaxDistance)
      return -1.0;

   return dist;
}

////////////////////////////////////////////////////////////////////////////////





// $Header: r:/t2repos/thief2/src/sound/schema.h,v 1.11 2000/01/29 13:41:49 adurant Exp $
#pragma once

#ifndef SCHEMA_H
#define SCHEMA_H

#include <schtype.h>
#include <osystype.h>
#include <matrixs.h>
#include <objpos.h>

// Initialize the schema system
EXTERN void SchemaInit(void);
EXTERN void SchemaShutdown(void);


// In C++, the pData parameters in the playing functions are optional.
#ifdef __cplusplus
#define OPT_DATA(d) = d
#else // __cplusplus
#define OPT_DATA(d)
#endif // __cplusplus


// Play a named schema return handle to schema playing
EXTERN int SchemaPlay(const Label *schemaName, sSchemaCallParams *pParams,
                      void *pData OPT_DATA(NULL));
// Play on an object (dynamic 3d)
EXTERN int SchemaPlayObj(const Label *schemaName, ObjID objID,
                         void *pData OPT_DATA(NULL));
// Play at a location (static 3d)
EXTERN int SchemaPlayLoc(const Label *schemaName, mxs_vector *pLoc,
                         void *pData OPT_DATA(NULL));

// Play at an object's location at time of call (static 3d)
#define SCHEMA_PLAY_OBJ_LOC(pSchemaName, objID) \
   SchemaPlayLoc(pSchemaName, &(ObjPosGet(objID)->loc.vec), NULL)

// Play a schema by ID
EXTERN int SchemaIDPlay(ObjID schemaID, sSchemaCallParams *pParams,
                        void *pData OPT_DATA(NULL));
EXTERN int SchemaIDPlayObj(ObjID schemaID, ObjID objID,
                           void *pData OPT_DATA(NULL));
EXTERN int SchemaIDPlayLoc(ObjID schemaID, mxs_vector *pLoc,
                           void *pData OPT_DATA(NULL));

#define SCHEMA_ID_PLAY_OBJ_LOC(schemaID, objID) \
   SchemaIDPlayLoc(schemaID, &(ObjPosGet(objID)->loc.vec), NULL)

EXTERN void SchemaPlayHalt(int hSchemaPlay);
EXTERN void SchemaHaltAll(void);

// Get a schema ID from the schema handle
EXTERN ObjID SchemaGetIDFromHandle(int hSchemaPlay);

// Get an appsfx handle from the schema handle
EXTERN int SchemaGetSFXFromHandle(int hSchemaPlay, int iWhich);

EXTERN void SchemaFrame(void);

// why is this here? where should it be?
EXTERN double SchemaRand(void);

#endif

// $Header: r:/t2repos/thief2/src/sound/schema_.h,v 1.2 2000/01/29 13:41:50 adurant Exp $
#pragma once

#ifndef SCHEMA__H
#define SCHEMA__H

#include <iobjsys.h>
#include <traitman.h>

EXTERN IObjectSystem* pObjSys;
EXTERN ITraitManager* pTraitMan;

#endif



// $Header: r:/t2repos/thief2/src/sound/schdb.cpp,v 1.31 1998/10/14 03:14:07 dc Exp $

#include <cfgdbg.h>

#include <objsys.h>
#include <traitman.h>
#include <propman.h>
#include <iobjsys.h>
#include <objquery.h>
#include <traitbas.h>

#include <dbasemsg.h>
#include <dispbase.h>

#include <datapath.h>
#include <config.h>

#include <schema.h>
#include <schprop.h>
#include <schbase.h>
#include <schdb.h>
#include <schsamps.h>
#include <schyacc.h>
#include <speech.h>
#include <esnd.h>
#include <schema_.h>
#include <schfile.h>

#include <texprop.h>

// Must be last header
#include <dbmem.h>

#define SCHEMA_DIR "schema" // where we expect to find schemas off base art path

// number of schemas/samples to start with
#define SCHEMAS_START_NUM       100
#define SAMPLES_START_NUM       200
#define SAMPLE_CHARS_START_NUM  2000

// Hey, I copied this from lresname.c
// It should undoubtedly be changed/centralised somewhere.
#ifndef __WATCOMC__
# if defined(__OS2__) || defined(__NT__)
#   define NAME_MAX	255		/* maximum filename for HPFS or NTFS */
#   define PATH_MAX	259 /* maximum length of full pathname excl. '\0' */
# else
#   define NAME_MAX	12		/* 8 chars + '.' +  3 chars */
#   define PATH_MAX	143 /* maximum length of full pathname excl. '\0' */
# endif
#endif

static struct sSchemaPlayParams baseSchemaPlayParams = {0, -1, 0, 0, 0};

// Is the object a schema?
BOOL ObjIsSchema(ObjID objID)
{
   ObjID baseSchemaID;

   if ((baseSchemaID = pObjSys->GetObjectNamed(BASE_SCHEMA_OBJ)) != OBJ_NULL)
      return pTraitMan->ObjHasDonor(objID, baseSchemaID);
   return FALSE;
}

// destroy all schemas
void SchemasDestroy(void)
{
   ObjID baseSchemaID;

   if ((baseSchemaID = pObjSys->GetObjectNamed(BASE_SCHEMA_OBJ)) != OBJ_NULL)
   {
      IObjectQuery *pQuery;

      pQuery = pTraitMan->Query(baseSchemaID, kTraitQueryAllDescendents);
      while (!pQuery->Done())
      {
         pObjSys->Destroy(pQuery->Object());
         pQuery->Next();
      }
      SafeRelease(pQuery);
   }
   SchemaSamplesClear();
}

static BOOL obj_is_missing(ObjID obj)
{
   ObjID missing = pObjSys->GetObjectNamed("Missing"); 
   return  missing != OBJ_NULL && pTraitMan->ObjHasDonor(obj,missing); 
}


// Create a new schema, return Obj ID of new object, 
// OBJ_NULL if can't create or object exists already
ObjID SchemaCreate(Label *pSchemaLabel, ObjID arch)
{

   ConfigSpew("SchemaCreate", ("SchemaCreate: %s, arch: %d\n", &pSchemaLabel[0], arch));

   ObjID obj = pObjSys->GetObjectNamed(pSchemaLabel->text);

   if (obj != OBJ_NULL)
   {
      if (ObjIsSchema(obj) || obj_is_missing(obj))
      {
         SchemaSamplesDestroy(obj);
         SCHEMA_PLAY_PARAMS_DELETE(obj);
         SCHEMA_LOOP_PARAMS_DELETE(obj);
         SCHEMA_PRIORITY_DELETE(obj);
         SCHEMA_MESSAGE_DELETE(obj);
         if (!ObjIsSchema(arch))
         {
            arch = pObjSys->GetObjectNamed(BASE_SCHEMA_OBJ);
            Warning(("Archetype %d is not a schema archetype\n",arch)); 
         }
         pTraitMan->SetArchetype(obj,arch); 
      }  
      else
      {
         Label newname = { "s$" }; 
         strncat(newname.text,pSchemaLabel->text,sizeof(newname.text)-strlen(newname.text)-1);
         Warning(("Schema name conflict! Renaming %s to %s\n",pSchemaLabel->text,newname.text)); 
         return SchemaCreate(&newname,arch); 
      }
   }
   else
   {
      obj = pTraitMan->CreateArchetype(pSchemaLabel->text, arch); 
      if (obj == OBJ_NULL)
         Warning(("SchemaCreate: can't create schema %s\n", &pSchemaLabel[0]));
   }
   return obj;
}

void SchemasBuildDefault(void)
{
   ISchemaPlayParamsProperty *playParamsProp;
   ITraitManager *pTraitMan = AppGetObj(ITraitManager);
   ObjID baseSchemaID;

   if (SUCCEEDED(pTraitMan->CreateBaseArchetype(BASE_SCHEMA_OBJ, &baseSchemaID)))
   {
      GetPropertyInterfaceNamed(PROP_SCHEMA_PLAY_PARAMS, ISchemaPlayParamsProperty, &playParamsProp);
      playParamsProp->Create(baseSchemaID);
      playParamsProp->Set(baseSchemaID, &baseSchemaPlayParams);
   }
   SafeRelease(pTraitMan);
}

#ifdef SCHEMA_LOADING
void SchemaFilesLoad(const char *what)
{
   SchemaFilesLoadFromDir("schema", what, SchemaYaccParse);
}

void SchemaFilesLoadAll()
{
   SchemaFilesLoad("*.spc");
   SchemaFilesLoad("*.arc");
   SchemaFilesLoad("*.sch");

   SpeechNotifyTextParseEnd();
   ESndNotifyTextParseEnd();
}
#endif

/*
  Deal with database events.
*/
EXTERN void SchemaDatabaseNotify(DispatchData *msg)
{
   msgDatabaseData data;

   data.raw = msg->data;
   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         SpeechDestroy();
         SchemaSamplesClear();
         break;

      case kDatabaseDefault:
         SchemasBuildDefault();
         SpeechDestroy();
         SpeechBuildDefault();
         terrainprop_load();         
         break;

      case kDatabaseSave:
         if (msg->subtype & kObjPartAbstract)
         {
            SchemaSamplesWrite(data.save);
         }
         break;

      case kDatabaseLoad:
         if (msg->subtype & kObjPartAbstract)
         {
            SchemaSamplesRead(data.load);
         }
         break;

      case kDatabasePostLoad:
         terrainprop_load();
         break;
   }
}
// $Header: r:/t2repos/thief2/src/sound/metasnd.cpp,v 1.5 2000/02/19 12:37:11 toml Exp $

#include <guistyle.h>
#include <metasnd.h>
#include <config.h>
#include <timer.h>

#include <mprintf.h>

#include <appsfx.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

///////////////////
// state

static BOOL inGameMode=FALSE;    // from gamemode.c - what a hack
static int  screen_type=-1;      // which type of panel is this
static int  vol_offset=0;        // do we want to hack volumes
static BOOL metaGameSound=TRUE;  // if we want to be able to turn it off

//#define TEST_MSND
#ifdef TEST_MSND
#define msnd_mprintf(x) mprintf x
#else
#define msnd_mprintf(x)
#endif

///////////////////
// guistyle

#define kMetaSndTick     (0)
#define kMetaSndSelect   (1)
#define kMetaSndAttend   (2)
#define kMetaSndAmbient1 (3)
#define kMetaSndAmbient2 (4)
#define kMetaSndNumTypes (5)

static char  metaSndNames[kMetaSndPanelCount][kMetaSndNumTypes][16];
static char *screens[kMetaSndPanelCount]={"def","main","saveload","options","loadout","book","game"};
static char *posts[kMetaSndNumTypes]={"tick","select","attend","ambient1","ambient2"};
static int   metaSndAmbHandle=SFX_NO_HND;

#define metaGetNamed(scr,snd) (metaSndNames[scr][kMetaSnd##snd])
#define metaGetNum(scr,num)   (metaSndNames[scr][num])

// load the stuff
void metaSndLoadGUINames(char *prefix)
{
   char buf[64];
   for (int i=0; i<kMetaSndPanelCount; i++)
      for (int j=0; j<kMetaSndNumTypes; j++)
      {
         sprintf(buf,"metasnd_%s_%s_%s",prefix,screens[i],posts[j]);
         if (config_is_defined(buf))
         {
            config_get_raw(buf,metaSndNames[i][j],16 /* sizeof(metaSndNames[i][j]) */);
         }
         else
            strcpy(metaSndNames[i][j],"");
      }
}

//////////////////////
// this is our actual callback

// do a frame
void metaSndDoFrame(void)
{
#ifdef AUTO_PAUSE   
   int tm=tm_get_millisec_unrecorded();
   while (tm_get_millisec_unrecorded()<tm+1)
      ;  // we are kinda trying to wait for asynch for now
#endif   
   SFX_Frame(NULL,NULL);  // lets repump
}

bool metaSndPlayGUICallback(StyleSound sound)
{  // will be StyleSoundTick, Select, Attention
   if (screen_type!=-1)
      if (metaSndNames[screen_type][sound][0]!='\0')
         if (metaGameSound)
         {
            SFX_Play_Raw(SFX_STATIC,NULL,metaGetNum(screen_type,sound));
            msnd_mprintf(("Argh, %d on screen %d\n",sound,screen_type));
            if (sound!=0)
               metaSndDoFrame();
         }
   return TRUE;
}

/////////////////////
// controlled plays for mode transistions
static void _metasnd_end_callback(int hSound, void *user_data)
{
   if (hSound==metaSndAmbHandle)
   {
      metaSndAmbHandle=SFX_NO_HND;
      msnd_mprintf(("Killing our amb in callback\n"));
   }
}

void metaSndEnterPanel(int panel_type)
{
   if (inGameMode&&panel_type!=kMetaSndPanelOptions&&panel_type!=kMetaSndPanelBook) 
      panel_type=kMetaSndPanelInGame; // for now - ok, this is getting idiotic
   
   // in real life we should, if inGameMode, do nothing here, i think
   BOOL no_change=(metaSndAmbHandle!=SFX_NO_HND);
   msnd_mprintf(("meta Enter %d (%d) [%d]\n",panel_type,inGameMode,screen_type));
   if (panel_type!=kMetaSndPanelLast)
   {
      if ((screen_type!=panel_type)&&(no_change))
         if (screen_type==-1)
            no_change=FALSE;
         else if (stricmp(metaGetNamed(screen_type,Ambient1),metaGetNamed(panel_type,Ambient1))!=0)
            no_change=FALSE;
      screen_type=panel_type;
   }
   if (no_change)
    { msnd_mprintf(("Same Amb\n")); return; }
   if (metaGetNamed(screen_type,Ambient1)[0]!='\0')
   {
      sfx_parm loop_parm={SFX_DEF_PARM,SFXFLG_LOOP,0,0};
      loop_parm.end_callback=_metasnd_end_callback;
      if (metaSndAmbHandle!=SFX_NO_HND)
      {
         msnd_mprintf(("Already Playing\n"));
         SFX_Kill_Hnd(metaSndAmbHandle);
      }
      if (metaGameSound)
         metaSndAmbHandle=SFX_Play_Raw(SFX_STATIC,&loop_parm,metaGetNamed(screen_type,Ambient1));
      msnd_mprintf(("handle %d for [%s]\n",metaSndAmbHandle,metaGetNamed(screen_type,Ambient1)));
   }
   else if (metaSndAmbHandle!=SFX_NO_HND)
   {  // we are supposed to play nothing!
      msnd_mprintf(("Nothing to play, killing existing\n"));
      SFX_Kill_Hnd(metaSndAmbHandle);
   }
   else
      msnd_mprintf(("Nothing to play, nothing currently playing\n"));
}

void metaSndExitPanel(BOOL kill_snds)
{
   if (kill_snds&&(metaSndAmbHandle!=SFX_NO_HND))
   {
      SFX_Kill_Hnd(metaSndAmbHandle);
      metaSndAmbHandle=SFX_NO_HND;
      screen_type=-1;
      msnd_mprintf(("killed..."));
   }
   else if (kill_snds)
      screen_type=-1;
   msnd_mprintf(("meta Exit\n"));
}

///////////
// find out what mode

void metaSndEnterGame(void)
{
   inGameMode=TRUE;
   metaSndExitPanel(TRUE);
   msnd_mprintf(("msGameOn\n"));
}

void metaSndExitGame(void)
{
   inGameMode=FALSE;
   msnd_mprintf(("msGameOff\n"));
}

///////////
// init/term

void metaSndInit(char *snd_prefix)
{
   metaSndLoadGUINames(snd_prefix);
   if (config_is_defined("no_metagame_sound"))
      metaGameSound=FALSE;
}

void metaSndTerm(void)
{
}
// $Header: r:/t2repos/thief2/src/sound/schema.cpp,v 1.89 2000/01/14 10:44:35 MAT Exp $

#include <stdlib.h>
#include <math.h>
#include <limits.h>
#include <lgassert.h>
#include <cfgdbg.h>
#include <timer.h>
#include <lgsound.h>

#include <matrix.h>
#include <dlist.h>
#include <appagg.h>

#include <wrtype.h>
#include <objpos.h>

#include <status.h>
#include <command.h>
#include <iobjsys.h>
#include <appsfx.h>
#include <winui.h>
#include <schema.h>
#include <schprop.h>
#include <schyacc.h>
#include <schbase.h>
#include <schsamps.h>
#include <schdb.h>
#include <speech.h>
#include <schmsg.h>
#include <schema_.h>
#include <tag.h>
#include <psndapi.h>
#include <esndglue.h>

#include <texprop.h>
#include <playrobj.h>
#include <camera.h>
#include <rand.h>
#include <objedit.h>

#ifdef PLAYTEST
#include <config.h>
#include <mprintf.h>
#endif

#ifndef SHIP
#include <recapi.h>
#include <dynarray.h>
#endif

// Must be last header
#include <dbmem.h>

#define min(x,y) ((x)<(y)?(x):(y))

#ifdef OLD_WAY
// this will be bad if the schema doesn't exist or have a name...
inline const char* OBJ_NAME(ObjID obj)
{
   static char buf[32]; 

   const char* s = pObjSys->GetName(obj); 
   if (!s)
   {
      sprintf(buf,"#%d",obj); 
      return buf; 
   }
   return s ; 
}
#else
#define OBJ_NAME(obj) ObjWarnName(obj)
#endif

#define SCHEMA_LOOP_NEXT_TIME(time, pLoopParams) \
   ((time)+(pLoopParams)->intervalMin+(int)(SchemaRand()* \
    ((pLoopParams)->intervalMax-(pLoopParams)->intervalMin)))

// This is the condition for special case zero delay schemas to loop
// over a single sample using the sound library rather than the schema
// looping code (if we need to count the iterations we handle it
// through a callback, but the sound library still does the looping)
#define SCHEMA_LOOP_SINGLE_SOUND(pLoopParams) \
   (((pLoopParams) != NULL) && \
    ((pLoopParams)->intervalMin == 0) && \
    ((pLoopParams)->intervalMax == 0))

#define SCHEMA_NUM_LOOPS(pLoopParams) \
      (((pLoopParams) && (pLoopParams->flags & SCHEMA_LOOP_COUNT))? \
      pLoopParams->count : 0)

// Maximum distance at which we start a schema playing, squared
#define SCHEMA_MAX_PLAY_DIST 5000

// are we playing back a recording?
#define RECORDER_PLAYBACK() \
   (pRecorder && ((pRecorder->GetMode() == kRecPlayback) || \
                  (pRecorder->GetMode() == kRecPausedPlayback)))

IObjectSystem* pObjSys = NULL;
ITraitManager* pTraitMan = NULL;

#ifndef SHIP
// Lots of recorder stuff to spoof sound callbacks

// The basic idea behind schema recording is to record the decisions
// to start samples and the callbacks that end them. Of course, the
// actual samples played during a recording may be completely out of
// synch with this. However, we should still send the same messages
// and therefore the game state should stay in synch.
static IRecorder *pRecorder = NULL;
// callback handles and data for spoofing
typedef cDynArray<int> cCallbackHandleArray;
typedef cDynArray<void*> cCallbackDataArray;
static cCallbackHandleArray callbackHandles;
static cCallbackDataArray callbackData;
static cCallbackHandleArray loopCallbackHandles;
static cCallbackDataArray loopCallbackData;
static BOOL spoofingCallbacks = FALSE;

// We have separate arrays for callbacks which occur while we're
// stuffing our regular callbacks into the recording stream (that is,
// for when spoofingCallbacks is TRUE).
static cCallbackHandleArray callbackHandles2;
static cCallbackDataArray callbackData2;
static cCallbackHandleArray loopCallbackHandles2;
static cCallbackDataArray loopCallbackData2;

#endif

// one for each sample playing as part of a schema
typedef struct sSchemaPlaySample
{
   int hSound;  // handle to sound
   struct sSchemaPlaySample *next;
#ifndef SHIP
   int hRealSound; // actual 
#endif
} sSchemaPlaySample;

struct sSchemaPlay;

class SchemaPlayList : public cDList<sSchemaPlay,1> 
{
public:
   ~SchemaPlayList()
   {
   }
};

typedef cDListNode<sSchemaPlay,1> SchemaPlayListNode;

// one for each schema that is currently playing
struct sSchemaPlay : public SchemaPlayListNode
{
   ObjID schemaID;
   int flags;
   ObjID sourceID;
   mxs_vector sourceLoc;
   int volume;
   int count;                   // no of samples
   int loopCount;               // number of samples we've played (cumulative)
   sSchemaPlaySample *pSamples; // currently playing samples
   SchemaCallback callback;     // optional callback on schema play end
   SchemaCallback loop_callback;// optional callback
   void *userData;              // for callbacks
   Label msg;
   long msgData[3];
   int nextTime;                // when to start next sample (if looping)
};

SchemaPlayList playingSchemas;

#define MAX_PLAYING_SAMPLES 32 
static struct sSchemaPlaySample playingSamples[MAX_PLAYING_SAMPLES];
static sSchemaPlaySample *pFreePlayingSamples;

static killingSamples = FALSE;

sSchemaCallParams g_sDefaultSchemaCallParams = {0,};

// forward declarations
void SchemaLoopStartNext(sSchemaPlay *pSchemaPlay);

#ifdef DBG_ON

// sample list debugging
// turn on with config "SampleList"

void SchemaSampleListSpew(sSchemaPlaySample *pSample)
{
   int count = 0;

   while (pSample != NULL)
   {
      ++count;
      pSample = pSample->next;
   }
}

#define SchemaSampleListsSpew(when) if (config_is_defined("SampleList")) SchemaSampleListsSpewFn(when)
#define SchemaListSpew(when) if (config_is_defined("SchemaList")) SchemaListSpewFn(when)

void SchemaSampleListsSpewFn(char *when)
{
   sSchemaPlay *pSchemaPlay;

   mprintf("%s ", when);
   // spew free list
   mprintf("Free list:");
   SchemaSampleListSpew(pFreePlayingSamples);
   // spew active schema sample lists
   pSchemaPlay = playingSchemas.GetFirst();
   while (pSchemaPlay != NULL)
   {
      mprintf(" %s", OBJ_NAME(pSchemaPlay->schemaID));
      SchemaSampleListSpew(pSchemaPlay->pSamples);
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   mprintf("\n");
}

void SchemaListSpewFn(char *when)
{
   sSchemaPlay *pSchemaPlay = playingSchemas.GetFirst();

   mprintf("%s, schema list:", when);
   while (pSchemaPlay != NULL)
   {
      mprintf(" %s", OBJ_NAME(pSchemaPlay->schemaID));
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   mprintf("\n");
}

#else

#define SchemaSampleListsSpew(when)
#define SchemaListSpew(when)

#endif

ulong SchemaGetTime()
{
   return tm_get_millisec_unrecorded();
}

// return rand 0->1 (exclusive)
double SchemaRand()
{
   return (double)UnrecordedRand()/(double)(RAND_MAX+1);
}

// play samples list setup
void SchemaPlaySamplesInit()
{
   int i;

   for (i=0; i<MAX_PLAYING_SAMPLES-1; i++)
      playingSamples[i].next = &playingSamples[i+1];
   playingSamples[MAX_PLAYING_SAMPLES-1].next = NULL;
   pFreePlayingSamples = &playingSamples[0];
}

// remove a sample from a list
// remember: must decrement list length count
// should probably also add the sample to the free list after calling this
void SchemaPlaySampleRemove(sSchemaPlaySample **ppListHead,
                            sSchemaPlaySample *pRemSample)
{
   sSchemaPlaySample *pSample;

   Assert_(ppListHead != NULL);
   if (*ppListHead == pRemSample)
      *ppListHead = pRemSample->next;
   else
   {
      pSample = *ppListHead;
      while ((pSample != NULL) && (pSample->next != pRemSample))
         pSample = pSample->next;
      Assert_(pSample != NULL);
      pSample->next = pRemSample->next;
   }
   pRemSample->next = NULL;
}

// return a sample structure to the free list
void SchemaPlaySampleFree(sSchemaPlaySample *pPlaySample)
{
   Assert_(pPlaySample != NULL);
   pPlaySample->next = pFreePlayingSamples;
   pFreePlayingSamples = pPlaySample;
}

// remove and free play sample structure
void SchemaPlaySampleRemoveAndFree(sSchemaPlay *pSchemaPlay,
                                   sSchemaPlaySample *pRemSample)
{
   Assert_(pRemSample != NULL);
   SchemaPlaySampleRemove(&(pSchemaPlay->pSamples), pRemSample);
   SchemaPlaySampleFree(pRemSample);
   --pSchemaPlay->count;
}

// get a new sample and add to list
// returns TRUE on success, FALSE if out of sample structures
// remember: must increment list count
sSchemaPlaySample *SchemaPlaySampleAdd(sSchemaPlaySample **ppListHead)
{
   sSchemaPlaySample *pSample;
   sSchemaPlaySample *pNewSample;

   Assert_(ppListHead != NULL);
   if (pFreePlayingSamples == NULL)
   {
      Warning(("SchemaPlaySampleAdd: out of play samples\n"));
      return FALSE;
   }
   pNewSample = pFreePlayingSamples;
   SchemaPlaySampleRemove(&pFreePlayingSamples, pNewSample);
   if (*ppListHead == NULL)
      *ppListHead = pNewSample;
   else
   {
      pSample = *ppListHead;
      while (pSample->next != NULL)
         pSample = pSample->next;
      pSample->next = pNewSample;
   }
   return pNewSample;
}

// find and return a sample structure corresponding to given sound handle
sSchemaPlaySample *SchemaPlaySampleFind(sSchemaPlaySample *ppListHead,
                                        int hSound)
{
   sSchemaPlaySample *pSample;

   pSample = ppListHead;
   while (pSample != NULL)
   {
      if (pSample->hSound == hSound)
         return pSample;
      pSample = pSample->next;
   }
   return NULL;
}

// Get schema object from its label
ObjID SchemaObjFromName(const Label *schemaName)
{
   if (pObjSys != NULL)
      return pObjSys->GetObjectNamed(schemaName->text);
   else
      return OBJ_NULL;
}

// get the handle of a free play structure, -1 if none
// initialize structure values to defaults
sSchemaPlay *SchemaPlayGet()
{
   sSchemaPlay *pSchemaPlay;

   if ((pSchemaPlay = new sSchemaPlay) != NULL)
   {
      pSchemaPlay->flags = 0;
      pSchemaPlay->schemaID = OBJ_NULL;
      pSchemaPlay->count = 0;
      pSchemaPlay->loopCount = 0;
      pSchemaPlay->pSamples = NULL;
      pSchemaPlay->nextTime = INT_MAX;
      playingSchemas.Append(pSchemaPlay);
   }
   else
      Warning(("SchemaPlayGet: can't get schema play structure\n"));
   return pSchemaPlay;
}

// Add a play structure for a given object
sSchemaPlay *SchemaPlayAdd(ObjID schemaID, const sSchemaCallParams *pCallParams)
{
   sSchemaPlay *pSchemaPlay;
   int i;

   if (killingSamples)
      return NULL;

   if ((pSchemaPlay = SchemaPlayGet()) == NULL)
   {
      Warning(("SchemaPlayAdd: max playing schemas reached\n"));
      return NULL;
   }
   pSchemaPlay->schemaID = schemaID;
   if (pCallParams == NULL)
      return pSchemaPlay;
   pSchemaPlay->flags = pCallParams->flags;
   pSchemaPlay->sourceID = pCallParams->sourceID;
   if (((pCallParams->flags)&SCH_SET_LOC) && (pCallParams->pSourceLoc != NULL))
      pSchemaPlay->sourceLoc = *(pCallParams->pSourceLoc);
   pSchemaPlay->volume = pCallParams->volume;
   pSchemaPlay->callback = pCallParams->callback;
   pSchemaPlay->loop_callback = pCallParams->loop_callback;
   pSchemaPlay->userData = pCallParams->pData;
   for (i=0; i<3; i++)
      pSchemaPlay->msgData[i] = pCallParams->msgData[i];

   SchemaListSpew("SchemaPlayAdd");
   return pSchemaPlay;
}

// setup next sample start time if either
// if we're starting and we're polyphonic
// if we're ending and we're monophonic

#define SAMPLE_START 0
#define SAMPLE_END   1
void SchemaLoopSetupNextTime(sSchemaPlay *pSchemaPlay, 
                             sSchemaLoopParams *pLoopParams,
                             long currentTime, int start_end)
{
   if (((start_end == SAMPLE_START) && (pLoopParams->flags & SCHEMA_LOOP_POLY))
    || ((start_end == SAMPLE_END) && !(pLoopParams->flags & SCHEMA_LOOP_POLY)))
   {
      // have we started all the samples we need to?
      if ((pLoopParams->flags) & SCHEMA_LOOP_COUNT)
         if (pLoopParams->count <= pSchemaPlay->loopCount)
            return;

      if (SCHEMA_LOOP_SINGLE_SOUND(pLoopParams))
         return;

      pSchemaPlay->nextTime = SCHEMA_LOOP_NEXT_TIME(currentTime, pLoopParams);
      ConfigSpew("SchemaTiming", ("Scheduled next sample for %s for %d\n",
                                  OBJ_NAME(pSchemaPlay->schemaID),
                                  pSchemaPlay->nextTime));
   }
}

// end schema play: make callback and free structure
void SchemaPlayEnd(sSchemaPlay *pSchemaPlay)
{
   // make callback - note this may happen before samples actually stop...
   if ((pSchemaPlay->flags & SCH_SET_CALLBACK)
    && (pSchemaPlay->callback != NULL))
   {
      ConfigSpew("SchemaCallback", 
                 ("SchemaPlayEnd callback: handle %d, schema %s, data %d\n",
                  (int)pSchemaPlay,
                  OBJ_NAME(pSchemaPlay->schemaID),
                  (int)(pSchemaPlay->userData)));
      pSchemaPlay->callback((int)pSchemaPlay, pSchemaPlay->schemaID,
                            pSchemaPlay->userData);
   }

   playingSchemas.Remove(pSchemaPlay);
   delete pSchemaPlay;
}

// stop a schema
// halt all samples playing as part of it
void SchemaPlayHalt(int hSchemaPlay)
{
   sSchemaPlay *pSchemaPlay = (sSchemaPlay*)hSchemaPlay;
   sSchemaPlaySample *pSample;

   if (pSchemaPlay == NULL)
   {
      Warning(("SchemaPlayHalt: called with NULL handle\n"));
      return;
   }

#ifdef DBG_ON
   {
      // find handle in playing list
      sSchemaPlay *pSearch = playingSchemas.GetFirst();

      while ((pSearch != NULL) && (pSearch != pSchemaPlay))
         pSearch = pSearch->GetNext();
      if (pSearch != pSchemaPlay)
      {
         Warning(("SchemaPlayHalt: called with invalid handle (%d)\n", (int)pSchemaPlay));
         return;
      }
   }
#endif

   // stop samples and free play sample structs
   if ((pSample = pSchemaPlay->pSamples) != NULL)
   {
      killingSamples = TRUE;
#ifndef SHIP
      if (RECORDER_PLAYBACK())
      {
         // the actual sound handles in the recording may be different
         // from those recorded in fact, some may already be dead, so
         // we may get warnings from appsfx
         if (pSample->hRealSound != -1)
            SoundHalt(pSample->hRealSound);
      }
      else
#endif
      {
         SoundHalt(pSample->hSound);
      }
         
      while (pSample->next != NULL)
      {
         pSample = pSample->next;
         SoundHalt(pSample->hSound);
      }
      pSample->next = pFreePlayingSamples;
      pFreePlayingSamples = pSchemaPlay->pSamples;
      pSchemaPlay->pSamples = NULL;
      killingSamples = FALSE;
   }
   SchemaPlayEnd(pSchemaPlay);
   SchemaSampleListsSpew("Schema halt");
   SchemaListSpew("SchemaPlayHalt");
}

// deal with the end of a sample
// can end the schema
void SchemaSampleEnd(sSchemaPlay *pSchemaPlay, sSchemaPlaySample *pSample)
{
   sSchemaLoopParams *pLoopParams;

   // check to see if we've finished loop count
   if ((pLoopParams = SchemaLoopParamsGet(pSchemaPlay->schemaID)) != NULL)
      if (((pLoopParams->flags) & SCHEMA_LOOP_COUNT)
       && (pSchemaPlay->count == 0)
       && (pLoopParams->count == pSchemaPlay->loopCount))
         SchemaPlayEnd(pSchemaPlay);

   // if we're actively killing samples, then don't bother setting up
   // new ones--also, the sample will be removed in the halting code...
   if (!killingSamples)
   {
      SchemaPlaySampleRemoveAndFree(pSchemaPlay, pSample);

      // setup next sample or end the schema
      if (pLoopParams != NULL)
         SchemaLoopSetupNextTime(pSchemaPlay, pLoopParams, SchemaGetTime(), 
                                 SAMPLE_END);
      else
         // non looping schema ends
         SchemaPlayEnd(pSchemaPlay);
   }

   SchemaSampleListsSpew("Sample end");
   SchemaListSpew("SchemaSampleEnd");
}


// This actually makes the call out of the schema system when a sound
// ends, or when we play back a recording and spoof the callback from
// the frame update function.
static void SchemaSampleEndCallOut(int hSound, void *data)
{
   sSchemaPlaySample *pSample;
   sSchemaPlay *pSchemaPlay;

   ConfigSpew("SchemaTiming", ("Sample %d (schema %s) ended\n",
              hSound, OBJ_NAME((ObjID)data)));

   // this is kind of a hack: if we're killing samples, then don't
   // bother dealing with the death of one...
   //   if (killingSamples)
   //      return;

   pSchemaPlay = playingSchemas.GetFirst();
   while (pSchemaPlay != NULL)
   {
      if (pSchemaPlay->schemaID == (ObjID)data)
      {
         // try to find play sample structure corresponding to sound handle
         pSample = SchemaPlaySampleFind(pSchemaPlay->pSamples, hSound);
         if (pSample != NULL)
         {
            SchemaSampleEnd(pSchemaPlay, pSample);
            return;
         }
      }
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   Warning(("SchemaSampleEndCallOut: no record of sample %d (schema %s)\n",
            hSound, OBJ_NAME((ObjID)data)));
}


// the sound referred to by this handle has ended
// if we are monophonic, then get ready to start a new sample after
// appropriate delay
static void SchemaSampleEndCallback(int hSound, void *data)
{
#ifndef SHIP
   if (pRecorder) {
      if (!RECORDER_PLAYBACK())
      {
         // if recording, save the callback data
         if (spoofingCallbacks) {
            callbackHandles2.Append(hSound);
            callbackData2.Append(data);
         } else {
            callbackHandles.Append(hSound);
            callbackData.Append(data);
         }
      }
      return;
   }
#endif

   SchemaSampleEndCallOut(hSound, data);
}


static void SchemaSampleLoopCallOut(int hSound, void *data)
{
   sSchemaPlaySample *pSample;
   sSchemaPlay *pSchemaPlay;

   ConfigSpew("SchemaTiming", ("Sample %d (schema %s) looped\n",
                               hSound, OBJ_NAME((ObjID)data)));

   pSchemaPlay = playingSchemas.GetFirst();
   ObjID Schema = (ObjID) data;
   while (pSchemaPlay != NULL)
   {
      if (pSchemaPlay->schemaID == Schema)
      {
         // try to find play sample structure corresponding to sound handle
         pSample = SchemaPlaySampleFind(pSchemaPlay->pSamples, hSound);
         if (pSample != NULL
          && (pSchemaPlay->flags & SCH_SET_LOOP_CALLBACK)
          && (pSchemaPlay->loop_callback != NULL)) {
            pSchemaPlay->loop_callback((int)pSchemaPlay, 
                                       pSchemaPlay->schemaID,
                                       pSchemaPlay->userData);
         }
         return;
      }
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   ConfigSpew("SchemaCallback",
              ("SchemaSampleLoopCallOut: no record of sample %d (schema %s)\n",
              hSound, OBJ_NAME(Schema)));
}


// This is for looping which is performed by the sound library.
// So all this does is make a callback out of the schema system.
static void SchemaSampleLoopCallback(int hSound, void *data)
{
#ifndef SHIP
   if (pRecorder)
   {
      if (!RECORDER_PLAYBACK())
      {
         if (spoofingCallbacks) {
            loopCallbackHandles2.Append(hSound);
            loopCallbackData2.Append(data);
         } else {
            loopCallbackHandles.Append(hSound);
            loopCallbackData.Append(data);
         }
      }
      return;
   }
#endif

   SchemaSampleLoopCallOut(hSound, data);
}


// choose a sample from a schema avoiding samples currently playing (if any)
// can force a sample choice
// return sample number within schema, SCH_RANDOM_SAMPLE if can't choose
int SchemaChooseSample(ObjID schemaID, int sampleNum)
{
   int samplesNum;
   int n;

   samplesNum = SchemaSamplesNum(schemaID);
   if (samplesNum<=0)
   {
#ifdef PLAYTEST
      mprintf("SchemaChooseSample: schema %s has no samples\n",OBJ_NAME(schemaID));
#endif
      return SCH_RANDOM_SAMPLE;
   }
   if (sampleNum>=0)
      if (sampleNum<samplesNum)
         n = sampleNum;
      else
      {
         Warning(("SchemaChooseSample: bad sample num (%d) for schema %s\n",
                  sampleNum, OBJ_NAME(schemaID)));
         n = 0;
      }
   else // choose randomly - consider freqs here
   {
      int count = 0;
      int choose;
      int freqTotal = 0;
      const uchar *pFreqs;
      sSchemaPlayParams *pParams;
      int lastSample;

      // get the last sample if we want to avoid reps
      if (((pParams = SchemaPlayParamsGet(schemaID)) != NULL) &&
          ((pParams->flags)&SCH_NO_REPEAT))
          lastSample = SchemaLastSampleGet(schemaID);
      // sum freqs - choose randomly in that range and then map back to samples
      pFreqs = SchemaFreqsGet(schemaID);
      for (n=0; n<samplesNum; n++)
      {
         if (n != lastSample)
            freqTotal += (int)(pFreqs[n]);
      }
      choose = (int)floor(SchemaRand()*(double)freqTotal);
      n = 0;
      count = 0;
      do
      {
         if (n != lastSample)
            count += pFreqs[n];
         ++n;
      } while ((n<=samplesNum-1) && (count<=choose));
      --n;
   }
   return n;
}

void SchemaMsgSend(Label *pMsgType, int volume, sSchemaPlay *pSchemaPlay)
{
   sSchemaMsg sMsg;
   int i;
   ObjPos *pPos;
   ObjPos pos;

   sMsg.msgType = *pMsgType;
   sMsg.volume = volume;
   sMsg.sourceID = pSchemaPlay->sourceID;
   if ((pSchemaPlay->flags)&SCH_SET_OBJ)
      pPos = ObjPosGet(pSchemaPlay->sourceID);
   else if ((pSchemaPlay->flags)&SCH_SET_LOC)
   {
      pos.loc.vec = pSchemaPlay->sourceLoc;
      pPos = &pos;
   }
   if (pPos == NULL)
      // use the player object's location
      pPos = ObjPosGet(PlayerObject());
   if (pPos == NULL)
   {
      Warning(("SchemaMsgSend: source object has no location\n"));
      sMsg.sourceLoc.x = 0;
      sMsg.sourceLoc.y = 0;
      sMsg.sourceLoc.z = 0;
   }
   else
      sMsg.sourceLoc = pPos->loc.vec;
   if ((pSchemaPlay->flags)&SCH_SET_MSG_DATA)
      for (i=0; i<SCHEMA_MSG_DATA_SIZE; i++)
         sMsg.data[i] = pSchemaPlay->msgData[i];
   SchemaMsgPropagate(&sMsg);
}

void SchemaParamsSetup(ObjID schemaID, sfx_parm *parm)
{
   sSchemaPlayParams *pParams;
   int priority;

   parm->flag = 0;
   parm->group = 0;
   parm->user_data = (void*)schemaID;
   parm->radius = 0;
   parm->num_loops = SFX_LOOP_INFINITE;
   parm->end_callback = &SchemaSampleEndCallback;
   parm->loop_callback = &SchemaSampleLoopCallback;

   if ((pParams = SchemaPlayParamsGet(schemaID)) != NULL)
   {
      // setup parameters
      if ((pParams->flags)&SCH_PAN_POS)
         parm->pan = pParams->pan;
      else if ((pParams->flags)&SCH_PAN_RANGE)
         parm->pan = (int)(((SchemaRand()*2.)-1.)*(double)pParams->pan);
      else
         parm->pan = 0;
      // TODO: make this not be stupid - what volume range will we use?
      parm->gain = pParams->volume;
      parm->delay = pParams->initialDelay;
      parm->fade = pParams->fade;

      // now fill in class flags and such!!!
      parm->group = (pParams->flags&SCH_CLASS_MASK)>>SCH_CLASS_SHIFT;
      if (pParams->flags&SCH_NO_CACHE)
         parm->flag|=SFXFLG_NOCACHE;
      if (pParams->flags&SCH_STREAM)
         parm->flag|=SFXFLG_STREAM;      

#ifdef NEW_NETWORK_ENABLED
      if (pParams->flags & SCH_NET_AMBIENT)
         parm->flag |= SFXFLG_NET_AMB;
      if (pParams->flags & SCH_LOC_SPATIAL)
         parm->flag |= SFXFLG_NO_NET;
#endif
   }
   else
   {
      parm->pan = 0;
      parm->gain = -1;
      parm->delay = 0;
      parm->fade = 0;
      parm->group = 0;
   }

   priority = SchemaPriorityGet(schemaID);
   if ((priority>SCH_PRIORITY_MAX) || (priority < SCH_PRIORITY_MIN))
   {
      Warning(("Schema %s priority out of range (%d)\n", OBJ_NAME(schemaID), priority));
      if (priority<0) priority=0;
      else if (priority>UCHAR_MAX) priority=UCHAR_MAX;
   }
   parm->pri = (uchar)priority;
}

// @HACK: this is to allow sndnet to get at the sample number, which is a
// more concise way of sending the sound than its name. We should think
// about how we actually want to expose this. Do we want to add it as a
// param to PSnd, or should we formalize this peek?
static int g_currSampleNum;
static void SchemaSampleCache(int sampleNum)
{
   g_currSampleNum = sampleNum;
}
EXTERN int SchemaGetCurrSample()
{
   return g_currSampleNum;
}

// Play a sample for a given schema
// Add the sample to the play list if we're a playing schema
// Return the sound handle for the new sample, NULL if can't play it
static int SchemaSamplePlay(ObjID schemaID, int sampleNum,
                            sSchemaPlay *pSchemaPlay, 
                            BOOL sampleLoop, int sampleLoopCount, void *pData)
{
   const char *sampleName;
   int hSound;
   int hRealSound = -1;
   Label *pMsgType;
   sSchemaPlaySample *pNewSample;

   // play the actual sample
   if ((sampleName = SchemaSampleGet(schemaID, sampleNum)) != NULL)
   {
      sfx_parm parm;

      SchemaSampleCache(sampleNum);

      ConfigSpew("SchemaSamplePlay", ("Playing schema %s, sample %d\n", OBJ_NAME(schemaID), sampleNum));
      SchemaParamsSetup(schemaID, &parm);
      if (sampleLoop)
      {
         parm.flag |= SFXFLG_LOOP;
         parm.num_loops = sampleLoopCount;
      }

      // override schema volume
      if (pSchemaPlay->flags&SCH_SET_VOLUME)
         parm.gain = pSchemaPlay->volume;
      else if (pSchemaPlay->flags&SCH_ADD_VOLUME)
         parm.gain += pSchemaPlay->volume;
      else if (pSchemaPlay->flags&SCH_SCALE_VOLUME)
         parm.gain = ((float)parm.gain * (float)pSchemaPlay->volume) / 100.0;
      else if (pSchemaPlay->flags&SCH_RADIUS_VOLUME)
         parm.radius = pSchemaPlay->volume;

      // set the sharp attenuation flag, if requested      
      if (pSchemaPlay->flags & SCH_SHARP_ATTEN)
         parm.flag |= SFXFLG_SHARP;

      // set the networking flags, if appropriate
      if ((pSchemaPlay->flags & SCH_SET_OBJ) ||
          (pSchemaPlay->flags & SCH_SET_LOC))
      {
         // Spatial sound is networked by default
         if (pSchemaPlay->flags & SCH_NO_NETWORK)
            parm.flag |= SFXFLG_NO_NET;
      } else {
         // Ambient sound is non-networked by default
         if (pSchemaPlay->flags & SCH_NETWORK)
            parm.flag |= SFXFLG_NET_AMB;
      }

      float att_fac=SchemaAttFacGet(schemaID);

      int flags = (pSchemaPlay->flags & SCH_FORCE_PLAY) ? kGSF_ForcePlay : kGSF_None;

      // actually play it
      if ((pSchemaPlay->flags&SCH_SET_OBJ)
       && (pSchemaPlay->sourceID != OBJ_NULL))
         hSound = GenerateSoundObj(pSchemaPlay->sourceID, schemaID,
                                   (char *)sampleName, att_fac, &parm, flags, pData);
      else if (pSchemaPlay->flags&SCH_SET_LOC)
         hSound = GenerateSoundVec(&pSchemaPlay->sourceLoc, pSchemaPlay->sourceID, schemaID,
                                   (char *)sampleName, att_fac, &parm, flags, pData);
      else
      {  // Since the sound is not coming from anywhere in particular
         // in this case, we'd have a hard time propagating the data.
#ifndef SHIP
         if (pData)
            Warning(("SchemaSamplePlay: data cannot be used w/no location\n"));
#endif // ~SHIP
         hSound = GenerateSound((char*)sampleName, &parm);
      }

#ifndef SHIP
      if (pRecorder)
      {
         // store the real handle
         if (RECORDER_PLAYBACK())
            hRealSound = hSound;
         // restore/save the recorded handle
         RecStreamAddOrExtract(pRecorder, &hSound, sizeof(int), "sample id");
      }
#endif
      // send out the attached message - note do this whether we can play or not
      if ((pSchemaPlay->flags)&SCH_SET_MSG)
         SchemaMsgSend(&(pSchemaPlay->msg), parm.gain, pSchemaPlay);
      if ((pMsgType = SchemaMessageGet(schemaID)) != NULL)
         SchemaMsgSend(pMsgType, parm.gain, pSchemaPlay);
      // give up if we can't play it
      if (hSound == -1)
      {
         ConfigSpew("SchemaSamplePlay", ("Couldnt Generate for schema %s\n", OBJ_NAME(schemaID)));
         return hSound;
      }
      ConfigSpew("SchemaTiming", ("Started new sample (%d) for schema %s at %d\n", 
                                  hSound, OBJ_NAME(schemaID), SchemaGetTime()));
      if ((pNewSample = SchemaPlaySampleAdd(&(pSchemaPlay->pSamples))) != NULL)
      {
         pNewSample->hSound = hSound;
#ifndef SHIP
         pNewSample->hRealSound = hRealSound;
#endif
         ++pSchemaPlay->count;
         ++pSchemaPlay->loopCount;
      }
      SCHEMA_LAST_SAMPLE_SET(schemaID, sampleNum);
      SchemaSampleListsSpew("Sample start");
   }
   else
   {
      Warning(("SchemaSamplePlay: can't get sample %d for schema %s\n",
               sampleNum, OBJ_NAME(schemaID)));
      SchemaSampleListsSpew("Sample start fail");
      return -1;  // ?????????? or _NULL
   }
   return hSound;
}

// recheck loops every second
#define SCHEMA_RECHECK_DELAY 1000

int SchemaSamplePlayAndSetupNext(ObjID schemaID, int sampleNum, 
                                 sSchemaPlay *pSchemaPlay, 
                                 sSchemaLoopParams *pLoopParams, void *pData)
{
   int hSound;

   // play the damn sample
   hSound = SchemaSamplePlay(schemaID, sampleNum, pSchemaPlay, 
                             SCHEMA_LOOP_SINGLE_SOUND(pLoopParams),
                             SCHEMA_NUM_LOOPS(pLoopParams), pData);
   if (hSound == -1)
   {  // we didn't start a sample for some reason
      if (pLoopParams != NULL)     // If we're playing a loop, schedule a recheck later
         pSchemaPlay->nextTime = SchemaGetTime() + SCHEMA_RECHECK_DELAY;
   }
   else
   {  // setup the start of the next sample
      if (pLoopParams != NULL)
         SchemaLoopSetupNextTime(pSchemaPlay, pLoopParams, SchemaGetTime(), 
                                 SAMPLE_START);
   }
   return hSound;
}

// This function is never called.  Commenting it out.  Note that
// we've changed a couple of things with sound so that in some camera modes
// it will use player box location instead of location of camera.  (REMOTE_CAM
// and VIEW_CAM)  (see sndloop.cpp).  AMSD 12/14/99
//inline BOOL SchemaTooFar(mxs_vector *pSource)
//{
//   return (mx_dist2_vec(pSource, &(PlayerCamera()->pos))>SCHEMA_MAX_PLAY_DIST);
//}

// play the selected sample from the schema
// choose sample if sampleNum==SCH_RANDOM_SAMPLE
// return play handle
int SchemaIDPlay(ObjID schemaID, sSchemaCallParams *pCallParams, void *pData)
{
   sSchemaLoopParams *pLoopParams;
   sSchemaPlay *pSchemaPlay = NULL;
   int sampleNum;

   // setup play stuff
   if ((pSchemaPlay = SchemaPlayAdd(schemaID, pCallParams)) == NULL)
      return SCH_HANDLE_NULL;

   // choose the sample
   if ((pCallParams == NULL) || (!(pCallParams->flags & SCH_SET_SAMPLE)))
      sampleNum = SchemaChooseSample(schemaID, SCH_RANDOM_SAMPLE);
   else
      sampleNum = SchemaChooseSample(schemaID, pCallParams->sampleNum);
   if (sampleNum == SCH_RANDOM_SAMPLE)
   {  // we need to clean up better, since we clearly have created pSchemaPlay
      playingSchemas.Remove(pSchemaPlay);
      delete pSchemaPlay;
#ifdef PLAYTEST
      mprintf("Couldn't find a sample to play for schema %s\n", ObjWarnName(schemaID));
#endif
      return SCH_HANDLE_NULL;
   }

   pLoopParams = SchemaLoopParamsGet(pSchemaPlay->schemaID);
   
   // play the sample and schedule start of next
   if (SchemaSamplePlayAndSetupNext(schemaID, sampleNum, pSchemaPlay,
                                    pLoopParams, pData) == -1)
   {
      ConfigSpew("SchemaPlay", ("Failed PlaySetupNext %s (%slooping)\n", OBJ_NAME(schemaID),
                                pLoopParams==NULL?"non-":""));
      if (pLoopParams == NULL)
      {  // give up if we can't play the sample
         playingSchemas.Remove(pSchemaPlay);
         delete pSchemaPlay;
         pSchemaPlay = NULL;
      }
   }

   ConfigSpew("SchemaPlay", ("Starting schema %s (%x)\n", OBJ_NAME(schemaID),pSchemaPlay));
   SchemaSampleListsSpew("SchemaIDPlay");
   SchemaListSpew("SchemaIDPlay");

   return (int)pSchemaPlay;
}

int SchemaIDPlayObj(ObjID schemaID, ObjID objID, void *pData)
{
   sSchemaCallParams callParams = g_sDefaultSchemaCallParams;

   callParams.flags |= SCH_SET_OBJ;
   callParams.sourceID = objID;
   return SchemaIDPlay(schemaID, &callParams, pData);
}

int SchemaIDPlayLoc(ObjID schemaID, mxs_vector *pLoc, void *pData)
{
   sSchemaCallParams callParams = g_sDefaultSchemaCallParams;

   callParams.flags &= ~SCH_SET_OBJ;
   callParams.flags |= SCH_SET_LOC;
   callParams.pSourceLoc = pLoc;
   return SchemaIDPlay(schemaID, &callParams, pData);
}

int SchemaPlay(const Label *schemaName, sSchemaCallParams *pCallParams,
               void *pData)
{
   ObjID schemaID = SchemaObjFromName(schemaName);

   if (schemaID == OBJ_NULL)
   {
      Warning(("SchemaPlay: no schema named %s\n", &schemaName->text[0]));
      return SCH_HANDLE_NULL;
   }
   return SchemaIDPlay(schemaID, pCallParams, pData);
}

int SchemaPlayObj(const Label *schemaName, ObjID objID, void *pData)
{
   sSchemaCallParams callParams = g_sDefaultSchemaCallParams;

   callParams.flags |= SCH_SET_OBJ;
   callParams.sourceID = objID;
   return SchemaPlay(schemaName, &callParams, pData);
}

int SchemaPlayLoc(const Label *schemaName, mxs_vector *pLoc, void *pData)
{
   sSchemaCallParams callParams = g_sDefaultSchemaCallParams;

   callParams.flags &= ~SCH_SET_OBJ;
   callParams.flags |= SCH_SET_LOC;
   callParams.pSourceLoc = pLoc;
   return SchemaPlay(schemaName, &callParams, pData);
}

#ifdef EDITOR
#define HAVE_SCHEMA_COMMANDS
#endif

#ifdef HAVE_SCHEMA_COMMANDS
int SchemaPlay0(const Label *schemaName)
{
   return SchemaPlay(schemaName, NULL, NULL);
}

void SchemasPlay(char *pszSchemas)
{
   int i = 0;
   char szSchema1[16]; // label length
   char *pSchema2;

   CommandParseStringArgs(pszSchemas, szSchema1, 16, &pSchema2);
   SchemaPlay((Label*)szSchema1, NULL, NULL);
   if (pSchema2)
      SchemaPlay((Label*)pSchema2, NULL, NULL);
}

void SchemaHaltNamed(const Label *schemaName)
{
   sSchemaPlay *pSchemaPlay;
   ObjID schemaID = SchemaObjFromName(schemaName);

   if (schemaID == OBJ_NULL)
   {
      Warning(("SchemaHaltNamed: no schema named %s\n", schemaName));
      return;
   }
   pSchemaPlay = playingSchemas.GetFirst();
   while (pSchemaPlay != NULL)
   {
      if (pSchemaPlay->schemaID == schemaID)
      {
         SchemaPlayHalt((int)pSchemaPlay);
         return;
      }
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   SchemaListSpew("SchemaHaltNamed");
}

void SoundDestroy(void)
{
   SpeechDestroy();
   ESndDestroy();
   SchemasDestroy();
}

#ifdef SCHEMA_LOADING
void SchemaFilesDestroyAndLoad(void)
{
   if (!winui_GetYorN("This will destroy all links to schemas."
                          "  Do it anyway?"))
      return;

   SchemaHaltAll();
   SoundDestroy();
   SchemaFilesLoadAll();
   terrainprop_load();   // for now, until yaccparse knows to deal correctly
}

// This doesn't destroy our schema archetypes, so that links to them can
// stick around.
static void SchemaFilesDestroySpeechAndLoad(void)
{
   SchemaHaltAll();
   SpeechDestroy();
   ESndDestroy();
   SchemaFilesLoadAll();
}

#ifndef SHIP
static void SchemaFilesDump(void)
{
   ESndDump();
}
#endif

#endif

static Command schema_commands[] =
{
   { "play_schema", FUNC_STRING, SchemaPlay0, "Play a named schema", HK_ALL },
   { "play_schemas", FUNC_STRING, SchemasPlay, "Play two schemas", HK_ALL},
   { "destroy_schemas", FUNC_VOID, SchemasDestroy, "Destroy all schemas", HK_ALL },
   { "destroy_speech", FUNC_VOID, SpeechDestroy, "Destroy all speech", HK_ALL },
   { "destroy_sound", FUNC_VOID, SoundDestroy, "Destroy all schemas and speech", HK_ALL },
   { "halt_schema", FUNC_STRING, SchemaHaltNamed, "Halt the first instance of a playing schema", HK_ALL},
   { "halt_schemas", FUNC_VOID, SchemaHaltAll, "Halt all playing schemas", HK_ALL},
#ifdef SCHEMA_LOADING   
   { "zggtvrk_load_schema", FUNC_STRING, SchemaFilesLoad, "Load a schema file", HK_ALL },
   { "zggtvrk_load_schemas", FUNC_VOID, SchemaFilesDestroyAndLoad, "Load all schemas in path (destroy first)", HK_ALL },
   { "reload_schemas", FUNC_VOID, SchemaFilesDestroySpeechAndLoad, "Load all schemas in path (don't destroy)", HK_ALL },
#endif   
#ifndef SHIP
   { "dump_schemas", FUNC_VOID, SchemaFilesDump, "Dump schema tags DB)", HK_ALL },
#endif
};

static void setup_commands()
{
   COMMANDS(schema_commands,HK_ALL);
}
#endif // HAVE_SCHEMA_COMMANDS


void SchemaInit()
{
   if (pObjSys == NULL)
      pObjSys = AppGetObj(IObjectSystem);
   if (pTraitMan == NULL)
      pTraitMan = AppGetObj(ITraitManager);
#ifndef SHIP
   if ( (pRecorder == NULL) && (! config_is_defined ("disable_schema_recording")) )
      pRecorder = AppGetObj(IRecorder);
#endif

#ifdef HAVE_SCHEMA_COMMANDS   
   setup_commands();
#endif
   SchemaPropsInit();
   SchemaPlaySamplesInit();

   SchemaListSpew("SchemaInit");
}

void SchemaShutdown()
{
   SchemaHaltAll();
   SchemaPropsTerm();
   SafeRelease(pObjSys);
   SafeRelease(pTraitMan);
#ifndef SHIP
   SafeRelease(pRecorder);
#endif
}

void SchemaHaltAll()
{
   sSchemaPlay *pSchemaPlay;

   pSchemaPlay = playingSchemas.GetFirst();
   while (pSchemaPlay != NULL)
   {
      SchemaPlayHalt((int)pSchemaPlay);
      pSchemaPlay = playingSchemas.GetFirst();
   }
   SchemaListSpew("SchemaHaltAll");
}

// kill a single sample playing as part of a schema
void SchemaSampleHalt(sSchemaPlay *pSchemaPlay, sSchemaPlaySample *pSample)
{
   killingSamples = TRUE;
   SoundHalt(pSample->hSound);
   SchemaPlaySampleRemoveAndFree(pSchemaPlay, pSample);
   killingSamples = FALSE;
}

// start the next scheduled schema loop
void SchemaLoopStartNext(sSchemaPlay *pSchemaPlay)
{
   sSchemaLoopParams *pSchemaLoopParams
      = SchemaLoopParamsGet(pSchemaPlay->schemaID);

   pSchemaPlay->nextTime = INT_MAX;
   if (pSchemaLoopParams)
   {
      int n;

      // check to see that we don't exceed max number of samples to play
      if (pSchemaPlay->count>pSchemaLoopParams->maxSamples)
         SchemaSampleHalt(pSchemaPlay, pSchemaPlay->pSamples);

      // choose a new sample and play it
      n = SchemaChooseSample(pSchemaPlay->schemaID, SCH_RANDOM_SAMPLE);
      if (n != SCH_RANDOM_SAMPLE)
         SchemaSamplePlayAndSetupNext(pSchemaPlay->schemaID, n, 
                                      pSchemaPlay, pSchemaLoopParams, NULL);
   }
   else
      Warning(("Non-looping schema %s has new sample scheduled?\n", 
               OBJ_NAME(pSchemaPlay->schemaID)));
}


#ifndef SHIP
static void RecordCallbacks(ulong *pNumCallbacks, char *pszLabel,
                            cCallbackHandleArray *pHandles,
                            cCallbackDataArray *pCallbackData)
{
   Assert_(pHandles->Size() == pCallbackData->Size());

   *pNumCallbacks = pHandles->Size();
   pRecorder->AddToStream((void*) pNumCallbacks, sizeof(ulong), pszLabel);
}


static void ExtractCallbacks(ulong *pNumCallbacks, char *pszLabel,
                             cCallbackHandleArray *pHandles,
                             cCallbackDataArray *pCallbackData)
{
   pRecorder->ExtractFromStream((void*) pNumCallbacks, sizeof(ulong), pszLabel);
   pHandles->SetSize(*pNumCallbacks);
   pCallbackData->SetSize(*pNumCallbacks);
}
#endif // ~SHIP


// per frame function
void SchemaFrame()
{
   sSchemaPlay *pSchemaPlay;
   long currentTime = SchemaGetTime();
   BOOL startNew;

#ifndef SHIP
   ulong i;
   ulong numCallbacks;
   ulong numLoopCallbacks;

   if (pRecorder)
   {
      // record or play back our sample end and loop callbacks
      spoofingCallbacks = TRUE;

      if (RECORDER_PLAYBACK())
      {
         ExtractCallbacks(&numCallbacks, "schema callbacks",
                          &callbackHandles, &callbackData);
         ExtractCallbacks(&numLoopCallbacks, "schema loop CBs",
                          &loopCallbackHandles, &loopCallbackData);
      }
      else
      {
         RecordCallbacks(&numCallbacks, "schema callbacks",
                         &callbackHandles, &callbackData);
         RecordCallbacks(&numLoopCallbacks, "schema loop CBs",
                         &loopCallbackHandles, &loopCallbackData);
      }

      // spoof callbacks
      for (i = 0; i < numCallbacks; ++i)
      {
         RecStreamAddOrExtract(pRecorder, &callbackHandles[i], 
                               sizeof(int), "schema callback handle");
         RecStreamAddOrExtract(pRecorder, &callbackData[i], 
                               sizeof(void*), "schema callback data");
         SchemaSampleEndCallOut(callbackHandles[i], callbackData[i]);
      }

      for (i = 0; i < numLoopCallbacks; ++i)
      {
         RecStreamAddOrExtract(pRecorder, &loopCallbackHandles[i], 
                               sizeof(int), "schema loop CB handle");
         RecStreamAddOrExtract(pRecorder, &loopCallbackData[i], 
                               sizeof(void*), "schema loop CB data");
         SchemaSampleLoopCallOut(loopCallbackHandles[i],
                                 loopCallbackData[i]);
      }

      callbackHandles.SetSize(0);
      callbackData.SetSize(0);
      loopCallbackHandles.SetSize(0);
      loopCallbackData.SetSize(0);

      spoofingCallbacks = FALSE;

      //////////////////////////////////////////////////////////////
      // This is the same deal as just above, but it handles any
      // schemas which ended or looped while we were making the first
      // set of callbacks.

      if (RECORDER_PLAYBACK())
      {
         ExtractCallbacks(&numCallbacks, "schema callbacks",
                          &callbackHandles2, &callbackData2);
         ExtractCallbacks(&numLoopCallbacks, "schema loop CBs",
                          &loopCallbackHandles2, &loopCallbackData2);
      }
      else
      {
         RecordCallbacks(&numCallbacks, "schema callbacks",
                         &callbackHandles2, &callbackData2);
         RecordCallbacks(&numLoopCallbacks, "schema loop CBs",
                         &loopCallbackHandles2, &loopCallbackData2);
      }

      // spoof callbacks
      for (i = 0; i < numCallbacks; ++i)
      {
         RecStreamAddOrExtract(pRecorder, &callbackHandles2[i], 
                               sizeof(int), "schema callback handle");
         RecStreamAddOrExtract(pRecorder, &callbackData2[i], 
                               sizeof(void*), "schema callback data");
         SchemaSampleEndCallOut(callbackHandles2[i], callbackData2[i]);
      }

      for (i = 0; i < numLoopCallbacks; ++i)
      {
         RecStreamAddOrExtract(pRecorder, &loopCallbackHandles2[i], 
                               sizeof(int), "schema loop CB handle");
         RecStreamAddOrExtract(pRecorder, &loopCallbackData2[i], 
                               sizeof(void*), "schema loop CB data");
         SchemaSampleLoopCallOut(loopCallbackHandles2[i], 
                                 loopCallbackData2[i]);
      }

      callbackHandles2.SetSize(0);
      callbackData2.SetSize(0);
      loopCallbackHandles2.SetSize(0);
      loopCallbackData2.SetSize(0);
   }
#endif // ~SHIP

   pSchemaPlay = playingSchemas.GetFirst();
   // look through playing schemas and see if we need to start new samples
   while (pSchemaPlay != NULL)
   {
      // check to see if we're scheduled to start a new sample
      startNew = (pSchemaPlay->nextTime < currentTime);
#ifndef SHIP
      if (pRecorder)
      {
         // record/playback decision to start new sample
         RecStreamAddOrExtract(pRecorder, &startNew, sizeof(BOOL), "new sample");
      }
#endif
      if (startNew)
         SchemaLoopStartNext(pSchemaPlay);
      pSchemaPlay = pSchemaPlay->GetNext();
   }
   SchemaSampleListsSpew("Frame");
}

ObjID SchemaGetIDFromHandle(int hSchemaPlay)
{
   if (hSchemaPlay == SCH_HANDLE_NULL)
      return OBJ_NULL;
   sSchemaPlay *pSchemaPlay = (sSchemaPlay*)hSchemaPlay;
   return pSchemaPlay->schemaID;
}

int SchemaGetSFXFromHandle(int hSchemaPlay, int iWhich)
{
   if (hSchemaPlay == SCH_HANDLE_NULL)
      return SFX_NO_HND;

   sSchemaPlay *pSchemaPlay = (sSchemaPlay*)hSchemaPlay;
   sSchemaPlaySample *pSample = pSchemaPlay->pSamples;
   if (!pSample)
      return SFX_NO_HND;

   // It's hard to imagine a client wanting iWhich > 0, but just in
   // case...
   for (int i = 0; i < iWhich; ++i) {
      pSample = pSample->next;
      if (!pSample)
         return SFX_NO_HND;
   }

   return pSample->hSound;
}
// $Header: r:/t2repos/thief2/src/sound/schfile.cpp,v 1.4 1998/10/14 03:14:17 dc Exp $

#include <schfile.h>
#include <findhack.h>  // all the abstracted lg_find stuff
#include <hashset.h>
#include <hshsttem.h>
#include <str.h>
#include <datapath.h>
#include <config.h>
#include <cfgdbg.h>

// Must be last header 
#include <dbmem.h>

typedef struct sSchemaFile
{
   cStr fileName;
   cStr pathName;
} sSchemaFile;

class cFileNameHash: public cStrHashSet<sSchemaFile *>
{
private:
   tHashSetKey GetKey(tHashSetNode node) const;
};

tHashSetKey cFileNameHash::GetKey(tHashSetNode node) const
{
   return (tHashSetKey)((const char*)(((sSchemaFile*)node)->fileName));
}

static cFileNameHash fileNameHash;


void SchemaFilesGet(const char *pszDataPath, const char *pszWhat)
{
   Datapath sDatapath;
   DatapathDir *pDatapathDir;
   char *pszFileName;
   sSchemaFile *pSchemaFile;

   DatapathClear(&sDatapath);
   DatapathAdd(&sDatapath, (char*)pszDataPath);
   pDatapathDir = DatapathOpenDir(&sDatapath, (char*)pszWhat, DP_SCREEN_DOT);
   while (NULL!=(pszFileName = DatapathReadDir(pDatapathDir)))
   {
      pSchemaFile = new sSchemaFile;
      pSchemaFile->fileName = pszFileName;
      (pSchemaFile->fileName).MakeLower();
      if (!fileNameHash.Search((const char*)(pSchemaFile->fileName)))
      {
         pSchemaFile->pathName = pszDataPath;
         fileNameHash.Insert(pSchemaFile);
      }
      else
         delete pSchemaFile;
   }
   DatapathCloseDir(pDatapathDir);
   DatapathFree(&sDatapath);
}

void SchemaFilesRead(fSchemaRead readFunc)
{
   cStr fullName;
   sSchemaFile *pSchemaFile;
   tHashSetHandle handle;

   pSchemaFile = (sSchemaFile*)(fileNameHash.GetFirst(handle));
   while (pSchemaFile != NULL)
   {
      fullName.FmtStr("%s\\%s", (const char*)(pSchemaFile->pathName), 
                      (const char*)(pSchemaFile->fileName));
      fileNameHash.Remove(pSchemaFile);
      delete pSchemaFile;
      ConfigSpew("SchemaFiles", ("Loading file %s\n", (const char*)fullName));
      (*readFunc)((char*)((const char*)fullName));
      pSchemaFile = (sSchemaFile*)fileNameHash.GetFirst(handle);
   }
}


// read all files from res path and local dir that match "what" string
void SchemaFilesLoadFromDir(const char *where, const char *what, fSchemaRead readFunc)
{
   static char szDataPath[PATH_MAX];
   cStr resSchemaPath;

   // open stuff in your current dir
   resSchemaPath.FmtStr(".\\%s",where);
   SchemaFilesGet((const char*)resSchemaPath, what);

   // get stuff from res path
   if (config_get_raw("schema_base_path", szDataPath, sizeof(szDataPath)))
   {
      resSchemaPath.FmtStr("%s\\%s", szDataPath, where);
      SchemaFilesGet((const char*)resSchemaPath, what);
   }
   // read it all
   SchemaFilesRead(readFunc);
}
// $Header: r:/t2repos/thief2/src/sound/auxsnd.h,v 1.6 1999/03/18 14:33:59 mwhite Exp $
// memory sound source stuff from Pat

#pragma once
#ifndef __AUXSND_H
#define __AUXSND_H

EXTERN ISndSample *
   CreateMemSoundSource( ISndMixer        *pMixer,          // your mixer
                         void             *pBuffer,         // the sound data
                         uint32           bufferLen,        // sizeof the sound data
                         SndEndCallback   endCB,            // your end callback
                         void             *pEndCBData );    // data for endCB

EXTERN ISndSample *
CreateMemSoundSourceLooped(ISndMixer           *pMixer,    // your mixer
                           void                *pBuffer,   // the sound data
                           uint32              bufferLen,  // sizeof pBuffer
                           SndEndCallback      endCB,      // end callback
                           void                *pEndCBData,// data for endCB
                           ISndSource          **ppSndSrc, // handle
                           int                 nLoops,     // times to play
                           SndPlaylistCallback loopCB,     // loop callback
                           void                *pLoopCBData );// for loopCB

ISndSample *
CreateNRezStreamedSoundSource( ISndMixer           *pMixer,          // your mixer
                               IRes                *pRez,
                               char                **ppStreamBuffer, // the stream buffer
                               SndEndCallback      endCB,            // your end callback
                               void                *pEndCBData,      // data for endCB
                               ISndSource          **ppSndSrc );       // handle to the sound source

ISndSample*
CreateSongSoundSource ( ISndMixer           *pMixer,
                        uint32              numSegments,
                        IRes*               *pResArray,     // An array of resources, size is numSegments.
                        char                **ppStreamBuffer,
                        SndEndCallback      endCB,
                        void                *pEndCBData,
                        ISndSource          **ppSndSrc,
                        SndPlaylistCallback segmentCB,         // segment callback
                        void                *pSegmentCBData ); // data for CB

#endif // __AUXSND_H
// $Header: r:/t2repos/thief2/src/sound/esnd.cpp,v 1.23 2000/01/10 14:07:11 porges Exp $

#include <limits.h>

#include <lgassert.h>
#include <dynarray.h>
#include <mprintf.h>
#include <comtools.h>
#include <packflag.h>

#include <timer.h>
#include <stdlib.h>
#include <cfgdbg.h>

#include <recapi.h>

#include <traitman.h>
#include <appagg.h>
#include <iobjsys.h>
#include <lnkquery.h>
#include <propman.h>
#include <objquery.h>
#include <objremap.h>
#include <traitbas.h>
#include <edittool.h>
#include <objedit.h>

#include <command.h>
#include <playrobj.h>
#include <dbasemsg.h>
#include <dispbase.h>

#include <esnd.h>
#include <esndglue.h>
#include <esndprop.h>
#include <rooms.h>

#include <schbase.h>
#include <schema.h>
#include <schprop.h>
#include <schsamps.h>

#include <hashpp.h>
#include <hshpptem.h>
#include <dlist.h>
#include <dlisttem.h>

#include <namemap.h>
#include <spchdom.h>
#include <speech.h>
#include <spchvoc.h>
#include <tagdbin.h>
#include <tagdbout.h>
#include <tagdbt.h>
#include <tagdbdat.h>

#include <config.h>
#include <cfgdbg.h>

#include <esndreac.h>

// Must be last header
#include <dbmem.h>


extern cSpeechDomain g_Domain;

static IPropertyManager *pPropMan = NULL;
static ITraitManager *pTraitMan = NULL;
static IRecorder *pRecorder = NULL;

// our databases--the tags and values and all that we borrow from the
// speech system
static cDynArray_<uchar, 2> g_LocalTagRequired(64);
static cPackedBoolSet *g_pTagRequired;
static ITagDBDatabase *g_pDatabase;

// These are used to build the databases from text files.
static sTagDBData g_InputKey;
static ITagDBKeySet *g_pInputKeySet;
static BOOL g_bCurrentInputValid;


static tESndGameCallback ESndGameCallback = 0;
tESndGameCallback ESndSetGameCallback(tESndGameCallback pfFunc)
{
   tESndGameCallback pOld = ESndGameCallback;
   ESndGameCallback = pfFunc;
   return pOld;
}


#ifndef SHIP
static void DumpTagSet(cTagSet *pTagSet)
{
   if (pTagSet && pTagSet->Size()) {
      cStr TempBuff;
      pTagSet->ToString(&TempBuff);
      mprintf("%s\n", TempBuff.BufIn());
   }
}
#endif // ~SHIP


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   These functions handle connections to the schema system, including
   playing the actual sounds.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static int ESndPlayCore(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2,
                        void *pData, sSchemaCallParams *pCallParams)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("env snd: objs %d and %d\n", Obj1, Obj2);
   #endif

   // We depend on the speech system for our label management so we've
   // got no chance without it.
   if (!g_bSpeechDatabaseLoaded)
      return -1;

   // Some tags are passed in.  There are as many as four other
   // sources for tags: each of our two objects, the room obj1 is in,
   // and a callback into the game which takes the entire list of tags
   // from other sources plus our ObjIDs.
   sESndTagList *pObj1ClassList, *pObj1MaterialList, *pRoomList;
   sESndTagList *pObj2ClassList, *pObj2MaterialList;
   cTagSet *pObj1ClassTags = 0, *pObj1MaterialTags = 0, *pRoomTags = 0;
   cTagSet *pObj2ClassTags = 0, *pObj2MaterialTags = 0;

   int retval = SCH_HANDLE_NULL;        // return this if we fail

   if (Obj1 != OBJ_NULL) {
      if (ObjGetESndClass(Obj1, &pObj1ClassList))
         pObj1ClassTags = new cTagSet(*pObj1ClassList->m_pTagSet); 
      if (ObjGetESndMaterial(Obj1, &pObj1MaterialList))
         pObj1MaterialTags = new cTagSet(*pObj1MaterialList->m_pTagSet);

      cRoom *Obj1Room = g_pRooms->GetObjRoom(Obj1);
      if (Obj1Room && ObjGetESndClass(Obj1Room->GetObjID(), &pRoomList))
         pRoomTags = new cTagSet(*pRoomList->m_pTagSet);
   }

   if (Obj2 != OBJ_NULL) {
      if (ObjGetESndClass(Obj2, &pObj2ClassList))
         pObj2ClassTags = new cTagSet(*pObj2ClassList->m_pTagSet);
      if (ObjGetESndMaterial(Obj2, &pObj2MaterialList))
         pObj2MaterialTags = new cTagSet(*pObj2MaterialList->m_pTagSet);
   }

   if (ESndGameCallback)
   {
      sESndEvent ev = 
        { Obj1, Obj2, 
          {
             pObj1ClassTags, 
             pObj1MaterialTags, 
             pObj2ClassTags,
             pObj2MaterialTags,
             pRoomTags,
             pTagSet
          },
          pCallParams,
        };
                      
      ESndGameCallback(&ev); 
   }

#ifndef SHIP
   if (config_is_defined("EnvSoundSpew")) {
      DumpTagSet(pTagSet);
      DumpTagSet(pObj1ClassTags);
      DumpTagSet(pObj1MaterialTags);
      DumpTagSet(pRoomTags);
      DumpTagSet(pObj2ClassTags);
      DumpTagSet(pObj2MaterialTags);
   }
#endif // ~SHIP

   cTagDBInput Input;
   Input.AppendTagSet(pTagSet, 0, 1.0);
   if (pObj1ClassTags)
      Input.AppendTagSet(pObj1ClassTags, 0, 1.0);
   if (pObj1MaterialTags)
      Input.AppendTagSet(pObj1MaterialTags, 0, 1.0);
   if (pRoomTags)
      Input.AppendTagSet(pRoomTags, 0, 1.0);
   if (pObj2ClassTags)
      Input.AppendTagSet(pObj2ClassTags, 0, 1.0);
   if (pObj2MaterialTags)
      Input.AppendTagSet(pObj2MaterialTags, 0, 1.0);

   Input.Sort();

   int iInSize = Input.Size();
   cTagDBInputTag *pInPointer = Input.AsPointer();
   for (int i = 0; i < iInSize; ++pInPointer, ++i)
      // Must check size here because set is only as big as the largest
      // numbered tag that IS required, not the largest numbered tag
      // that we could ask IF IT IS required.
      if ((pInPointer->m_KeyType < g_pTagRequired->Size()) &&
             (g_pTagRequired->IsSet(pInPointer->m_KeyType)))
         pInPointer->m_iFlags |= kTagDBInputFlagRequired;

   ObjID SchemaID = OBJ_NULL; 
   cTagDBOutput Output;
   Output.Clear();
   if (!g_pDatabase->MatchPartialSet(&Input, &Output))
   {
      #ifndef SHIP
      if (config_is_defined("EnvSoundSpew"))
         mprintf("ESndPlayCore:No Partial Set Match\n");
      #endif

      goto out;
   }

   Output.NextByWeight(0);
   SchemaID = Output[0].m_iData;

   if (SchemaID == OBJ_NULL) {
      #ifndef SHIP
      if (config_is_defined("EnvSoundSpew"))
         mprintf("ESndPlayCore: No schemas found!\n");
      #endif

      goto out; 
   }

   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndPlayCore: playing %s\n", ObjEditName(SchemaID));
   #endif

   // start our schema
   pCallParams->sampleNum = -1;

   // does this do the job?
   pCallParams->sourceID = Obj1;

   retval = SchemaIDPlay(SchemaID, pCallParams, pData);

out:
   delete pObj1ClassTags;
   delete pObj2ClassTags;
   delete pRoomTags;
   delete pObj1MaterialTags;
   delete pObj2MaterialTags;
   return retval; 
}


int ESndPlay(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2, 
             sSchemaCallParams *pParams, void *pData)
{
   sSchemaCallParams Params, *pUsedParams;

   if (pParams)
      pUsedParams = pParams;
   else {
      Params = g_sDefaultSchemaCallParams;
      pUsedParams = &Params;
   }

   return ESndPlayCore(pTagSet, Obj1, Obj2, pData, pUsedParams);
}


// treat Obj1 as the source
int ESndPlayObj(cTagSet *pTagSet, ObjID Obj1, ObjID Obj2,
                sSchemaCallParams *pParams, void *pData)
{
   sSchemaCallParams Params, *pUsedParams;

   if (pParams)
      pUsedParams = pParams;
   else {
      Params = g_sDefaultSchemaCallParams;
      pUsedParams = &Params;
   }

   pUsedParams->flags |= SCH_SET_OBJ;
   pUsedParams->sourceID = Obj1;

   return ESndPlayCore(pTagSet, Obj1, Obj2, pData, pUsedParams);
}


int ESndPlayLoc(cTagSet *pTagSet,  ObjID Obj1, ObjID Obj2, 
                const mxs_vector *pLoc, sSchemaCallParams *pParams, 
                void *pData)
{
   sSchemaCallParams Params, *pUsedParams;

   if (pParams)
      pUsedParams = pParams;
   else {
      Params = g_sDefaultSchemaCallParams;
      pUsedParams = &Params;
   }

   pUsedParams->flags |= SCH_SET_LOC;
   pUsedParams->pSourceLoc = (mxs_vector *)pLoc;  // why isn't source loc a const?

   return ESndPlayCore(pTagSet, Obj1, Obj2, pData, pUsedParams);
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   This section is our loading and saving.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

static TagFileTag g_TagFileTag = { "ENV_SOUND" };
static TagVersion g_TagVersion = { 1, 1 };


static void ESndLoad(ITagFile *pFile)
{
   TagVersion found_version = g_TagVersion;
   HRESULT result = ITagFile_OpenBlock(pFile, &g_TagFileTag, &found_version);

   if (result == S_OK
    && found_version.major == g_TagVersion.major
    && found_version.minor == g_TagVersion.minor) {
      int temp;
      ITagFile_Read(pFile, (char *) &temp, sizeof(temp));
      g_LocalTagRequired.SetSize(temp);
      ITagFile_Read(pFile, (char *) g_LocalTagRequired.AsPointer(), temp);

      g_pDatabase->Load(pFile);
      ITagFile_CloseBlock(pFile);
   }
}


static void ESndSave(ITagFile *pFile)
{
   HRESULT result = ITagFile_OpenBlock(pFile, &g_TagFileTag, &g_TagVersion);

   if (result == S_OK) {
      int temp = g_LocalTagRequired.Size();
      ITagFile_Write(pFile, (const char *) &temp, sizeof(temp));
      ITagFile_Write(pFile,
                     (const char *) g_LocalTagRequired.AsPointer(), temp);

      g_pDatabase->Save(pFile);
      ITagFile_CloseBlock(pFile);
   }
}


extern "C" void ESndInit(void)
{
   if (!pPropMan)
      pPropMan = AppGetObj(IPropertyManager);
   if (!pTraitMan)
      pTraitMan = AppGetObj(ITraitManager);
   if (!pRecorder)
      pRecorder = AppGetObj(IRecorder);

   ESndPropsInit();

   g_pDatabase = NewITagDBDatabase();
   g_pInputKeySet = NewITagDBKeySet();

   EnvSoundReactionInit();
}


extern "C" void ESndTerm(void)
{
   SafeRelease(pPropMan);
   SafeRelease(pTraitMan);
   SafeRelease(pRecorder);
   if (g_pTagRequired)
      delete g_pTagRequired;

   delete g_pDatabase;
}

#ifndef SHIP
void ESndDump() {
   g_pDatabase->Dump();
}
#endif

// Our required bits--telling us which tags to require in our
// searches--do not represent a new name space.  So we only need to
// swizzle in one direction, from local to global.
static void FindRequiredBits()
{
   int i;
   int iHighestRemappedToken = 0;
   int iSize = g_LocalTagRequired.Size();
   for (i = 0; i < iSize; ++i) {
      if (g_LocalTagRequired[i]) {
         sTagRemap Remap(i, 0, 0, 0);
         g_Domain.TokensLocalToGlobal(&Remap, TRUE);
         if (Remap.m_GlobalType > iHighestRemappedToken)
            iHighestRemappedToken = Remap.m_GlobalType;
      }
   }

   if (g_pTagRequired)
      delete g_pTagRequired;

   g_pTagRequired  = new cPackedBoolSet(iHighestRemappedToken + 1);

   for (i = 0; i < iSize; ++i) {
      if (g_LocalTagRequired[i]) {
         sTagRemap Remap(i, 0, 0, 0);
         g_Domain.TokensLocalToGlobal(&Remap, TRUE);
         g_pTagRequired->Set(Remap.m_GlobalType);
      }
   }
}


static void RemapDatabase(void Func(cTagDBKey *))
{
   ITagDBDatabase *pTemp = g_pDatabase->CopyWithFilter(Func);
   delete g_pDatabase;
   g_pDatabase = pTemp;
}


EXTERN void ESndDatabaseNotify(DispatchData *msg)
{
   msgDatabaseData data;

   data.raw = msg->data;
   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         break;

      case kDatabaseDefault:
         ESndDestroy();
         break;

      case kDatabaseSave:
         if (msg->subtype & kObjPartAbstract) {
            RemapDatabase(SpeechGlobalToLocal);
            ESndSave(data.save);
            RemapDatabase(SpeechLocalToGlobal);
         }
         break;

      case kDatabaseLoad:
         if (msg->subtype & kObjPartAbstract) {
            ESndDestroy();
            ESndLoad(data.load);
         }
         break;

      case kDatabasePostLoad:
         if (msg->subtype & kObjPartAbstract) {
            RemapDatabase(SpeechLocalToGlobal);
            FindRequiredBits();
         }
         break;
   }
}


void ESndNotifyTextParseEnd()
{
   FindRequiredBits();
}


// clear out all this tag and concept stuff
static void ESndDatabasesDestroy(void)
{
   g_pDatabase->Clear();
   g_LocalTagRequired.SetSize(0);
}


// Destroy all voice data structures and objects (except base archetypes)
void ESndDestroy(void)
{
   ITraitManager *pTraitMan = AppGetObj(ITraitManager);

   // clean up all relations involving voices or concepts
   ESndDatabasesDestroy();

   SafeRelease(pTraitMan);
}


/* <<--- /-/-/-/-/-/-/-/ <<< (( / (( /\ )) \ )) >>> \-\-\-\-\-\-\-\ --->> *\

   Here's our text file reading.  See schema.y for the other end of
   this.

\* <<--- \-\-\-\-\-\-\-\ <<< (( \ (( \/ )) / )) >>> /-/-/-/-/-/-/-/ --->> */

extern "C" void ESndSetTagRequired(const Label *pTagName)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndSetTagRequired: %s\n", &pTagName->text);
   #endif

   int iTagIndex = g_Domain.TagIndex(pTagName);
   if (iTagIndex == kNameMapIndexNotFound) {
      Warning(("ESndSetTagRequired: not found: %s\n", pTagName->text));
      return;
   }

   if (g_LocalTagRequired.Size() <= iTagIndex) {
      int iOldSize = g_LocalTagRequired.Size();
      g_LocalTagRequired.SetSize(iTagIndex + 1);
      for (int i = iOldSize; i < iTagIndex; ++i)
         g_LocalTagRequired[i] = 0;
   }

   g_LocalTagRequired[iTagIndex] = 1;
}


extern "C" void ESndSchemaNewStart(const Label *pSchemaName, ObjID SchemaObjID)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndSchemaNewStart: %s\n", &pSchemaName->text);
   #endif

   g_pInputKeySet->Clear();
   g_InputKey.m_iData = SchemaObjID;
   g_InputKey.m_fWeight = 1.0;
}


extern "C" void ESndSchemaNewAddIntTag(const Label *pTagName,
                                       int iMin, int iMax)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndSchemaNewAddIntTag: %s [%d %d]\n", &pTagName->text, iMin, iMax);
   #endif

   cTagDBKey NewKey(g_Domain.TagIndex(pTagName), iMin, iMax);
   SpeechLocalToGlobal(&NewKey);
   g_pInputKeySet->AddKey(&NewKey);
}


// pEnum here is expected to be an array of eight const labels.
extern "C" void ESndSchemaNewAddEnumTag(const Label *pTagName,
                                        const Label *pEnum)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndSchemaNewAddEnumTag: %s [", &pTagName->text);
   #endif

   tTagDBKeyEnum aEnum[8];

   // force type-value pairs into existance in tag system
   for (int i = 0; i < 8; ++pEnum, ++i) {
      if (pEnum->text[0]) {
         aEnum[i] = (uchar) g_Domain.ValueIndex(pEnum);
         ConfigSpew("EnvSoundSpew", ("%s (%d)", pEnum->text,aEnum[i]));
      } else {
         aEnum[i] = kTagDBKeyEnumUnused;
      }
   }

   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("]\n");
   #endif

   cTagDBKey NewKey(g_Domain.TagIndex(pTagName), aEnum);
   SpeechLocalToGlobal(&NewKey);
   g_pInputKeySet->AddKey(&NewKey);
}


extern "C" void ESndSchemaNewFinish(void)
{
   #ifndef SHIP
   if (config_is_defined("EnvSoundSpew"))
      mprintf("ESndSchemaNewFinish\n");
   #endif

   g_pDatabase->Insert(g_pInputKeySet, g_InputKey);
}







// $Header: r:/t2repos/thief2/src/sound/sndframe.h,v 1.2 2000/02/26 12:43:39 adurant Exp $

// Utilities for keeping track of which objects made noise heard by
// the player in each frame.  

#ifndef SNDFRAME_H
#define SNDFRAME_H

#include <objtype.h>

void SNDFrameInit();
void SNDFrameTerm();
void SNDFrameNextFrame();
void SNDFrameAddObj( ObjID objID );
BOOL SNDFramePlayedObj( ObjID objID );

#endif
////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/esndreac.cpp,v 1.1 1999/05/29 21:58:28 JON Exp $
//

#include <esndreac.h>

#include <appagg.h>

#include <reaction.h>
#include <reacbase.h>
#include <stimbase.h>

#include <esnd.h>

#include <sdestool.h>
#include <sdesbase.h>

#include <phclsn.h>
#include <phcollev.h>

// must be last header
#include <dbmem.h>


//
// Env Sound reaction
//

//
// The parameters
//

struct sEnvSoundReactionParam
{
   char tags[64];
};

//
// The reaction
// Stim intensity is a multiplier on duration 
//

static eReactionResult LGAPI EnvSoundReactionResult(sReactionEvent* pEvent, const sReactionParam* param, tReactionFuncData )
{
   sEnvSoundReactionParam* pParam = (sEnvSoundReactionParam*)&param->data; 

   cTagSet tagSet(pParam->tags);
   ObjID sourceID = OBJ_NULL;
   sPhysClsnEvent* pClsnEvent = (sPhysClsnEvent*)pEvent->stim->Find(kEventKindCollision);
   if (pClsnEvent != NULL)
      sourceID = pClsnEvent->collision->GetObjID();
   ESndPlay(&tagSet, pEvent->sensor_obj, sourceID);

   return kReactionNormal; 
}

static sReactionDesc EnvSoundReactionDesc = 
{
   "EnvSound",
   "EnvSound", 
   REACTION_PARAM_TYPE(sEnvSoundReactionParam),
}; 


//
// The sdesc
//

static sFieldDesc EnvSoundReactionFDesc[] = 
{
   { "Tags", kFieldTypeString, FieldLocation(sEnvSoundReactionParam, tags) }
};

static sStructDesc EnvSoundReactionSDesc = StructDescBuild(sEnvSoundReactionParam,kStructFlagNone,EnvSoundReactionFDesc); 

//
// Init/Term 
//

EXTERN void EnvSoundReactionInit()
{
   AutoAppIPtr(Reactions); 
   pReactions->Add(&EnvSoundReactionDesc,EnvSoundReactionResult,NULL); 
   AutoAppIPtr_(StructDescTools,pTools); 
   pTools->Register(&EnvSoundReactionSDesc); 
}

EXTERN void EnvSoundReactionTerm()
{
}
////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/esndreac.h,v 1.1 1999/05/29 21:58:36 JON Exp $
//

#pragma once  

#ifndef __ESNDREAC_H
#define __ESNDREAC_H

//
// EnvSound reaction
//
EXTERN void EnvSoundReactionInit(void);
EXTERN void EnvSoundReactionTerm(void); 

#endif // __ESNDREAC_H
// $Header: r:/t2repos/thief2/src/sound/metasnd.h,v 1.3 1998/11/03 04:22:51 dc Exp $
//

#pragma once

#ifndef __METASND_H
#define __METASND_H

#include <guistyle.h>

#define kMetaSndPanelLast     (-1)
#define kMetaSndPanelDefault   (0)
#define kMetaSndPanelMain      (1)
#define kMetaSndPanelSaveLoad  (2)
#define kMetaSndPanelOptions   (3)
#define kMetaSndPanelLoadout   (4)
#define kMetaSndPanelBook      (5)
#define kMetaSndPanelInGame    (6)
#define kMetaSndPanelCount     (7)

///////////
// actual play callback
EXTERN bool metaSndPlayGUICallback(StyleSound sound);

// call as we transit panels
EXTERN void metaSndEnterPanel(int panel_type);
EXTERN void metaSndExitPanel(BOOL kill_snds);

// call on enter/exit game mode
EXTERN void metaSndEnterGame(void);
EXTERN void metaSndExitGame(void);

/////////
// yea yea
EXTERN void metaSndInit(char *snd_prefix);
EXTERN void metaSndTerm(void);

#endif  // __METASND_H
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psnd.h,v 1.22 1999/08/05 18:20:32 Justin Exp $
//
// Sound propagation header
//

#pragma once

#ifndef __PSND_H
#define __PSND_H

#include <matrixs.h>
#include <hashpp.h>

#include <objtype.h>

#include <roomsys.h>
#include <roompa.h>

#include <psndapi.h>
#include <psndinst.h>
#include <psndinfo.h>

#include <mprintf.h>

///////////////////////////////////////////////////////////////////////////////

#define EFF_PRI_MIN 0
#define EFF_PRI_MAX 65535

const int kMinUpdateFrequency = 16;
const int kMaxUpdateFrequency = 1;
const int kDeferredUpdateFrequency = 16;

////////////////////////////////////////////////////////////////////////////////

typedef class cPropSndInst     cPropSndInst;
typedef class cPropSndInstHigh cPropSndInstHigh;
typedef class cPropSndInstLow  cPropSndInstLow;

typedef cHashTableFunctions<long> LongHashFunctions;
typedef cHashTable<long, mxs_real, LongHashFunctions> cSoundBlockingTable;

////////////////////////////////////////////////////////////////////////////////

class cPropSnd 
{
public:

   /////////////////
   //
   // Constructor / Destructor
   //
   cPropSnd();
   ~cPropSnd();

   /////////////////
   //
   // Functions
   //
   int  GenerateSound(ObjID objID, ObjID schemaID, const char *sampleName, float atten_factor, 
                      sfx_parm *parms, int flags, void *data = NULL);
   int  GenerateSound(mxs_vector &vec, ObjID src_obj, ObjID schemaID, const char *sampleName, float atten_factor,
                      sfx_parm *parms, int flags, void *data = NULL);
   int  GenerateSound(const char *sampleName, sfx_parm *parms);


   int  GenerateSoundHandle(int handle, ObjID objID, ObjID schemaID, const char *sampleName, float atten_factor, 
                            sfx_parm *parms, int flags, void *data = NULL);
   int  GenerateSoundHandle(int handle, mxs_vector &vec, ObjID src_obj, ObjID schemaID, const char *sampleName, 
                            float atten_factor, sfx_parm *parms, int flags, void *data = NULL);

   // Stops the sound, all sounds, and checks for any playing sounds
   void SoundHalt(int handle);
   void SoundHaltObj(ObjID objID);
   void SoundHaltAll();
   BOOL AreSounds();

   // Informs each non-player object about sounds this frame
   void ApplySoundInfo();
   void ClearSoundInfo();

   // Cleans up game-mode created objects
   void Cleanup();

   // Informs the active sound system that the sound has ended
   void EndActiveSound(cSoundInfo *pSoundInfo);

   // Valid handle checking
   int               GetSoundHandle();
   void              RegisterSound(int handle, cPlayerSoundList *pSoundList);
   int               FindSound(cPlayerSoundList *pSoundList);
   cPlayerSoundList *GetSound(int handle);
   void              RemoveSound(int handle);

   // Sound blocking functions
   void     ClearBlockingFactors();
   void     SetBlockingFactor(short roomID1, short roomID2, mxs_real factor, BOOL blockAdjacent = TRUE);
   mxs_real GetBlockingFactor(short roomID1, short roomID2);
   void     RemoveBlockingFactor(short roomID1, short roomID2, BOOL blockAdjacent = TRUE);

   PrioritizationResult Prioritize(const cPlayerSoundList* pPlayerList);

   // Networking functions
   BOOL ShouldPlaySound(const sfx_parm *pParms, int flags, BOOL onObject, ObjID srcObject) const;
   BOOL ShouldNetworkSound(const sfx_parm *pParms, int flags, BOOL onObject, ObjID srcObject) const;

#ifndef SHIP
   void SetDrawSoundPath(BOOL state);

   void DrawActiveSounds();
   void SpewActiveSounds();
#endif

private:
   // Prioritization functions.
   BOOL TypeCapReached(uchar type);
   int  EffectivePriority(const cPlayerSoundList *pPlayerList);
   cPlayerSoundList* LowestPrioritySoundOfType(uchar type, int *itsEffectivePriority);
   cPlayerSoundList* LowestPrioritySound(int *itsEffectivePriority);

   void BumpActiveSound(cPlayerSoundList *pPlayerList);

   // Sound blocking
   void BlockAdjacentRooms(short roomID1, short roomID2, mxs_real factor);

   cPlayerSoundList *GeneratePlayerSoundList(int handle);

   cPlayerSoundList *m_SoundList[kMaxActiveSounds];

   cSoundBlockingTable m_SoundBlockingTable;

   cPropSndInstHigh  m_SoundInstHigh;
 
   cPropSndInst   *m_SoundInstance;
   cRoomPropAgent  m_PropAgent;

   BOOL  m_NoSound;

};

////////////////////////////////////////

inline void cPropSnd::ApplySoundInfo()
{
   Assert_(m_SoundInstance);
   m_SoundInstance->ApplySoundInfo();
}

////////////////////////////////////////

inline void cPropSnd::ClearSoundInfo()
{
   Assert_(m_SoundInstance);
   m_SoundInstance->ClearSoundInfo();
}

////////////////////////////////////////

inline void cPropSnd::Cleanup()
{
   Assert_(m_SoundInstance);
   m_SoundInstance->Cleanup();
}

////////////////////////////////////////////////////////////////////////////////

inline void cPropSnd::RegisterSound(int handle, cPlayerSoundList *pSoundList)
{
   Assert_((handle >= 0) && (handle < kMaxActiveSounds));
   Assert_(m_SoundList[handle] == NULL);

   m_SoundList[handle] = pSoundList;
}

////////////////////////////////////////

inline cPlayerSoundList *cPropSnd::GetSound(int handle)
{
   Assert_((handle >= 0) && (handle < kMaxActiveSounds));

   return m_SoundList[handle];
}

////////////////////////////////////////

inline void cPropSnd::RemoveSound(int handle)
{
   Assert_((handle >= 0) && (handle < kMaxActiveSounds));

   m_SoundList[handle] = NULL;
}   

////////////////////////////////////////////////////////////////////////////////

inline void cPropSnd::EndActiveSound(cSoundInfo *pSoundInfo)
{
   m_SoundInstance->EndActiveSound(pSoundInfo);
}

////////////////////////////////////////////////////////////////////////////////

inline cPlayerSoundList *cPropSnd::GeneratePlayerSoundList(int handle)
{
   return m_SoundInstance->GeneratePlayerSoundList(handle);
}
////////////////////////////////////////////////////////////////////////////////

inline void cPropSnd::ClearBlockingFactors()
{
   m_SoundBlockingTable.Clear();
}

////////////////////////////////////////////////////////////////////////////////

#ifndef SHIP
inline void cPropSnd::SetDrawSoundPath(BOOL state)
{
   Assert_(m_SoundInstance);
   m_SoundInstance->SetDrawSoundPath(state);
}

inline void cPropSnd::DrawActiveSounds()
{
   Assert_(m_SoundInstance);
   m_SoundInstance->DrawActiveSounds();
}

#endif

////////////////////////////////////////////////////////////////////////////////

EXTERN cPropSnd *g_pPropSnd;
EXTERN int       g_SndWatchHandle;


////////////////////////////////////////////////////////////////////////////////

#endif


///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/sound/psndapi.cpp,v 1.26 1999/08/05 18:20:56 Justin Exp $
//
// Sound propagation functions
//

#include <lg.h>

#include <timer.h>
#include <playrobj.h>
#include <command.h>
#include <ged_line.h>
#include <gedit.h>
#include <ghostmvr.h>

#include <rooms.h>
#include <psnd.h>
#include <psndapi.h>

#include <schema.h>
#include <schbase.h>

#include <mprintf.h>

// Must be last header
#include <dbmem.h>


#ifndef SHIP
////////////////////////////////////////////////////////////////////////////////

#define SOUND_SCHEMA  -372

void MakeSound(mxs_real volume)
{
   mxs_vector zero;

   mx_zero_vec(&zero);

#if 0
   SchemaIDPlayLoc(SOUND_SCHEMA, &zero);
#endif

   sfx_parm parms = {0, 0, 0, 0, 0, 100, 0, 0, 0, NULL, NULL};
   g_pPropSnd->GenerateSound(5, OBJ_NULL, "ai_fire1", 1.0, &parms, TRUE);
}

void MeMakeSound(mxs_real volume)
{
   SchemaIDPlayObj(SOUND_SCHEMA, PlayerObject());
}

////////////////////////////////////////////////////////////////////////////////

void SpewRoomAI()
{
   const cRoom *room;
   const ObjID *obj_list;
   int   list_size;

   for (int i=0; i<g_pRooms->GetNumRooms(); i++)
   {
      room = g_pRooms->GetRoom(i);
      room->GetObjList(&obj_list, &list_size, g_SndWatchHandle);
      while (list_size--)
         mprintf(" [room %d (obj %d)]  AI obj %d\n", room->GetRoomID(), room->GetObjID(), obj_list[list_size]);
   }
}

////////////////////////////////////////////////////////////////////////////////

void DrawSoundPath(char *args)
{
#ifdef EDITOR
   ObjID src_obj;
   Label schema_name;
   int radius;

   gedDeleteChannelLines(1<<LINE_CH_SOUND);
   ged_line_view_channels |= (1<<LINE_CH_SOUND);

   if (strstr(args, "goat"))
      sscanf(args, "%dgoat%dgoat%s", &src_obj, &radius, &schema_name);
   else
      sscanf(args, "%d,%d,%s", &src_obj, &radius, &schema_name);

   mprintf("playing %s on %d and drawing path (radius %d)\n", &schema_name, src_obj, radius);

   sSchemaCallParams callParams = g_sDefaultSchemaCallParams;
   callParams.flags |= SCH_SET_OBJ | SCH_RADIUS_VOLUME;
   callParams.volume = radius;
   callParams.sourceID = src_obj;

   g_pPropSnd->SetDrawSoundPath(TRUE);
   SchemaPlay(&schema_name, &callParams);
   g_pPropSnd->SetDrawSoundPath(FALSE);

   gedit_full_redraw();
#else
   mprintf("This command does not work without an editor build!\n");
#endif
}

void ClearSoundPath()
{
#ifdef EDITOR
   gedDeleteChannelLines(1<<LINE_CH_SOUND);
   ged_line_view_channels &= ~(1<<LINE_CH_SOUND);

   gedit_full_redraw();
#endif
}

void DrawSounds()
{
   g_pPropSnd->DrawActiveSounds();
}   

void SpewSounds()
{
   g_pPropSnd->SpewActiveSounds();
}

////////////////////////////////////////////////////////////////////////////////


BOOL g_show_sounds = FALSE;

static Command g_RoomCommands[] =
{
   {"make_sound_z",    FUNC_FLOAT,  MakeSound,         "Generate a sound at 0,0,0",        HK_ALL},
   {"make_sound" ,     FUNC_FLOAT,  MeMakeSound,       "Generate a sound at the player",   HK_ALL},
   {"spew_room_ai",    FUNC_VOID,   SpewRoomAI,        "List each AI's current room",      HK_ALL},
   {"show_sounds",     TOGGLE_BOOL, &g_show_sounds,    "Toggles visible sound display",    HK_ALL},
   {"draw_sound_path", FUNC_STRING, DrawSoundPath,     "Draw the sound prop path",         HK_ALL},
   {"clear_sound_path",FUNC_VOID,   ClearSoundPath,    "Clears any drawn sound paths",     HK_ALL},
   {"spew_sounds",     FUNC_VOID,   SpewSounds,        "Spews all propagating sounds",     HK_ALL},
};
#endif

////////////////////////////////////////////////////////////////////////////////

static IProperty *_pAIProp = NULL;

BOOL IsSoundListener(ObjID objID)
{
   return ((PlayerObjectExists() && objID==PlayerObject()) || _pAIProp->IsRelevant(objID) ||
           ((GetGhostType(objID) & kGhostListenTypes) == kGhostListenTypes));
}

////////////////////////////////////////

void _SoundProp_Setup(void)
{
   g_pPropSnd = new cPropSnd;
   g_pRooms->AddWatch(IsSoundListener, &g_SndWatchHandle);
}

////////////////////////////////////////

void _SoundProp_Clear(void)
{
   if (g_pRooms && (g_SndWatchHandle != -1))
      g_pRooms->RemoveWatch(g_SndWatchHandle);

   delete g_pPropSnd;
   g_pPropSnd = NULL;

}

////////////////////////////////////////

void SoundPropagationInit(void)
{
   _SoundProp_Setup();
   _pAIProp = GetPropertyNamed("AI");

   #ifndef SHIP
   COMMANDS(g_RoomCommands, HK_ALL);
   #endif
}

void SoundPropagationTerm(void)
{
   _SoundProp_Clear();
   SafeRelease(_pAIProp);
}

void SoundPropagationReset(void)
{
   _SoundProp_Clear();
   _SoundProp_Setup();
}

////////////////////////////////////////////////////////////////////////////////

int GenerateSoundObj(ObjID objID, ObjID schemaID, const char *sampleName, float atten_factor, 
                     sfx_parm *parms, int flags, void *data)
{
   return g_pPropSnd->GenerateSound(objID, schemaID, sampleName, atten_factor, parms, flags, data);
}

////////////////////////////////////////

int  GenerateSoundVec(mxs_vector *vec, ObjID src_obj, ObjID schemaID, const char *sampleName, float atten_factor, 
                      sfx_parm *parms, int flags, void *data)
{
   return g_pPropSnd->GenerateSound(*vec, src_obj, schemaID, sampleName, atten_factor, parms, flags, data);
}

////////////////////////////////////////

int  GenerateSound(const char *sampleName, sfx_parm *parms)
{
   return g_pPropSnd->GenerateSound(sampleName, parms);
}

////////////////////////////////////////

void SoundHalt(int handle)
{
   g_pPropSnd->SoundHalt(handle);
}

////////////////////////////////////////

void SoundHaltObj(ObjID objID)
{
   g_pPropSnd->SoundHaltObj(objID);
}

////////////////////////////////////////////////////////////////////////////////

void ApplyPropSounds()
{
   AssertMsg(g_pPropSnd != NULL, "Attempt to apply sounds of unitialized propagation system");

   g_pPropSnd->ApplySoundInfo();
}

////////////////////////////////////////

void ClearPropSounds()
{
   AssertMsg(g_pPropSnd != NULL, "Attempt to clear sounds of unitialized propagation system");

   g_pPropSnd->ClearSoundInfo();
}

////////////////////////////////////////

void CleanupSoundObjects()
{
   AssertMsg(g_pPropSnd != NULL, "Attempt to clean up sound objects of unitialized propagation system");

   g_pPropSnd->Cleanup();
}
   
////////////////////////////////////////////////////////////////////////////////
