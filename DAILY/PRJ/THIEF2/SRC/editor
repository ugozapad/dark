// $Header: r:/t2repos/thief2/src/editor/alignpnp.c,v 1.23 2000/02/19 12:27:36 toml Exp $
// Brush Texture PnP gadget

#include <gadblist.h>
#include <lgsprntf.h>

#include <command.h>

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <csgbrush.h>
#include <csg.h>

#include <brushGFH.h>
#include <PnPtools.h>
#include <swappnp.h>
#include <texmem.h>

#include <mprintf.h>
#include <rand.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 *            ___________
 * 1<txt>     | grid rep |  (grid flips to the brush grid pnp)
 * 2<grid>    |so you can|  (show causes main 3d view to try to look at this wall)
 * 3<reset>   | vslider  |  (reset resets all fields to defaults)
 * 4<brush>   |__________|  ( aligns the texture to the brush
 *  5<-uoff->   6<-voff->   (0-256 ints
 *     7 <- scale ->        (scale 4 default, who knows - wacky scale thing)
 *     8  <- rot ->         (rot is angular, not implemented)
 */

#define NUM_BUTTONS (0x9)
static Rect alignPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (alignPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 4
#define BTN_BELOW 3
#define VERT_DIV  4
#define HORIZ_DIV (0.50)

void alignPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,HORIZ_DIV,1,2,1);
   for (i=0; i<BTN_ABOVE; i++)
      buildYLineRect(curRect++,whole,i,HORIZ_DIV,0,2,1);
   buildYLineRect(curRect++,whole,VERT_DIV,HORIZ_DIV,0,2,2);
   buildYLineRect(curRect++,whole,VERT_DIV,HORIZ_DIV,1,2,2);
   for (i=1; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,0,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[4].lr.y;
}

#define BUTTON_TXT     1
#define BUTTON_GRID    2
#define BUTTON_RESET   3
#define BUTTON_ALIGN   4

#define FROBS_XOFFS    5
#define FROBS_YOFFS    6
#define FROBS_SCALE    7
#define FROBS_ROT      8

#define FROBS_PICTURE  9

#define NUM_OWNED (FROBS_PICTURE+1)
static int pnpOwners[NUM_OWNED];

// particular state for the gadget
static editBrush *alignPnP_br;
static int        xoff, yoff, scale, texture;
static fixang     rot;
static TexInfo   *alignTexInf=(TexInfo *)0xffffffff; // @HACK: try and make sure first use has to refresh this
static bool       _local_align=FALSE;

// for now, this is our PnP Set
static _PnP_GadgData alignPnP;

// hide or show all the buttons of face info, for on/off when you switch to null face
static void frobs_hide(bool which)
{
   int i;
   for (i=FROBS_XOFFS; i<=FROBS_ROT; i++)
      PnP_Hide(pnpOwners[i],which);
}

// TODO: bug is that on first run through, if you are set to cur_face -1
//  then both alignTexInf and this_face are NULL, so we dont execute switch
//  so, then we dont hide the frobs cause we dont think anything changed

// this is sort of a mess, as it syncs the globals and the brush
// update is TRUE if we know the globals just changed, false to reload globals
// here we have to make sure cur_face didnt secretly change behind our back
static void alignPnP_setvars(editBrush *br, bool update)
{
   BOOL change=FALSE, face_change=FALSE;
   TexInfo *this_face;
   int mt;

   if (!update)       alignPnP_br=br;   // not an update: set us from data
   else if (br==NULL) br=alignPnP_br;   // else allow reload from brush

   if (br==NULL) return;

   if (br->cur_face==-1) this_face=NULL;   // no face data to work with;
   else                  this_face=&br->txs[br->cur_face];
   if (update&&(this_face!=alignTexInf))
      Warning(("Hey, face switched behind the scene??\n"));

   PnP_SetCurrent(&alignPnP);
   if (alignTexInf!=this_face)
   {
      if (alignTexInf==NULL)   // unhide the boxes
      {
         frobs_hide(FALSE);
      }
      alignTexInf=this_face;
      face_change=TRUE;
      PnP_Redraw(pnpOwners[FROBS_PICTURE],NULL);
   }
   if (alignTexInf!=NULL)
   {
      BOOL rotalign;
      _varforPnP_synch(alignTexInf->tx_x,xoff,update,pnpOwners[FROBS_XOFFS],change);
      _varforPnP_synch(alignTexInf->tx_y,yoff,update,pnpOwners[FROBS_YOFFS],change);
      _varforPnP_synch(alignTexInf->tx_scale,scale,update,pnpOwners[FROBS_SCALE],change);
      _varforPnP_synch(alignTexInf->tx_rot,rot,update,pnpOwners[FROBS_ROT],change);

      rotalign=(rot==TEXINFO_HACK_ALIGN);
      if ((_local_align)!=rotalign)
         PnP_Redraw(pnpOwners[BUTTON_ALIGN],NULL);
      PnP_Hide(pnpOwners[FROBS_ROT],rotalign);

      mt=alignTexInf->tx_id;
      if (mt==-1) mt=alignPnP_br->tx_id;
      if (mt!=texture) 
         PnP_Redraw(pnpOwners[FROBS_PICTURE],NULL);
   }
   else if (face_change)
      frobs_hide(TRUE);
   if (change&&update)
      if (gedit_reassign_texture(br,FALSE))
         gedit_redraw_3d();
}

// @HACK: this is ultra-gross, but im not sure how to get this to bootstrap right
//   in particular, we detect fine, but too early, ie. i cant hide the frobs, cause 
//   they dont exist yet.  sounds like i really need a 3rd input state... ie. i
//   need Update Gadget From World (false), Update World From Gadget (true), and Initialize
static void sneaky_hideshow_refresh(void)
{
   alignTexInf=(TexInfo *)0xffffffff; // @HACK: try and make sure first use has to refresh this
   rot=0;
   alignPnP_setvars(alignPnP_br,FALSE);
   PnP_FullRedraw(&alignPnP);
}

// the idea here is that this just makes sure the globals are right
// then calls setvars, which deals with making the brush consistent with the globals
static void alignPnP_IntFrob(PnP_SliderOp op, Rect *where, int val, int data)
{
   if (op == PnP_SliderUpdateOp)
      alignPnP_setvars(NULL,TRUE);
}

static void alignPnP_FixangFrob(PnP_SliderOp op, Rect *where, fixang val, int data)
{
   if (op == PnP_SliderUpdateOp)
      alignPnP_setvars(NULL,TRUE);
}

// @TODO: figure out why we cant get the ROTATE gadget to update, eh?
// just do these one of command sort of things
static void alignPnP_OneShots(int lid)
{
   switch (lid)
   {
      case BUTTON_TXT:
         PnP_ExecCommandInt("start_pnp", PNP_TEXTURE);
         break;
      case BUTTON_GRID:
         PnP_ExecCommandInt("start_pnp", PNP_GRID);
         break;
      case BUTTON_RESET:
         if (alignTexInf!=NULL)
         {  
            BOOL change=FALSE;
            int tmp=alignTexInf->tx_id;
            *alignTexInf=defTexInf;
            alignTexInf->tx_id=tmp;
            // ok, this is pretty gross - we cant just setvars since no update will mean no reassign textures
            PnP_SetCurrent(&alignPnP);
            _varforPnP_synch_FALSE(alignTexInf->tx_x,xoff,pnpOwners[FROBS_XOFFS],change);
            _varforPnP_synch_FALSE(alignTexInf->tx_y,yoff,pnpOwners[FROBS_YOFFS],change);
            _varforPnP_synch_FALSE(alignTexInf->tx_scale,scale,pnpOwners[FROBS_SCALE],change);
            _varforPnP_synch_FALSE(alignTexInf->tx_rot,rot,pnpOwners[FROBS_ROT],change);
            if (change&&gedit_reassign_texture(alignPnP_br,FALSE))
               gedit_redraw_3d();
         }
         break;
   }
}

static void alignPnP_Toggle(Rect *where, bool val, int data)
{
   if (rot==TEXINFO_HACK_ALIGN) rot=0; else rot=TEXINFO_HACK_ALIGN;
   alignPnP_setvars(NULL,TRUE);
}

// this really should probably just load from the brush
// since we really hope it is consistent and right when we get here
// but hey, oh well

// @TODO: this should really call the txtpnp stuff, which we should generalize
static void alignPnP_Picture(int data)
{
   if (alignPnP_br)
      if (alignPnP_br->cur_face==-1)
         gr_clear(0);                   // cant really do this
      else
      {
         int mt=alignPnP_br->txs[alignPnP_br->cur_face].tx_id;
         if (mt==-1)
            mt=alignPnP_br->tx_id;
         texture=mt;
         if (texmemValidIdx(mt))
            gr_scale_bitmap(texmemGetTexture(mt),0,0,grd_canvas->bm.w,grd_canvas->bm.h);
         else
            gr_clear(0);
      }
}
#pragma on(unreferenced)

#define MIN_SCALE 8
#define MAX_SCALE 24

void Create_alignPnP(LGadRoot *root, Rect *bounds, editBrush *br)
{
   GFHSetCoordMask(GFH_ALL_COORDS);
   alignPnP_buildRects(bounds);
   PnP_GadgStart(&alignPnP,root);
   alignPnP_setvars(br,FALSE);
   pnpOwners[FROBS_PICTURE]=PnP_PictureBox(getRect(0),alignPnP_Picture,0);
   if (!brushGFH_AlignNTextureUp())
   {  // not a lot of point in these if both PnP's are up, eh?
      PnP_ButtonOneShot(getRect(1),"Txt",alignPnP_OneShots,BUTTON_TXT);
      PnP_ButtonOneShot(getRect(2),"Grid",alignPnP_OneShots,BUTTON_GRID);
   }
   PnP_ButtonOneShot(getRect(3),"Reset",alignPnP_OneShots,BUTTON_RESET);
   // @TODO: make this a maintained toggle??
   pnpOwners[BUTTON_ALIGN]=
      PnP_ButtonToggle(getRect(4),"AlignNorm","AlignBr",&_local_align,alignPnP_Toggle,BUTTON_ALIGN);

   pnpOwners[FROBS_XOFFS]=
      PnP_SliderInt(getRect(5),"U",0,CB_MAX_ALIGN,1,&xoff,alignPnP_IntFrob,FROBS_XOFFS,PNP_SLIDER_VSLIDE);
   pnpOwners[FROBS_YOFFS]=
      PnP_SliderInt(getRect(6),"V",0,CB_MAX_ALIGN,1,&yoff,alignPnP_IntFrob,FROBS_YOFFS,PNP_SLIDER_VSLIDE);
   pnpOwners[FROBS_SCALE]=
      PnP_SliderInt(getRect(7),"Scale",0,MAX_SCALE,1,&scale,alignPnP_IntFrob,FROBS_SCALE,0);
   pnpOwners[FROBS_ROT]=
      PnP_SliderFixang(getRect(8),"Rot",0,0xFFFF,1,&rot,alignPnP_FixangFrob,FROBS_ROT,PNP_SLIDER_VSLIDE|PNP_SLIDER_WRAP);
   sneaky_hideshow_refresh();    // probably the problem on return back from game to edit mode, eh?
}

void Destroy_alignPnP(void)
{
   PnP_GadgFree(&alignPnP);
   alignPnP_br=NULL;
}

void Update_alignPnP(GFHUpdateOp op, editBrush *br)
{
   alignPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      sneaky_hideshow_refresh();
}
// $Header: r:/t2repos/thief2/src/editor/arcmd.cpp,v 1.17 2000/02/19 12:27:38 toml Exp $

#include <wtypes.h>

#include <comtools.h>
#include <appagg.h>

#include <stimuli.h>
#include <stimsens.h>
#include <stimbase.h>

#include <receptro.h>
#include <reaction.h>
#include <stimul8r.h>

#include <ssrctype.h>
#include <ssrcbase.h>

#include <stimsrc.h>

#include <pg8rtype.h>
#include <pg8rbase.h>
#include <propag8n.h>
#include <propag8r.h>


#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>
#include <objedit.h>

#include <string.h>
#include <ctype.h>
#include <mprintf.h>

#include <command.h>
#include <status.h>

#include <aredit.h>
#include <iobjed.h>
#include <lnktrai_.h>
#include <linkman.h>
#include <relation.h>
#include <linkbase.h>

////////////////////////////////////////////////////////////
// ACT/REACT COMMANDS
//
// These are intended for debugging & to tide over until 
// real act/react editing happens
//


//------------------------------------------------------------
// Query Receptrons
//

struct sQueryTron 
{
   char object[32];
   char stimulus[32];
}; 

static sFieldDesc query_tron_fields[] = 
{
   { "Object", kFieldTypeString, FieldLocation(sQueryTron,object), },
   { "Stimulus", kFieldTypeString, FieldLocation(sQueryTron,stimulus), },
};

static sStructDesc query_tron_desc = StructDescBuild(sQueryTron,kStructFlagNone,query_tron_fields); 


static void query_tron()
{
   AutoAppIPtr_(Stimuli,pStimuli);

   // Set up initial values
   sQueryTron tron = { "", "Stimulus"};

   sStructEditorDesc editdesc = 
   {  
      "Query Receptron", 
   };

   IStructEditor* ed = CreateStructEditor(&editdesc,&query_tron_desc,&tron);

   if (ed->Go(kStructEdModal))
   {
      AutoAppIPtr_(StimSensors,pSensors);
      AutoAppIPtr_(Reactions,pReactions);
      sQueryTron* querytron = &tron;

      ObjID obj = EditGetObjNamed(querytron->object);
      ObjID stim = EditGetObjNamed(querytron->stimulus);

      IReceptronQuery* query = pSensors->QueryInheritedReceptrons(obj,stim);

      for (query->Start(); !query->Done(); query->Next())
      {
         const sReceptron& tron = *query->Receptron();
         sObjStimPair elems = query->Elems();
         mprintf("[ ");
         mprintf("Obj: %s ", ObjEditName(elems.obj));
         mprintf("Stim: %s ", ObjEditName(elems.stim));
         // mprintf does yucky floats
         char buf[80]; 
         sprintf(buf, "Min: %.2f Max: %.2f ", tron.trigger.min,tron.trigger.max);
         mprintf(buf);
         char* effectstr = "None";
         if (tron.effect.kind != REACTION_NULL)
         {
            effectstr = (char*)pReactions->DescribeReaction(tron.effect.kind)->name;
         }
         mprintf("Effect: %s ", effectstr);
         mprintf("]\n");
      }
      SafeRelease(query);
   }
   SafeRelease(ed);

}

//------------------------------------------------------------
// Stimulate
//

struct sStimulate
{
   char object[32];
   char stimulus[32];
   tStimLevel level;
}; 

static sFieldDesc stimulate_fields[] = 
{
   { "Object", kFieldTypeString, FieldLocation(sStimulate,object), },
   { "Stimulus", kFieldTypeString, FieldLocation(sStimulate,stimulus), },
   { "Intensity", kFieldTypeFloat, FieldLocation(sStimulate,level), },
};

static sStructDesc stimulate_desc = StructDescBuild(sStimulate,kStructFlagNone,stimulate_fields); 



static void stimulate()
{
   AutoAppIPtr_(Stimuli,pStimuli);

   // Set up initial values
   sStimulate _late = { "", "Stimulus", 1.0};


   sStructEditorDesc editdesc = 
   {  
      "Stimulate Object", 
   };

   IStructEditor* ed = CreateStructEditor(&editdesc,&stimulate_desc,&_late);

   if (ed->Go(kStructEdModal))
   {
      AutoAppIPtr_(Stimulator,pStimulate);
      AutoAppIPtr_(StimSensors,pSensors);
      
      sStimulate* late = &_late;

      ObjID obj = EditGetObjNamed(late->object);
      ObjID stim = EditGetObjNamed(late->stimulus);

      StimSensorID id = pSensors->LookupSensor(obj,stim); 
      if (id != SENSORID_NULL)
      {
         sStimEventData data = { stim, late->level, 0.0, id, 0, 0, kStimEventNoDefer };
         sStimEvent event(&data); 
         pStimulate->StimulateSensor(id,&event); 
         Status ("Stimulating...");
      }
      else
         Status ("No such sensor");
   }

   SafeRelease(ed);
}

//------------------------------------------------------------
// IMPORTED ACT/REACT EDITORS


#include <dynfunc.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static IActReactEditors* LGAPI import_woe(void)
{
   CriticalMsg("Could not load dialog!");
   return NULL;
}

DeclDynFunc_(IActReactEditors*, LGAPI, ExportActReactEditors, (void));
ImplDynFunc(ExportActReactEditors, "darkdlgs.dll", "_ExportActReactEditors@0", import_woe);

#define ImportEditors (DynFunc(ExportActReactEditors).GetProcAddress())

//------------------------------------------------------------
// Fancy add-source dialog
//


static void add_source(char* arg)
{
   sObjStimPair pair = { EditGetObjNamed(arg), OBJ_NULL};
   sStimSourceDesc desc;
   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;
   

   memset(&desc,0,sizeof(desc));
   if (editors->SourceDialog(kARDlgModal,&pair,&desc) == S_OK)
   {
      if (pair.obj == OBJ_NULL || pair.stim == OBJ_NULL 
          || &desc.propagator == PGATOR_NULL)
         return; 
      
      AutoAppIPtr_(StimSources,pSources);
      

      if (SUCCEEDED(pSources->AddSource(pair.obj,pair.stim,&desc)))
         Status ("Added Source");
      else
         Status ("Source Add Failed");      
   }
}

static void view_source(char* arg)
{
   int srcid;
   sscanf(arg,"%x",&srcid);

   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;



   AutoAppIPtr_(StimSources,pSources);

   sObjStimPair pair = pSources->GetSourceElems(srcid); 
   sStimSourceDesc desc;
   pSources->DescribeSource(srcid,&desc); 
   
   if (editors->SourceDialog(kARDlgModal,&pair,&desc) == S_OK)
   {

      

   }
}



//------------------------------------------------------------
// Fancy add-receptron dialog
//

static void add_tron(char* arg)
{
   sObjStimPair pair = { EditGetObjNamed(arg), OBJ_NULL};
   sReceptron tron;

   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;

   memset(&tron,0,sizeof(tron));   

   if (editors->ReceptronDialog(kARDlgModal,&pair,&tron) == S_OK)
   {
      if (pair.obj == OBJ_NULL || pair.stim == OBJ_NULL) 
         return; 
      
      AutoAppIPtr_(StimSensors,pSensors);
      

      if (SUCCEEDED(pSensors->AddReceptron(pair.obj,pair.stim,&tron)))
         Status ("Added Receptron");
      else
         Status ("Receptron Add Failed");      
   }
}

////////////////////////////////////////

static void edit_tron(char* arg)
{
   int tronid;
   sscanf(arg,"%x",&tronid);

   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;


      AutoAppIPtr_(StimSensors,pSensors);
   sObjStimPair pair = pSensors->GetReceptronElems(tronid);
   sReceptron tron;
   pSensors->GetReceptron(tronid,&tron); 

   if (editors->ReceptronDialog(kARDlgModal,&pair,&tron) == S_OK)
   {
      if (pair.obj == OBJ_NULL || pair.stim == OBJ_NULL) 
         return; 
      
      if (SUCCEEDED(pSensors->SetReceptron(tronid,&tron)))
         Status ("Added Receptron");
      else
         Status ("Receptron Add Failed");      
   }
}



////////////////////////////////////////

static void list_trons(char* arg)
{
   // blast trailing whitespace
   for (char* s= arg +strlen(arg); s >= arg && isspace(*s); s--)
      *s = '\0';

   sObjStimPair pair = { EditGetObjNamed(arg), OBJ_NULL};

   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;

   if (editors->ReceptronList(kARDlgModal,&pair) == S_OK)
   {

      

   }
}

////////////////////////////////////////

static void list_sources(char* arg)
{
   // blast trailing whitespace
   for (char* s= arg +strlen(arg); s >= arg && isspace(*s); s--)
      *s = '\0';

   sObjStimPair pair = { EditGetObjNamed(arg), OBJ_NULL};

   cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
   if (editors == NULL) 
      return;

   if (editors->SourceList(kARDlgModal,&pair) == S_OK)
   {

      

   }
}

////////////////////////////////////////////////////////////
// EDIT TRAITS FOR A/R
//

static sEditTraitDesc tron_tdesc = 
{
   kRelationTrait,
   {
      "Receptrons",
      "Receptrons",
      "Act/React",
   }
}; 

class cTronEditTrait : public cLinkEditTrait
{
   static RelationID GetRel()
   {
      AutoAppIPtr_(LinkManager,pLinkMan); 
      cAutoIPtr<IRelation> pRel ( pLinkMan->GetRelationNamed("Receptron") ); 
      return pRel->GetID(); 
   }

   void LinkDialog(ObjID obj)
   {
      sObjStimPair pair = { obj, OBJ_NULL }; 
      cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
      if (editors == NULL) 
         return;

      editors->ReceptronList(kARDlgModal,&pair); 
   }

public:
   cTronEditTrait() : cLinkEditTrait(GetRel(),&tron_tdesc)
   {
      strcpy(mDesc.strings.category,"Act/React"); 
      mCaps.flags |= kTraitCanAdd; 
   }

};

static sEditTraitDesc source_tdesc = 
{
   kRelationTrait,
   {
      "arSrcDesc",
      "Sources",
      "Act/React",
   }
}; 

class cSourceEditTrait : public cLinkEditTrait
{
   static RelationID GetRel()
   {
      AutoAppIPtr_(LinkManager,pLinkMan); 
      cAutoIPtr<IRelation> pRel ( pLinkMan->GetRelationNamed("arSrcDesc") ); 
      return pRel->GetID(); 
   }



   void LinkDialog(ObjID obj)
   {
      sObjStimPair pair = { obj, OBJ_NULL }; 
      cAutoIPtr<IActReactEditors> editors ( ImportEditors() );
      if (editors == NULL) 
         return;

      editors->SourceList(kARDlgModal,&pair); 

   }

public:
   cSourceEditTrait() : cLinkEditTrait(GetRel(),&source_tdesc)
   {
      strcpy(mDesc.strings.category,"Act/React"); 
      mCaps.flags |= kTraitCanAdd; 
   }
};


////////////////////////////////////////////////////////////
// COMMAND INSTALLATION
//

static Command commands[] = 
{
   { "ar_receptron_add", FUNC_STRING, add_tron, "Add an act/react receptron", HK_EDITOR},
   { "ar_receptron_query", FUNC_VOID, query_tron, "Query a set of act/react receptron", HK_EDITOR},
   { "ar_source_add", FUNC_STRING, add_source, "Add an act/react source", HK_EDITOR },
   //   { "ar_source_view", FUNC_STRING, view_source, "View an act/react source", HK_EDITOR },
   //   { "ar_receptron_edit", FUNC_STRING, edit_tron, "Edit an act/react receptron", HK_EDITOR },

   { "ar_list_receptrons", FUNC_STRING, list_trons, "Edit an object's receptrons", HK_EDITOR}, 
   { "ar_list_sources", FUNC_STRING, list_sources, "Edit an object's sources", HK_EDITOR}, 


   { "ar_stimulate", FUNC_VOID, stimulate, "Test-stimulate an object", HK_EDITOR},

};

typedef cAutoIPtr<IEditTrait> ETP;

EXTERN void add_ar_commands(void)
{
   COMMANDS(commands,HK_ALL);

   AutoAppIPtr_(ObjEditors,pEdit);
   
   pEdit->AddTrait(ETP(new cTronEditTrait)); 
   pEdit->AddTrait(ETP(new cSourceEditTrait)); 

}


// $Header: r:/t2repos/thief2/src/editor/areapnp.c,v 1.25 2000/02/19 12:27:39 toml Exp $
// HotRegion/Time Filter ("Area") PnP gadget

#include <gadblist.h>
#include <lgsprntf.h>
#include <mprintf.h>

#include <command.h>
#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <brlist.h>
#include <brinfo.h>
#include <brrend.h>
#include <brquery.h>
#include <vbrush.h>
#include <status.h>

#include <brushGFH.h>
#include <PnPtools.h>

#include <areapnp.h>
#include <namenum.h>
#include <prompts.h>
#include <ged_rmap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// global Named Hot Region system pointer
sNameNum *pNN_HotRegions=NULL;

/* artists conception
 *
 * 0  [show hot/show all]   (tog bool renderHotsOnly (comm "hots_filter"))
 * 1 [activate/deactivate]  (tog this hot region ("hots_state" 0 or 1))
 * 2       [me only]        (toggle this brush being ME, ("hots_state" 2)
 * 3 make/add to multibrush
 * 4      Current Name
 *    5 Name   7 Search
 *  6 time lo  8 time hi    (slider times, 0 is none, "time_filter_lo/hi")
 */

#define NUM_BUTTONS (0x9)
static Rect areaPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (areaPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 5
#define BTN_BELOW 2
#define VERT_DIV  5
#define HORIZ_DIV (0.5)

void areaPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   for (i=0; i<BTN_ABOVE; i++)
      buildYLineRect(curRect++,whole,i,0,1,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,0,2,2);   
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,1,2,2);
}

static bool actv_hot=FALSE, me_only=FALSE;
static editBrush *areaPnP_br;

static char *unnamed="UnNamed";
static char *areaPnP_brush_name=NULL;

#define BRUSH_NAME 0
#define NUM_OWNED (BRUSH_NAME+1)
static int pnpOwners[NUM_OWNED];

static _PnP_GadgData areaPnP;

#define HOTS_OR_ALL  1
#define ACTIVATE     2
#define DO_MEONLY    3
#define DO_MULTI_ADD 4

#define NAME_CHOSE   6
#define NAME_SEARCH  7

#define TIME_LO     1
#define TIME_HI     2
static int time_max;

// update is TRUE to mean the globals just changed
void areaPnP_setvars(editBrush *br, BOOL update)
{
   areaPnP_br=br;       // silly, since we do it a lot, but oh well
   if (areaPnP_br==NULL) return;
   if (brushGetType(br)!=brType_HOTREGION)
      actv_hot=me_only=0;
   else
   {
      actv_hot=((brHot_Status(br)&brHot_ACTIVE)>0);
      me_only=(brHot_IsMEONLY(br)>0);
   }
   areaPnP_brush_name=NamenumFetchByTag(pNN_HotRegions,areaPnP_br->br_id);
   if (areaPnP_brush_name==NULL)
      areaPnP_brush_name=unnamed;
   if (update)
   {
      PnP_SetCurrent(&areaPnP);
      PnP_Redraw(pnpOwners[BRUSH_NAME],areaPnP_brush_name);
   }
   time_max=blistCount();
}

static void areaPnP_UpdateFlag(Rect *where, bool val, int data)
{
   switch (data)
   {
   case HOTS_OR_ALL:
      if (renderHotsOnly) Status("Hot regions on"); else Status("Hot regions off");
      break;
   case ACTIVATE:
      PnP_ExecCommandInt("hots_state",brHot_TOGACTIVE);
      Status(brHot_Status(areaPnP_br)&brHot_ACTIVE?"area now Active":"area now Inactive");
      break;
   case DO_MEONLY:
      PnP_ExecCommandInt("hots_state",brHot_TOGMEONLY);
      if (brHot_IsMEONLY(areaPnP_br))
         renderHotsOnly=TRUE;  // is this right
      Status(brHot_IsMEONLY(areaPnP_br)?"area MeOnly-ed, back off":"area now normal");
      break;
   }
   areaPnP_setvars(areaPnP_br,TRUE);
   PnP_FullRedraw(&areaPnP);
   gedit_full_redraw();  // you have changed what hotregions are active, lets just go redraw this sucker
}

static void areaPnP_Names(int which)
{
   switch (which)
   {
   case NAME_CHOSE:
      {
         char buf[PROMPT_STR_LEN], def[64], *val;
         BOOL inited=FALSE;
         int hnd;

         val=NamenumFetchByTag(pNN_HotRegions,areaPnP_br->br_id);
         if (val==NULL)
         {
            strcpy(def,"brush_");
            itoa(areaPnP_br->br_id,def+strlen(def),10);
         }
         else
         {
            strcpy(def,val);
            inited=TRUE;
         }
         val=prompt_string(def,buf);
         if (inited)
            NamenumClearByTag(pNN_HotRegions,areaPnP_br->br_id);
         hnd=NamenumStore(pNN_HotRegions,val,areaPnP_br->br_id);
         areaPnP_brush_name=NamenumFetch(pNN_HotRegions,hnd);
         break;
      }
   case NAME_SEARCH:
      {
         int picked_tag=NamenumSimpleMenuChooseTag(pNN_HotRegions);
         if (picked_tag!=NAMENUM_NO_TAG)
            vBrush_SelectBrush(brFind(picked_tag));
         break;
      }
   }
   areaPnP_setvars(areaPnP_br,TRUE);
   PnP_FullRedraw(&areaPnP);
}

// simple functions to change state of brushes inside of current region
editBrush *gedit_get_meonly_brush(void);
static int cnts[2];
static void areaPnP_addtoMulti(editBrush *us)
{                                            // lets try not putting ourselves in it
   if ((brushGetType(us)!=brType_HOTREGION)) // ||(us==areaPnP_br)) // hmmm, does this work
      if (vBrush_editBrush_Op(us,vBrush_OP_ADD))
         cnts[0]++;
      else
         cnts[1]++;
}

#ifdef NEED_REM_FROM_MULTI
static void areaPnP_remfromMulti(editBrush *us)
{
   if (brushGetType(us)!=brType_HOTREGION)
      vBrush_editBrush_Op(us,vBrush_OP_ADD);
}
#endif

// really want a custom RunOnActive for current hotregion only, somehow....

static void areaPnP_OneShots(int lid)
{
   editBrush *old_meonly=gedit_get_meonly_brush(), *init_brush=areaPnP_br;
   BOOL old_rhots=renderHotsOnly;
   int our_old_state=brHot_Status(areaPnP_br);
   char buf[100];

   if (init_brush==NULL) return;
   
   // setup for oneshot trigger
   if (old_meonly)
      brHot_Status(old_meonly)&=~brHot_MEONLY;
   brHot_Status(areaPnP_br)|=brHot_MEONLY;
   
   renderHotsOnly=TRUE;
   cnts[0]=cnts[1]=0;

   // now do the work
   switch (lid)
   {
   case DO_MULTI_ADD:
      brushRunOnActive(areaPnP_addtoMulti);
      vBrush_getToCurGroup();
      break;
   }

   // now cleanup after ourselves
   brHot_Status(init_brush)=our_old_state;
   renderHotsOnly=(our_old_state==0)?FALSE:old_rhots;
   if (old_meonly)
      brHot_Status(old_meonly)|=brHot_MEONLY;

   // and tell/show the world what we did
   sprintf(buf,"Changed %d of %d",cnts[0],cnts[0]+cnts[1]);
   Status(buf);
   gedit_full_redraw();  // who knows how many brushes we just changed representations for
}

static void areaPnP_time(PnP_SliderOp op, Rect *where, int val, int data)
{
   if (op != PnP_SliderUpdateOp)
      return;
   switch (data)
   {
   case TIME_LO:     break;
   case TIME_HI:
      if (val==time_max+1)
         editbr_filter_time_hi=0;
      break;
   }
   gedit_full_redraw();  // just made changes to what brushes are visible
}

//////////////
// per frame control

void Create_areaPnP(LGadRoot* root, Rect* bounds, editBrush *br)
{
   GFHSetCoordMask(GFH_ALL_COORDS);
   areaPnP_buildRects(bounds);
   PnP_GadgStart(&areaPnP,root);
   areaPnP_setvars(br,FALSE);
   PnP_ButtonToggle(getRect(0),"Show Hot","Show All",&renderHotsOnly,areaPnP_UpdateFlag,HOTS_OR_ALL);
   PnP_ButtonToggle(getRect(1),"Activate","DeActivate",&actv_hot,areaPnP_UpdateFlag,ACTIVATE);
   PnP_ButtonToggle(getRect(2),"Me Only","Not Me Only",&me_only,areaPnP_UpdateFlag,DO_MEONLY);
   PnP_ButtonOneShot(getRect(3),"multi-brush-me",areaPnP_OneShots,DO_MULTI_ADD);
   pnpOwners[BRUSH_NAME]=PnP_TextBox(getRect(4),areaPnP_brush_name);
   PnP_ButtonOneShot(getRect(5),"Name",areaPnP_Names,NAME_CHOSE);
   PnP_ButtonOneShot(getRect(7),"Search",areaPnP_Names,NAME_SEARCH);   
   PnP_SliderInt(getRect(6),"Lo",0,time_max,1,&editbr_filter_time_lo,areaPnP_time,TIME_LO,PNP_SLIDER_VSLIDE);
   PnP_SliderInt(getRect(8),"Hi",0,time_max+1,1,&editbr_filter_time_hi,areaPnP_time,TIME_HI,PNP_SLIDER_VSLIDE);
}

void Destroy_areaPnP(void)
{
   PnP_GadgFree(&areaPnP);
   areaPnP_br=NULL;
}

void Update_areaPnP(GFHUpdateOp op, editBrush *br)
{
   areaPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)           
      PnP_FullRedraw(&areaPnP);
}

/////////////////
// maintain pNN_HotRegions

#define MAX_AREAS_NAMED 256
#define NAME_AREA_NAMES "HotRegions"

// reset the names to nothing
void AreaPnP_Names_Reset(void)
{
   if (pNN_HotRegions)
      NamenumFree(pNN_HotRegions);
   pNN_HotRegions=NamenumInit(NAME_AREA_NAMES,MAX_AREAS_NAMED);
}

// load a new set from the tagfile
BOOL AreaPnP_Names_Load(ITagFile *file)
{
   if (pNN_HotRegions)
      NamenumFree(pNN_HotRegions);
   pNN_HotRegions=NamenumLoad(NAME_AREA_NAMES,file);
   if (pNN_HotRegions)
      return TRUE;
   pNN_HotRegions=NamenumInit(NAME_AREA_NAMES,MAX_AREAS_NAMED);
   return FALSE;
}

// fixup overused tags, out of date tags, from old bad delete code days
void AreaPnP_Names_Fixup(void)
{
   int *tags, cnt;
   char **names;
   cnt=NamenumAll(pNN_HotRegions,&names,&tags);
   if (cnt)
   {
      int *toast, toasted=0, i, j;
      toast=(int *)Malloc(cnt*sizeof(int));
      for (i=0; i<cnt; i++)
      {
         editBrush *us=brFind(tags[i]);
         if ((us==NULL)||(brushGetType(us)!=brType_HOTREGION))
         {
            Warning(("AreaPnPFixup: no brush or not area on tag %d (%s)\n",tags[i],names[i]));
            toast[toasted++]=tags[i];
         }
         else
            for (j=i+1; j<cnt; j++)
               if (tags[i]==tags[j])
               {
                  Warning(("AreaPnPFixup: Later match on %d (%s) to %d (%s) [%d,%d]\n",tags[i],names[i],tags[j],names[j],i,j));
                  toast[toasted++]=tags[i];
                  break;
               }
      }
      for (i=0; i<toasted; i++)
         NamenumClearByTag(pNN_HotRegions,toast[i]);
   }
   Free(names);
   Free(tags);
}

// delete this hotregions name tags
void AreaPnP_Delete_Brush_Tags(editBrush *us)
{
   if (brushGetType(us)==brType_HOTREGION)
      if (NamenumFetchByTag(pNN_HotRegions,us->br_id))
         NamenumClearByTag(pNN_HotRegions,us->br_id);
}

// go save them off
BOOL AreaPnP_Names_Save(ITagFile *file)
{
   if (pNN_HotRegions!=NULL)
      return NamenumSave(pNN_HotRegions,file);
   return FALSE;
}

// really just needs to retag the list
void AreaPnP_Names_Remap(int *mapping_array)
{
   if (pNN_HotRegions)
      NamenumRetag(pNN_HotRegions,mapping_array);
}

// for app init
void AreaPnP_Names_Init(void)
{
   ged_remap_add_callback(AreaPnP_Names_Remap);
   pNN_HotRegions=NULL;
}

// and app close
void AreaPnP_Names_Term(void)
{
   ged_remap_rem_callback(AreaPnP_Names_Remap);
   if (pNN_HotRegions)   
      NamenumFree(pNN_HotRegions);
   pNN_HotRegions=NULL;
}
// $Header: r:/t2repos/thief2/src/editor/areapnp.h,v 1.3 2000/01/29 13:11:09 adurant Exp $
// areapnp named file block support
#pragma once

#ifndef __AREAPNP_H
#define __AREAPNP_H

#include <tagfile.h>
#include <brlist.h>

// reset the names to nothing
EXTERN void AreaPnP_Names_Reset(void);

// load a new set from the tagfile
EXTERN BOOL AreaPnP_Names_Load(ITagFile *file);

// for now, a horror to fixup old broken area pnp things
EXTERN void AreaPnP_Names_Fixup(void);

// delete this hotregions name tags
EXTERN void AreaPnP_Delete_Brush_Tags(editBrush *us);

// go save them off
EXTERN BOOL AreaPnP_Names_Save(ITagFile *file);

// really just needs to retag the list
EXTERN void AreaPnP_Names_Remap(int *mapping_array);

// for app init
EXTERN void AreaPnP_Names_Init(void);

// and app close
EXTERN void AreaPnP_Names_Term(void);


#endif  // __AREAPNP_H
// $Header: r:/t2repos/thief2/src/editor/autovbr.cpp,v 1.3 2000/02/19 12:27:40 toml Exp $

// COM fun
#include <appagg.h>
#include <aggmemb.h>

#include <mprintf.h>
#include <matrix.h>

// sdesc
#include <sdesc.h>
#include <sdesbase.h>
#include <propbase.h>
#include <propface.h>

#include <command.h>
#include <iobjsys.h>
#include <objdef.h>
#include <objnotif.h>
#include <objpos.h>

#include <wrtype.h>
#include <editbr_.h>
#include <editbr.h>
#include <editbrs.h>
#include <vbrush.h>
#include <autovbr.h>
#include <vbr_math.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

ILabelProperty *gAutoVBrushProp;
EXTERN void br_update_obj(editBrush *us);

static void ObjSysListener(ObjID obj, eObjNotifyMsg msg, void*)
{
   AutoAppIPtr_(ObjectSystem,pObjSys);
   char cmd[255];
   Label *vbrname;

   if ((msg == kObjNotifyCreate) && (OBJ_IS_CONCRETE(obj)))
   {
      if (gAutoVBrushProp->IsRelevant(obj))
      {
         gAutoVBrushProp->Get(obj, &vbrname);
         sprintf(cmd,"load_group %s",vbrname->text);

         mprintf("loading group %s from obj %d\n",vbrname->text,obj);

         // load up the multibrush
         CommandExecute(cmd);

         // move the multibrush to this location
         ObjPos *p1;
         editBrush *br=vBrush_GetSel();
         p1 = ObjPosGet(obj);
         mx_sub_vec(br_trans_vec,&p1->loc.vec,&br->pos);
         vBrush_GroupOp(FALSE,br_translate);    // zero relative them all
         vBrush_GroupOp(FALSE,br_update_obj);    

         // delete this poor object
         pObjSys->Destroy(obj);
      }
   }

}

static sPropertyDesc AutoVBrushDesc =
{
   "AutoVBR", 0, 
   NULL, 0, 0, // constraints, versions
   { "Editor", "Auto-Multibrush" },
};

void AutoVBrushInit(void)
{
   gAutoVBrushProp = CreateLabelProperty(&AutoVBrushDesc, kPropertyImplDense);

   // listen to obj sys changes 
   AutoAppIPtr_(ObjectSystem,pObjSys);
   sObjListenerDesc listener = { ObjSysListener, NULL}; 
   pObjSys->Listen(&listener); 
}
// $Header: r:/t2repos/thief2/src/editor/autovbr.h,v 1.2 2000/01/29 13:11:10 adurant Exp $
#pragma once

#ifndef __AUTOVBR_H
#define __AUTOVBR_H

EXTERN void AutoVBrushInit(void);

#endif// $Header: r:/t2repos/thief2/src/editor/bldstair.c,v 1.9 2000/02/19 12:27:41 toml Exp $
// stair building tools

#include <math.h>

#include <lg.h>
#include <matrix.h>
#include <mprintf.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brundo.h>
#include <primal.h>
#include <primfast.h>
#include <vbrush.h>
#include <status.h>
#include <gedit.h>
#include <brquery.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define STAIRS_STRAIGHT (0)
#define STAIRS_SPIRAL   (1)

static char *stairNames[]={"StraightStairSerf", "SpiralStairSerf"};

/////////////////////////
// shared stair parameters structure

typedef struct {
   char  type;     // STRAIGHT or SPIRAL, for now
   char  pad[3];   // hack hack hack
   BOOL  slats;    // do we have slats or full stairs
   BOOL  use_grid; // try and snap to grid/fit nicely with it
   int   cnt;      // how many stairs you want
   float height;   // if slats, how high each slat should be
   int   face_txt; // face textures
   int   step_txt; // step textures
   int   br_id;    // since we arent modal, we need to know who/where we are
   editBrush *br;  // filled in after the sdesc is entered with the br of our br_id
} sStairParms;

static sFieldDesc stair_fields [] =
{
   { "Step Count",   kFieldTypeInt,   FieldLocation(sStairParms,cnt) },
   { "Slats",        kFieldTypeBool,  FieldLocation(sStairParms,slats) },
   { "Use Grid",     kFieldTypeBool,  FieldLocation(sStairParms,use_grid) },
   { "Face Texture", kFieldTypeInt,   FieldLocation(sStairParms,face_txt) },
   { "Step Texture", kFieldTypeInt,   FieldLocation(sStairParms,step_txt) },
   { "Height",       kFieldTypeFloat, FieldLocation(sStairParms,height) }
};

static sStructDesc stair_struct = StructDescBuild(sStairParms,kStructFlagNone,stair_fields);

// im not gonna bother malloc and freeing this over and over, it just isnt worth it
static sStairParms static_stair_parms;
static BOOL        _stairs_inuse=FALSE;

// this is at the bottom of the code, but called by prop_cb on done, of course
BOOL stair_build(sStairParms *s);

///////////////////////////
// dialog controllers

static void LGAPI stair_prop_cb(sStructEditEvent *event, StructEditCBData data)
{
   sStairParms *s=(sStairParms *)data;
   switch (event->kind)
   {
      case kStructEdOK:
         stair_build(s);
         break;
      case kStructEdCancel:
         _stairs_inuse=FALSE;
         break;
   }
}

static BOOL stair_dialog(sStairParms *stairs)
{
   IStructEditor *sed;
   sStructEditorDesc editdesc;
   BOOL result;

   strncpy(editdesc.title, stairNames[stairs->type], sizeof(editdesc.title));
   editdesc.flags = kStructEditNoApplyButton;
   sed = CreateStructEditor(&editdesc, &stair_struct, stairs);
   if (!sed)
    { _stairs_inuse=FALSE; return FALSE; }
   IStructEditor_SetCallback(sed,stair_prop_cb,stairs);
   result = IStructEditor_Go(sed,kStructEdModal);
   SafeRelease(sed);
   return TRUE;
}

///////////////////////
// setup code, build the sStairParms struct and stuff

// pass 0 to mean i want to do fancy dialog parameter selection
// pass -1 to mean just do something - or a number of stairs

static BOOL stair_startup_common(sStairParms *ssp, int cnt, int br_id)
{
   ssp->slats=TRUE;
   ssp->use_grid=TRUE;
   ssp->cnt=(cnt==0)?8:cnt;
   ssp->height=0.0;
   ssp->br_id=br_id;
   ssp->face_txt=0;
   ssp->step_txt=0;
   _stairs_inuse=TRUE;
   if (cnt==0)
      return stair_dialog(ssp);
   else
      return stair_build(ssp);
}

BOOL straight_stair_startup(int cnt, int br_id)
{
   sStairParms *ssp=&static_stair_parms;
   ssp->type=STAIRS_STRAIGHT;
   return stair_startup_common(ssp,cnt,br_id);
}

BOOL spiral_stair_startup(int cnt, int br_id)
{
   sStairParms *ssp=&static_stair_parms;
   ssp->type=STAIRS_SPIRAL;
   return stair_startup_common(ssp,cnt,br_id);
}

//////////////////////////////
// commands - do validity checking, then hand off to above
// pass 0 to mean i want to do fancy dialog parameter selection
// pass -1 to mean just do something - or a number of stairs

// hacks till we have real code design for primal types
#define STAIR_CODE_CUBE (0)    // some cube type
#define STAIR_CODE_CYL  (1)    // current brush is solo ngon cylinder (or trunc pyramid, somehow?)

// verify the brush in question is ok
static int stair_brush_verify(editBrush *us, int primal_type)
{
   if (brSelect_Flag(us)==brSelect_VIRTUAL)
      return -1;
   else if (brushGetType(us)!=brType_TERRAIN)
      return -1;
   else if (us->media!=1)
      return -1;
   else
   {
      switch (primal_type)
      {
         case STAIR_CODE_CUBE:
            if (us->primal_id==PRIMAL_CUBE_IDX)
               return us->br_id;
            break;
         case STAIR_CODE_CYL:
            if (primalID_GetType(us->primal_id)==PRIMAL_TYPE_CYLINDER)
               return us->br_id;
            break;
      }
   }
   return -1;
}

static void do_stair_cmd(int cnt, int primal_type, BOOL (*startup_call)(int cnt, int br_id))
{
   int br_id=stair_brush_verify(vBrush_editBrush_Get(),primal_type);
   if (br_id==-1)
      Status("Illegal initial brush");
   else
      if ((*startup_call)(cnt,br_id))
         Status("Have some stairs");
      else
         Status("Couldnt startup stairSerf");
}

// actual command calls
void straight_stair_cmd(int cnt)
{
   do_stair_cmd(cnt,STAIR_CODE_CUBE,straight_stair_startup);
}

void spiral_stair_cmd(int cnt)
{
   do_stair_cmd(cnt,STAIR_CODE_CYL,spiral_stair_startup);
}

//////////////////////////
// shared utilities for all stair building

#define STAIR_EPS (0.00001)

// given pt_list (len cnt) as a clockwise face,
//  picks normal and center (from all) and src_pt (midway from 1st to last pt)
static BOOL get_face_vecs(mxs_vector *norm, mxs_vector *src_pt, mxs_vector *center_pt, mxs_vector *width_vec, mxs_vector *pt_list, int cnt)
{
   mxs_vector edge[2];
   int i;
   
   if (cnt<3) return FALSE;
   
   mx_sub_vec(&edge[0],&pt_list[0],&pt_list[1]);      // build the first two edges of the face
   mx_sub_vec(&edge[1],&pt_list[1],&pt_list[2]);
   mx_cross_norm_vec(norm,&edge[0],&edge[1]);         // and cross to get the normal
   
   mx_add_vec(src_pt,&pt_list[0],&pt_list[cnt-1]);    // and then get the "face base point"
   mx_scaleeq_vec(src_pt,0.5);                        //   by averaging the first and last points in the poly

   mx_sub_vec(width_vec,&pt_list[cnt-1],&pt_list[0]); // and then get the width vec by assuming 

   mx_zero_vec(center_pt);
   for (i=0; i<cnt; i++)
      mx_addeq_vec(center_pt,&pt_list[i]);
   mx_scaleeq_vec(center_pt,1.0/(float)cnt);
   
   return TRUE;
}

static BOOL decode_face(editBrush *br, int face, mxs_vector *norm, mxs_vector *src_pt, mxs_vector *center_pt, mxs_vector *width_vec)
{
   int pt_cnt, *pt_id_list;  // cnt, ids of points on this face
   mxs_vector *pt_raw_vecs;  // raw transformed point vectors
   BOOL rv=FALSE;

   pt_id_list=primalBr_FacePts(br->primal_id,face,&pt_cnt);
   if (pt_id_list==NULL) return FALSE;
   pt_raw_vecs=(mxs_vector *)Malloc(pt_cnt*sizeof(mxs_vector));
   if (pt_raw_vecs==NULL) return FALSE;
   primalRawPart(br->primal_id,&br->sz,pt_raw_vecs,pt_id_list,pt_cnt);
   rv=get_face_vecs(norm,src_pt,center_pt,width_vec,pt_raw_vecs,pt_cnt);
   Free(pt_raw_vecs);
   return rv;
}

static int find_primary_axis(mxs_vector *step)
{
   int i, axis;
   for (axis=-1, i=0; i<3; i++)  // find axis
      if (fabs(step->el[i])>STAIR_EPS)
         if (axis==-1)
            axis=i;
         else
         {
            Warning(("Multiple valued primary axis (%d %d) - (%g %g %g)???\n",axis,i,step->x,step->y,step->z));
            return -1;
         }
   return axis;
}

static BOOL finalize_stair_brush(editBrush *br, sStairParms *s)
{
   br->ang=s->br->ang;                            // set angles
   br->media=0;                                   // this means fill solid, sneakily
   if (s->face_txt==0) s->face_txt=s->br->tx_id;  // inherit from brush, i guess
   br->tx_id=s->face_txt;
   if (s->step_txt==0) s->step_txt=s->face_txt;
   br->txs[5].tx_id=br->txs[4].tx_id=s->step_txt; // and the step top and bottom
   return TRUE;
}

// warning - actual code that does work starts here
////////////////////////////////
// straight stair tool
// given a cube air brush, generate a bunch of new stair brushes

static BOOL build_straight_stairs(sStairParms *s)
{
   mxs_vector norm, src_pt, center_pt, face_width_vec;
   mxs_vector h_step, v_step, cur_pos;
   mxs_matrix rot;
   int h_axis, v_axis;
   int i, j;

   if (!decode_face(s->br,s->br->cur_face==-1?0:s->br->cur_face,&norm,&src_pt,&center_pt,&face_width_vec))
       return FALSE;      // go find axis of the brushes
       
   // so, by symmetry arguments, we know h_total is -center_pt*2 and v_total is (center_pt-src_pt)*2
   mx_scale_vec(&h_step,&center_pt,-2.0/(float)s->cnt);
   mx_sub_vec(&v_step,&center_pt,&src_pt);
   mx_scaleeq_vec(&v_step,2.0/(float)s->cnt);
   h_axis=find_primary_axis(&h_step);   // go get the primary axis'
   v_axis=find_primary_axis(&v_step);   
   if ((h_axis==-1)||(v_axis==-1)) return FALSE;
   if (h_axis==v_axis) { Warning(("horiz and vert axis the same???\n")); return FALSE; }
   
   mx_scale_add_vec(&cur_pos,&src_pt,&h_step,0.5);   // get to right initial pos (1/2 step from base, really)
   mx_scale_addeq_vec(&cur_pos,&v_step,0.5);
   mx_ang2mat(&rot,&s->br->ang);
   editUndoStoreBlock(TRUE);
   for (i=0; i<s->cnt; i++)
   {
      editBrush *tmp=brushInstantiate(PRIMAL_CUBE_IDX); // get a brush to work with...
      mxs_vector real_pos=cur_pos;
      mx_mat_mul_vec(&real_pos,&rot,&cur_pos);       // fix position up by rotation
      mx_add_vec(&tmp->pos,&real_pos,&s->br->pos);   
      for (j=0; j<3; j++)                            // size based on axis fun...
      {
//this code appears to do the right thing except for making sure size gets
//abs value.  So I'm making it all use abs.  AMSD
         if (j==h_axis)
            tmp->sz.el[j]=fabs(h_step.el[j]/2.0);
         else if (j==v_axis)
            if (s->slats)
               if (s->height>STAIR_EPS)              // 0.0 means use size based on step size
                  tmp->sz.el[j]=s->height; //guaranteed positive
               else
                  tmp->sz.el[j]=fabs(v_step.el[j]/4.0);
            else
               tmp->sz.el[j]=fabs(cur_pos.el[j]-src_pt.el[j]);
         else
            tmp->sz.el[j]=fabs(s->br->sz.el[j]);
      }
      finalize_stair_brush(tmp,s);
      gedit_full_create_brush(tmp,NULL,GEDIT_CREATE_AT_END,GEDIT_DEFAULT_BRTYPE);
      vBrush_NewBrush(tmp);                          // build and notify about the brush
      mx_addeq_vec(&cur_pos,&h_step);                // update cur_pos to next step
      mx_addeq_vec(&cur_pos,&v_step);
      if (!s->slats)
         cur_pos.el[v_axis]-=v_step.el[v_axis]/2.0;  // downstep the base 
   }
   editUndoStoreBlock(FALSE);
   return TRUE;
}

///////////////////////////
// spiral stair tool
// given an ngon cyl air brush, generate a bunch of new stair brushes

static BOOL build_spiral_stairs(sStairParms *s)
{
   
   return TRUE;
}

/////////////////////////////
// base call/dispatch
// actually to the building of each type
static BOOL stair_build(sStairParms *s)
{
   _stairs_inuse=FALSE;
   s->br=brFind(s->br_id);
   if (s->br) // make sure it is an air brush
   {
      switch (s->type)
      {
         case STAIRS_STRAIGHT:
            if (stair_brush_verify(s->br,STAIR_CODE_CUBE))
               return build_straight_stairs(s);
            break;
         case STAIRS_SPIRAL:
            if (stair_brush_verify(s->br,STAIR_CODE_CYL))
               return build_spiral_stairs(s);
            break;
      }
      Warning(("Bad media or brush data type for genesis brush\n"));
   }
   else
      Warning(("Brush you started the serf on is missing\n"));
   Status("Cant build stairs with this brush");
   return FALSE;
}
// $Header: r:/t2repos/thief2/src/editor/bldstair.h,v 1.2 2000/01/29 13:11:11 adurant Exp $
#pragma once

#ifndef __BLDSTAIR_H
#define __BLDSTAIR_H

EXTERN void straight_stair_cmd(int cnt);
EXTERN void spiral_stair_cmd(int cnt);

#endif  // _BLDSTAIR_H
// $Header: r:/t2repos/thief2/src/editor/brestore.h,v 1.1 1998/08/02 00:24:08 mahk Exp $
#pragma once  
#ifndef __BRESTORE_H
#define __BRESTORE_H

////////////////////////////////////////////////////////////
// STUPID BRUSH SELECTION SAVE/RESTORE
//

EXTERN void SaveBrushSelection(void); 
EXTERN void RestoreBrushSelection(void); 



#endif // __BRESTORE_H
// $Header: r:/t2repos/thief2/src/editor/brinfo.c,v 1.45 2000/02/19 12:27:42 toml Exp $
// setup and create code for each brush type
// random maintenance for brush motion and so on

#include <mprintf.h>

#include <stdio.h>
#include <string.h>       // memcpy

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <editobj.h>
#include <objsys.h>
#include <osysbase.h>
#include <portal.h>
#include <objscale.h>
#include <areapnp.h>

#include <traitman.h>

#include <ged_csg.h>
#include <ged_room.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//------------------------------------------------------------
// TERRAIN BRUSHES
//

#pragma off(unreferenced) 

static void _Terr_copy(editBrush *us, editBrush *old, BOOL clone)
{
   us->tx_id=old->tx_id;
   us->media=old->media;
   if (us->primal_id==DEF_PRIMAL)   // ?? - is this a good idea?
      us->primal_id=old->primal_id; // hmmm.. for now we want to keep ourselves
   memcpy(us->txs,old->txs,sizeof(TexInfo)*old->num_faces);
}

static void _Terr_new(editBrush *us)
{
  //if we weren't <=0 or >256, then we probably intended to be that way...
  // so let's keep on trucking with that.  AMSD (Fixes stair create problem)
   if ((us->tx_id <= 0) || (us->tx_id >256))
     us->tx_id=1;   // 0 is not really useful anymore
}

static void _Terr_setup(editBrush *us)
{
}

static void _Terr_delete(editBrush *us)
{
}

//------------------------------------------------------------
// LIGHT BRUSHES
//

static void _Light_copy(editBrush *us, editBrush *old, BOOL clone)
{
   brLight_Handle(us)=0;
   brLight_Type(us)=brLight_Type(old);
   brLight_Hue(us)=brLight_Hue(old);
   brLight_Script(us)=brLight_Script(old);
   brLight_Bright(us)=brLight_Bright(old);
   brLight_Saturation(us)=brLight_Saturation(old);
}

static void _Light_new(editBrush *us)
{
   brLight_Handle(us)=0;
   brLight_Type(us)=0;
   brLight_Hue(us)=0;
   brLight_Script(us)=0;
   brLight_Bright(us)=127.0;
   brLight_Saturation(us)=0.0;            
}

static void _Light_setup(editBrush *us)
{  // kind of an auto-auto-portalize, uses light handle internally to decide what to
   gedcsg_parse_light_brush(us, LIGHT_QUICK);
}

static void _Light_delete(editBrush *us)
{
}


//------------------------------------------------------------
// AREA BRUSHES
//

static void _Area_copy(editBrush *us, editBrush *old, BOOL clone)
{
}

static void _Area_new(editBrush *us)
{
}

static void _Area_setup(editBrush *us)
{
}

static void _Area_delete(editBrush *us)
{
   AreaPnP_Delete_Brush_Tags(us);
}

//------------------------------------------------------------
// OBJ BRUSHES
//

int brinfo_obj_type_default=0;

static void _Obj_copy(editBrush *us, editBrush *old, BOOL clone)
{
   ObjID arch = OBJ_NULL;
   ObjID oldobj = brObj_ID(old);
   if (clone)
   {
      arch = oldobj;
   }
   brObj_Type(us)= brinfo_obj_type_default;   // brObj_Type(old);
   editObjCreateObjFromBrush(arch, us);

}

static void _Obj_new(editBrush *us)
{
   brObj_Type(us) = brinfo_obj_type_default;
   editObjCreateObjFromBrush(OBJ_NULL, us);
}

static void _Obj_setup(editBrush *us)
{
   ObjID obj = brObj_ID(us);

   if (ObjectExists(obj))
   {  //@OPTIMIZE: this may be totally superfluous, add a BOOL new parm to figure it out. 
      editObjSetObjectBrush(brObj_ID(us),us);
      //      editobjUpdateBrushfromObj(brObj_ID(us));
      editobjUpdateObjfromBrush(us);
   }
   else 
      editObjCreateObjFromBrush(OBJ_NULL, us);
}

static void _Obj_delete(editBrush *us)
{  // should this be an editobj call?
   ObjID obj = brObj_ID(us); 
   if (obj != OBJ_NULL)
   {
      editObjSetObjectBrush(obj,NULL);
      DestroyObject(obj);
   }
}

// Flow
static void _Flow_copy(editBrush *us, editBrush *old, BOOL clone)
{
   brFlow_Index(us)=brFlow_Index(old);
}

static void _Flow_new(editBrush *us)
{
   brFlow_Index(us) = 1;
}

static void _Flow_setup(editBrush *us)
{
   // rewater level
}
   
static void _Flow_delete(editBrush *us)
{
   // rewater level
}

//------------------------------------------------------------
// ROOM BRUSHES
//

static mxs_vector zero = {0, 0, 0};

static void _Room_new(editBrush *us)
{
   brRoom_ObjID(us) = ged_room_get_default_arch();
   brRoom_InternalRoomID(us) = -1;   
 
   if (!ged_is_room(ged_room_get_default_arch()))
      brRoom_ObjID(us) = ged_room_get_default();
   else
      brRoom_ObjID(us) = ged_room_get_default_arch();

   if (!OBJ_IS_CONCRETE(brRoom_ObjID(us)))
   {
      Warning(("Attempt to create abstract room!\n"));
      brRoom_ObjID(us) = ged_room_get_default();
   }
}

static void _Room_copy(editBrush *us, editBrush *old, BOOL clone)
{
   if (clone)
   {
      brRoom_ObjID(us) = brRoom_ObjID(old);
      brRoom_InternalRoomID(us) = -1;
   }
   else
      _Room_new(us);
}

static void _Room_setup(editBrush *us)
{
   // update graph?
}
   
static void _Room_delete(editBrush *us)
{
   // update graph?
}

#pragma on(unreferenced)

// basically, this table takes each brush type and knows how to copy it to a new
// one of itself, or to create a new one

static void (*_same_type_copy_create[])(editBrush *us, editBrush *old, BOOL clone)=
 { _Terr_copy, _Light_copy, _Area_copy, _Obj_copy, _Flow_copy, _Room_copy };

static void (*_new_brush[])(editBrush *us)=
 { _Terr_new, _Light_new, _Area_new, _Obj_new, _Flow_new, _Room_new };

static void (*_setup_brush[])(editBrush *us)=
 { _Terr_setup, _Light_setup, _Area_setup, _Obj_setup, _Flow_setup, _Room_setup };

static void (*_delete_brush[])(editBrush *us)=
 { _Terr_delete, _Light_delete, _Area_delete, _Obj_delete, _Flow_delete, _Room_delete };

void brush_field_update(editBrush *us, editBrush *last, ulong flags)
{
   int idx=brushGetType(us);
   if (flags & brField_New)
      if (last && brushGetType(us)==brushGetType(last))
         (*_same_type_copy_create[idx])(us,last,flags & brField_Clone);
      else
         (*_new_brush[idx])(us);
   (*_setup_brush[idx])(us);
}

void brush_field_delete(editBrush *us)
{
   int idx=brushGetType(us);
   (*_delete_brush[idx])(us);
}
// $Header: r:/t2repos/thief2/src/editor/brinfo.h,v 1.15 2000/01/29 13:11:12 adurant Exp $
// brinfo has the nasty internal types and defines for gedit
#pragma once

#ifndef __BRINFO_H
#define __BRINFO_H

#include <brtypes.h>


// media works by making 0->N mean terrain medias, else - of the brType_ above
// ie -1 is Light, -2 Hotregion, and so on
// so you need to use brushGet and Set type to do this
EXTERN int brushSetType(struct _editBrush *br, int type);
EXTERN int brushGetType(struct _editBrush *br);

////////////// EDGE/POINT SELECT
// setup of the edges

#define brSelect_Edge(cb)   ((cb)->edge)
#define brSelect_Point(cb)  ((cb)->point)
#define brSelect_Flag(cb)   ((cb)->use_flg)
#define brSelect_Group(cb)  ((cb)->group_id)

#define brSelect_EDGE       (1<<1)   // if on, means we use an edge, else a point
#define brSelect_COMPLEX    (1<<2)   // if on, means edge or point, not face or whole
#define brSelect_VIRTUAL    (1<<3)

/////////////// LIGHTS
// mapping to brush fields, then defines

#define brLight_Bright(cb)    ((cb)->sz.el[0])
//#define brLight_Focal(cb)   ((cb)->sz.el[1])
//#define brLight_Ambi(cb)    ((cb)->sz.el[2])
#define brLight_Hue(cb)       ((cb)->sz.el[1])
#define brLight_Saturation(cb) ((cb)->sz.el[2])
#define brLight_Type(cb)      ((cb)->num_faces)
#define brLight_Handle(cb)    ((cb)->primal_id)
#define brLight_Script(cb)    ((cb)->tx_id)
#define brLight_isSpot(cb)    (brLight_Type(cb)&1)


/////////////// HOTREGIONS (areas)
// mapping to brush fields, then defines

// status of hot region setup and such
#define brHot_Status(cb)      ((cb)->tx_id)
#define brHot_MEONLY          2
#define brHot_ACTIVE          1
#define brHot_INACTIVE        0

#define brHot_BASEMASK        1
#define brHot_MEMASK          2

// accesors for hot regions
#define brHot_IsMEONLY(cb)    (brHot_Status(cb)&brHot_MEMASK)
#define brHot_GetBase(cb)     (brHot_Status(cb)&brHot_BASEMASK)

#define brHot_TOGACTIVE       (-2)  // just for setup calls, never store this
#define brHot_TOGMEONLY       (-1)

/////////////// OBJECTS
#define brObj_Type(cb)      ((cb)->num_faces)
#define brObj_ID(cb)        ((cb)->primal_id)

/////////////// FLOW
#define brFlow_Index(cb)    ((cb)->tx_id)

/////////////// ROOM
#define brRoom_ObjID(cb)           ((cb)->primal_id)
#define brRoom_InternalRoomID(cb)  ((cb)->tx_id)

////////////// MISC INTERNALS

// this is for creating or copying a brush - or "recreating" it
// new_brush means we are creating it from nothing, in which case we try
//  and use last to set defaults (unless last is NULL or of a different type)
// in the recreate case, we just update US and make sure any changes that 
// must occur do happen

#define brField_Old 0
#define brField_New (1 << 0)
#define brField_Clone (1 << 1)

EXTERN void brush_field_update(struct _editBrush *us, struct _editBrush *last, ulong flags);

// when deleting a brush, will do any special de-setup that is needed
EXTERN void brush_field_delete(struct _editBrush *us);

#endif  // __BRINFO_H





// $Header: r:/t2repos/thief2/src/editor/brlist.c,v 1.18 2000/02/19 12:27:43 toml Exp $

//
// Brush List (blist.c)
//   stores the actual sequential brush list.  has calls to insert a brush
// into the list, to delete a brush from the list, to set the brush list
// cursor position, return current brush, and other low level brush needs. 
//     - define seek_types - SEEK_SET, SEEK_CUR, SEEK_END
//     * brush_list *blistAlloc(int size_guess), blistFree(brush_list *bl)
//         allocate and free the master brush list
//     * bool blistSeek(int pos, int seek_type)
//         set blist cursor to pos, uses fseek style SEEK types
//     * int blistInsert(editBrush *new), editBrush *blistDelete()
//         works on the current cursor position
//     * editBrush *blistGet()
//         retrieves pointer to the current brush
//     * int blistCheck(editBrush *chk)
//         returns where the brush is in the blist, or -1 if not there
//     * int blistSetPostoBrush(editBrush *targ)
//         sets the blist cursor to point at targ, returns pos or -1
//         (ie. this really just calls check then seek_set)
// 
// note this basically uses the dstruct lib llist 
// 

#include <stdlib.h>

#include <mprintf.h>
#include <lg.h>
#include <llist.h>
#include <hheap.h>

#include <editbr.h>
#include <brlist.h>

#include <config.h>
#include <command.h>
#include <status.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern BOOL brushIsLocked (editBrush* brush);

typedef struct _brushElem {
   struct _llist;       // the list data
   editBrush *data;     // the data in the list
} brushElem;            // note how brutally memory inefficient this is

// this is typedef'ed to brush_list to brlist.h
struct _brush_list {
   llist_head list;     // the actual list
   int flags;           // status flags and such
   int count;           // how big is the list
   brushElem *cursor;   // the actual cursor object
   int cursor_pos;      // the actual "index" of the cursor
   HheapHead brushHeap; // the data storage for brush elements
};

// the current master brush list
static brush_list *cur_bl;

static void set_cursor(brush_list* bl, brushElem* curs, int pos)
{
   bl->cursor= curs;
   bl->cursor_pos = pos;
   if (blist_new_cursor_func)
      blist_new_cursor_func((curs != NULL) ? curs->data : NULL);
}


#define _blistZeroCursor(bl) set_cursor(bl,NULL,0)

// attempt to allocate the master brush list, return NULL if you fail
brush_list *blistAlloc(int size_guess)
{
   brush_list *us;      // we will try and allocate us here

   if (size_guess<256) size_guess=256;
   us=(brush_list *)Malloc(sizeof(brush_list)); // allocate brush
   if (us!=NULL) 
   {
      llist_init(&us->list);  // set up the dstruct llist type
      us->flags=0;
      us->count=0;
      _blistZeroCursor(us);   // now the cursor setup... initially point at head
      HheapInit(&us->brushHeap, sizeof(brushElem), 128, TRUE);
   }                    // we use an Hheap to store the brushElems
   return us;           // return us, which is NULL if we failed
}

// free a brush list and all associated brushes
bool blistFree(brush_list *bl)
{
#ifdef DBG_ON
   int cnt=HheapGetNumItems(&bl->brushHeap);
   if (cnt!=0)
      Warning(("Freeing brushElems with %d alloced brushes\n",cnt));
#endif   
   HheapFreeAll(&bl->brushHeap);
   Free(bl);
#ifdef DBG_ON
   if (bl==cur_bl)
      cur_bl=NULL;
#endif
   return TRUE;
}

// set the current brush list (implicit arg to all blist functions
void blistSetCurrent(brush_list *bl)
{
   cur_bl=bl;
   if (bl != NULL && blist_new_cursor_func != NULL)
      blist_new_cursor_func((bl->cursor != NULL) ? bl->cursor->data : NULL);
}

// set blist cursor to pos, uses fseek style SEEK types, false if out of range
bool blistSeek(int pos, int seek_type)
{
   int target_pos, ptr_pos; // where we want the cursor, where the ptr is
   brushElem *ptr;          // ptr is used to walk through the list

   switch (seek_type)   // first find the target position
   {
   case SEEK_CUR: target_pos=cur_bl->cursor_pos+pos; break;
   case SEEK_SET: target_pos=pos; break;
   case SEEK_END: target_pos=cur_bl->count+pos; break;      // -1
   default: return FALSE;
   }

   if ((target_pos<0)||(target_pos>cur_bl->count))          // >=
      return FALSE;             // out of range, go home
   if ((seek_type==SEEK_CUR)&&(target_pos==cur_bl->count))
      return FALSE;             // HACK: to avoid double stepping on last one

   if (target_pos<=(cur_bl->count/2))
      if ((cur_bl->cursor==NULL)|| 
          (abs(target_pos-cur_bl->cursor_pos)>target_pos))
      {
         ptr_pos=0;             // start at the head
         ptr=llist_head(&cur_bl->list);
      }
      else
      {                         // go from the cursor
         ptr_pos=cur_bl->cursor_pos;
         ptr=cur_bl->cursor;
      }
   else
      if ((cur_bl->cursor==NULL)||
          (abs(target_pos-cur_bl->cursor_pos)>cur_bl->count-target_pos))
      {                         // start at the tail
         ptr_pos=cur_bl->count-1;
         ptr=llist_tail(&cur_bl->list);
      }
      else 
      {                         // go from the cursor
         ptr_pos=cur_bl->cursor_pos;
         ptr=cur_bl->cursor;
      }
   if (target_pos<ptr_pos)
   {
      if (ptr_pos==cur_bl->count)   // woo-woo, wacky secret end of list
         ptr_pos--;                 // hack compensation
      while (ptr_pos!=target_pos)
      {                         // target is before us, so go back
         ptr=llist_prev(ptr);
         ptr_pos--;
      }
   }
   else 
      while (ptr_pos!=target_pos)
      {                         // target after us, cruise up the list
         ptr_pos++;                 // unless secret past end is insert point
         if (ptr_pos<cur_bl->count)    // hack to do the secret off list
            ptr=llist_next(ptr);       // idx for the end of the list
      }
   if (ptr==llist_end(&cur_bl->list))
      ptr=NULL;
   set_cursor(cur_bl,ptr,ptr_pos);
   return TRUE;                 // go home
}

// insert to the current brush list position
int blistInsert(editBrush *new)
{
   brushElem *ours;
   int ins_point=cur_bl->cursor_pos;

   ours=HheapAlloc(&cur_bl->brushHeap);
   ours->data=new;
   if (cur_bl->cursor==NULL)    // inserting at top of the list
   {
      llist_add_head(&cur_bl->list,ours);       // this didnt work
   }                                            // w/o curly braces
   else
   {
      llist_insert_after(ours,cur_bl->cursor);
   }
   if (cur_bl->count==cur_bl->cursor_pos)       // we are at end of list
   {
      brushElem* curs;
      if (cur_bl->count==0)                     // if list was empty
         curs=llist_head(&cur_bl->list);
      else                                      // we go after ourselves
         curs=llist_next(cur_bl->cursor);
      set_cursor(cur_bl,curs,cur_bl->cursor_pos+1);      
   }
   cur_bl->count++;
   return ins_point;
}

// removes from the current brush list position
editBrush *blistDelete(void)
{
   editBrush *us=NULL;
   brushElem *toToast=NULL;

   if (cur_bl->count==0)
      return NULL;
   if (cur_bl->cursor==NULL)            // we are pointing at head
   {
      toToast=llist_head(&cur_bl->list);
   }
   else                                 // otherwise in list
   {
      toToast=cur_bl->cursor;           // so kill us and then move the

      do
      {
          if (cur_bl->cursor==llist_tail(&cur_bl->list))
          {
             if (cur_bl->cursor==llist_head(&cur_bl->list))
             {
                _blistZeroCursor(cur_bl);
                break;
             }
             else
             {
                set_cursor(cur_bl,llist_prev(cur_bl->cursor),cur_bl->cursor_pos-1);
             }
          }
          else
          {
              set_cursor(cur_bl,llist_next(cur_bl->cursor),cur_bl->cursor_pos);
          }

      } while (brushIsLocked (cur_bl->cursor->data) && cur_bl->cursor != toToast);

   }            // dont know what this does when at end (what next does)
   
   // if this is the last unlocked brush left...
   if (cur_bl->cursor == toToast)
       _blistZeroCursor(cur_bl);
   
   if (toToast)
   {
      us=toToast->data;
      if (brushIsLocked(us))
      {
          Status("* LOCKED *");
          return NULL;
      }

      llist_remove(toToast);
      HheapFree(&cur_bl->brushHeap,toToast);
#ifdef DBG_ON
      if (us==NULL)
         Warning(("Toasted fine, but left us a NULL brush somehow\n"));
#endif
   }
   else
      Warning(("Somehow couldnt blistDelete\n"));
   cur_bl->count--;
   return us;   // inited to NULL, so return NULL if cant delete
}

// retrieves pointer to brush structure for the current brush list pos
editBrush *blistGet(void)
{
   if (cur_bl->cursor!=NULL)
      return cur_bl->cursor->data;
   else 
      return NULL;
}

// sets the blist cursor to point at targ, returns pos or -1
//         (ie. this really just calls check then seek_set)
int blistSetPostoBrush(editBrush *targ)
{
   int pos;
   
   pos=blistCheck(targ);
   if (pos!=-1)
   {
      if ((cur_bl->cursor_pos==cur_bl->count)&&
          (cur_bl->cursor->data==targ))
         return cur_bl->cursor_pos;    // ??? or maybe -1 ???
      if (!blistSeek(pos,SEEK_SET))
         return -1;
   }
   return pos;
}

typedef struct _sBlistIter {
   brushElem   *ptr;
   int          idx;     // 0 at start, -1 if freed from beneath the top
} sBlistIter;

#define iterPtr(hnd)     (iter_stack[hnd].ptr)
#define iterBrush(hnd)  ((iter_stack[hnd].ptr)->data)
#define iterIdx(hnd)     (iter_stack[hnd].idx)

#define ITER_STACK_DEPTH 8
static sBlistIter iter_stack[ITER_STACK_DEPTH];
static int        iter_stack_ptr=-1;
static int        iter_last_used=-1;

#ifdef DBG_ON
#define blistIterDebugHeader(hnd) \
   if (((hnd)>iter_stack_ptr)||((hnd)<0)) Warning(("blistIter: bad handle %d - gonna break\n",hnd))
#else
#define blistIterDebugHeader(hnd)
#endif

editBrush *_blistIterFinish(int hnd)
{
   iter_last_used=hnd;
   if ((iterPtr(hnd)==NULL)||(iterBrush(hnd)==NULL))
   {
      blistIterDone(hnd);
      return NULL;
   }
   else
      return iterBrush(hnd);
}

editBrush *blistIterStart(int *iter_handle)
{
   if (iter_stack_ptr>=ITER_STACK_DEPTH-1)  // have we overrun our iter stack
    { Warning(("blistIter stack depth exceeded\n")); return NULL; }
   if (llist_empty(&cur_bl->list))
      return NULL;     // if empty
   *iter_handle=++iter_stack_ptr;
   iterPtr(*iter_handle)=llist_head(&cur_bl->list);   
   iterIdx(*iter_handle)=0;
   return _blistIterFinish(*iter_handle);   
}

// returns next in list
// dont screw with the list while calling this, or panic
editBrush *blistIterNext(int iter_handle)
{
   blistIterDebugHeader(iter_handle);
   if (iterPtr(iter_handle)==llist_end(&cur_bl->list))
      iterPtr(iter_handle)=NULL;
   else
   {
      iterPtr(iter_handle)=llist_next(iterPtr(iter_handle));
      iterIdx(iter_handle)++;
   }
   return _blistIterFinish(iter_handle);
}

int blistIterDone(int iter_handle)
{
   blistIterDebugHeader(iter_handle);
   if (iter_handle==iter_stack_ptr)
   {  // walk down looking for next used
      while (--iter_handle>=0)
         if (iterIdx(iter_handle)!=-1)
            break;
      iter_stack_ptr=iter_handle;
   }
   else
      iterIdx(iter_handle)=-1;
   iter_last_used=iter_stack_ptr;
   return iter_stack_ptr;
}

// returns where the brush is in the blist, or -1 if not there
// has secret gnosis of blistNext
// in particular, if you Check the current brush from Next, it is fast
int blistCheck(editBrush *chk)
{
   brushElem *loopvar;
   int i=0;

#ifdef OLD_WAY   
   if ((curIter!=NULL)&&(chk==curIter->data)) // shortcut as mentioned above
      return curIdx;                          // look, mom, we just know!
#endif
   if ((iter_last_used!=-1)&&(chk==iterBrush(iter_last_used)))
      return iterIdx(iter_last_used);
   forallinlist(brushElem,&cur_bl->list, loopvar)
   {
      if (loopvar->data==chk)
         return i;
      i++;
   }
   return -1;
}

void blistDump(void)
{
   brushElem *iter=llist_head(&cur_bl->list);
   int i=0;

   while (iter!=llist_end(&cur_bl->list))
   {
      mprintf("Elem %d> %x (%x)\n",i++,iter,iter->data);
      iter=llist_next(iter);   
   }
   mprintf("Curs %d> %x (%x)\n",
           cur_bl->cursor_pos,cur_bl->cursor,
           cur_bl->cursor?cur_bl->cursor->data:0);
   mprintf("Count is %d, hheap size %d, list %d\n",
           cur_bl->count,
           HheapGetNumItems(&cur_bl->brushHeap),
           llist_num_nodes(&cur_bl->list));
}

// get the current brush count
int blistCount(void)
{
   return cur_bl->count;
}

// where are we in time
int blistGetPos(void)
{
   return cur_bl->cursor_pos;
}

#ifndef HORRIBLE_DEBUG_EVERY_BRUSH_CURSOR_CHANGE
// call me whenever a new brush happens
void (*blist_new_cursor_func)(struct _editBrush* ) = NULL;
#else
static void hack_func(editBrush *moo)
{
   mprintf("Yep, new cursor %x\n",moo);
}

void (*blist_new_cursor_func)(struct _editBrush* ) = hack_func;
#endif
// $Header: r:/t2repos/thief2/src/editor/brlist.h,v 1.8 2000/01/29 13:11:13 adurant Exp $
#pragma once

#ifndef __BRLIST_H
#define __BRLIST_H

#include <editbrs.h>

//
// Brush List (brlist.h)
//   stores the actual sequential brush list.  has calls to insert a brush
// into the list, to delete a brush from the list, to set the brush list
// cursor position, return current brush, and other low level brush needs. 
//     - define seek_types - SEEK_SET, SEEK_CUR, SEEK_END
//     * brush_list *blistAlloc(int size_guess), blistFree(brush_list *bl)
//         allocate and free the master brush list
//     * brush_list *blistSetCurrent(brush_list *bl)
//         sets the current used brush list for the system
//     * bool blistSeek(int pos, int seek_type)
//         set blist cursor to pos, uses fseek style SEEK types
//     * int blistInsert(editBrush *new), editBrush *blistDelete()
//         works on the current cursor position
//     * editBrush *blistGet()
//         retrieves pointer to the current brush
//     * int blistCheck(editBrush *chk)
//         returns where the brush is in the blist, or -1 if not there
//     * int blistSetPostoBrush(editBrush *targ)
//         sets the blist cursor to point at targ, returns pos or -1
//         (ie. this really just calls check then seek_set)
// 
// note this basically uses the dstruct lib llist 
//
// really need to break this up

typedef struct _brush_list brush_list;

// attempt to allocate the master brush list, return NULL if you fail
EXTERN brush_list *blistAlloc(int size_guess);

// free a brush list and all associated brushes
EXTERN bool blistFree(brush_list *bl);

// set the current brush list (implicit arg to all blist functions
EXTERN void blistSetCurrent(brush_list *bl);

// set blist cursor to pos, uses fseek style SEEK types, false if out of range
EXTERN bool blistSeek(int pos, int seek_type);

// insert to the current brush list position
EXTERN int blistInsert(editBrush *newbr);

// removes from the current brush list position
EXTERN editBrush *blistDelete(void);

// retrieves pointer to brush structure for the current brush list pos
EXTERN editBrush *blistGet(void);

// returns where the brush is in the blist, or -1 if not there
EXTERN int blistCheck(editBrush *chk);

// sets the blist cursor to point at targ, returns pos or -1
//         (ie. this really just calls check then seek_set)
EXTERN int blistSetPostoBrush(editBrush *targ);

EXTERN void (*blist_new_cursor_func)(struct _editBrush* ); // call me whenever the cursor changes

// take a wild guess
EXTERN int blistCount(void);

// return order in list of cursor
EXTERN int blistGetPos(void);

///////////////////////
// iteration

// dont screw with the list while calling these, or panic
// the idea is, you call IterStart to setup and get a handle back, then IterNext to continue
// IterDone says "im done with the handle"
// NOTE: YOU MUST USE DIFFERENT STARTS HANDLES IN A STACK FASHION!!!
// ie you can IterStart within a different Iter, but you MUST FINISH the new Iter and "Done" it
//   before IterNext'ing the old one

// start an iteration, get start of list and handle
EXTERN editBrush *blistIterStart(int *iter_handle);
// continue to iterate on this handle (MUST BE SAME AS LAST IterStart HANDLE, or popped handle from Done)
// NOTE: auto-pops when it reaches the end!!! ie. it calls IterDone
EXTERN editBrush *blistIterNext(int iter_handle);
// finish an Iter, returns handle of previous ("popped") iteration
//  (in case you need to just abort everything??? you could just keep IterDone'ing its own return values
//   im not actually sure this is a good idea, but i dont see why it wouldnt work)
EXTERN int        blistIterDone(int iter_handle);

/////////////////
// debugging tool, dumps brush list to mono screen
EXTERN void blistDump(void);

//////////////////////
// for the seek parameters - you probably already have these in stdio.h or something
#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif

#ifndef SEEK_END
#define SEEK_END 2
#endif

#endif  // __BRLIST_H
// $Header: r:/t2repos/thief2/src/editor/brloop.c,v 1.23 2000/02/19 12:27:44 toml Exp $

#include <lg.h>
#include <comtools.h>
#include <loopapi.h>
#include <mprintf.h>
#include <command.h>

#include <loopmsg.h>
#include <dbasemsg.h>
#include <dispbase.h>
#include <objnotif.h>

#include <brloop.h>
#include <objloop.h>
#include <uiloop.h>

#include <editbr.h>
#include <brlist.h>
#include <vbrush.h>
#include <property.h>
#include <brprop.h>
#include <editobj.h>
#include <editsave.h>
#include <areapnp.h>
#include <wrloop.h>
#include <backup.h>

#include <editbr_.h>  // for the horror of curBrush save/load hell
#include <brinfo.h>
#include <editobj.h>
#include <brquery.h>

#include <appagg.h>
#include <iobjsys.h>
#include <objquery.H>
#include <osysbase.h>
#include <brestore.h>
#include <edmedmo.h>

#include <editmode.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/////////////////////////////////////////////////////////////
// BRUSH LOOP CLIENT
////////////////////////////////////////////////////////////

//////////////////
// CONSTANTS
//
// These are just here to separate out boiler-plate code and leave it untouched
//



#define MY_FACTORY BrushListLoopFactory

//
//
#define MY_GUID   LOOPID_BrushList

//
//
// My context data
typedef void Context;

//
// 
// My state
typedef struct _StateRecord
{
   Context* context; // a pointer to the context data I got.

   BOOL edit_mode; 
   // State fields go here
} StateRecord;


////////////////////////////////////////
// DATABASE MESSAGE HANDLER
//

static brush_list *master_bl;

static void db_message(DispatchData* msg)
{
   msgDatabaseData info;

   info.raw = msg->data;

   if (BackupSaving() || BackupLoading())
      return ;

   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         EdMedMoClearMediumMotion();
         brushClearAll();
         AreaPnP_Names_Reset();
         vBrushReset();
         break;
   
      case kDatabaseLoad:
         vBrush_DontUpdateFocus=TRUE;
         if (msg->subtype & kDBMap)
            editor_LoadCow(info.load);
         break;

      case kDatabasePostLoad:
         if (msg->subtype & kDBMap)
            editor_PostLoadCow();
         vBrush_DontUpdateFocus=FALSE;
         vBrush_SelectBrush(vBrush_editBrush_Get());

         break;
   
      case kDatabaseSave:
         if (msg->subtype & kDBMap)
            editor_SaveCow(info.load);
         break;
   }
}


////////////////////////////////////////
// BRUSH PROPERTY CREATE
//

static PropertyID brush_prop_id = -1; 

static void init_brush_prop(void)
{
   IBrushProperty* prop = BrushPropInit();
   brush_prop_id = IProperty_GetID(prop);
}

////////////////////////////////////////
// OBJECT MESSAGE HANDLER 
//

static void create_obj_brushes(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   IObjectQuery* query = IObjectSystem_Iter(pObjSys,kObjectConcrete); 
   for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
   {
      ObjID obj = IObjectQuery_Object(query); 
      editobjCreateBrushfromObj(obj);   
   }
   SafeRelease(query);
   SafeRelease(pObjSys); 
}

static void destroy_obj_brushes(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   IObjectQuery* query = IObjectSystem_Iter(pObjSys,kObjectConcrete); 
   
   CommandExecute ("unlock_all");
   for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
   {
      ObjID obj = IObjectQuery_Object(query); 
      editObjDeleteObjBrush(obj);   
   }
   SafeRelease(query);
   SafeRelease(pObjSys); 
}

#pragma off(unreferenced)
static void obj_message(ObjID obj, eObjNotifyMsg msg, void* data)
{

   switch (msg)
   {
      case kObjNotifyCreate:
      case kObjNotifyLoadObj:
         editobjCreateBrushfromObj(obj);
         break;
   }
}
#pragma on(unreferenced)

static tObjListenerHandle listen; 

static void init_obj_message(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   sObjListenerDesc desc = { obj_message, NULL }; 
   listen = IObjectSystem_Listen(pObjSys,&desc);
   SafeRelease(pObjSys); 
}

static void term_obj_message(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   listen = IObjectSystem_Unlisten(pObjSys,listen);
   SafeRelease(pObjSys); 
}

////////////////////////////////////////
// BRESTORE.H API
//
// and speaking of dirty work, horrible save brush focus code
static int   editorLastBrushID=-1;
static ObjID editorLastObjID=OBJ_NULL;

void SaveBrushSelection(void)
{
   editBrush *cur_br=vBrush_editBrush_Get();
   editorLastObjID=OBJ_NULL;
   editorLastBrushID=-1;
   if (brushGetType(cur_br)==brType_OBJECT)
      editorLastObjID=brObj_ID(cur_br);
   else
      editorLastBrushID=cur_br->br_id;
   //   mprintf("Store for restore %s: %d\n",
   //           editorLastObjID!=OBJ_NULL?"Obj":"Brush",
   //           editorLastObjID!=OBJ_NULL?editorLastObjID:editorLastBrushID);
}

void RestoreBrushSelection(void)
{
   editBrush *focus_br;
   //            mprintf("Want to restore %s: %d\n",
   //               editorLastObjID!=OBJ_NULL?"Obj":"Brush",
   //               editorLastObjID!=OBJ_NULL?editorLastObjID:editorLastBrushID);
   create_obj_brushes(); 
   if (editorLastObjID!=OBJ_NULL)
      focus_br=editObjGetBrushFromObj(editorLastObjID);
   else
      focus_br=brFind(editorLastBrushID);
   if (focus_br==NULL)
      focus_br=vBrush_editBrush_Get();
   vBrush_SelectBrush(focus_br);
}

////////////////////////////////////////
//
// LOOP/DISPATCH callback
// Here's where we do the dirty work.
//


#pragma off(unreferenced)
static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   // useful stuff for most clients
   eLoopMessageResult result = kLoopDispatchContinue; 
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;

   info.raw = hdata; 

   switch(msg)
   {
      case kMsgAppInit:
         brushSysInit();
         vBrushInit();
         AreaPnP_Names_Init();
         master_bl=blistAlloc(256);
         blistSetCurrent(master_bl);
         init_brush_prop();
         editObjInit();
         break;

      case kMsgAppTerm:
         editObjTerm();
         vBrushFree();
         AreaPnP_Names_Term();
         brushClearAll();
         blistSetCurrent(NULL);
         blistFree(master_bl);
         brushSysFree();
         break;

      case kMsgResumeMode:
      case kMsgEnterMode:
      {
         state->edit_mode = IsEqualGUID(info.mode->to.pID,&LOOPID_EditMode); 
         if (state->edit_mode)
         {
            // we can't do this here because the mission backup might load
            //            create_obj_brushes();
            init_obj_message(); 
         }
      }
      break; 

      case kMsgExitMode:
      case kMsgSuspendMode:
      {
         if (state->edit_mode)
         {
            destroy_obj_brushes(); 
            vBrush_SelectBrush(vBrush_editBrush_Get());
            term_obj_message();
         }
      }
      break; 

      case kMsgEndFrame:
         if (state->edit_mode)
            vBrush_FrameCallback();
         break;

      case kMsgDatabase:
         db_message(info.dispatch);
         break;

      case kMsgEnd:
         Free(state);
         break;   
   }
   return result;
}

F_DECLARE_INTERFACE(IPropertyManager);

////////////////////////////////////////////////////////////
// 
// Loop client factory function. 
//

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   // allocate space for our state, and fill out the fields
   state = (StateRecord*)Malloc(sizeof(StateRecord));
   state->context = (Context*)data;
   
   return CreateSimpleLoopClient(_LoopFunc,state,pDesc);
}
#pragma on(unreferenced)

///////////////
// DESCRIPTOR
// 

sLoopClientDesc BrushListLoopClientDesc =
{
   &MY_GUID,                              // GUID
   "Brush List",                          // NAME        
   kPriorityNormal,                       // PRIORITY          
   kMsgEnd
   | kMsgEndFrame
   | kMsgDatabase 
   | kMsgsAppOuter
   | kMsgsMode, // INTERESTS      

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,
   
   {
      { kConstrainBefore, &LOOPID_UI, kMsgDatabase }, 
      // so we get brushes before textures 
      { kConstrainBefore, &LOOPID_Wr, kMsgDatabase }, 
      { kConstrainBefore, &LOOPID_Editor, kMsgsMode }, 



      {kNullConstraint} // terminator
   }
};




// $Header: r:/t2repos/thief2/src/editor/brloop.h,v 1.3 2000/01/29 13:11:14 adurant Exp $
#pragma once
#ifndef __BRLOOP_H
#define __BRLOOP_H


// Loop client GUID
DEFINE_LG_GUID(LOOPID_BrushList, 0x3a);

// Loop Client Descriptor
EXTERN struct sLoopClientDesc  BrushListLoopClientDesc;

//
// KEEP THIS FILE RELATIVELY CLEAR OF JUNK!  DO NOT PUT YOUR SYSTEM'S API HERE! 
// DO NOT INCLUDE OTHER HEADER FILES FROM THIS FILE!
//

 
#endif // __BRLOOP_H
// $Header: r:/t2repos/thief2/src/editor/brobjpro.cpp,v 1.3 2000/02/19 12:27:45 toml Exp $
// expose brush property info to brush/editor system
// mostly for objects which have props which make them behave like other brush types

#include <brrend.h>
#include <brinfo.h>
#include <brobjpro.h>
#include <litprop.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


// You can think of this as an enumeration of those properties which
// light the world.
static BOOL get_brightness(ObjID obj, float *brightness)
{
   if (ObjLightGetBrightness(obj, brightness))
      return TRUE;

   if (ObjAnimLightGetBrightness(obj, brightness))
      return TRUE;

   return FALSE;
}


// Lights take a brightness of [0, 1024].
float brObjProp_getLightLevel(ObjID o_id)
{
   float brightness;

   if (get_brightness(o_id, &brightness))
      return brightness;

   return -1.0;
}

// for now, only knows about the light prop
int brObjProp_getFilterType(ObjID o_id)
{
   if (brObjProp_getLightLevel(o_id)>=0.0)
      return brFlag_FILTER_OBJ|brFlag_FILTER_LIGHT;
   return brFlag_FILTER_OBJ;
}
// $Header: r:/t2repos/thief2/src/editor/brobjpro.h,v 1.2 2000/01/29 13:11:15 adurant Exp $
// expose brush property info to brush/editor system
// mostly for objects which have props which make them behave like other brush types
#pragma once

#ifndef __BROBJPRO_H
#define __BROBJPRO_H

#include <objtype.h>

// returns <0.0 if no light on obj, else 0->n light level
EXTERN float brObjProp_getLightLevel(ObjID o_id);

// returns the br filter code for the object
EXTERN int   brObjProp_getFilterType(ObjID o_id);

#endif  // __BROBJPRO_H
// $Header: r:/t2repos/thief2/src/editor/brprop.cpp,v 1.8 1998/10/02 10:44:35 JUSTIN Exp $

#include <propert_.h>
#include <dataops_.h>
#include <brprop.h>
#include <prophash.h>
#include <editbr_.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////////////////////////
// BRUSH PROPERTY INTERFACE
//

class cBrushStore: public cHashPropertyStore<cSimpleDataOps>
{
}; 

typedef cSpecificProperty<IBrushProperty,&IID_IBrushProperty,editBrush*,cBrushStore> cBaseBrushProp; 

class cBrushProperty : public cBaseBrushProp
{
public:
   cBrushProperty(const sPropertyDesc* desc)
      : cBaseBrushProp(desc)
   {
   };

   STANDARD_DESCRIBE_TYPE(editBrush); 
   
};

////////////////////////////////////////////////////////////
// THE UNIQUE BRUSH PROPERTY
//

static sPropertyDesc PropDesc = 
{
   PROP_BRUSH_NAME,
   kPropertyTransient|kPropertyNoInherit
   |kPropertyNoClone|kPropertyNoEdit,
   NULL, // constraints
   0, 0, // version
   {
      "Editor",
      "Brush Name",  // named, but not seen in the editor
   },
   kPropertyChangeLocally, // net_flags
}; 

IBrushProperty* BrushPropInit(void)
{
   IBrushProperty* prop = new cBrushProperty(&PropDesc);

   return prop;
}

//////////////////////////////////////////////////////////////
// THE "HAS BRUSH" PROPERTY
//
// If FALSE, the object can't have a brush.  
// 

static sPropertyDesc HasBrushDesc = 
{
   PROP_HASBRUSH_NAME,
   0, // flags
   NULL, // constraints
   0, 0, // version
   {
      "Editor",
      "Has Brush", 
   },
   0, // net_flags
}; 

IBoolProperty* HasBrushPropInit(void)
{
   return CreateBoolProperty(&HasBrushDesc,kPropertyImplSparseHash); 
}

// $Header: r:/t2repos/thief2/src/editor/brprop.h,v 1.5 2000/01/29 13:11:16 adurant Exp $
#pragma once

#ifndef BRPROP_H
#define BRPROP_H

#include <property.h>
#include <propdef.h>
#include <editbr.h>
#include <propface.h>

////////////////////////////////////////////////////////////
// BRUSH PROPERTY INTERFACE
//


#undef INTERFACE
#define INTERFACE IBrushProperty
DECLARE_PROPERTY_INTERFACE(IBrushProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(editBrush*); 
}; 


////////////////////////////////////////////////////////////
// THE BRUSH PROPERTY
//

#define PROP_BRUSH_NAME "Brush" 
#define PROP_HASBRUSH_NAME "HasBrush"

EXTERN IBoolProperty* HasBrushPropInit(void); 
EXTERN IBrushProperty* BrushPropInit(void);


#endif // BRPROP_H
// $Header: r:/t2repos/thief2/src/editor/brquery.c,v 1.3 2000/02/19 12:27:46 toml Exp $
// some misc brush query/list control functions

#include <editbr.h>
#include <editbr_.h>
#include <brlist.h>
#include <vbrush.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/////////////////
// brush finder - returns the brush (if there is one) of brush id br_id
editBrush *brFind(int br_id)
{
   editBrush *us;
   int hIter;

   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (us->br_id==br_id)
      {
         blistIterDone(hIter);
         break;             // found it
      }
      us=blistIterNext(hIter);
   }
   return us;
}

/////////////////
// generic brush cycler - takes a "is brush ok" callback which you provide
BOOL brCycle(int dir, BOOL (*br_ok)(editBrush *br))
{
   editBrush *initial_br=vBrush_GetSel(), *cur;
   int seek_fix=dir>0?SEEK_SET:SEEK_END;
   BOOL rv=TRUE;
   
   do {
      if (!blistSeek(dir,SEEK_CUR))
         blistSeek(0,seek_fix);
      if (br_ok==NULL) break;     // if no criterion, first found brush is it
      cur=blistGet();
      if (cur==initial_br) rv=FALSE; // back at front, you lose.  rv=FALSE will cause us to break out
   } while (rv && (!(*br_ok)(cur))); // we can just call br_ok, cause if NULL we already left loop
   if (rv)
      we_switched_brush_focus();
   return rv;
}

/////////////////
// brush finder - returns the brush (if there is one) of brush id br_id
int brFilter(BOOL (*br_ok)(editBrush *br), BOOL (*br_run)(editBrush *br))
{
   editBrush *us;
   int hIter, cnt=0;

   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if ((*br_ok)(us))
         if ((*br_run)(us))
            cnt++;
      us=blistIterNext(hIter);
   }
   return cnt;
}
// $Header: r:/t2repos/thief2/src/editor/brquery.h,v 1.3 2000/01/29 13:11:17 adurant Exp $
// some misc brush query/list control functions
#pragma once

#ifndef __BRQUERY_H
#define __BRQUERY_H

#include <editbrs.h>

// brush finder - returns the brush (if there is one) of brush id br_id 
EXTERN editBrush *brFind(int br_id);

// generic brush cycler - takes a "is brush ok" callback which you provide
EXTERN BOOL brCycle(int dir, BOOL (*br_ok)(editBrush *br));

// run br_ok on all brushes, run br_run on all that pass, returns count of ones which _run passes
EXTERN int brFilter(BOOL (*br_ok)(editBrush *br), BOOL (*br_run)(editBrush *br));

#endif  // __BRQUERY_H
// $Header: r:/t2repos/thief2/src/editor/brrend.c,v 1.29 2000/02/19 12:27:47 toml Exp $

// actual brush renderer, picker, so on

#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>

#include <lg.h>
#include <g2.h>
#include <r3d.h>
#include <matrix.h>
#include <mprintf.h>

#include <uiedit.h>     // get color fixup code

#include <viewmgr.h>    // sad, isnt it
#include <editbr.h>
#include <brlist.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brobjpro.h>
#include <brrend.h>
#include <primal.h>
#include <primfast.h>
#include <vbrush.h>
#include <gridsnap.h>
#include <hilight.h>

#include <csg.h>
#include <rand.h>
#include <config.h>

#include <appagg.h>
#include <comtools.h>
#include <iobjsys.h>
#include <traitman.h>

// this controls whether portal conversion will be doubles or floats
#define PORTAL_CONVERT_USE_DOUBLES   

/////////////////////
// color horribleness

// this is hideous, fix it - (color horribleness, see end)
typedef enum {
   terrCur,    
   terrNorm,   
   terrFace,   
   lightCur,   
   lightNorm,  
   areaCur,    
   areaMeOnly, 
   areaActive,
   areaNorm,   
   objCur,     
   objNorm,
   camCur,
   camNorm,
   terrMulti,
   lightMulti,
   areaMulti,
   objMulti,
   flowCur,
   flowMulti,
   flowNorm,
   roomCur,
   roomMulti,
   roomNorm,
   highlight1,
   NumColors
} brushColorNames;

#define NUM_GREY_SHADES 12

int brushColors[NumColors];
int greyRange[NUM_GREY_SHADES];

int brushRaws[]=
{
   uiRGB(0xd5,0xd5,0xd5),  // terr cur
   uiRGB(0x63,0xa3,0xb8),
   uiRGB(0xa1,0x66,0x40),
   uiRGB(0xc0,0xc0,0x2a),  // light
   uiRGB(0x90,0x90,0x1a),   
   uiRGB(0xc4,0x78,0x4a),  // area
   uiRGB(0xa1,0x66,0x40),
   uiRGB(0x83,0x55,0x36),
   uiRGB(0x6e,0x44,0x2d),
   uiRGB(0xd5,0xa5,0xa5),  // obj, past here is not done
   uiRGB(0xa5,0x25,0x25),  
   uiRGB(0xd5,0xd5,0xd5),  // cam
   uiRGB(0xd5,0xd5,0xd5),  //
   uiRGB(0xa4,0xa4,0x1a),  // multi-terr
   uiRGB(0xa4,0xa4,0x1a),  // multi-light
   uiRGB(0xa4,0xa4,0x1a),  // multi-area
   uiRGB(0xa4,0xa4,0x1a),  // multi-obj
   uiRGB(0x88,0x10,0xc4),  // flow cur, multi, norm
   uiRGB(0xa4,0xa4,0x1a),  // 
   uiRGB(0x58,0x10,0x80),
   uiRGB(0x88,0x10,0xc4),  // room cur, multi, norm
   uiRGB(0xa4,0xa4,0x1a),  
   uiRGB(0x48,0x48,0x48),
   uiRGB(0x80,0xa0,0x20),  // highlight
};
#define NUM_BRUSH_COLORS (sizeof(brushRaws)/sizeof(brushRaws[0]))

// pick weight for grey for i, with i/NGS
#define PikR(i) (i*0x70/(NUM_GREY_SHADES-1))
#define PikG(i) (0x28+(i*0xa8/(NUM_GREY_SHADES-1)))
#define PikB(i) (0x30+(i*0xcf/(NUM_GREY_SHADES-1)))

void brushPickColors(void)
{
   int i;
   if (config_is_defined ("hens_changes"))
   {
      brushRaws[highlight1] = uiRGB(0x00,0xFF,0x00);  //	the new (green) highlight
   }

   for (i=0; i<NumColors; i++)
      brushColors[i]=uieditFixupColor(brushRaws[i]);
   for (i=0; i<NUM_GREY_SHADES; i++)
      greyRange[i]=uieditFixupColor(uiRGB(PikR(i),PikG(i),PikB(i)));
}

//////////////////////////////
// brush render/convert/pick craziness

//////////////////////////////
// "global" state for the brush which we are currently drawing
// this is untrue, but works for now
#define MAX_PTS_PER_BRUSH 32

// static state for the setup/transform/draw brush pipeline
static r3s_point   brush_pts[MAX_PTS_PER_BRUSH]; // transformed points
static mxs_vector  obj_pts[MAX_PTS_PER_BRUSH], world_pts[MAX_PTS_PER_BRUSH];
static int         brush_pt_cnt=-1;
static BOOL        no_rotations=FALSE;
static mxs_vector  obj_offset;
static int         brush_primal;

//////////////////////////////
// "global" current filter/scale/active list for which brushes to draw and how

// default filter is show all, default color is distance based
int editbr_color_mode=brFlag_COLOR_DIST;
int editbr_filter=brFlag_FILTERMASK;

static int brush_color_mode;                    // for use during the frame
static float cur_scale=1.0, cur_lo=0.0;         // for color scaling
static mxs_vector _cur_cam_vec, _cur_cam_pos;   // space to store them
static mxs_vector *cur_cam_vec, *cur_cam_pos;   // pointers, null if not using

static editBrush  *cur_cursor;
static BOOL       isIso=FALSE;

// hot region filter fun
#define MAX_HOTS  32
static int        hot_cnt=0;
static editBrush *hots[MAX_HOTS];

int editbr_filter_time_lo=0, editbr_filter_time_hi=0;
float editbr_filter_size=0.0;
bool renderHilightOnly=FALSE;
bool renderHotsOnly=FALSE;

// set global draw context, color and filters
void brushDrawContext(int filter, int color_mode)
{
   if (color_mode!=-1) editbr_color_mode=color_mode;
   if (filter!=-1) editbr_filter=filter;
}

// MOVE THIS ALL SOMEWHERE ELSE TOO
#define vec_prin(v) (v)->el[0],(v)->el[1],(v)->el[2]

// controls for the fast renderer
static BOOL       fastRender=FALSE; // are we in fastrender (2d) mode
static mxs_vector base, scale;      // upper left of view, scale factor 
static int        scr_x_axis, scr_y_axis;

BOOL fastrendererSetup(int camera, mxs_vector *cam_pos)
{
   mxs_vector scr_unit_x, scr_unit_y; // unit pixel in world space on each axis

   vm_get_camera_axis(camera,&scr_x_axis,&scr_y_axis);
   vm_map_screen_to_world(camera,&base,0,0);
   vm_screen_axes(camera,&scr_unit_x,&scr_unit_y);
   mx_zero_vec(&scale);
   scale.el[scr_x_axis]=1.0/scr_unit_x.el[scr_x_axis];
   scale.el[scr_y_axis]=1.0/scr_unit_y.el[scr_y_axis];

   // @TODO: once we have 6 drawers, pick the correct function pointer here...
   
   return TRUE;
}

#ifdef MOO
// do correct splufty clip coding here... conservative due to line rules...
// @OPTIMIZE: assemblize
static uchar fastrenderClipCode(r3s_point *us)
{
   uchar ccode=CLIP_NONE;
   
   if (us->grp.sx<fix_make(0,0x8000))
      ccode|=CLIP_LEFT;
   else if (us->grp.sx>fix_make(grd_canvas->bm.w-1,0x8000))
      ccode|=CLIP_RIGHT;
   
   if (us->grp.sy<fix_make(0,0x8000))
      ccode|=CLIP_TOP;
   else if (us->grp.sy>fix_make(grd_canvas->bm.h-1,0x8000))
      ccode|=CLIP_BOT;
   
   return ccode;
}
#endif

static uchar fastrenderFloatClipCode(float x, float y)
{
   uchar ccode=CLIP_NONE;
   
   if (x<0.5)
      ccode|=CLIP_LEFT;
   else if (x>(float)(grd_canvas->bm.w-1)-0.5)
      ccode|=CLIP_RIGHT;
   
   if (y<0.5)
      ccode|=CLIP_TOP;
   else if (y>(float)(grd_canvas->bm.h-1)-0.5)
      ccode|=CLIP_BOT;
   
   return ccode;
}

// @OPTIMIZE: do 6 versions of this, function table them
// @OPTIMIZE: assemblize
// given the 2d setup in fastrender, do the 2d axis scale/clip for this point list
void fastrenderTransformBlock(int cnt, r3s_point *view_pts, mxs_vector *pt_list)
{
   int i;

   for (i=0; i<cnt; i++)
   {
      mxs_vector diff;
      mx_sub_vec(&diff,&pt_list[i],&base);

      mx_elmuleq_vec(&diff,&scale);  // 0 relative to up left of window, i guess

      if ((fabs(diff.el[scr_x_axis])>fix_int(FIX_MAX))||
          (fabs(diff.el[scr_y_axis])>fix_int(FIX_MAX)))
         view_pts[i].ccodes=CLIP_ALL;
      else
         view_pts[i].ccodes=fastrenderFloatClipCode(diff.el[scr_x_axis],diff.el[scr_y_axis]);

      view_pts[i].grp.sx=fix_from_float(diff.el[scr_x_axis]);
      view_pts[i].grp.sy=fix_from_float(diff.el[scr_y_axis]);

      r3d_ccodes_or |=view_pts[i].ccodes;
      r3d_ccodes_and&=view_pts[i].ccodes;
   }
}

// @J4FIX: get this out of brinfo.h, clean this shit up
//   maybe have brrend as a new source file, eh?
// setup to draw, uses global context
BOOL brushSetupDraw(int flags, int camera)
{
   float dist, lo=100000.0, hi=0.0;
   mxs_vector tmp, *cam_pos;
   editBrush *us;
   int hIter;

   flags&=brFlag_EDITBR_MASK;  // mask out gedit controls
   vm_get_3d_camera_loc(&cam_pos,NULL);
   cur_cam_vec=cur_cam_pos=NULL; // dont need to do special distance stuff
   brush_color_mode=flags&brFlag_COLOR_MASK;
   if (brush_color_mode==brFlag_COLOR_GLOB)
      brush_color_mode=editbr_color_mode;
   isIso=(flags&brFlag_IsoView)!=0;
   if (flags&brFlag_NO_SELECTION)
      cur_cursor=NULL;
   else
      cur_cursor=blistGet();
   fastRender=FALSE;
   if (isIso&&!vm_get_3d(camera))
      fastRender=fastrendererSetup(camera,cam_pos);  // activate the Fast Renderer
   switch (brush_color_mode)
   {
   case brFlag_COLOR_TIME:
      cur_scale=(float)max(blistCount()-blistGetPos(),blistGetPos());
      cur_lo=0.0;       // scale is max distance from current time
      break;
   case brFlag_COLOR_DIST:
      _cur_cam_vec=*r3_get_forward_slew();   // store off vec
      _cur_cam_pos=*cam_pos;
      if (isIso)
      {                                // set cam vec to the storage
         cur_cam_vec=&_cur_cam_vec;    // so the non-NULL will mean
         cur_cam_pos=&_cur_cam_pos;    // we need to do special distance
      }                                // processing
      us=blistIterStart(&hIter);
      while (us!=NULL)
      {
         mx_sub_vec(&tmp,&us->pos,cam_pos);        // do our own distance
         if (isIso)  
            dist=fabs(mx_dot_vec(&tmp,cur_cam_vec));     // cant use z
         else
            dist=mx_mag_vec(&tmp);                       // can use z
         if (dist<lo) lo=dist;
         if (dist>hi) hi=dist;
         us=blistIterNext(hIter);
      }                    // for now, we ignore lo, so if you are far from
      cur_scale=hi;        // something, it is darker.  if you set cur_lo to lo
      cur_lo=0.0;          // and scale to hi-lo, then you darken the range
      break;               // but it wont get darker as you get far away
   default:                
      cur_scale=1.0;
      cur_lo=0.0;
      break;
   }
   hot_cnt=0;

   if (renderHotsOnly)
   {  // and now, the real fun, the scan hot regions stuff
      us=blistIterStart(&hIter);
      while (us!=NULL)
      {
         if (brushGetType(us)==brType_HOTREGION)
         {
            if (brHot_IsMEONLY(us))
            {
               hots[0]=us;    // if we are a me only
               hot_cnt=1;     // set hots 0 to us, set cnt to 1
               blistIterDone(hIter);
               break;         // and stop looking
            }                 // so we are only hot in the list
            else if (brHot_GetBase(us)==brHot_ACTIVE)
               hots[hot_cnt++]=us;  // add ourselves to current hot list
            if (hot_cnt>=MAX_HOTS)
            {
               Warning(("Too Many Active Hot Regions!!"));
               blistIterDone(hIter);
               return FALSE;
            }
         }
         us=blistIterNext(hIter);
      }
   }
   return TRUE;
}

// @TODO: need to learn about vBrush
// Draw the brush darker if its closest point is far away
int brushSetDrawColor (editBrush *us, r3s_point *p)
{
   int i, lp;
   float val;

   if (us==cur_cursor)        // if we are the cursor, set to white and go
      return brushColors[terrCur];
   switch (brush_color_mode)
   {
   case brFlag_COLOR_NONE:
      return brushColors[terrNorm];
   case brFlag_COLOR_TIME:
      val=(float)abs(blistGetPos()-blistCheck(us));
      break;
   case brFlag_COLOR_DIST: // @J4FIX
      if (cur_cam_vec)        // means we cant look at z since we are Iso View
      {                       // so have to go do the computation based on
         mxs_vector tmp;      // the camera vector
         mx_sub_vec(&tmp,&us->pos,cur_cam_pos);
         val=fabs(mx_dot_vec(&tmp,cur_cam_vec));
      }
      else
      {                          // the z coordinates do indicate depth
         val = 10000.0;          // so just zip through each corner
         for (lp = 0; lp < brush_pt_cnt; lp++)  
            if (p[lp].p.z < val) // and find the closest
               val = p[lp].p.z;
      }
      break;
   }
   if ((val<cur_lo)||(cur_scale==0))  // now actually scale and pick the color
      i=0;                            // underflow, just do zero (max)
   else
      i=(int)((float)NUM_GREY_SHADES*(val-cur_lo)/cur_scale);
   if (i>=NUM_GREY_SHADES) i=NUM_GREY_SHADES-1;
   return greyRange[NUM_GREY_SHADES-i-1];
}

#ifdef PORTAL_CONVERT_USE_DOUBLES
#include <matrixd.h>
#include <mxcvrt.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 
#ifdef DBG_ON
void mp_mxds_vector(char *prefix, mxds_vector *pt)
{
   char buf[256];
   sprintf(buf,"%s: %.14lf, %.14lf, %.14lf\n",prefix,pt->x,pt->y,pt->z);
   mprintf(buf);
}
#endif

static mxds_vector db_world_pts[MAX_PTS_PER_BRUSH];
void brushTerrFancyDoubleSetupNTransform(editBrush *curBrush)
{
   mxs_vector  obj_single_pts[MAX_PTS_PER_BRUSH];
   mxds_vector o_pt, o_offset, angs;
   mxds_matrix o_angmat;
   int         i;
   
   primalQuantizePos(curBrush,&obj_offset);
   if (brushGetType(curBrush)==brType_TERRAIN)
      brush_primal=curBrush->primal_id;
   else
      brush_primal=PRIMAL_CUBE_IDX;
   primalBr_SetFastUnsafePrimal(brush_primal);
   // need the doubles here...?? would be nice for angles on primal craziness... argh, though
   brush_pt_cnt=primalRawFull(brush_primal,&curBrush->sz,obj_single_pts);
   mx_vec_d_from_s(&o_offset,&obj_offset);
   primalQuantizeAng(&curBrush->ang,&angs);
//   mprintf("Took %x %x %x..\n",curBrush->ang.el[0],curBrush->ang.el[1],curBrush->ang.el[2]);
//   mp_mxds_vector("got  ",&angs);
   mxd_rad2mat(&o_angmat,&angs);

   for (i=0; i<brush_pt_cnt; i++)
   {
      mx_vec_d_from_s(&o_pt,&obj_single_pts[i]);
//      mp_mxds_vector("raw  ",&o_pt);
      mxd_mat_mul_vec(&db_world_pts[i],&o_angmat,&o_pt);
      mxd_addeq_vec(&db_world_pts[i],&o_offset);
      // oh, and here... oh, very very sad
      if (curBrush->grid.grid_enabled)
      {
         mx_vec_s_from_d(&world_pts[i],&db_world_pts[i]);      
         gedit_vertex_snap(&curBrush->grid,&world_pts[i],&world_pts[i]);
         mx_vec_d_from_s(&db_world_pts[i],&world_pts[i]);
      }
//      mp_mxds_vector("real ",&db_world_pts[i]);
   }
}
#endif

// you should setup obj_offset yourself prior to calling this....
void brushGenericPrimalSetup(int primal_id, mxs_vector *scale, mxs_angvec *ang)
{
   brush_primal=primal_id;
   primalBr_SetFastUnsafePrimal(primal_id);
   brush_pt_cnt=primalRawFull(primal_id,scale,obj_pts);

   no_rotations=((ang->tx==0)&&(ang->ty==0)&&(ang->tz==0));

   if (!no_rotations)
      r3_start_object_angles(&obj_offset,ang,R3_DEFANG);
   else if (!fastRender)
      r3_start_object(&obj_offset);  // this is really doing the obj_offset thing, secretly
}

// sets up points for a terrain brush
void brushTerrSetup(editBrush *curBrush)
{
   primalQuantizePos(curBrush,&obj_offset);
   brushGenericPrimalSetup(curBrush->primal_id,&curBrush->sz,&curBrush->ang);
}

// special for "cube" things, such as hotregions, water, so on
void brushCubeSetup(editBrush *curBrush)
{
   obj_offset = curBrush->pos;
   brushGenericPrimalSetup(PRIMAL_CUBE_IDX,&curBrush->sz,&curBrush->ang);
}

// what to scale rendering sizes by for lights
#define lightScale (0.007)  // was 0.025
void brushLightSetup(editBrush *curBrush)
{
   mxs_vector mono_scale_vec;
   mono_scale_vec.x=mono_scale_vec.y=mono_scale_vec.z=brLight_Bright(curBrush)*lightScale;
   obj_offset = curBrush->pos;
   brushGenericPrimalSetup(PRIMAL_LIGHT_IDX,&mono_scale_vec,&curBrush->ang);
}

void brushLineSetup(mxs_vector *p1, mxs_vector *p2)
{
   obj_pts[0]=*p1;
   if (p2)
   {
      obj_pts[1]=*p2;
      brush_pt_cnt=2;
   }
   else
      brush_pt_cnt=1;      
   no_rotations=TRUE;
   obj_offset.x=obj_offset.y=obj_offset.z=0;
   if (!fastRender)
      r3_start_object(&obj_offset);
}

static BOOL pt_on_screen(r3s_point *p)
{
   if (isIso&&!fastRender)    // probably should clip verse the canvas or something
      return TRUE;
   return p->ccodes==0;
}

// hacks for now for the whole line_draw callback thing...
static void line_2d_clip(r3s_point *p1, r3s_point *p2)
{
   gr_fix_line(p1->grp.sx,p1->grp.sy,p2->grp.sx,p2->grp.sy);
}

static void line_2d_unclip(r3s_point *p1, r3s_point *p2)
{
   gr_fix_uline(p1->grp.sx,p1->grp.sy,p2->grp.sx,p2->grp.sy);
}

static void line_3d(r3s_point *p1, r3s_point *p2)
{
   r3_draw_line(p1,p2);
}

// @TODO: add a "show all vGroups" mode, which just does brSelect_Group()!=0
static int _get_color_for_brush(editBrush *curBrush)
{
   BOOL isVb=vBrush_inCurGroup(curBrush);
   int col;

   //  Stuff for AI colouring
   //
   BOOL isAI = FALSE;
   ObjID rootAI;
   IObjectSystem* objSys;
   ITraitManager* traitMan;

   if ((curBrush!=cur_cursor)&&(isActiveHighlight(curBrush->br_id)))
      return brushColors[highlight1];   // someday want an array here of colors

   switch (brushGetType(curBrush))
   {
      case brType_HOTREGION:
         if (curBrush==cur_cursor)                       col=brushColors[areaCur];
         else if (isVb&&cur_cursor)                      col=brushColors[areaMulti];
         else if (brHot_IsMEONLY(curBrush))              col=brushColors[areaMeOnly];
         else if (brHot_GetBase(curBrush)==brHot_ACTIVE) col=brushColors[areaActive];
         else                                            col=brushColors[areaNorm];
         break;
      case brType_TERRAIN:
         if (curBrush==cur_cursor)                       col=brushColors[terrCur];
         else if (isVb&&cur_cursor)                      col=brushColors[terrMulti];
         else                                            col=brushSetDrawColor(curBrush,brush_pts);
         break;
      case brType_OBJECT:
         if (brObjProp_getLightLevel(brObj_ID(curBrush))<0.0)
         {
            if (curBrush==cur_cursor)                       col=brushColors[objCur];
            else if (isVb&&cur_cursor)                      col=brushColors[objMulti];
            else
            {
                if (config_is_defined ("hens_changes"))
                {
                    //	If object is an AI, make it a different colour
                    //
                    objSys = AppGetObj (IObjectSystem);
                    rootAI = IObjectSystem_GetObjectNamed(objSys, "AIs");
                    SafeRelease (objSys);
                    
                    if (rootAI != OBJ_NULL)
                    {
                        traitMan = AppGetObj (ITraitManager);
                        isAI = ITraitManager_ObjHasDonor(traitMan, brObj_ID(curBrush), rootAI);
                        SafeRelease (traitMan);
                        if (isAI)
                        {
                            col=brushColors[roomCur];	//	This happens to be purple
                            break;
                        }
                    }
                }
                col=brushColors[objNorm];
            }
            break;
         }  // otherwise fall though and treat it like a light....
      case brType_LIGHT:
         if (curBrush==cur_cursor)                       col=brushColors[lightCur];
         else if (isVb&&cur_cursor)                      col=brushColors[lightMulti];
         else                                            col=brushColors[lightNorm];
         break;
      case brType_FLOW:
         if (curBrush==cur_cursor)                       col=brushColors[flowCur];
         else if (isVb&&cur_cursor)                      col=brushColors[flowMulti];
         else                                            col=brushColors[flowNorm];
         break;
      case brType_ROOM:
         if (curBrush==cur_cursor)                       col=brushColors[roomCur];
         else if (isVb&&cur_cursor)                      col=brushColors[roomMulti];
         else                                            col=brushColors[roomNorm];
         break;
      default:
         col=Rand()&0xff;
         break;
   }
   return col;
}

#define POINT_SIZE 5

// should have a "get line draw" call

// actually draw the terrain brush, after setup has been called
void brushPrimalRender(editBrush *curBrush)
{
   void (*line_draw)(r3s_point *p1, r3s_point *p2);
   int edge_cnt=primFastUnsafe_EdgeCnt();
   r3s_point *p=brush_pts;
   int i, col;

   if (r3d_ccodes_and)
      return;

   col=_get_color_for_brush(curBrush);
   gr_set_fcolor(col);  // kind of super annoying to have to do both of these everywhere
   r3_set_color(col);   // does this set fcolor, if not, set that here too
   
   if (r3d_ccodes_or)  // @OPTIMIZE: inline all of this, or assemblize it?
      if (fastRender)
         line_draw=line_2d_clip;
      else
         line_draw=line_3d;
   else
      line_draw=line_2d_unclip;

   for (i=0; i<edge_cnt; i++)     // actually draw the brush
   {
//#define LOCAL_HACK
#ifdef LOCAL_HACK
      if (brSelect_Flag(curBrush)&brSelect_EDGE)
         if (i!=brSelect_Edge(curBrush))
            continue;
         else
            mprintf("Use %d and %d\n",primFastUnsafe_EdgePt(i,0),primFastUnsafe_EdgePt(i,1));
#endif
      if ((p[primFastUnsafe_EdgePt(i,0)].ccodes!=CLIP_ALL)&&
          (p[primFastUnsafe_EdgePt(i,1)].ccodes!=CLIP_ALL))
         (*line_draw)(&p[primFastUnsafe_EdgePt(i,0)],&p[primFastUnsafe_EdgePt(i,1)]);
   }

   // only HotRegions and Terrain can have any complex selections on them
   if ((brushGetType(curBrush)!=brType_HOTREGION)&&
       (brushGetType(curBrush)!=brType_TERRAIN))
      return;

   if (curBrush==cur_cursor)
   {
      r3_set_color(brushColors[terrFace]); gr_set_fcolor(brushColors[terrFace]);
      if (brSelect_Flag(curBrush)&brSelect_COMPLEX)
      {  // all complex brush (edge or points here)... test for now to be safe
         if (brSelect_Flag(curBrush)&brSelect_EDGE)
            (*line_draw)(&p[primFastUnsafe_EdgePt(brSelect_Edge(curBrush),0)],
                         &p[primFastUnsafe_EdgePt(brSelect_Edge(curBrush),1)]);
         else     // point case - for now, we know we are a cube
         {
            int pid=brSelect_Point(curBrush);
            if (pt_on_screen(&p[pid]))
               for (i=0; i<POINT_SIZE*POINT_SIZE; i++)
               {
                  grs_point tmp=p[pid].grp;
                  tmp.sx+=fix_make(((i%POINT_SIZE)-((POINT_SIZE-1)/2)),0);
                  tmp.sy+=fix_make(((i/POINT_SIZE)%POINT_SIZE)-((POINT_SIZE-1)/2),0);
                  gr_draw_point(brushColors[terrFace],(g2s_point *)&tmp);
               }
         }
      }  // in simple case, we either just draw, or draw as us
      else if (curBrush->cur_face!=-1)
      {  // have to show which the current face is
         int cur_edge_loop=0, edge_idx;
         primFastUnsafe_FaceEdgeSetup(curBrush->cur_face);
         while ((edge_idx=primFastUnsafe_FaceEdge(cur_edge_loop++))!=-1)
            (*line_draw)(&p[primFastUnsafe_EdgePt(edge_idx,0)],
                         &p[primFastUnsafe_EdgePt(edge_idx,1)]);
      }
   }
}

// dorky render a line code
// @OPTIMIZE: inline all of this, or assemblize it?
static BOOL brushLineRender(int color)
{
   r3s_point *p=brush_pts;

   if (r3d_ccodes_and)
      return FALSE;

   gr_set_fcolor(color);  // kind of super annoying to have to do both of these everywhere

   if (brush_pt_cnt==1)
      gr_point(p[0].grp.sx,p[0].grp.sy);
   else
      if (r3d_ccodes_or)     
         if (fastRender)
            line_2d_clip(&p[0],&p[1]);
         else
         {
            r3_set_color(color);
            line_3d(&p[0],&p[1]);
         }
      else
         line_2d_unclip(&p[0],&p[1]);
   return TRUE;
}

// starts a block, moves world points (world_pts) to view space (brush_pts)
void _brushWorldToView(void)
{
   r3d_ccodes_or=r3d_ccodes_and=0;
   if (!fastRender)
   {
      r3_start_block();      
      r3_transform_block(brush_pt_cnt,brush_pts,world_pts);
      if (isIso)
         r3d_ccodes_or|=CLIP_ALL; // for now, since we dont clip code iso right
   }
   else
      fastrenderTransformBlock(brush_pt_cnt,brush_pts,world_pts);
}

// moves the presetup points (obj_pts) to world space (world_pts)
// Unrolled to try and speed it up...
void _brushTransformToWorld(editBrush *br)
{
   int i;

   if (no_rotations&&fastRender)
      if (br->grid.grid_enabled)
         for (i=0; i<brush_pt_cnt; i++)
         {
            mx_add_vec(&world_pts[i],&obj_pts[i],&obj_offset);
            gedit_vertex_snap(&br->grid,&world_pts[i],&world_pts[i]);
         }
      else
         for (i=0; i<brush_pt_cnt; i++)         
            mx_add_vec(&world_pts[i],&obj_pts[i],&obj_offset);         
   else
   {
      if (br->grid.grid_enabled)
         for (i=0; i<brush_pt_cnt; i++)
         {
            r3_transform_o2w(&world_pts[i],&obj_pts[i]);
            gedit_vertex_snap(&br->grid,&world_pts[i],&world_pts[i]);
         }
      else
         for (i=0; i<brush_pt_cnt; i++)
            r3_transform_o2w(&world_pts[i],&obj_pts[i]);
      r3_end_object();
   }
}

// really just ends the block, for now
void _brushCleanandFinish(void)
{
   if (!fastRender)   
      r3_end_block();
}

///////////
// click distance code

#define INTERVAL_EPSILON (0.01)

// is val between unordered points e1 and e2
BOOL check_interval(float val, float e1, float e2)
{  // make sure we are in the interval... im sure this can be less dumb
   // @OPTIMIZE: it seems like you could just do some tests and muls and check sign
   if (e2>e1)  
    { if ((e1>val)||(e2<val)) return FALSE; }
   else        
    { if ((e1<val)||(e2>val)) return FALSE; }

#ifdef WITH_INTERVAL      
    { if ((e1>val+INTERVAL_EPSILON)||(e2<val-INTERVAL_EPSILON)) return FALSE; }
   else        // it seems like you could just do some tests and muls and check sign
    { if ((e1<val-INTERVAL_EPSILON)||(e2>val+INTERVAL_EPSILON)) return FALSE; }
#endif
   
   return TRUE;
}

// @OPTIMIZE: do a less braindead algorthim, and a less braindead calling convention
// for now, just use cramers rule, solve the system of equations
// then, check either coordinate to make sure we are "in" the line
// then compute distance squared from x0,y0 and x,y
float solve_2d_point_to_line(float x0, float y0, float x1, float y1, float x2, float y2)
{
   static float coeff[6]={0,-1,0,0,-1,0};
   float slope, invslope, x, y, detA;

   if (fabs(x2-x1)<INTERVAL_EPSILON)
      if (check_interval(y0,y1,y2))
         return (x0-x1)*(x0-x1);
      else
         return DISTANCE_INF;
   if (fabs(y2-y1)<INTERVAL_EPSILON)
      if (check_interval(x0,x1,x2))
         return (y0-y1)*(y0-y1);
      else
         return DISTANCE_INF;   
   slope=(y2-y1)/(x2-x1);  // rise over run, woo woo-woo
   invslope=-1.0/slope;
   coeff[0]=slope;    /* -1 */ coeff[2]=slope*x1-y1;     /*    m x - y =     m x1 - y1 */
   coeff[3]=invslope; /* -1 */ coeff[5]=invslope*x0-y0;  /*-(1/m)x - y = -(1/m)x0 - y0 */
   detA=-coeff[0]+coeff[3];  // since i know coeff[1] and [4] are always -1
   x=-coeff[2]+coeff[5];
   x/=detA;

   if (!check_interval(x,x1,x2))
      return DISTANCE_INF;         

   y=coeff[0]*coeff[5]-coeff[3]*coeff[2];
   y/=detA;

   return (x-x0)*(x-x0)+(y-y0)*(y-y0);
}

// get a float from a fix
#define get_float(fixv) (((float)fixv)/65536.0)

// so you can see what the function thought was the best fit
static int best_pt, best_edge;

//#define DBG_CLOSE_PTS
#ifdef DBG_CLOSE_PTS
#define cp_mprint(x) mprintf x
#else
#define cp_mprint(x)
#endif

// write some cool trivial reject based on largest axis plus center?

// check for nearest point
float findClosestPt(editBrush *curBrush, int x, int y)
{
   r3s_point *p=&brush_pts[0];
   float best_dist_sqr=DISTANCE_INF, dist;   // dist is for this computation
   int i, num_edge=primFastUnsafe_EdgeCnt();

   if (r3d_ccodes_and) return best_dist_sqr;
   
   best_pt=best_edge=-1;
   for (i=0; i<brush_pt_cnt; i++)   // first, we go through all the points
      if (pt_on_screen(&p[i]))
      {
         float dx=get_float(p[i].grp.sx)-x, dy=get_float(p[i].grp.sy)-y;
         dist=dx*dx+dy*dy;
         if (dist<best_dist_sqr)
         {
            best_dist_sqr=dist;
            best_pt=i;
            cp_mprint(("New best %d for brush %x (dist %g)\n",i,curBrush,dist));
         }
         else
            cp_mprint(("         %d further for brush %x\n",i,curBrush));
      }
      else cp_mprint(("Discard pt %d for brush %x\n",i,curBrush));

   // points are more interesting, so lie about the distance
   best_dist_sqr/=4;

   // next, the edges - for now i ignore lights, a more satisfying solution would be good, eh?
//   if (brushGetType(curBrush)!=brType_LIGHT)
      for (i=0; i<num_edge; i++)
      {
         int p1=primFastUnsafe_EdgePt(i,0), p2=primFastUnsafe_EdgePt(i,1);
         if (pt_on_screen(&p[p1])&&pt_on_screen(&p[p2]))
         {
            dist=solve_2d_point_to_line((float)x,(float)y,
                                        get_float(p[p1].grp.sx), get_float(p[p1].grp.sy),
                                        get_float(p[p2].grp.sx), get_float(p[p2].grp.sy));
            if (dist<best_dist_sqr)
            {
               best_dist_sqr=dist;
               best_pt=-1;
               best_edge=i;
               cp_mprint(("New edge %d (%d %d) for brush %x (dist %g)\n",i,p1,p2,curBrush,dist));
            }
            else
               cp_mprint(("    edge %d (%d %d) still for brush %x\n",i,p1,p2,curBrush));
            
         }
         else cp_mprint(("Discard pair %d %d for brush %x\n",p1,p2,curBrush));
      }
   
   return best_dist_sqr;
}

#pragma disable_message(202)
void brushGrowExtents(editBrush *curBrush, mxs_vector *bounds)
{
   int i,j;
   for (i=0; i<brush_pt_cnt; i++)
      for (j=0; j<3; j++)
      {
         if (world_pts[i].el[j]<bounds[0].el[j])
            bounds[0].el[j]=world_pts[i].el[j];
         if (world_pts[i].el[j]>bounds[1].el[j])
            bounds[1].el[j]=world_pts[i].el[j];
      }
}
#pragma enable_message(202)

// Basically, first index eliminates an number, and the 
// second index gives the other number
const int index_lookup[3][3] = 
{ { -1,  2,  1},
  {  2, -1,  0},
  {  1,  0, -1} };

// Ya down with OBB yeah you know me
//
// From "Fast Overlap Test for OBBs", by ???, courtesy of Doug
bool brushOBBIntersect(editBrush *b1, editBrush *b2)
{
   mxs_vector T;           // Translation vector between brushes
   mxs_vector L;           // Sparating Axis
   mxs_real T_L;           // Length of projection of T onto L
   mxs_angvec ang;         // Rotation between brushes
   mxs_matrix M, M_abs;    // Rotation matrix between brushes, and 
                           //  absolute value version
   mxs_matrix M_1, M_2;    // Rotation matrices for each brush
   mxs_real   sum;         // Accumulation of summation elements
   mxs_vector A[3], B[3];  // Box-aligned unit vectors
   mxs_vector u_temp[3];   // XYZ unit vectors 
   int i, j, k;

   // Calculate T vector and M matrix
   mx_sub_vec(&T, &b1->pos, &b2->pos); 
   for (i=0; i<3; ++i)
      ang.el[i] = b1->ang.el[i] - b2->ang.el[i];
   mx_ang2mat(&M, &ang);

   // Create unit vectors
   for (i=0; i<3; ++i)
      mx_unit_vec(&(u_temp[i]), i);

   // Rotate for OBB-aligned unit vectors
   mx_ang2mat(&M_1, &(b1->ang));
   for (i=0; i<3; ++i) 
      mx_mat_mul_vec(&(A[i]), &M_1, &(u_temp[i]));
   mx_ang2mat(&M_2, &(b2->ang));
   for (i=0; i<3; ++i) 
      mx_mat_mul_vec(&(B[i]), &M_2, &(u_temp[i]));

   // Calculate absolute valued M matrix
   for (i=0; i<9; ++i) 
      M_abs.el[i] = (M.el[i] > 0) ? M.el[i] : -M.el[i];

   // Use first brush's normals for separating axis generation
   for (i=0; i<3; ++i) {

      // Calculate distance between projected centers
      T_L = mx_dot_vec(&T, &(A[i]));

      // Calculate length of maximum radius of brush, projected
      sum = b1->sz.el[i];
      for (j=0; j<3; ++j)
         sum += b2->sz.el[j] * M_abs.vec[i].el[j];

      if (sum < T_L)
         return FALSE;
   }

   // Use second brush's normals for separating axis generation
   for (i=0; i<3; ++i) {
   
      // Calculate distance between projected centers
      T_L = mx_dot_vec(&T, &(B[i]));

      // Calculate length of maximum radius of brush, projected
      sum = b2->sz.el[i];
      for (j=0; j<3; ++j)
         sum += b1->sz.el[j] * M_abs.vec[j].el[i];

      if (sum < T_L)
         return FALSE;
   }

   // Use edge-pairs for separating axis generation
   for (i=0; i<3; ++i) {
      for (j=0; j<3; ++j) {
         
         // @OPTIMIZE: Somehow this reduces to 2 mults and a sub
         // Calculate distance between projected centers
         mx_cross_vec(&L, &(A[i]), &(B[j]));
         T_L = fabs(mx_dot_vec(&T, &L));

         // Calculate length of maximum radius of brush, projected
         sum = 0;
         for (k=0; k<3; k++) {
            if (k == i)  
               continue;
            sum += b1->sz.el[k] * M_abs.vec[index_lookup[i][k]].el[j];
         }

         for (k=0; k<3; k++) {
            if (k == j)
               continue;
            sum += b2->sz.el[k] * M_abs.vec[i].el[index_lookup[j][k]];
         }
      
         // If radius is smaller than the distance from center to center,
         //  then they must not intersect
         if (sum < T_L)
            return FALSE;
      }
   }

   // All separating axis tests fell through, must intersect
   return TRUE;
}


bool pointOBBIntersect(editBrush *point, editBrush *brush)
{
   mxs_vector u, norm;     // Pre-rotated and rotated normals
   mxs_matrix R;           // Rotation matrix of brush
   mxs_vector pt;          // Point on each plane of brush
   mxs_vector vec;         // Vector from point on plane to point
   int i;

   // Find rotation matrix for brush orientation
   mx_ang2mat(&R, &(brush->ang));

   // Iterate through each face of the brush
   for (i=0; i<6; ++i) {

      // Generate unit vector
      mx_unit_vec(&u, i%3);
      if (i >= 3)
         mx_scaleeq_vec(&u, -1);

      // Rotate to brush orientation
      mx_mat_mul_vec(&norm, &R, &u);

      // Find point on plane of face 
      mx_scale_add_vec(&pt, &(brush->pos), &norm, brush->sz.el[i%3]);

      // Check if given point is in front of face (outside brush)
      mx_sub_vec(&vec, &(point->pos), &pt);
      if (mx_dot_vec(&vec, &norm) > 0.0)
         return FALSE;
   }

   return TRUE;
}

BOOL brrendTypeFilterActive(void)
{
   return (editbr_filter&brFlag_FILTERMASK)!=brFlag_FILTERMASK;
}

BOOL brrendCheckTypeFilter(editBrush *curBrush)
{
   int filter_type;
   if (brushGetType(curBrush)==brType_OBJECT)
      filter_type=brObjProp_getFilterType(brObj_ID(curBrush));
   else
      filter_type=brFlag_GetFilterType(brushGetType(curBrush));
   return (filter_type&editbr_filter)!=0;
}

// Now allows rotation and does proper OBB intersection checking
bool applyFilters(editBrush *curBrush)
{
   int i;

   if (curBrush==NULL)       // we are too stupid
      return FALSE;
   if (curBrush==cur_cursor) // hey, its us, draw
      return TRUE;

   if (!brrendCheckTypeFilter(curBrush))
      return FALSE;
   if (renderHilightOnly&&!isActiveHighlight(curBrush->br_id))
      return FALSE;
   if (brushGetType(curBrush)==brType_HOTREGION) 
      return TRUE;           // for now, we always draw hotregions regardless of time/space
      
   // temporal filters first
   if (editbr_filter_time_hi||editbr_filter_time_lo)
   {
      int tm=blistCheck(curBrush);
      if (editbr_filter_time_lo && (tm<editbr_filter_time_lo))
         return FALSE;
      if (editbr_filter_time_hi && (tm>editbr_filter_time_hi))
         return FALSE;
   }

   if ((editbr_filter_size>0.01)&&(brushGetType(curBrush)==brType_TERRAIN)) 
      if ((curBrush->sz.x<editbr_filter_size)||
          (curBrush->sz.y<editbr_filter_size)||
          (curBrush->sz.z<editbr_filter_size))
         return FALSE;

   // and now hot region filters, with real OBB checking
   if (hot_cnt==0) return TRUE;
   for (i=0; i<hot_cnt; i++)
   {
      if (brushGetType(curBrush) == brType_LIGHT)
      {
         if (pointOBBIntersect(curBrush, hots[i]))
            return TRUE;
      }
      else if (brushOBBIntersect(curBrush, hots[i]))
         return TRUE;
   }

   return FALSE;
}

// dispatches to setup draw and clean based on brush type
bool brushDraw(editBrush *curBrush)
{
   if (!applyFilters(curBrush))
      return FALSE;
   switch (brushGetType(curBrush))
   {
   case brType_TERRAIN:
      brushTerrSetup(curBrush);
      break;
   case brType_HOTREGION:
   case brType_OBJECT:
   case brType_FLOW:
   case brType_ROOM:
      brushCubeSetup(curBrush);
      break;
   case brType_LIGHT:
      brushLightSetup(curBrush);
      break;
   default:
      return FALSE;
   }
   _brushTransformToWorld(curBrush);
   _brushWorldToView();
   brushPrimalRender(curBrush);
   _brushCleanandFinish();
   return TRUE;
}

// dispatches based on brush type, 
float brushClickCheck(editBrush *curBrush, int x, int y)
{
   float best_dist=DISTANCE_INF;
   if (!applyFilters(curBrush))
      return best_dist;
   switch (brushGetType(curBrush))
   {
   case brType_TERRAIN:
      brushTerrSetup(curBrush);
      break;
   case brType_HOTREGION:
   case brType_OBJECT:
   case brType_FLOW:      
   case brType_ROOM:
      brushCubeSetup(curBrush);
      break;
   case brType_LIGHT:
      brushLightSetup(curBrush);
      break;
   default:
      return INT_MAX;
   }
   _brushTransformToWorld(curBrush);
   _brushWorldToView();
   best_dist=findClosestPt(curBrush,x,y);
   _brushCleanandFinish();
   return best_dist;
}

static editBrush dummy_br;  // all zeros, so no grid enabled
BOOL brushLineDraw(mxs_vector *p1, mxs_vector *p2, int color)
{
   BOOL rv;
   // apply point filter here
   brushLineSetup(p1,p2);
   _brushTransformToWorld(&dummy_br);
   _brushWorldToView();
   rv=brushLineRender(color);
   _brushCleanandFinish();
   return rv; // returns FALSE if triv reject
}

float brushLineCheck(mxs_vector *p1, mxs_vector *p2, int x, int y)
{
   float best_dist=DISTANCE_INF;   
   // apply point filter here
   brushLineSetup(p1,p2);
   _brushTransformToWorld(&dummy_br);
   _brushWorldToView();
   best_dist=findClosestPt(&dummy_br,x,y);   
   _brushCleanandFinish();
   return best_dist;
}

BOOL brushSelectFancy(editBrush *curBrush, int x, int y)
{
   if (brushGetType(curBrush)!=brType_TERRAIN)
      return FALSE;
   if (brushClickCheck(curBrush,x,y)==INT_MAX)
   {
      Warning(("We were selected fancy, but no love\n"));
      return FALSE;
   }
   if (best_pt!=-1)
   {
      brSelect_Flag(curBrush)&=~brSelect_EDGE;
      curBrush->point=best_pt;
   }
   else if (best_edge!=-1)
   {
      brSelect_Flag(curBrush)|=brSelect_EDGE;
      curBrush->edge=best_edge;
   }
   else
   {
      Warning(("SelectFancy: Somehow no best point or edge\n"));
      return FALSE;
   }
   brSelect_Flag(curBrush)|=brSelect_COMPLEX;
   return TRUE;
}

BOOL brushCheckExtents(editBrush *curBrush, mxs_vector *bounds)
{
   if (!applyFilters(curBrush))
      return FALSE;
   switch (brushGetType(curBrush))
   {
   case brType_HOTREGION:
      if ((!brHot_IsMEONLY(curBrush))&&(brHot_GetBase(curBrush)==brHot_INACTIVE))
         return FALSE;
   case brType_OBJECT:
   case brType_FLOW:
   case brType_ROOM:
      brushCubeSetup(curBrush);
      break;
   case brType_TERRAIN:
      brushTerrSetup(curBrush);
      break;
   case brType_LIGHT:
      brushLightSetup(curBrush);
      break;
   default:
      return FALSE;
   }
   _brushTransformToWorld(curBrush);
   brushGrowExtents(curBrush,bounds);
   return TRUE;
}

// transform a brush to world space by itself
mxs_vector *brushBuildSolo(editBrush *us)
{
   r3_start_frame();
   brushTerrSetup(us);
   _brushTransformToWorld(us);
   r3_end_frame();
   return world_pts;
}

/// argh, what to do for fancy primals
static mxs_vector cube_src_uv[6][2] =
 { {  { 0, 1, 0 }, { 0, 0,-1 } },
   {  {-1, 0, 0 }, { 0, 0,-1 } },
   {  { 0,-1, 0 }, { 0, 0,-1 } },
   {  { 1, 0, 0 }, { 0, 0,-1 } },
   {  { 1, 0, 0 }, { 0, 1, 0 } },
   {  { 1, 0, 0 }, { 0,-1, 0 } } };

static mxs_vector wedge_src_uv[5][2] = 
{
   {{0,-1,1}, {-1,0,0}},
   {{1,0,0}, {0,1,0}},
   {{1,0,0}, {0,0,-1}},
   {{0,0,1}, {0,1,0}},
   {{0,-1,0,}, {0,0,-1}},
//   {{0,0,1}, {0,1,-1}},
//   {{0,-1,1}, {0,0,-1}},
};

// externed in gedit.c, of course
bool get_uv_align(editBrush *br, int face, mxs_vector *u, mxs_vector *v)
{
   //   if (br->primal_id!=1) return FALSE;  // check for cube somehow???
   r3_start_frame();
   fastRender=FALSE;
   brushTerrSetup(br);   // this is actually totally broken - if we are fastRenderer/norotations we lose
   if (config_is_defined("old_wedge_align"))
   {
      r3_rotate_o2w(u, &cube_src_uv[face][0]);
      r3_rotate_o2w(v, &cube_src_uv[face][1]);
   }
   else
   {
      switch (br->primal_id)
      {
      case PRIMAL_WEDGE_IDX:
         if (face < 5)
         {
            r3_rotate_o2w(u, &wedge_src_uv[face][0]);
            r3_rotate_o2w(v, &wedge_src_uv[face][1]);
         }
         break;

      default:
         if (face < 6)
         {
            r3_rotate_o2w(u, &cube_src_uv[face][0]);
            r3_rotate_o2w(v, &cube_src_uv[face][1]);
         }
         break;
      }
   }

   r3_end_object();
   r3_end_frame();
   return TRUE;
}

// for now we brutally cheat and assume old hotregion contexts and
//   brushSetupDraw data is good
// in real life, i suppose we should not do that, oh well
void brushRunOnActive(void (*cback)(editBrush *me))
{
   editBrush *us, *tmp;
   int hIter;
   brushSetupDraw(brFlag_COLOR_NONE,NULL);
   r3_start_frame();
   us=blistIterStart(&hIter);
   while (us)
   {
      tmp=us;
      us=blistIterNext(hIter);
      if (applyFilters(tmp))   // if we is in the scene
         (*cback)(tmp);        //   rock us
   }
   r3_end_frame();
}

// maybe really should have its own local context?
void brushConvertStart(void)
{
   brushSetupDraw(brFlag_COLOR_NONE,NULL);
   r3_start_frame();
}

void brushConvertEnd(void)
{
   r3_end_frame();
}

BOOL brushConvertTest(editBrush *br)
{
   return applyFilters(br);
}

// why arent these in a header file?  hello? sean? hello?
extern void *PortalMakeEdge(BspVertex *a, BspVertex *b);
extern void *PortalMakePolyhedron(void);
extern void *PortalMakePolygon(void *ph);
extern void *PortalAddPolygonEdge(void *poly, void *edge, void *old_edge);

bool passive_hotregions=FALSE;

// are we part of the deal (tm)
static BOOL validHotRegion(editBrush *br)
{
   int i;
   if (passive_hotregions) return FALSE;
   if (hot_cnt==0) return FALSE;
   if (brushGetType(br)!=brType_HOTREGION)
      return FALSE;
   for (i=0; i<hot_cnt; i++)
      if (hots[i]==br)
         return TRUE;
   return FALSE;
}

// i hate this
// convert from internal format to newer CSG format
void *brushConvertPortal(editBrush *eb)
{
   int edge_cnt, face_cnt, i;          // temps for edge and face cnt, loop var
   BspVertex pts[MAX_PRIMAL_PTS];      // should we malloc this stuff, as opposed to putting it on the stack?
   void *first_usr[MAX_PRIMAL_EDGES];  // keep track of first user in poly of this edge, since CSG database is stupid 
   void *poly_edge[MAX_PRIMAL_EDGES];  // get the PolyEdge data from the CSG database
   void *ph;

   // do type testing here... active hotregion, other wackiness
   if (!((brushGetType(eb)==brType_TERRAIN)||validHotRegion(eb)))
      return NULL;

   if ((eb->sz.x<=0)||(eb->sz.y<=0)||(eb->sz.z<=0)) return NULL;
   if (!applyFilters(eb)) return NULL;

#ifdef PORTAL_CONVERT_USE_DOUBLES
   brushTerrFancyDoubleSetupNTransform(eb);
   for (i=0; i<brush_pt_cnt; i++)
    { pts[i].x=db_world_pts[i].x; pts[i].y=db_world_pts[i].y; pts[i].z=db_world_pts[i].z; }
#else   
   brushTerrSetup(eb);
   _brushTransformToWorld(eb);
   for (i=0; i<brush_pt_cnt; i++)
    { pts[i].x=world_pts[i].x; pts[i].y=world_pts[i].y; pts[i].z=world_pts[i].z; }
#endif

   edge_cnt=primFastUnsafe_EdgeCnt();
   face_cnt=primFastUnsafe_FaceCnt();
   
   memset(first_usr,0,sizeof(int)*edge_cnt);  // first_usr's all start at 0
   for (i=0; i<edge_cnt; i++)   // go setup all the inital edges
      poly_edge[i]=PortalMakeEdge(&pts[primFastUnsafe_EdgePt(i,0)],
                                  &pts[primFastUnsafe_EdgePt(i,1)]);
         
   ph = PortalMakePolyhedron();
   for (i=0; i<face_cnt; i++)
   {  // generate the polyhedron
      int cur_edge_loop=0, edge_idx;
      void *face = PortalMakePolygon(ph);
      primFastUnsafe_FaceEdgeSetup(i);
      while ((edge_idx=primFastUnsafe_FaceEdge(cur_edge_loop++))!=-1)
      {
         void *new_edge_user=PortalAddPolygonEdge(face, poly_edge[edge_idx], first_usr[edge_idx]);
         if (first_usr[edge_idx]==0)
            first_usr[edge_idx]=new_edge_user;
      }
   }
   
   return ph;
}
// $Header: r:/t2repos/thief2/src/editor/brrend.h,v 1.11 2000/01/29 13:11:18 adurant Exp $
// brush rendering controls
#pragma once

#ifndef __BRREND_H
#define __BRREND_H

#include <matrixs.h>
#include <editbrs.h>

// flags, defines, misc protos for per frame setup sort of stuff

// for color coding
#define brFlag_COLOR_GLOB     0     // use the global mask
#define brFlag_COLOR_NONE     1
#define brFlag_COLOR_DIST     2
#define brFlag_COLOR_TIME     3
#define brFlag_COLOR_MASK     3

#define brFlag_HotOnly        4
#define brFlag_IsoView        8

#define brFlag_FILTERSHIFT   (4)
#define brFlag_FILTERMASK    (0xFF<<brFlag_FILTERSHIFT)
#define brFlag_FILTER_TERR   (0x10<<brType_TERRAIN)
#define brFlag_FILTER_LIGHT  (0x10<<brType_LIGHT)
#define brFlag_FILTER_AREA   (0x10<<brType_HOTREGION)
#define brFlag_FILTER_OBJ    (0x10<<brType_OBJECT)
#define brFlag_FILTER_FLOW   (0x10<<brType_FLOW)
#define brFlag_FILTER_ROOM   (0x10<<brType_ROOM)

#define brFlag_GetFilterType(t) (1<<((t)+brFlag_FILTERSHIFT))

#define brFlag_NO_SELECTION  (0x1000)

#define brFlag_EDITBR_MASK   (0xffff)
// bottom 16 bits are brFlag Control

// set global draw context, color and filters
EXTERN void brushDrawContext(int filter, int color_mode);

// setup to draw, uses global context
// this is here so if we decide to make it per view, we easily can
EXTERN BOOL brushSetupDraw(int flags, int camera);

// for COMMAND system's convienience - directly modifiable
EXTERN int editbr_color_mode, editbr_filter;
EXTERN bool renderHotsOnly;
EXTERN bool renderHilightOnly;
EXTERN int editbr_filter_time_lo, editbr_filter_time_hi;
EXTERN float editbr_filter_size;

// filter utilities
BOOL brrendTypeFilterActive(void);
BOOL brrendCheckTypeFilter(editBrush *curBrush);

// fancy drawing/other wackiness

// assumes we are in an edit3d context, i guess.  hmmmmm...
EXTERN bool brushDraw(editBrush *curBrush);

// line primitives
EXTERN BOOL brushLineDraw(mxs_vector *p1, mxs_vector *p2, int color);
EXTERN float brushLineCheck(mxs_vector *p1, mxs_vector *p2, int x, int y);

// clickCheck returns a best distance for this figure
EXTERN float brushClickCheck(editBrush *curBrush, int x, int y);
// select fancy goes and sets the internal edge or point correctly
EXTERN BOOL brushSelectFancy(editBrush *curBrush, int x, int y);

// get boundary vectors for extent of brush
EXTERN BOOL brushCheckExtents(editBrush *curBrush, mxs_vector *bounds);

// Pick colors for editor
EXTERN void brushPickColors(void);   // in editbr

// if you want to get world coordinates for a given brush
EXTERN mxs_vector *brushBuildSolo(editBrush *us);

// call cback on all brushes drawn in last frame (ie. which pass the current
//   filter for the world)
typedef void (*editbr_callback)(editBrush *me);
EXTERN void brushRunOnActive(editbr_callback cback);

// conversion process for portalization
EXTERN void brushConvertStart(void);
EXTERN void brushConvertEnd(void);
EXTERN void *brushConvertPortal(editBrush *br);
// test (within convert) for being "in scene"
EXTERN BOOL brushConvertTest(editBrush *br);

// check if brush is filtered
EXTERN bool applyFilters(editBrush *curBrush);

#endif  // __BRREND_H
// $Header: r:/t2repos/thief2/src/editor/brtypes.h,v 1.1 1997/12/08 15:26:54 mahk Exp $
#pragma once  
#ifndef __BRTYPES_H
#define __BRTYPES_H

enum eBrushTypes
{
   brType_TERRAIN,        
   brType_LIGHT,          
   brType_HOTREGION,
   brType_OBJECT, 
   brType_FLOW, 
   brType_ROOM, 
}; 

#endif // __BRTYPES_H
// $Header: r:/t2repos/thief2/src/editor/brundo.c,v 1.14 2000/02/19 12:27:48 toml Exp $
// brush level undo code

#include <stdlib.h>     // all the S's
#include <string.h>
#include <stdio.h>

#include <lg.h>
#include <mprintf.h>
#include <command.h>

#include <editbr.h>
#include <editbr_.h>
#include <brlist.h>
#include <vbrush.h>
//#include <gedit.h>
#include <ged_undo.h>
#include <undoredo.h>
#include <brundo.h>
#include <brquery.h>
#include <brinfo.h>
#include <editobj.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static BOOL editUndoInProgress=FALSE;
static BOOL editUndoSuspended=FALSE;
static editBrush start_brush;

extern bool set_brush_to_time_n(editBrush *br, int n);

//#define UNDO_STACK_TRACE
#ifdef UNDO_STACK_TRACE
#define editUndoStoreAndTraceAction(action) do { undoStoreAction(action); editUndoStackPrint(); } while (0)
#else
#define editUndoStoreAndTraceAction(action) undoStoreAction(action)
#endif

#define noUndoRedoActions (editUndoInProgress||editUndoSuspended)

typedef struct {
   int type;
   char data[];
} undoGeneric;

typedef struct {
   int type;
   int time;
   editBrush total;  // has the brush id inside it, of course
} undoBrushState;

typedef struct {
   int type;
   int data1, data2;
} undoData;

#define UNDO_BRUSH     1
#define UNDO_DELETE    2
#define UNDO_CREATE    3
#define MAX_UNDO_BRUSH_OP (UNDO_CREATE)

#define UNDO_BLOCK_ST  4
#define UNDO_BLOCK_END 5
#define UNDO_GROUP     6

#ifdef FANCY_DELTA_STUFF

// a delta structure looks like
// typedef struct {
//    uchar len;
//    uchar offset;
//    uchar old[len];
//    uchar new[len];
// } delta;
//
// the deltalist_header starts with the current total length

#define DELTA_HEADER_SIZE        (sizeof(uchar)*2)
#define DELTALIST_HEADER_SIZE    (sizeof(short)*1)
#define delta_header(len,offset)
#define delta_size(len)          (DELTA_HEADER_SIZE+sizeof(uchar)*len)
#define deltalist_get_len(dl)    (*((short *)dl))

static void *_storeDelta(void **dlist, uchar *o, uchar *n, int offset, int len)
{
   uchar *ptr;
   int deltalist_len=0;
   if (dlist==NULL)
      *dlist=(void *)Malloc(DELTALIST_HEADER_SIZE+delta_size(len));
   else
   {
      deltalist_len=(int)deltalist_get_len(dlist);
      *dlist=(void *)Realloc(dlist,deltalist_len+delta_size(len));
   }
   ptr=((uchar *)*dlist)+deltalist_len;
   *ptr++=(uchar)len;
   *ptr++=(uchar)offset;
   memcpy(ptr,o+offset,len);
   memcpy(ptr+len,n+offset,len);
   *((short *)*dlist)=(short)deltalist_len+delta_size(len);
   return *dlist;
}

// returns a deltalist that it has malloced
static void *_buildBrushDelta(editBrush *old_br, editBrush *new_br)
{
   uchar *o=(uchar *)old_br, *n=(uchar *)new_br;
   void  *delta=NULL;
   int   i, missmatch=-1;

   for (i=0; i<sizeof(editBrush); i++)
   {
      bool diff=(*(o+i)!=*(n+i));
      if (diff&&(missmatch==-1))
         missmatch=i;
      if (!diff&&(missmatch!=-1))
      {
         delta=_storeDelta(&delta,o,n,missmatch,i-missmatch);
         missmatch=-1;
      }
   }
   return delta;
}
#endif

// this is to be called before performing an action which will modify a brush
// for now it saves the whole brush
// TODO: eventually, it should check to see if top of undo stack is this
//  brush, and know not to bother if it is.  unless your last actions was an
//  undo, in which case it should.  of course, really really it should scan
//  the brush and record just the delta.  hmmm, maybe ill do that now.
// so for now, full is ignored, since we always do full
static void *_buildBrushState(int type, editBrush *us, bool full)
{
   undoBrushState *newU;
   newU=(undoBrushState *)Malloc(sizeof(undoBrushState));
   newU->type=type;
   newU->time=blistCheck(us);
   newU->total=*us;
   return newU;
}

static void *_buildData(int type, int data1, int data2)
{
   undoData *newU;
   newU=(undoData *)Malloc(sizeof(undoData));
   newU->type=type;
   newU->data1=data1;
   newU->data2=data2;
   return newU;
}

static void *_restoreBrushState(undoGeneric *undoRec, bool create)
{
   undoBrushState *lastU=(undoBrushState *)undoRec;
   editBrush *us;
   void *rv=NULL;
   
   if (create)
   {
      us=brushCopy(&lastU->total);
      us->br_id=lastU->total.br_id; // preseve brush id

      //  Undelete objects properly
      //
      if (brushGetType(us) == brType_OBJECT)
      {
          editObjCreateObjFromBrush(OBJ_NULL, us);
      }
      blistInsert(us);              // and insert, so if we reverse it brush id will still be valid
      blistSetPostoBrush(us);
      set_brush_to_time_n(us, lastU->time);
      we_switched_brush_focus();
   }
   else
   {  // for now, this gross hack to try and make undo/redo for texture changes more useful

      if (lastU->total.br_id==VIRTUAL_BRUSH_ID)
      {
         if ((us=vBrush_UndoVBrush(&lastU->total))!=NULL)
         {
            rv=_buildBrushState(UNDO_BRUSH,us,FALSE);
            *us=lastU->total;
         }
         else
            Warning(("MultiBrush Undo failed\n"));
      }
      else if ((us=brFind(lastU->total.br_id))!=NULL)
      {
         BOOL tdelta=gedundo_check_texture_delta(&lastU->total,us);
         rv=_buildBrushState(UNDO_BRUSH,us,FALSE);
         *us=lastU->total;
         if (tdelta)
            gedundo_do_texture_delta(us);
      }
      else
         Warning(("Cant find undo brush %d!!\n",lastU->total.br_id));
   }
   return rv;
}

// for now, just saves off the current brush, for use or not
void editUndoStoreStart(editBrush *us)
{
   if (!noUndoRedoActions && (us!=NULL))
      start_brush=*us;
}

// this is the guts of the undo thinking - which will someday be smart and sensible...
// till then, this hack

// ok, lastU->total is the brush in the current undo (ie. state we will currently undo to)
//     start_brush is where we started this frame (often != lastU)
//     us is the brush as it currently exists
// we hand them to gedit, it tells us existing thing is ok, or to save it
void editUndoStoreBrush(editBrush *us)
{
   undoBrushState *lastU=(undoBrushState *)undoPeek();
   editBrush *base=NULL;

   if (noUndoRedoActions) return;  // well, the easy case
   if (lastU&&lastU->type==UNDO_BRUSH) base=&lastU->total;
   if (gedundo_check_brush_delta(us,&start_brush,base))
   {
      void *newAction=_buildBrushState(UNDO_BRUSH,&start_brush,FALSE);
      editUndoStoreAndTraceAction(newAction);
//      mprintf("new action for brush %d record (tx %d - old %d)\n",us->br_id,us->tx_id,start_brush.tx_id);
   }
//   else
//      mprintf("punt store of brush, we think it is the same\n");
}

// these both store full, so that neither needs to change for redo or anything
// ie. the del and create records are just backwards versions of eachother
//   which have the same packet, and direction+type indicates which to do
void editUndoStoreDelete(editBrush *us)
{
   if (!noUndoRedoActions)
      editUndoStoreAndTraceAction(_buildBrushState(UNDO_DELETE,us,TRUE));
}

void editUndoStoreCreate(editBrush *us)
{
   if (!noUndoRedoActions)
      editUndoStoreAndTraceAction(_buildBrushState(UNDO_CREATE,us,TRUE));
}

// this is used to store off block starts and stops
// so that you can treat a set of undo's as a block
// and a single call to undo/redo will do all of them
void editUndoStoreBlock(BOOL start_of_block)
{
   undoBrushState *lastU=(undoBrushState *)undoPeek();

   if (noUndoRedoActions) return;
   if (!start_of_block && (lastU!=NULL) && (lastU->type==UNDO_BLOCK_ST))
      undoKillStackTop();
   else
      editUndoStoreAndTraceAction(_buildData(start_of_block?UNDO_BLOCK_ST:UNDO_BLOCK_END,-1,-1));
}

void editUndoStoreGroup(int old_group, int new_group)
{
   if (!noUndoRedoActions)
      editUndoStoreAndTraceAction(_buildData(UNDO_GROUP,old_group,new_group));
}

void editUndoDoGroupOp(undoData *groupOp, BOOL is_undo)
{
   if (is_undo)
      vBrush_GoToGroup(groupOp->data1);
   else
      vBrush_GoToGroup(groupOp->data2);
}

void editUndoSuspend(BOOL suspend)
{
   editUndoSuspended=suspend;   
}

static int getBrushIdfromUndo(undoGeneric *und)
{
   undoBrushState *lastU=(undoBrushState *)und;
   return lastU->total.br_id;
}

bool editUndoDoUndo(void)
{
   int in_block=0;
   editBrush *us;
   BOOL rv=TRUE;

   editUndoInProgress=TRUE;
   do {
      undoGeneric *lastUndo=(undoGeneric *)undoDoUndo();
      if (lastUndo==NULL)
         rv=FALSE;
      else
         switch (lastUndo->type)
         {
            case UNDO_GROUP:
               editUndoDoGroupOp((undoData *)lastUndo,TRUE);
               break;
            case UNDO_BLOCK_ST:
               in_block--;
               break;
            case UNDO_BLOCK_END:
               in_block++;
               break;
            case UNDO_BRUSH:
               undoUndoReplace(_restoreBrushState(lastUndo,FALSE));
               break;
            case UNDO_CREATE:
               us=brFind(getBrushIdfromUndo(lastUndo));
               vBrush_DeletePtr(us);
               break;
            case UNDO_DELETE:
               _restoreBrushState(lastUndo,TRUE);
               break;
         }
   } while (in_block&&rv);
   editUndoInProgress=FALSE;
   return rv;
}

bool editUndoDoRedo(void)
{
   int in_block=0;   
   editBrush *us;
   BOOL rv=TRUE;

   editUndoInProgress=TRUE;   
   do {
      undoGeneric *lastUndo=(undoGeneric *)undoDoRedo();
      if (lastUndo==NULL)
         rv=FALSE;
      else
         switch (lastUndo->type)
         {
            case UNDO_GROUP:
               editUndoDoGroupOp((undoData *)lastUndo,FALSE);
               break;
            case UNDO_BLOCK_ST:
               in_block++;
               break;
            case UNDO_BLOCK_END:
               in_block--;
               break;
            case UNDO_BRUSH:
               undoRedoReplace(_restoreBrushState(lastUndo,FALSE));
               break;
            case UNDO_CREATE:
               _restoreBrushState(lastUndo,TRUE);
               break;
            case UNDO_DELETE:
               us=brFind(getBrushIdfromUndo(lastUndo));
               vBrush_DeletePtr(us);
               break;
         }
   } while (in_block&&rv);
   editUndoInProgress=FALSE;   
   return rv;
}

#ifdef DBG_ON
void _undostackwalkcallback(void *action, bool next)
{
   undoGeneric *tmpUndo=(undoGeneric *)action;
   mprintf("%s",next?"[":"(");
   if (tmpUndo==NULL)
      mprintf("NULL");
   else if (tmpUndo->type<=MAX_UNDO_BRUSH_OP)
      mprintf("%d %d",
              ((undoGeneric *)action)->type,
              ((undoBrushState *)action)->total.br_id);
   else
      mprintf("%d",((undoGeneric *)action)->type);
   mprintf("%s",next?"]":")");
}

void editUndoStackPrint(void)
{
   undoDumpStack(_undostackwalkcallback);
}
#endif // DBG_ON// $Header: r:/t2repos/thief2/src/editor/brundo.h,v 1.5 2000/01/29 13:11:19 adurant Exp $
// brush specific undo and redo
#pragma once

#ifndef __BRUNDO_H
#define __BRUNDO_H

#include <editbrs.h>

// start saves off current brush state
EXTERN void editUndoStoreStart(editBrush *us);
EXTERN void editUndoStoreBrush(editBrush *us);
EXTERN void editUndoStoreDelete(editBrush *us);
EXTERN void editUndoStoreCreate(editBrush *us);

// this is used to store off block starts and stops
// so that you can treat a set of undo's as a block
// and a single call to undo/redo will do all of them
EXTERN void editUndoStoreBlock(BOOL start_of_block);

// as we get more specific and hateful
EXTERN void editUndoStoreGroup(int old_group, int new_group);

// if you want to do stuff undo/redo cant see/deal with
EXTERN void editUndoSuspend(BOOL suspend);

// actually go do the undo and redo
EXTERN bool editUndoDoUndo(void);
EXTERN bool editUndoDoRedo(void);

#ifdef DBG_ON
EXTERN void editUndoStackPrint(void);
#endif

#endif  // __BRUNDO_H
// $Header: r:/t2repos/thief2/src/editor/brushgfh.c,v 1.45 2000/02/19 12:27:50 toml Exp $

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <comtools.h>
#include <res.h>
#include <rect.h>
#include <resrect.h>
#include <drawelem.h>
#include <gadget.h>
#include <region.h>
#include <util2d.h>
#include <mprintf.h>
#include <config.h>
#include <cfgdbg.h>
#include <lgsprntf.h>
#include <gcompose.h>
#include <guistyle.h>

#include <uiapp.h>
#include <brushgfh.h>
#include <swappnp.h>
#include <reg.h>
#include <editbr_.h>
#include <editbr.h>
#include <brlist.h>
#include <brinfo.h>
#include <vbrush.h>
#include <cyclegad.h>
#include <brundo.h>
#include <gedit.h>
#include <vslider.h>
#include <status.h>
#include <viewmgr.h>
#include <dragbox.h>
#include <cmdbutts.h>
#include <command.h>
#include <contexts.h>
#include <gfhfrobs.h>

#include <editor.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define NUM_SPATIAL_DIMS 3 // This will not change unless the universe does
#define NUM_COORDS 9

////////////////////////////////////////

static struct _BrushGFH
{
   LGadRoot root;
   CycleGadg coords[NUM_COORDS];
   float vals[NUM_COORDS];
   LGadButton labels[NUM_COORDS];
   
   LGadButtonList menu1_buttons;
   CmdButtonListDesc menu1_desc;

   LGadButtonList menu2_buttons;
   CmdButtonListDesc menu2_desc;

   Rect pnp1area;
   BOOL dualpnps;     // this is hideous

   BOOL pnp2isup;
   Rect pnp2area;     // area for pnp 2
   LGadRoot pnp2root; // its own special root, cause were crazy

   Rect swaparea;
   editBrush* brush;
   BOOL created; 
   ulong coordmask;
} BrushGFH;

////////////////////////////////////////////////////////////
// The Nine Coordinate editors
//////////////////////////////////////////////////////////// 

// convert axis to brush structs 0-2 = xyz, 3-5 = dwh, 6-8 = phb

enum 
{
   TRANS_AXES,
   SIZE_AXES,
   ROT_AXES
};

#define ANGLE_UNITS 360

void stuff_brush_axis(editBrush* brush, int axis, float val)
{
   int mod3 = axis %NUM_SPATIAL_DIMS; // har
   int div3 = axis /NUM_SPATIAL_DIMS; // har
   if (brush == NULL)
      return;

   switch(div3)
   {
      case TRANS_AXES:
         brush->pos.el[mod3] = val;
         break;      
      case SIZE_AXES:
         brush->sz.el[mod3] = val/2;
         break;
      case ROT_AXES:
         brush->ang.el[mod3] = (fixang)(val*2*FIXANG_PI/ANGLE_UNITS);
         break;   
   }
   ConfigSpew("grabstuff",("stuffing %f to axis %d\n",(fix)(val*FIX_UNIT),axis));
}

////////////////////////////////////////

void grab_brush_axis(editBrush* brush, int axis, float* val)
{
   int mod3 = axis %NUM_SPATIAL_DIMS; // har
   int div3 = axis /NUM_SPATIAL_DIMS; // har

   if (brush == NULL)
   {
      *val = 0.0;
      return;
   }

   switch(div3)
   {
      case TRANS_AXES:
         *val = brush->pos.el[mod3];
         break;      
      case SIZE_AXES:
         *val = 2*brush->sz.el[mod3];
         break;
      case ROT_AXES:
         // here we are, do the angles
         *val = brush->ang.el[mod3]*1.0*ANGLE_UNITS/(2*FIXANG_PI);
         break;   
   }
   //   ConfigSpew("grabstuff",("grabbing %f from axis %d\n",(fix)((*val)*FIX_UNIT),axis));
}

////////////////////////////////////////

typedef struct _CoordDef
{
   char* name;      
   Ref ref;
} CoordDef;

CoordDef coord_defs[] = 
{
   { "X", REF_RECT_GFHBrushTopL,},
   { "Y", REF_RECT_GFHBrushMidL,},
   { "Z", REF_RECT_GFHBrushBotL,},
   { "D", REF_RECT_GFHBrushTopR,},
   { "W", REF_RECT_GFHBrushMidR,},
   { "H", REF_RECT_GFHBrushBotR,},
   { "B", REF_RECT_GFHBrushBotM,},
   { "P", REF_RECT_GFHBrushMidM,},
   { "H", REF_RECT_GFHBrushTopM,},
};

#define COORD_DELTA (0.01)
#define ANG_DELTA (1.00)
#define AXIS_IS_ANG(axis) (axis>=6)

////////////////////////////////////////

static bool coord_cycle_call(CycleGadg* gadg, ulong action, eCyclePart part, void* var, CycleGadgDesc* desc)
{
   float* pval = var; 
   int axis = (int)desc->user_data;

   if (CYCLE_ACTION_KIND(action) == kCycleActionUpdate)
   {
      grab_brush_axis(BrushGFH.brush,axis,pval);
      return FALSE;
   }
   
   editUndoStoreStart(BrushGFH.brush);
   stuff_brush_axis(BrushGFH.brush,axis,*pval);
   i_changed_the_brush(BrushGFH.brush,FALSE,FALSE,FALSE);
   editUndoStoreBrush(BrushGFH.brush);
   
   return TRUE;
}

////////////////////////////////////////

#ifdef BITMAP_ARROWS
DrawElement stupid_arrows[] = 
{
   { DRAWTYPE_RES, REF_IMG_LeftArrow,},
   { DRAWTYPE_RES, REF_IMG_RightArrow,},
};
#else
DrawElement stupid_arrows[] = 
{
   { DRAWTYPE_TEXT, "<", 0, 0, 0, BORDER(DRAWFLAG_BORDER_OUTLINE)|FORMAT(DRAWFLAG_FORMAT_RIGHT), },
   { DRAWTYPE_TEXT, ">", 0, 0, 0, BORDER(DRAWFLAG_BORDER_OUTLINE)|FORMAT(DRAWFLAG_FORMAT_LEFT), },
};
#endif 


////////////////////////////////////////

extern void get_scaled_rect(Ref ref, Rect* bounds,Rect* out, Rect* anchor);

void create_coord_cycler(LGadRoot* root, Rect* bounds, CycleGadg* gadg, int axis, float* var, 
                         CycleGadg *next, CycleGadg *prev)
{
   floatCycleGadgDesc fdesc;
   CycleGadgDesc desc;
   BOOL is_ang=(axis / NUM_SPATIAL_DIMS) == ROT_AXES;
   
   memset(&desc,0,sizeof(desc));

   get_scaled_rect(coord_defs[axis].ref,bounds,&desc.bounds,NULL);
   desc.var = var;
   desc.arrow_drawelems = stupid_arrows;
   desc.cb = coord_cycle_call;
   desc.format_string = "%3.2f"; 
   desc.flags = CYCLE_FOCUS_FLAG|CYCLE_EDIT_FLAG|CYCLE_NOSPACE_FLAG;
   desc.next = next;
   desc.prev = prev;
   desc.user_data = (void*)axis;
   if (is_ang)
   {
      fdesc.delta = ANG_DELTA;
      fdesc.min   = 0.0;
      fdesc.max   = 360.0;
      fdesc.wrap  = TRUE;
   }
   else
   {
      fdesc.delta =  COORD_DELTA;
      fdesc.min   = -1000.00;
      fdesc.max   = +1000.00;
      fdesc.wrap  =  FALSE;
   }
   CreatefloatCycleGadg(gadg,root,&desc,&fdesc);
}

////////////////////////////////////////

void destroy_coord_cycler(CycleGadg* gadg)
{
   DestroyfloatCycleGadg(gadg);
}

////////////////////////////////////////////////////////////
// Label Buttons w/ virtual slider mojo
//

static int vs_update_axis = 0;

void label_vs_update(void)
{
   grab_brush_axis(BrushGFH.brush,vs_update_axis,&BrushGFH.vals[vs_update_axis]);
   UpdateCycleGadg(&BrushGFH.coords[vs_update_axis],TRUE);
   gedit_raw_change_brush(BrushGFH.brush,FALSE,FALSE,FALSE);
   vm_render_cameras();
}

////////////////////////////////////////

bool label_button_call(short action, void* data, LGadBox* vb)
{
   if (action & MOUSE_LDOWN)
   {
      editBrush* br = BrushGFH.brush;
      int varnum = (int)LGadBoxGetUserData(vb);
      int axis = varnum%NUM_SPATIAL_DIMS;
      fixangSlider angslider;
      floatSlider fslider;
      void* slidah;
      
      switch (varnum/NUM_SPATIAL_DIMS)
      {
         case ROT_AXES:
            Status("Drag to rotate brush");
            slidah = brushVSsetupAng(&angslider,br,axis);
            break;
         case TRANS_AXES:
            Status("Drag to move brush");
            slidah = brushVSsetupPos(&fslider,br,axis,1.0);
            break;
         case SIZE_AXES:
            Status("Drag to size brush");
            slidah = brushVSsetupSz(&fslider,br,axis,1.0);
            break;
      }
      editUndoStoreStart(br);
      vs_update_axis = varnum;
      gedit_setup_check_lazy_drag();
      if (virtual_slider(1,&slidah,label_vs_update)==VSLIDER_CHANGED)
         i_changed_the_brush(br,FALSE,FALSE,FALSE);   // this will do brush updates as it sees fit
      gedit_finish_check_lazy_drag();
      editUndoStoreBrush(br);
      Status("");
      return TRUE;
   }
   return FALSE;
   
}

////////////////////////////////////////

static void create_label_button(LGadButton* butt, LGadRoot* root, Rect* bounds, int axis)
{
   int idx = coord_defs[axis].ref - REF_RECT_GFHBrushTopL;
   Rect area;
   DrawElement draw;

   get_scaled_rect(MKREF(RES_GFHcoord,idx),bounds,&area,NULL);

   ElementClear(&draw); 
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = coord_defs[axis].name;
   draw.draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);

   
   LGadCreateButtonArgs(butt,root,area.ul.x,area.ul.y,
                 (short)RectWidth(&area), (short)RectHeight(&area),
                 &draw, label_button_call,0);
   LGadButtonSetFlags(butt,LGADBUTT_FLAG_GETDOWNS);
   LGadBoxSetUserData(VB(butt),(void*)axis);
}

////////////////////////////////////////
// Root draw call. Does nothing.
//

#ifdef ROOT_DRAW
#pragma off(unrefereneced)
static void root_draw_call(void* data, LGadBox* vb)
{
   gr_clear(guiStyleGetColor(NULL,StyleColorBG));
}
#pragma on(unreferenced)
#endif 

////////////////////////////////////////////////////////////
// GFH API FUNCTIONS
////////////////////////////////////////////////////////////

void brushGFH_OpenPnPs(int n);
void brushGFH_ClosePnPs(void);
void brushGFH_UpdatePnPs(GFHUpdateOp op, editBrush *brush);
void set_pnp_mode(int n);

static bool New_Brush_Hack=FALSE;     // so setcur sets it, update does it

void GFHUpdate(GFHUpdateOp op)
{
   int i;
   for (i = 0; i < NUM_COORDS; i++)
   {
      float val = BrushGFH.vals[i];
      bool update = op == GFH_FORCE;
      grab_brush_axis(BrushGFH.brush,i,&BrushGFH.vals[i]);
      if (update || BrushGFH.vals[i] != val)
         UpdateCycleGadg(&BrushGFH.coords[i],TRUE);
   }
   if ((New_Brush_Hack)&&(op==GFH_FRAME))
   {
      set_pnp_mode(PnP_ForBrush(BrushGFH.brush));
      Update_GFHFrobs(GFH_FORCE,BrushGFH.brush);
      New_Brush_Hack=FALSE;
   }
   else
   {
      brushGFH_UpdatePnPs(op,BrushGFH.brush);
      Update_GFHFrobs(op,BrushGFH.brush);
   }
   GFHUpdateSwappable(op,BrushGFH.brush);
}

void GFHRedrawPnPnSuch(void)
{
   New_Brush_Hack=TRUE;
}

////////////////////////////////////////


void GFHSetCurrentBrush(editBrush* brush)
{
   int i;
   
   ConfigSpew("brushset",("Setting gfx brush to %x of type %d\n",brush,brush?brushGetType(brush):666));
   if (!BrushGFH.created)
   {
      Warning(("Setting GFH current brush, but GFH hasn't been created\n"));
      return;
   }

   if (BrushGFH.brush!=brush)
   {
      New_Brush_Hack=TRUE;
      brushGFH_UpdatePnPs(GFH_MINIMAL,NULL);  // to indicate this one is dead
   }
   BrushGFH.brush = brush;

   for (i = 0; i < NUM_COORDS; i++)
   {
      grab_brush_axis(brush,i,&BrushGFH.vals[i]);
      UpdateCycleGadg(&BrushGFH.coords[i],TRUE);
   }
}

////////////////////////////////////////

// some zany little tables to make the next/prev thing
// correspond to actual screen layout instead of internal
// ordering
static int next_table[NUM_COORDS] = { 
   1, 2, 8,
   4, 5, 0,
   3, 6, 7,
};
static int prev_table[NUM_COORDS] = { 
   5, 0, 1,
   6, 3, 4,
   7, 8, 2, 
};

void CreateBrushGFHInternal(Rect* bounds, editBrush* brush)
{
   Rect area, anchor;
   Rect top_reg, bot_reg;
   int pnp = PnP_ForBrush(brush), swap=0;   
   int i;
   struct _BrushGFH* gfh = &BrushGFH;

   AssertMsg(!gfh->created,"Hey, brush GFH was already created");

   LGadSetupSubRoot(&gfh->root,LGadCurrentRoot(),
                    bounds->ul.x,bounds->ul.y,
                    (short)RectWidth(bounds),(short)RectHeight(bounds));
   gfh->coordmask = 0;
   gfh->brush = brush;

   // MAIN PNP AREAS
   config_get_int("pnp",&pnp);
   get_scaled_rect(REF_RECT_GFHModalArea,bounds,&area,&anchor);
   gfh->pnp1area = area;
   if (grd_visible_canvas->bm.w>640)
   {
      gfh->pnp2area.ul.x=0; gfh->pnp2area.ul.y=area.ul.y;
      gfh->pnp2area.lr.x=RectWidth(&area);
      gfh->pnp2area.lr.y=area.ul.y+RectHeight(&area);
      LGadSetupSubRoot(&gfh->pnp2root,LGadCurrentRoot(),
                       bounds->lr.x+4,bounds->ul.y,
                       (short)RectWidth(&area),(short)RectHeight(&area));
      gfh->pnp2isup = FALSE;
      gfh->dualpnps = TRUE;
   }
   else
      gfh->pnp2isup = gfh->dualpnps = FALSE;
   brushGFH_OpenPnPs(pnp);

   // SWAPPABLE AREA
   config_get_int("swap",&swap);
   get_scaled_rect(REF_RECT_GFHSwapArea,bounds,&area,&anchor);
   gfh->swaparea = area;
   GFHOpenSwappable(swap,&gfh->root,&area,brush);

   for (i = 0; i < NUM_COORDS; i++)
   {
      grab_brush_axis(brush,i,&gfh->vals[i]);
      create_coord_cycler(&gfh->root,bounds,&gfh->coords[i],i,&gfh->vals[i],
         &gfh->coords[next_table[i]],&gfh->coords[prev_table[i]]);
      create_label_button(&gfh->labels[i],&gfh->root,bounds,i);
   }
      
   gfh->created = TRUE;
   vBrush_Change_Callback = GFHSetCurrentBrush; 

   get_scaled_rect(REF_RECT_GFH_UndoArea,bounds,&area,&anchor);
   CreateConfigButtonDesc(&gfh->menu1_desc,2,&area,"gfh_menu1",MakePoint(1,2),MakePoint(1,1));
   CreateCmdButtonList(&gfh->menu1_buttons,&gfh->root,&gfh->menu1_desc);
   bot_reg.ul.x=area.ul.x; top_reg.ul.x=area.lr.x+8; top_reg.ul.y=area.ul.y;

   get_scaled_rect(REF_RECT_GFH_DeleteArea,bounds,&area,&anchor);
   CreateConfigButtonDesc(&gfh->menu2_desc,2,&area,"gfh_menu2",MakePoint(1,2),MakePoint(1,1));
   CreateCmdButtonList(&gfh->menu2_buttons,&gfh->root,&gfh->menu2_desc);
   bot_reg.lr.x=area.lr.x; top_reg.lr.x=area.ul.x-8; top_reg.lr.y=area.lr.y;
   
   get_scaled_rect(REF_RECT_GFH_TimeArea,bounds,&area,&anchor);
   bot_reg.ul.y=area.ul.y+1;   bot_reg.lr.y=area.lr.y;
   Create_GFHFrobs(&gfh->root,&top_reg,&bot_reg,brush);
   
   LGadDrawBox(VB(&BrushGFH),NULL);
}
   

////////////////////////////////////////

void CreateBrushGFH(Rect* bounds)
{
   CreateBrushGFHInternal(bounds, blistGet());
}

////////////////////////////////////////

void DestroyBrushGFH(void)
{
   int i;
   struct _BrushGFH* gfh = &BrushGFH;

   brushGFH_ClosePnPs();
   GFHCloseSwappable();
   for (i = 0; i < NUM_COORDS; i++)
   {
      destroy_coord_cycler(&BrushGFH.coords[i]);
      LGadDestroyBox((LGadBox*)&BrushGFH.labels[i],FALSE);
   }
   LGadDestroyButtonList(&gfh->menu1_buttons);
   DestroyConfigButtonDesc(&gfh->menu1_desc);

   LGadDestroyButtonList(&gfh->menu2_buttons);
   DestroyConfigButtonDesc(&gfh->menu2_desc);

   Destroy_GFHFrobs();

   LGadDestroyRoot(&BrushGFH.root);
   if (BrushGFH.dualpnps)
      LGadDestroyRoot(&BrushGFH.pnp2root);
    
   BrushGFH.brush = NULL;
   BrushGFH.created = FALSE;
   vBrush_Change_Callback = NULL;
}           

void GFHSetCoordMask(ulong mask)
{
   //   ulong changes = BrushGFH.coordmask ^ mask;
   int i;
   if (!BrushGFH.created)
    { BrushGFH.coordmask = mask; return; }
   for (i = 0; i < NUM_COORDS; i++)
   {
      bool invis = (mask & (1 << i)) != 0;
      LGadHideBox(VB(&BrushGFH.coords[i]),invis);
      LGadHideBox(VB(&BrushGFH.labels[i]),invis);
   }   
   BrushGFH.coordmask = mask;
}

////////////////////////////////////////

void get_scaled_rect(Ref ref, Rect* bounds,Rect* out, Rect* anchor)
{
   Rect scale = *(Rect*)RefGet(REF_RECT_GFHbounds);
   Rect source = ((RectElem*)RefGet(ref))->area;
   Rect ancr   = ((RectElem*)RefGet(ref))->anchor;
   short sw = RectWidth(&scale);
   short sh = RectHeight(&scale);
   short bw = RectWidth(bounds);
   short bh = RectHeight(bounds);
   
   // relativize the source rect
   source.ul.x -= scale.ul.x;
   source.ul.y -= scale.ul.y;
   source.lr.x -= scale.ul.x;
   source.lr.y -= scale.ul.y;

   // grow the rect 1 in all directions
   source.ul.x--;
   source.ul.y--;
   source.lr.x++;
   source.lr.y++;

   // scale source and anchor from scale to bounds
   source.ul.x = source.ul.x*bw/sw;
   source.lr.x = source.lr.x*bw/sw;
   source.ul.y = source.ul.y*bh/sh;
   source.lr.y = source.lr.y*bh/sh;

   ancr.ul.x = ancr.ul.x*bw/sw;
   ancr.lr.x = ancr.lr.x*bw/sw;
   ancr.ul.y = ancr.ul.y*bh/sh;
   ancr.lr.y = ancr.lr.y*bh/sh;

   *out = source;
   if (anchor != NULL)
      *anchor = ancr;
}

////////////////////////////////////////////////////////////
// GFH Commands
////////////////////////////////////////////////////////////

BOOL brushGFH_AlignNTextureUp(void)
{
   return BrushGFH.pnp2isup;
}

// abstract over the pnp system, since we dont have the same root or area
static void brushGFH_OpenPnPs(int n)
{
   if ((n==PNP_TEXTURE)&&BrushGFH.dualpnps)
   {  // do things with PnP 2 here
      BrushGFH.pnp2isup=TRUE;
      GFHOpen_a_PNP(1,PNP_ALIGN,&BrushGFH.pnp2root,&BrushGFH.pnp2area,BrushGFH.brush);
   }
   GFHOpen_a_PNP(0,n,&BrushGFH.root,&BrushGFH.pnp1area,BrushGFH.brush);
}

static void brushGFH_ClosePnPs(void)
{
   if (BrushGFH.pnp2isup)
      GFHClose_a_PNP(1);
   GFHClose_a_PNP(0);
   BrushGFH.pnp2isup=FALSE;
}

static void brushGFH_UpdatePnPs(GFHUpdateOp op, editBrush *brush)
{
   if (BrushGFH.pnp2isup)
      GFHUpdate_a_PNP(1,op,brush);
   GFHUpdate_a_PNP(0,op,brush);
}

// high level call
static void set_pnp_mode(int n)
{
   brushGFH_ClosePnPs();
   brushGFH_OpenPnPs(n);
   //   GFHOpenPNP(n,&BrushGFH.root,&BrushGFH.pnp1area,BrushGFH.brush);
   LGadDrawBox(VB(&BrushGFH.root),NULL);
   if (BrushGFH.pnp2isup)
      LGadDrawBox(VB(&BrushGFH.pnp2root),NULL);
}

static void set_swap_mode(int n)
{
   GFHCloseSwappable();
   GFHOpenSwappable(n,&BrushGFH.root,&BrushGFH.swaparea,BrushGFH.brush);
   LGadDrawBox(VB(&BrushGFH.root),NULL);
}

static void do_pnp_mode(int n)
{
   uiDefer((deferfunc)set_pnp_mode,(void *)n);
}

static void do_swap_mode(int n)
{
   uiDefer((deferfunc)set_swap_mode,(void *)n);
}

static void set_coord_mask(int n)
{
   GFHSetCoordMask(n);
}

static void coord_edit(char *str)
{
   int n=-1, i;

   if (str==NULL) return;
   if (isdigit(str[0]))
   {
      n=atoi(str);
      if ((n>=0)&&(n<NUM_COORDS))
      {
         for (i=0; i<NUM_COORDS; i++)
         {
            int idx=coord_defs[i].ref - REF_RECT_GFHBrushTopL;
            if (idx==n)
               break;
         }
         n=i;  // if i==NUM_COORDS, will fail < in if below
      }
   }
   else
   {
      int i;
      for (i=0; i<NUM_COORDS; i++)
         if (strnicmp(coord_defs[i].name,str,1)==0)
         {
            n=i;
            break;
         }
   }
   if ((n>=0)&&(n<NUM_COORDS))
   {
      LGadTextBox *tb=&BrushGFH.coords[n].text;
      LGadTextBoxSetCursor(tb,0);
      LGadFocusTextBox(tb);
      LGadTextBoxSetFlag(tb,TEXTBOX_EDIT_BRANDNEW);
      LGadDrawBox(VB(tb),NULL);
   }
   else
      Status("Invalid Coordinate");
}

static Command gfh_commands[]=
{
   { "start_pnp",FUNC_INT,do_pnp_mode,"Change the plug-n-play gadget\n",},
   { "start_swap",FUNC_INT,do_swap_mode,"Change the swap gadget\n",},
   { "coord_mask",FUNC_INT,set_coord_mask,"Hide/show some GFH coords\n",},
   { "gfh_coord_edit",FUNC_STRING,coord_edit,"Text edit coord N\n" },
};

void setup_gfh_commands(void)
{
   COMMANDS(gfh_commands,HK_EDITOR);
}
// $Header: r:/t2repos/thief2/src/editor/brushgfh.h,v 1.9 2000/01/29 13:11:20 adurant Exp $
#pragma once

#ifndef __BRUSHGFH_H
#define __BRUSHGFH_H
#include <lg.h>
#include <rect.h>

// create the Brush Gadget From Hell.  bounds specifies
// the bounding rectangle for the gadget
EXTERN void CreateBrushGFH(Rect* bounds);
EXTERN void DestroyBrushGFH(void);

// forces a redraw and such
EXTERN void GFHRedrawPnPnSuch(void);

// tell the GFH to edit a different brush
EXTERN void GFHSetCurrentBrush(struct _editBrush*);

// tell the GFH to update
typedef enum 
{ 
   GFH_FORCE,   // force full update
   GFH_MINIMAL, // only update changes
   GFH_FRAME,   // this really means minimal, and safe to do region stuff
} GFHUpdateOp;

EXTERN void GFHUpdate(GFHUpdateOp op);

// hack for dealing with dual PnP stuff
EXTERN BOOL brushGFH_AlignNTextureUp(void);

// Coordinate mask

#define GFH_NO_X     0x0001
#define GFH_NO_Y     0x0002
#define GFH_NO_Z     0x0004

#define GFH_NO_D     0x0008
#define GFH_NO_W     0x0010
#define GFH_NO_H     0x0020

#define GFH_NO_BANK  0x0040
#define GFH_NO_PITCH 0x0080
#define GFH_NO_HEAD  0x0100

#define GFH_ALL_COORDS 0x0000

EXTERN void GFHSetCoordMask(ulong mask);

#endif // __BRUSHGFH_H
// $Header: r:/t2repos/thief2/src/editor/cmdbutts.c,v 1.5 2000/02/19 12:27:51 toml Exp $

#include <string.h>
#include <stdlib.h>

#include <lgsprntf.h>
#include <config.h>


#include <cmdbutts.h>
#include <command.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


//
// Layout rects
//

void LayoutRectangles(Rect* bounds, Rect* rvec, int n, Point dims, Point sp)
{
   short bw = RectWidth(bounds);
   short bh = RectHeight(bounds);
   Point ul = bounds->ul;
   short w;
   short h;
   int i,j;
   int m;

   if (dims.x <= 0 || dims.y <= 0) 
   {
      Warning(("Tried to lay out rects for a zero-sided matrix\n"));
      return;
   }

   w = (bw - sp.x*(dims.x-1))/dims.x;
   h = (bh - sp.y*(dims.y-1))/dims.y;

   m = 0;
   for (j = 0; j < dims.y; j++)
      for (i = 0; i < dims.x; i++)
      {
         Rect* r = &rvec[m];
         r->ul.x = ul.x;
         if (dims.x > 1)
            r->ul.x += (bw - w)*i/(dims.x-1);
         r->lr.x = r->ul.x + w;
         
         r->ul.y = ul.y;
         if (dims.y > 1)
            r->ul.y += (bh - h)*j/(dims.y-1);
         r->lr.y = r->ul.y + h;

         m++;
         if (m >= n)
            goto out;

      }
out: ;
}

////////////////////////////////////////

static bool cmd_blist_call(ushort action, int button, void* data, LGadBox* vb)
{
   if (action & BUTTONGADG_LCLICK)
   {
      char** cmds = (char**)data;
      CommandExecute(cmds[button]);
      return TRUE;
   }
   return FALSE;
}

////////////////////////////////////////

LGadButtonList* CreateCmdButtonList(LGadButtonList* list, LGadRoot* root, CmdButtonListDesc* desc)
{
   LGadButtonListDesc bdesc;
   LGadButtonList* result;

   memset(&bdesc,0,sizeof(bdesc));
   bdesc.num_buttons = desc->num_buttons;
   bdesc.button_rects = desc->rects;
   bdesc.button_elems = desc->appearance;
   bdesc.cb = cmd_blist_call;
   
   result = LGadCreateButtonListDesc(list,root,&bdesc);
   LGadBoxSetUserData(VB(list),desc->commands);
   return result;
}

#define BUTTNAME_BUFSIZ 32
#define COMMAND_BUFSIZ 64

void CreateConfigButtonDesc(CmdButtonListDesc* desc, int n, Rect* bounds, char* var_prefix, Point dims, Point spacing)
{
   int i;
   if (n < 1)
   {
      Warning(("Tried to create a config-driven button list with %d buttons\n",n));
      return;
   }

   desc->num_buttons = n;
   desc->appearance = Malloc(sizeof(DrawElement)*n);
   Assrt(desc->appearance != NULL);
   desc->rects = Malloc(sizeof(Rect)*n);
   Assrt(desc->rects != NULL);
   desc->commands = Malloc(sizeof(char*)*n);
   Assrt(desc->commands != NULL);
   
   for (i = 0; i < n; i++)
   {
      char vbuf[65];
      DrawElement* de = &desc->appearance[i];
      char** pcmd = &desc->commands[i];

      memset(de,0,sizeof(*de));
      de->draw_type = DRAWTYPE_TEXT;
      lg_sprintf(vbuf,"%s_name_%d",var_prefix,i);
      de->draw_data = Malloc(BUTTNAME_BUFSIZ);  
      Assrt(de->draw_data != NULL);
      *(char*)de->draw_data = '\0';
      config_get_raw(vbuf,(char*)de->draw_data,BUTTNAME_BUFSIZ);
      de->draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);
      
      lg_sprintf(vbuf,"%s_cmd_%d",var_prefix,i);
      *pcmd = Malloc(COMMAND_BUFSIZ);
      Assrt(*pcmd != NULL);
      **pcmd = '\0';
      config_get_raw(vbuf,*pcmd,COMMAND_BUFSIZ);
   }
   LayoutRectangles(bounds,desc->rects,n,dims,spacing);
}

void DestroyConfigButtonDesc(CmdButtonListDesc* desc)
{
   int n = desc->num_buttons;
   int i;

   for (i = 0; i < n; i++)
   {
      Free(desc->appearance[i].draw_data);
      Free(desc->commands[i]);
   }
   Free(desc->appearance);
   Free(desc->rects);
   Free(desc->commands);
   desc->num_buttons = 0;
}

// $Header: r:/t2repos/thief2/src/editor/cmdbutts.h,v 1.2 2000/01/29 13:11:21 adurant Exp $
#pragma once

#ifndef __CMDBUTTS_H
#define __CMDBUTTS_H

#include <gadget.h>
#include <gadblist.h>

//
// Simple function to create a buttonlist where each button signals a command
// from the config file.
//


typedef struct _CmdButtonListDesc 
{
   int num_buttons;
   DrawElement* appearance; // appearance of each button (array)
   Rect* rects; // array of rectangles
   char** commands; // commands to execute for each button
} CmdButtonListDesc;


EXTERN LGadButtonList* CreateCmdButtonList(LGadButtonList* list, LGadRoot* root, CmdButtonListDesc* desc);

//
// Tool for laying out rectangles
// 
// fill rvec with a matrix of rectangles whose matrix dimensions are dims
// with spacing between each rect.

EXTERN void LayoutRectangles(Rect* bounds, Rect rvec[], int num_rects, Point dims, Point spacing);

//
// Fill in a desc given a number of buttons and a config variable prefix
//
// uses <prefix>_name_<n> for the name of button n and 
//      <prefix>_cmd_<n> for the command of button n
// malloc's a whole bunch of stuff.  don't destroy the desc until after
// you've destroyed the buttonlist you make with it.


EXTERN void CreateConfigButtonDesc(CmdButtonListDesc* desc, int num_buttons, Rect* bounds, char* var_prefix, Point dims, Point spacing);

EXTERN void DestroyConfigButtonDesc(CmdButtonListDesc *desc);

#endif // __CMDBUTTS_H
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/editor/convpred.cpp,v 1.4 2000/02/19 12:27:52 toml Exp $
//

#include <proped.h>
#include <iobjed.h>

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>
#include <sdesbase.h>
#include <sdestool.h>

#include <aiprconv.h>
#include <aicnvrse.h>

#include <simpwrap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////////////////////////////////////////////////////////////
// Conversation property editing

//
// The step struct desc
//
static const char* _g_AIConversationActorNames[] = 
{
   "Unused",
   "ActorOne",
   "ActorTwo",
   "ActorThree",
   "ActorFour",
   "ActorFive",
   "ActorSix",
};

static char *_g_AIConversationFlagBits[] = 
{
   "Don't Block",
};

#define CONVERSATION_FIELDS(i) \
   { "Actor", kFieldTypeEnum, FieldLocation(cAIConversationDesc, steps[0][i].actor),  kFieldFlagNone, -1, \
      sizeof(_g_AIConversationActorNames)/sizeof(_g_AIConversationActorNames[0])-1, \
      sizeof(_g_AIConversationActorNames)/sizeof(_g_AIConversationActorNames[0]), \
      _g_AIConversationActorNames}, \
   { "Flags", kFieldTypeBits, FieldLocation(cAIConversationDesc, steps[0][i].flags), kFieldFlagNone, 0, 1, 1, _g_AIConversationFlagBits,}, \
   AIPSDSCR_ARG_FIELD("Conversation: Action " #i, cAIConversationDesc, steps[0][i].act)

static sFieldDesc _g_AIConversationFieldDesc[] =
{
   CONVERSATION_FIELDS(0),
   CONVERSATION_FIELDS(1),
   CONVERSATION_FIELDS(2),
   CONVERSATION_FIELDS(3),
   CONVERSATION_FIELDS(4),
   CONVERSATION_FIELDS(5),
};

static sStructDesc _g_AIConversationStructDesc = StructDescBuild(cAIConversationDesc, kStructFlagNone, _g_AIConversationFieldDesc);

//
// The abort conditions struct desc
//

const char * _g_ppszAIAwareAlertLevels[kAIAL_Num+1] =
{
   "(0) Lowers",
   "(1) Low",
   "(2) Moderate",
   "(3) High",
   "None"
};

static sFieldDesc _g_AIConvAbortFieldDesc[] =
{
   { "Abort level", kFieldTypeEnum, FieldLocation(cAIConversationDesc, abortLevel), kFieldFlagNone, 0, FieldNames(_g_ppszAIAwareAlertLevels) },
   { "Abort priority", kFieldTypeEnum, FieldLocation(cAIConversationDesc, abortPriority), kFieldFlagNone, 0, FieldNames(g_ppszAIPriority) },
};

static sStructDesc _g_AIConvAbortStructDesc = StructDescBuild(cAIConversationDesc, kStructFlagNone, _g_AIConvAbortFieldDesc);

///////////////////////////////////////

void AIConvDescPropSetStep(int step)
{
   sFieldDesc* pField;
   
   // field 0 is abort level
   for (int i=0; i<kAIMaxConvActions; i++)
   {
      // actor
      pField = &_g_AIConversationStructDesc.fields[i*6];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].actor);
      // flags
      pField = &_g_AIConversationStructDesc.fields[i*6+1];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].flags);
      // psuedo-script
      // action type
      pField = &_g_AIConversationStructDesc.fields[i*6+2];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].act.type);
      // action args
      pField = &_g_AIConversationStructDesc.fields[i*6+3];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].act.args[0]);
      pField = &_g_AIConversationStructDesc.fields[i*6+4];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].act.args[1]);
      pField = &_g_AIConversationStructDesc.fields[i*6+5];
      pField->offset = FieldOffset(cAIConversationDesc, steps[step][i].act.args[2]);
   }
}

class cAIConversationEditTrait: public cBasePropEditTrait
{
public:

   cAIConversationEditTrait(IAIConversationProperty* prop)
      : cBasePropEditTrait((IProperty*)prop)
   {
      Caps.flags |= kTraitCanEdit; 
   }

   STDMETHOD(Edit)(ObjID obj)
   {
      cAIConversationDesc* pConvDesc; 
      IAIConversationProperty* prop = (IAIConversationProperty*)Prop; 
      HRESULT retval = S_FALSE; 

      int iNumMenuSlots = kAIMaxConvSteps+1;
      char **ppszMenu = (char **)Malloc(sizeof(char**)*iNumMenuSlots);

      for (int i=0; i<iNumMenuSlots-2; i++)
      {
         ppszMenu[i] = (char*) Malloc(sizeof(char)*3);
         // wacky string sorting...
         if (i<10)
            sprintf(ppszMenu[i], "0%d", i);
         else
            sprintf(ppszMenu[i], "%d", i);
      }
      ppszMenu[i] = (char*) Malloc(sizeof(char)*20);
      sprintf(ppszMenu[i], "Abort Steps");
      ppszMenu[++i] = (char*) Malloc(sizeof(char)*20);
      sprintf(ppszMenu[i], "Abort Conditions");
      int iChoice = PickFromStringList("Step", (const char* const*)ppszMenu, iNumMenuSlots);
      if ((iChoice>=0) && (iChoice<iNumMenuSlots-1))
      {
         AIConvDescPropSetStep(iChoice);

         if (!prop->Get(obj,&pConvDesc))
            return E_FAIL; 
         
         sStructEditorDesc eddesc = { "" , kStructEditAllButtons };
         strncpy(eddesc.title, Desc.strings.friendly_name, sizeof(eddesc.title)); 
         IStructEditor* sed = CreateStructEditor(&eddesc, &_g_AIConversationStructDesc, pConvDesc); 
         
         if (sed->Go(kStructEdModal))
         {
            prop->Set(obj, pConvDesc); 
            retval = S_OK; 
         }
         SafeRelease(sed);
      }
      else if (iChoice == iNumMenuSlots-1)
      {
         if (!prop->Get(obj,&pConvDesc))
            return E_FAIL; 
         
         sStructEditorDesc eddesc = { "" , kStructEditAllButtons };
         strncpy(eddesc.title, Desc.strings.friendly_name, sizeof(eddesc.title)); 
         IStructEditor* sed = CreateStructEditor(&eddesc, &_g_AIConvAbortStructDesc, pConvDesc); 
         
         if (sed->Go(kStructEdModal))
         {
            prop->Set(obj, pConvDesc); 
            retval = S_OK; 
         }
         SafeRelease(sed);
      }
      for (i = 0; i < iNumMenuSlots; ++i)
         Free(ppszMenu[i]);
      Free(ppszMenu);
      return retval; 
   }

   STDMETHOD(Parse)(ObjID obj, const char* val)
   {
      return S_FALSE;
   }

   STDMETHOD(Unparse)(ObjID obj, char* buf, int buflen)
   {
      return S_FALSE; 
   }
};
  
void CreateAIConversationPropEditor(IAIConversationProperty* prop)
{
   IObjEditors* pEditors = AppGetObj(IObjEditors);
   if (pEditors)
   {
      IEditTrait* trait = new cAIConversationEditTrait(prop); 
      pEditors->AddTrait(trait);
      SafeRelease(trait); 
      SafeRelease(pEditors); 
   }
}
// $Header: r:/t2repos/thief2/src/editor/csgbrush.h,v 1.15 2000/01/29 13:11:22 adurant Exp $
#pragma once

#ifndef __CSGBRUSH_H
#define __CSGBRUSH_H

//  Interface to brushes for CSG stuff

//  brushes have a unique numeric id, and
//  the csg engine wants to access certain
//  information from it.  An array of structs
//  is the most obvious implementation; we
//  use an array of pointers which point to
//  structs which are managed elsewhere

//  Rather than reading the structs directly,
//  since all that might change, we do all the
//  accesses here; the macros can be turned into
//  structure indices, function calls, whatever

#include <editbr_.h>
#include <ged_csg.h>
#include <brtypes.h>

#define MAX_CSG_BRUSHES   7068
EXTERN struct _editBrush *csg_brush[MAX_CSG_BRUSHES];
EXTERN int csg_num_brushes;

///////////////////////////
// actual interface elements to csg data structures

  // step 1: we need to be able to index by brush id

#define CSG_BRUSH(x)                     csg_brush[x]

  // step 2: we need to get at some information about the whole brush

#define CB_TIMESTAMP(x)                  (CSG_BRUSH(x)->timestamp)
#define CB_MEDIUM(x)                     (CSG_BRUSH(x)->media)

//#define CB_MEDIUM_HOTREGION               4  // evaporate
#define CB_MEDIUM_HOTREGION               (-brType_HOTREGION)

  // step 3: we need to get information about faces and their textures

#define CB_FACE_TEXTURE(x,y)             gedcsgGetFaceTexture(x,y)

#define CB_MAX_ALIGN                     (256)

#define get_face(x,y)                    (gedcsgGetFaceTexInfo(x,y))
#define CB_FACE_TEX_SCALE(x,y)           (gedcsgGetFaceScale(x,y))
#define CB_FACE_TEX_ALIGN_U(x,y)         ((float)(get_face(x,y)->tx_x*4)/((float)CB_MAX_ALIGN))
#define CB_FACE_TEX_ALIGN_V(x,y)         ((float)(get_face(x,y)->tx_y*4)/((float)CB_MAX_ALIGN))
#define CB_FACE_TEX_ROT(x,y)             (get_face(x,y)->tx_rot)

#define CB_FACE_BRUSH_ALIGN_TEX(x,y,u,v) gedcsgGetFaceTextureAligned(x,y,u,v)

#define CB_FACE_IS_SELF_LUMINOUS(x,y)    gedcsgGetFaceTextureSelfLit(x,y)

#endif  // __CSGBRUSH_H
// $Header: r:/t2repos/thief2/src/editor/cvtbrush.c,v 1.7 2000/02/19 12:27:53 toml Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   cvtbrush.c

   The sides of groups of cells with persistant media are preserved
   through portalization, since to the portalizer there's a medium
   boundary. They are used where we want the cell database to include
   particular surfaces (as portals, that is).  Once we have our portal
   database, we convert the persistant media to regular media, here.

   We have some autohose medium portals in nonpersistant cells,
   because they lead into persistant ones.  These, too, must die.

   We only use this for doors, so far, and it's a bit hard-coded.
   In fact, we have no way to specify how the persistant cells are
   used, so if we want to generalize this setup we'll have to mark 
   the persistant brushes and propagate that somehow.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <config.h>
#include <mprintf.h>

#include <media.h>
#include <portal.h>
#include <wrdbrend.h>
#include <texmem.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is a helper for ConvertRemovePersistance(), which is a helper
   for ConvertPersistantCells(), both of which are below.

   Given a medium, this tells us what medium it will be when we're done
   converting them all.

   And still, good help is so hard to find these days.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
uchar ConvertFindFinalMedium(uchar medium)
{
      if (medium >= MEDIA_SOLID_PERSIST
       && medium <= MEDIA_WATER_PERSIST)
         return medium - (MEDIA_SOLID_PERSIST - MEDIA_SOLID);
      else
         return medium;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is a helper for ConvertPersistantCells(), below.

   This makes sure the extraneous portals we've created will not be
   drawn.  We iterate over all the rendered surfaces of a cell, and
   those which are marked as medium boundaries get their flags
   fiddled.  We have to make an exception for those which represent
   _real_ medium boundaries so we can have doors in half-flooded areas
   (and because it's the correct thing to do).

   This is called on both cells with persistant media and the cells
   adjacent to them, and only recurses to adjacent cells if we're in a
   persistant one.  So it's called before the medium is changed so we
   can tell which kind we're in.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void ConvertRemovePersistance(PortalCell *cell, uchar final_medium)
{
   PortalPolygonCore *poly_core;
   PortalPolygonRenderInfo *render_info;
   PortalCell *dest_cell;
   uchar dest_final_medium;
   uchar num_solid_polys, num_rendered_portals;
   int i;

   num_solid_polys = cell->num_polys - cell->num_portal_polys;
   num_rendered_portals = cell->num_render_polys - num_solid_polys;

#ifndef SHIP
   if (config_is_defined("CvtBrushSpew")) {
      mprintf("\nsolid_polys = %d  polys = %d  portal_polys = %d",
              (int) num_solid_polys, 
              (int) cell->num_polys, 
              (int) cell->num_portal_polys);

      mprintf(" rendered_portals = %d render_polys = %d\n",
              (int) num_rendered_portals,
              (int) cell->num_render_polys);
   }
#endif // ~SHIP

   poly_core = cell->portal_poly_list;
   render_info = cell->render_list + num_solid_polys;

   for (i = 0; i < num_rendered_portals; i++) {

      // Where are we going from the portal, and what medium are we
      // headed into?  Accounting for persistant media, of course.
      // If there's a medium difference, there's a clut.
      if (poly_core->clut_id) {
         dest_cell = wr_cell[poly_core->destination];
         dest_final_medium = ConvertFindFinalMedium(dest_cell->medium);

#ifndef SHIP
         if (config_is_defined("CvtBrushSpew"))
            mprintf("medium: %d  dest_medium: %d",
                    final_medium, dest_final_medium);
#endif // ~SHIP

         // If our final medium is the same as that of the cell we reach
         // through this portal, we don't want to render the boundary.
         if (dest_final_medium == final_medium) {
            render_info->texture_id = 0;
            poly_core->flags &= ~(PORTAL_SPLITS_OBJECT | RENDER_DOESNT_LIGHT);

            // If we're in a cell with a persistant medium, the cell
            // on the other side of this portal may have unwanted
            // visible medium boundaries.
            if (cell->medium != final_medium)
               ConvertRemovePersistance(dest_cell, dest_final_medium);
         } else
            if (final_medium == MEDIA_WATER)
               render_info->texture_id = WATEROUT_IDX;
            else 
               render_info->texture_id = WATERIN_IDX;
      }
      poly_core++;
      render_info++;
   }
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   The outer loop handles only those cells with persistant media, so
   it's the place to change their medium flags.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void ConvertPersistantCells(uchar added_flags)
{
   PortalCell *cell;
   int i;
   uchar final_medium;

   for (i = 0; i < wr_num_cells; i++) {
      cell = wr_cell[i];
      final_medium = ConvertFindFinalMedium(cell->medium);

      if (cell->medium != final_medium) {
         ConvertRemovePersistance(cell, final_medium);
         cell->medium = final_medium;
         cell->flags |= added_flags;
      }
   }
}


extern BOOL doing_opt_pass1;
// decide what texture to show at boundaries between media
int get_texture_for_medium_transition(int x, int y)
{
   uchar final_x = ConvertFindFinalMedium((uchar) x);
   uchar final_y = ConvertFindFinalMedium((uchar) y);

   if (final_x == MEDIA_AIR && final_y == MEDIA_WATER)
      return WATERIN_IDX;
   if (final_x == MEDIA_WATER && final_y == MEDIA_AIR)
      return WATEROUT_IDX;

   if (doing_opt_pass1 && x != y) {
      // force this to be a surface so the optimizer
      // will know about it
      return 1;
   }

   return -1;
}


// nowadays, we don't actually use the value from this except
// to see if it's non-zero
int get_clut_for_medium_transition(int x, int y)
{
   uchar final_x = ConvertFindFinalMedium((uchar) x);
   uchar final_y = ConvertFindFinalMedium((uchar) y);

   if (final_x == MEDIA_AIR && final_y == MEDIA_WATER)
      return 1;   // going from air into water
   if (final_x == MEDIA_WATER && final_y == MEDIA_AIR)
      return 2;   // going from water into air

   return 0;
}

// $Header: r:/t2repos/thief2/src/editor/cvtbrush.h,v 1.5 2000/01/29 13:11:23 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   cvtbrush.h

   export file

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _CVTBRUSH_H_
#define _CVTBRUSH_H_

#include <wr.h>

EXTERN uchar ConvertFindFinalMedium(uchar medium);
EXTERN void ConvertRemovePersistance(PortalCell *cell, uchar final_medium);
EXTERN void ConvertPersistantCells(uchar added_flags);

#endif
// $Header: r:/t2repos/thief2/src/editor/cyclegad.c,v 1.21 2000/02/22 22:33:31 bfarquha Exp $

#include <stdio.h>
#include <string.h>

#include <gadget.h>
#include <drawelem.h>
#include <kbcook.h>
#include <keydefs.h>
#include <gadtext.h>

#define _IMPLEMENT_CYCLEGADG
#include <cyclegad.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//
// Gadget callbacks
//

void UpdateCycleGadg(CycleGadg* gadg,bool redraw)
{
   bool is_f=FALSE;
   char* f = gadg->desc.format_string;
   char* buf = LGadTextBoxText(&gadg->text);

   TriggerCycleGadg(gadg,CYCLE_MAKE_ACTION(kCycleActionUpdate,redraw),kCycleCenterPart);

   switch(f[strlen(f)-1])
   {
      case 'e':
      case 'E':
      case 'f':
      case 'F':
      case 'g':
      case 'G':
         sprintf(buf,f,*(float*)gadg->desc.var);
         break;
      case 's':
         sprintf(buf,f,(char*)gadg->desc.var);
         break;
      default:
         if (strlen(f)>1)
            if (f[strlen(f)-2]=='h')
            {
               is_f=TRUE;
               sprintf(buf,f,*(short*)gadg->desc.var);
            }
         if (!is_f)
            sprintf(buf,f,*(int*)gadg->desc.var);
         break;
   }
   LGadUpdateTextBox(&gadg->text);
   if (redraw)
   {
      //      LGadTextBoxSetFlag(&gadg->text,TEXTBOX_EDIT_BRANDNEW);
      LGadTextBoxSetCursor(&gadg->text,strlen(buf));
      LGadUnfocusTextBox(&gadg->text);
      LGadDrawBox(VB(gadg),NULL);
   }
}

static char format[3] = "%d";

void read_text_buf(CycleGadg* gadg)
{
   char* f = gadg->desc.format_string;
//   char* format = "%d";
   char* buf = LGadTextBoxText(&gadg->text);
   char last = f[strlen(f)-1];
   int delta = 0;

   // if there is no associated text, leave it unchanged
   if (strlen(buf) == 0)
      return;

   format[1] = last;

   if ((strncmp(buf,"++",2) == 0) || (strncmp(buf,"--",2) == 0))
      delta = 1;
   if (delta)
   {
      int i;
      // remove the bogus leading sign
      for (i=0; i < strlen(buf) - 1; i++)
         buf[i] = buf[i+1];
      buf[strlen(buf)-1] = '\0';
   }

   switch(last)
   {
      case 'e':
      case 'E':
      case 'f':
      case 'F':
      case 'g':
      case 'G':
         {
            float var;
            sscanf(buf,format,&var); // (float*)gadg->desc.var);
            if (delta)
               *((float *)gadg->desc.var) = (var) + *((float *)gadg->desc.var);
            else
               *((float *)gadg->desc.var) = var;
         }
         break;
      case 's':
         sscanf(buf,format,(char*)gadg->desc.var);
         break;
      default:
         {
            int var;
            sscanf(buf,format,&var); // (float*)gadg->desc.var);
            if (delta)
               *((int *)gadg->desc.var) = (var) + *((int *)gadg->desc.var);
            else
               *((int *)gadg->desc.var) = var;
            sscanf(buf,format,(int*)gadg->desc.var);
         }
         break;
   }
}


bool cycle_button_list_cb(ushort action, int button, void* data, LGadBox* vb)
{
   bool retval = FALSE;
   CycleGadg* gadg = (CycleGadg*)data;
   if (gadg->desc.cb != NULL)
   {
      ulong act = CYCLE_MAKE_ACTION(kCycleActionMouse,action);
      retval = gadg->desc.cb(gadg,act,button,gadg->desc.var,&gadg->desc);
      if (retval)
         UpdateCycleGadg(gadg,TRUE);
   }
   
   return retval;
}


bool TriggerCycleGadg(CycleGadg* gadg, ulong action, eCyclePart part)
{
   if (gadg->desc.cb != NULL)
   {
      return gadg->desc.cb(gadg,action,part,gadg->desc.var,&gadg->desc);
   }
   return FALSE;
}

static bool cycle_do_key(CycleGadg* gadg, int key)
{
   bool update = TRUE;
   switch(key)
   {
      case KB_FLAG_DOWN|KEY_ENTER:   
         read_text_buf(gadg);
         break;
      case KB_FLAG_DOWN|KEY_ESC:
         break;
      case KB_FLAG_DOWN|KEY_TAB:
      case KB_FLAG_SHIFT|KB_FLAG_DOWN|KEY_TAB:
         // lock in our current data
         read_text_buf(gadg);
         // and then advance to the next
         if (gadg->desc.next != NULL)
         {
            LGadTextBox *tb;
            if (key == (KB_FLAG_DOWN|KEY_TAB))
               tb = &(gadg->desc.next->text);
            else
               tb = &(gadg->desc.prev->text);
            LGadTextBoxSetCursor(tb,0);
            LGadFocusTextBox(tb);
            LGadTextBoxSetFlag(tb,TEXTBOX_EDIT_BRANDNEW);
            LGadDrawBox(VB(tb),NULL);
         }         
         break;
   } 
   return update;
}

bool cycle_textbox_callback(LGadTextBox* box, LGadTextBoxEvent event, int eventdata, void* user_data)
{
   bool update = FALSE;  // whether to reload text from var
   bool signal = FALSE;  // whether to send to client (update implies signal)
   ushort kind;
   CycleGadg* gadg = (CycleGadg*)user_data;

   switch(event)
   {
   case TEXTBOX_BUTTON:
      if (gadg->desc.flags & CYCLE_NONPOTENT_FLAG)
         signal = TRUE;
      kind = kCycleActionMouse;
      break;
   case TEXTBOX_SPECKEY:
      update = cycle_do_key(gadg, eventdata);
      kind = kCycleActionKey;
      break;
   default:
      return FALSE;
   }

   if (update || signal)
   {
      ulong action = CYCLE_MAKE_ACTION(kind,eventdata);
      if (gadg->desc.cb != NULL)
         signal = gadg->desc.cb(gadg,action,kCycleCenterPart,gadg->desc.var,&gadg->desc);
      if (update || signal)
         UpdateCycleGadg(gadg,TRUE);
   }
   return update;
}

//
// Create the gadget
//

static short special_keys[] =
{
   KEY_ESC|KB_FLAG_DOWN,
   KEY_ENTER|KB_FLAG_DOWN,
   KEY_TAB|KB_FLAG_DOWN,
   KEY_TAB|KB_FLAG_DOWN|KB_FLAG_SHIFT,
   0,
};

#define TEXT_BUFLEN 64

CycleGadg* CreateCycleGadg(CycleGadg* gadg, LGadRoot* root, CycleGadgDesc* desc)
{
   int i;
   Point arrow_dims[kCycleNumArrows]; 
   short totwid;
   Rect editarea;
   short gw = RectWidth(&desc->bounds);
   short gh = RectHeight(&desc->bounds);

   if (gadg == NULL)
   {
      gadg = Malloc(sizeof(CycleGadg));
      AssertMsg(gadg != NULL, "Failed to alloc a CycleGadg");
      memset(gadg,0,sizeof(CycleGadg));
      gadg->free_self = TRUE;
   }
   else 
      gadg->free_self = FALSE;

   if (root == NULL)
      root = LGadCurrentRoot();

   gadg->desc = *desc;

   LGadSetupSubRoot(&gadg->root, root, desc->bounds.ul.x, desc->bounds.ul.y,gw,gh);

   for (i = 0, totwid = 0; i < kCycleNumArrows; i++)
   {
      short w,h;
      DrawElement* elem = &desc->arrow_drawelems[i];
      ElementSize(elem,&w,&h);
      totwid += w;
      arrow_dims[i] = MakePoint(w,h);
   }

   editarea.ul.y = 0;
   editarea.lr.y = gh;
   {
      Point dims = arrow_dims[kCycleLeftArrow];
      Rect* r = &gadg->arrow_rects[kCycleLeftArrow];
      //      r->ul = MakePoint(0,max(0,(gh-dims.y)/2));
      //      r->lr = MakePoint(dims.x,r->ul.y+dims.y);
      r->ul = MakePoint(0,0);
      r->lr = MakePoint(dims.x,gh);
      editarea.ul.x = r->lr.x;
   }

   {
      Point dims = arrow_dims[kCycleRightArrow];
      Rect* r = &gadg->arrow_rects[kCycleRightArrow];
      //      r->ul = MakePoint(gw - dims.x,max(0,(gh-dims.y)/2));
      //      r->lr = MakePoint(gw,r->ul.y+dims.y);
      r->ul = MakePoint(gw - dims.x,0);
      r->lr = MakePoint(gw,gh);
      editarea.lr.x = r->ul.x;
   }

   
   {
      LGadButtonListDesc listdesc = { kCycleNumArrows, };

      listdesc.button_rects = gadg->arrow_rects;
      listdesc.button_elems = gadg->desc.arrow_drawelems;
      listdesc.cb = cycle_button_list_cb;

      LGadCreateButtonListDesc(&gadg->list, &gadg->root, &listdesc);
      LGadBoxSetUserData(VB(&gadg->list),gadg);
   }

   {
      LGadTextBoxDesc tdesc;
      bool edit = desc->flags & CYCLE_EDIT_FLAG;

      memset(&tdesc,0,sizeof(tdesc));
      tdesc.bounds = editarea; 
      tdesc.editbuf = Malloc(TEXT_BUFLEN);
      tdesc.editbuflen = TEXT_BUFLEN;
      tdesc.cb = cycle_textbox_callback;
      tdesc.data = gadg;
      tdesc.flags = TEXTBOX_BORDER_FLAG|((desc->flags >> CYCLE_TEXTBOX_SHF) & CYCLE_TEXTBOX_MASK);
      tdesc.editbuf[0] = '\0';
      LGadCreateTextBoxDesc(&gadg->text,&gadg->root,&tdesc);
      LGadTextBoxSetFlag(&gadg->text,(desc->flags >> CYCLE_EDIT_SHF) & CYCLE_EDIT_MASK);
      LGadTextBoxSetSpecialKeys(&gadg->text,special_keys);

      LGadTextBoxClrFlag(&gadg->text,TEXTBOX_EDIT_BRANDNEW);
      if (edit) 
      {
         if (desc->flags & CYCLE_FOCUS_FLAG)
            LGadTextBoxClrFlag(&gadg->text,TEXTBOX_EDIT_EDITABLE);
         else
            LGadTextBoxSetFlag(&gadg->text,TEXTBOX_EDIT_EDITABLE|TEXTBOX_EDIT_BRANDNEW);
      }
      LGadTextBoxSetCursor(&gadg->text,strlen(tdesc.editbuf));
   }
   UpdateCycleGadg(gadg,FALSE);

   return gadg;
}


void DestroyCycleGadg(CycleGadg* gadg)
{
   AssertMsg(gadg != NULL, "Tried to destroy a NULL cyclegadg");
   LGadDestroyButtonList(&gadg->list);
   LGadDestroyTextBox(&gadg->text);
   Free(LGadTextBoxText(&gadg->text));
   LGadDestroyRoot(&gadg->root);
   if (gadg->free_self)
      Free(gadg);
}


//////////////////////////////////////////////////////////////
// STRING CYCLEGADG
//

typedef struct _string_cycle_data
{
   CycleGadgDesc desc;
   StringCycleGadgDesc sdesc;
   char buf[256];
} string_cycle_data;


bool string_cycle_cb(CycleGadg* gadg, ulong _action, eCyclePart part, void* _var, CycleGadgDesc* desc);




static void string_cycle_reparse(CycleGadg* gadg)
{
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   StringCycleGadgDesc* sdesc = (StringCycleGadgDesc*)&data->sdesc;
   int* var = (int*)data->desc.var;

   // fill the buffer from the string vector based on the new value
   strncpy(data->buf,sdesc->strings[*var],sizeof(data->buf));
   data->buf[sizeof(data->buf)-1] = '\0';
}

void RedescribeStringCycleGadg(CycleGadg* gadg, char** strings, int num)
{
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   StringCycleGadgDesc* sdesc = (StringCycleGadgDesc*)&data->sdesc;
   int* var = (int*)data->desc.var;
   sdesc->strings = strings;
   sdesc->num = num;
   *var %= num;

   // fill the buffer from the string vector based on the new value
   strncpy(data->buf,sdesc->strings[*var],sizeof(data->buf));
   data->buf[sizeof(data->buf)-1] = '\0';
}

void string_cycle_update(CycleGadg* gadg, ulong _action, eCyclePart part)
{
   CycleGadgDesc* desc = &gadg->desc;
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   int* var = (int*)data->desc.var;

   string_cycle_reparse(gadg);

   desc->user_data = data->desc.user_data;  // data data, your face is a mess
   desc->cb = data->desc.cb;
   desc->cb(gadg,_action,part,var,desc);
   desc->cb = string_cycle_cb;
   desc->user_data = data;
} 


void string_cycle_popup_menu(CycleGadg* gadg, Point pos, int item);

static bool string_do_key(CycleGadg* gadg, ushort key)
{
   bool update = FALSE;
   switch(key ^ KB_FLAG_DOWN)
   {
      case KEY_ENTER:
         update = TRUE;
         break;
   }
   return update;
}

bool string_cycle_cb(CycleGadg* gadg, ulong _action, eCyclePart part, void* _var, CycleGadgDesc* desc)
{
   ushort kind = CYCLE_ACTION_KIND(_action);
   ushort action = CYCLE_ACTION_DATA(_action);
   string_cycle_data* data = (string_cycle_data*)desc->user_data;
   StringCycleGadgDesc* sdesc = (StringCycleGadgDesc*)&data->sdesc;
   int* var = (int*)data->desc.var;
   bool update = FALSE;

   switch (kind)
   {
      case kCycleActionMouse:
         if (action & BUTTONGADG_LCLICK)
         {
            static int deltas[3] = { -1, 1, 0}; 
            *var += deltas[part]; 
            update = TRUE;
         }
         if (action & MOUSE_RDOWN)
         {
            Point mousepos;
            mouse_get_xy(&mousepos.x,&mousepos.y);
            string_cycle_popup_menu(gadg, mousepos, *var);            
         }
         break;
      case kCycleActionKey:
         update = string_do_key(gadg,action);
         break;
      case kCycleActionUpdate:
         update = TRUE;
         break;
   }
   if (update)
   {
      // wrap or clip
      if (sdesc->flags & STRING_CYCLE_WRAP)
      {
         while (*var < 0) *var += sdesc->num;
         *var %= sdesc->num;
      }
      else
         *var = max(0,min(*var,sdesc->num-1));

      string_cycle_update(gadg,_action, part);
   }
   return update;
}

CycleGadg* CreateStringCycleGadg(CycleGadg* gadg, LGadRoot* root, CycleGadgDesc* user_desc, 
                                 StringCycleGadgDesc* sdesc)
{
   CycleGadgDesc desc = *user_desc;
   string_cycle_data* sdata = Malloc(sizeof(*sdata));
   sdata->desc = *user_desc;
   sdata->sdesc = *sdesc;

   sdata->desc.cb = user_desc->cb;

   desc.cb = string_cycle_cb;
   desc.user_data = sdata;
   desc.var = &sdata->buf;

   // fill the buffer from the string vector based on the value
   strncpy(sdata->buf,sdesc->strings[*(int*)user_desc->var],sizeof(sdata->buf));
   sdata->buf[sizeof(sdata->buf)-1] = '\0';   

   if (desc.format_string == NULL)
      desc.format_string = "%s";

   if (sdesc->flags & STRING_CYCLE_MENU)
      desc.flags |= CYCLE_TDOWNS_FLAG;

   gadg = CreateCycleGadg(gadg,root,&desc);
   return gadg;
}

void DestroyStringCycleGadg(CycleGadg* gadg)
{
   void* sdata = gadg->desc.user_data;
   DestroyCycleGadg(gadg);
   Free(sdata);
}

void* StringCycleGadgData(CycleGadg* gadg)
{
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   return data->desc.user_data;
}


//----------------------------------------
// String cyclegadg menu
//

static bool string_menu_cb(int item, LGadMenu *menu)
{
   CycleGadg* gadg = (CycleGadg*)LGadBoxGetUserData(VB(menu));
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   ulong action = CYCLE_MAKE_ACTION(kCycleActionKey,KEY_ENTER|KB_FLAG_DOWN);
   int* var = (int*)data->desc.var; 

   if (item >= 0)
   {
      *var = item;
      string_cycle_update(gadg,action,kCycleCenterPart); 
   }
   return TRUE;   
}

void string_cycle_popup_menu(CycleGadg* gadg, Point pos, int item)
{
   string_cycle_data* data = (string_cycle_data*)gadg->desc.user_data;
   StringCycleGadgDesc* sdesc = (StringCycleGadgDesc*)&data->sdesc;
   LGadMenu* menu;
   DrawElement* elems = Malloc(sdesc->num*sizeof(*elems));
   int i;
   short mw =0, mh = 0; // menu dims
   short ew, eh;        // elem dims;
   uint drawflags = BORDER(DRAWFLAG_BORDER_OUTLINE);
   uint menuflags = MENU_GRAB_FOCUS | MENU_OUTER_DISMISS | MENU_ALLOC_ELEMS;
   Rect bounds = *LGadBoxRegion(gadg)->parent->r;
   region_abs_rect(LGadBoxRegion(gadg)->parent,&bounds,&bounds);
   
   for (i = 0; i < sdesc->num; i++)
   {
      ElementClear(&elems[i]);
      elems[i].draw_type = DRAWTYPE_TEXT;
      elems[i].draw_data = sdesc->strings[i]; 
   }

   ElementSize(&elems[0],&ew,&eh);   
   LGadMenuComputeSize(&mw,&mh,sdesc->num,sdesc->num,menuflags,elems,drawflags,0,0);
   // translate the menu down to be over item.
   pos.x -= ew/2;
   pos.y -= item*eh + eh/2;
   
   // clip the menu against the bounds.  
   pos.x = max(bounds.ul.x,min(pos.x,bounds.lr.x - mw));
   pos.y = max(bounds.ul.y,min(pos.y,bounds.lr.y - mh));

   menu = LGadCreateMenuArgs(NULL,NULL, pos.x, pos.y, mw, mh, sdesc->num,sdesc->num, 
            elems, string_menu_cb, 0, menuflags, drawflags, NULL, 0); 

   LGadBoxSetUserData(VB(menu),gadg);

   Free(elems);
}

// $Header: r:/t2repos/thief2/src/editor/cyclegad.h,v 1.14 2000/01/29 13:11:25 adurant Exp $
#pragma once

#ifndef __CYCLEGAD_H
#define __CYCLEGAD_H

#include <gadget.h>
#include <gadblist.h>
#include <gadtext.h>
#include <drawelem.h>

////////////////////////////////////////////////////////////
// GENERIC "cycle" gadget
// 
// Has a "left" and "right" arrow, and a value in the center
//
////////////////////////////////////////////////////////////


//
// callback argument: which part of the gadget was poked at
//

typedef enum eCyclePart
{
   kCycleLeftPart,
   kCycleRightPart,
   kCycleCenterPart,
} eCyclePart;

//
// The callback itself.  Note that the app must change the variable.  
// action is decoded using the following macros:
//

typedef enum _CycleActionKinds
{
   kCycleActionKey,
   kCycleActionMouse,
   kCycleActionUpdate,
} CycleActionKinds;

#define CYCLE_KIND_SHF 16
#define CYCLE_KIND_MASK 0xFFFF
#define CYCLE_DATA_MASK ((1 << CYCLE_KIND_SHF)-1)

#define CYCLE_ACTION_KIND(action) (((action) >> CYCLE_KIND_SHF) & CYCLE_KIND_MASK)
#define CYCLE_ACTION_DATA(action) ((action) & CYCLE_DATA_MASK)

#define CYCLE_MAKE_ACTION(kind,data) (((kind) << CYCLE_KIND_SHF) | (data))

typedef bool (*CycleCallback)(struct _CycleGadg* gadg, ulong action, eCyclePart part, void* var, struct _CycleGadgDesc *desc);

//
// Id's for arrow display elements
//

typedef enum eCycleArrow
{
   kCycleLeftArrow,
   kCycleRightArrow,
   kCycleNumArrows,
} eCycleArrow;


//
// Types of vars supported
//

//----------------------------------------
// And, of course, how could we not have a descriptor
//

#define CYCLE_EDIT_FLAG      0x80000000  // can we edit the text of the box
#define CYCLE_NONPOTENT_FLAG 0x40000000  // should we get non-potent callbacks

#define CYCLE_TEXTBOX_MASK 0xFFFF
#define CYCLE_TEXTBOX_SHF 0 
#define CYCLE_FOCUS_FLAG (TEXTBOX_FOCUS_FLAG << CYCLE_TEXTBOX_SHF) // grab focus on click
#define CYCLE_TDOWNS_FLAG (TEXTBOX_MOUSE_DOWNS << CYCLE_TEXTBOX_SHF) // should we get down events in the textbox

#define CYCLE_EDIT_SHF 16
#define CYCLE_EDIT_MASK  0xFF

#define CYCLE_NOSPACE_FLAG (TEXTBOX_EDIT_NOSPACES << CYCLE_EDIT_SHF) // disallow typed spaces
#define CYCLE_OVERSTRIKE_FLAG (TEXTBOX_EDIT_OVERMODE << CYCLE_EDIT_SHF) // overstrike mode

typedef struct _CycleGadgDesc
{
   Rect bounds; 
   void* var;
   DrawElement* arrow_drawelems;
   CycleCallback cb;
   char* format_string;  // printf/scanf format string
   void* user_data;
   ulong flags;
   struct _CycleGadg *next;
   struct _CycleGadg *prev;
} CycleGadgDesc;


//----------------------------------------
// The CycleGadg data structure
//

typedef struct _CycleGadg
{
   LGadRoot root;
   LGadButtonList list;
   //   LGadEditMenu menu;
   LGadTextBox text;
   CycleGadgDesc desc;
   Rect arrow_rects[kCycleNumArrows];
   bool free_self;
} CycleGadg;

//
// Create the sucker!
//

EXTERN CycleGadg* CreateCycleGadg(CycleGadg* gadg, LGadRoot* root, CycleGadgDesc* desc);
EXTERN void DestroyCycleGadg(CycleGadg* gadg);

EXTERN void UpdateCycleGadg(CycleGadg* gadg, bool redraw);

// Spoof an event.
EXTERN bool TriggerCycleGadg(CycleGadg* gadg, ulong action, eCyclePart part);

////////////////////////////////////////////////////////////
// STRING CYCLEGADG 
//
// a cyclegadg that cycles through a list of strings.
//

// flags
#define STRING_CYCLE_MENU 0x1  // should clicking on the gadget generate a menu.
#define STRING_CYCLE_WRAP 0x2  // should it wrap around

typedef struct _StringCycleGadgDesc
{
   char** strings; // the string vector
   int num;  // the size of the vector in elements
   ulong flags; // flags as above
} StringCycleGadgDesc;

EXTERN CycleGadg* CreateStringCycleGadg(CycleGadg* gadg, LGadRoot* root, 
    CycleGadgDesc* desc, StringCycleGadgDesc* sdesc);

EXTERN void DestroyStringCycleGadg(CycleGadg* gadg);

// extract the user data from a cyclegadg
EXTERN void* StringCycleGadgData(CycleGadg* gadg); 

// reset our strings and number 
EXTERN void RedescribeStringCycleGadg(CycleGadg* gadg, char** strings, int num);

////////////////////////////////////////////////////////////
// Generator macros for typed cycle gadg
////////////////////////////////////////////////////////////


#define CycleGadgType(type) \
typedef struct _##type##CycleGadgDesc \
{ \
  type min,max; \
  type delta; \
  bool wrap ; /* should we wrap from bottom/top */ \
  /* internal use only*/ \
  void* data; \
  CycleCallback cb;\
} type##CycleGadgDesc; \
\
EXTERN CycleGadg* Create##type##CycleGadg(CycleGadg* gadg, LGadRoot* root, CycleGadgDesc* desc, struct _##type##CycleGadgDesc* typedesc); \
EXTERN void Destroy##type##CycleGadg(CycleGadg* gadg); 

#ifndef _IMPLEMENT_CYCLEGADG
#define impCycleGadgType(type)


#else

#define impCycleGadgType(type) \
static bool type##_cycle_cb(CycleGadg* gadg, ulong act, eCyclePart part, void* var, CycleGadgDesc* desc) \
{ \
  bool update = part == kCycleCenterPart; \
  ushort kind = CYCLE_ACTION_KIND(act); \
  ushort action = CYCLE_ACTION_DATA(act); \
  type* realvar = (type*)var; \
  type##CycleGadgDesc* tdesc = (type##CycleGadgDesc*)desc->user_data;\
  if (kind == kCycleActionMouse && (action & BUTTONGADG_LCLICK)) \
  { \
    switch(part)\
    { \
      case kCycleLeftPart:  *realvar -= tdesc->delta; update = TRUE; break; \
      case kCycleRightPart: *realvar += tdesc->delta; update = TRUE; break; \
    } \
  } \
  if (update) \
  { \
     if (*realvar < tdesc->min) *realvar = (tdesc->wrap) ? tdesc->max-tdesc->delta : tdesc->min; \
     if (*realvar > tdesc->max) *realvar = (tdesc->wrap) ? tdesc->min : tdesc->max; \
     /* here we stuff user data to fool user */ \
     desc->user_data = tdesc->data;\
     desc->cb = tdesc->cb; \
     desc->cb(gadg,act,part,var,desc); \
     /* now unstuff it */\
     desc->cb = type##_cycle_cb;  \
     desc->user_data = tdesc;           \
  }     \
  return update;        \
} \
\
CycleGadg* Create##type##CycleGadg(CycleGadg* gadg, LGadRoot* root, CycleGadgDesc* desc, type##CycleGadgDesc* typedesc) \
{  \
   CycleGadgDesc desc2; \
   type##CycleGadgDesc* tdesc2 = Malloc(sizeof(*typedesc)); \
   desc2 = *desc; \
   *tdesc2 = *typedesc;                 \
   tdesc2->cb = desc->cb;       \
   tdesc2->data = desc->user_data;      \
   desc2.cb=type##_cycle_cb; \
   desc2.user_data = tdesc2; \
   return CreateCycleGadg(gadg,root,&desc2); \
} \
\
void Destroy##type##CycleGadg(CycleGadg* gadg)\
{ \
  DestroyCycleGadg(gadg); \
  Free(gadg->desc.user_data); \
}       

#endif


CycleGadgType(int);
impCycleGadgType(int);

CycleGadgType(float);
impCycleGadgType(float);

CycleGadgType(short);
impCycleGadgType(short);

CycleGadgType(fixang);
impCycleGadgType(fixang);

#endif // __CYCLEGAD_H
// $Header: r:/t2repos/thief2/src/editor/doorblok.cpp,v 1.9 2000/03/06 12:31:20 ccarollo Exp $

/* --<<= --/-/-/-/-/-/-/ <<< ((( ((( /\ ))) ))) >>> \-\-\-\-\-\-\-- =>>-- *\
   doorblok.cpp

   This is the editor-side code which enforces door boundaries during
   portalization.  It does this by generating temporary terrain
   brushes matching the OBBs of the doors, using the media_op for
   blocking.

\* --<<= --\-\-\-\-\-\-\ <<< ((( ((( \/ ))) ))) >>> /-/-/-/-/-/-/-- =>>-- */


#include <mprintf.h>
#include <cfgdbg.h>
#include <dynarray.h>
#include <brinfo.h>
#include <brlist.h>
#include <doorprop.h>
#include <doorphys.h>
#include <editbr.h>
#include <editbr_.h>
#include <wrtype.h>
#include <objpos.h>
#include <phprop.h>
#include <primal.h>
#include <propbase.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


// These are in ged_csg.c.
extern "C" char *mediaop_names[];
extern "C" int num_media_ops;


// We keep track of our brushes so we can destroy them after
// portalization.
static cDynArray<editBrush *> g_BrushList;


// When we make a terrain brush to match a door, we want to make sure
// it's completely inside the door and extends well into the door
// frame.  So we treat it as having a constant thinness on its
// smallest axis and enlarge it a little on the other two.
#define kfDoorThickness .04
#define kfDoorGrowth .1

#define kMinorAxis 0
#define kMajorAxis 1

// The brush system's notion of size is really the distance from the
// center to each face, so it's half the kind of size an object has.
static float RescaleAxis(float fSize, int iSize)
{
   if (iSize == kMinorAxis)
      return kfDoorThickness;
   else
      return fSize * .5 + kfDoorGrowth;
}


// rescale a brush's OBB as described above
static void RescaleOBB(mxs_vector *pDims, int iXSize, int iYSize, int iZSize)
{
   pDims->x = RescaleAxis(pDims->x, iXSize);
   pDims->y = RescaleAxis(pDims->y, iYSize);
   pDims->z = RescaleAxis(pDims->z, iZSize);
}


// creates the appropriate brush, if appropriate
static void GenerateBrush(ObjID obj, sDoorProp *pDoor, mxs_angvec *pOrient,
                          int iMedium)
{
   if (OBJ_IS_ABSTRACT(obj))
      return;
   if (!pDoor->vision_blocking)
      return;

   cPhysDimsProp *pDimsProp;
   if (!g_pPhysDimsProp->Get(obj, &pDimsProp))
   {
      mprintf("Door %d has no OBB--cannot block terrain\n", obj);
      return;
   }

   editBrush *pBrush = brushInstantiate(PRIMAL_CUBE_IDX);
   brushSetType(pBrush, brType_TERRAIN);

   mxs_vector obj_offset, world_offset;
   mxs_matrix rotation;

   mx_copy_vec(&obj_offset, &pDimsProp->offset[0]);
   mx_ang2mat(&rotation, pOrient);
   mx_mat_mul_vec(&world_offset, &rotation, &obj_offset);

   mx_add_vec(&pBrush->pos, &pDoor->base_closed_location, &world_offset);
   pBrush->ang = *pOrient;
   pBrush->media = iMedium;

   // find minor axis & set our dimensions
   pBrush->sz = pDimsProp->size;

   if (pBrush->sz.x < pBrush->sz.y && pBrush->sz.x < pBrush->sz.z)
      RescaleOBB(&pBrush->sz, kMinorAxis, kMajorAxis, kMajorAxis);
   else if (pBrush->sz.y < pBrush->sz.x && pBrush->sz.y < pBrush->sz.z)
      RescaleOBB(&pBrush->sz, kMajorAxis, kMinorAxis, kMajorAxis);
   else
      RescaleOBB(&pBrush->sz, kMajorAxis, kMajorAxis, kMinorAxis);

   blistSeek(0, SEEK_END);
   blistInsert(pBrush);

   // keep track so we can nuke 'em when we're done portalizing
   g_BrushList.Append(pBrush);
}


extern "C" void DrBlkGenerateBrushes(void)
{
   // We'd rather do this than have a magic number for our media op.
   int iOpIndex;
   for (iOpIndex = 0; iOpIndex < num_media_ops; ++iOpIndex)
      if (strcmp(mediaop_names[iOpIndex], "blockable") == 0)
         break;

   Assert_ (iOpIndex < num_media_ops);

   sPropertyObjIter iter;
   ObjID obj;
   sRotDoorProp *pRotDoor;
   sTransDoorProp *pTransDoor;

   // For rotating doors we can pull the orientation straight out of
   // the property.
   g_pRotDoorProperty->IterStart(&iter);

   while (g_pRotDoorProperty->IterNext(&iter, &obj)) {
      g_pRotDoorProperty->Get(obj, &pRotDoor);
      GenerateBrush(obj, pRotDoor, &pRotDoor->base_closed_facing, iOpIndex);
   }

   g_pRotDoorProperty->IterStop(&iter);

   // The property for translating doors does not have an orientation
   // since that's constant--so we get it from the Position property.
   g_pTransDoorProperty->IterStart(&iter);

   while (g_pTransDoorProperty->IterNext(&iter, &obj)) {
      g_pTransDoorProperty->Get(obj, &pTransDoor);

      ObjPos *pPos = ObjPosGet(obj);
      if (!pPos) {
         ConfigSpew("BlockSpew", 
                    ("Door %d has no position--cannot block terrain\n", obj));
         break;
      }

      GenerateBrush(obj, pTransDoor, &pPos->fac, iOpIndex);
   }

   g_pTransDoorProperty->IterStop(&iter);
}


extern "C" void DrBlkDestroyBrushes(void)
{
   int iSize = g_BrushList.Size();

   for (int i = 0; i < iSize; ++i) {
      blistSetPostoBrush(g_BrushList[i]);
      blistDelete();
   }

   g_BrushList.SetSize(0);
}


// This is in preparation for lighting the level.  We don't want the
// doors to interfere with how we find the cells affected by each
// light, since the boundary between affected and unaffeted cells
// looks goofy.
extern "C" void DrBlkUnblockAll(void)
{
   sPropertyObjIter iter;
   ObjID obj;

   g_pRotDoorProperty->IterStart(&iter);
   while (g_pRotDoorProperty->IterNext(&iter, &obj))
      if (OBJ_IS_CONCRETE(obj))
         RemoveDoorBlocking(obj);
   g_pRotDoorProperty->IterStop(&iter);

   g_pTransDoorProperty->IterStart(&iter);
   while (g_pTransDoorProperty->IterNext(&iter, &obj))
      if (OBJ_IS_CONCRETE(obj))
         RemoveDoorBlocking(obj);
   g_pTransDoorProperty->IterStop(&iter);
}


// This is the opposite of the above.  All doors which are supposed to
// be blocking are set to do so.
extern "C" void DrBlkReblockAll(void)
{
   sPropertyObjIter iter;
   ObjID obj;

   g_pRotDoorProperty->IterStart(&iter);
   while (g_pRotDoorProperty->IterNext(&iter, &obj))
      if (OBJ_IS_CONCRETE(obj))
         UpdateDoorBrush(obj);
   g_pRotDoorProperty->IterStop(&iter);

   g_pTransDoorProperty->IterStart(&iter);
   while (g_pTransDoorProperty->IterNext(&iter, &obj))
      if (OBJ_IS_CONCRETE(obj))
         UpdateDoorBrush(obj);
   g_pTransDoorProperty->IterStop(&iter);
}
// $Header: r:/t2repos/thief2/src/editor/doorblok.h,v 1.4 2000/01/29 13:11:26 adurant Exp $
#pragma once

/* --<<= --/-/-/-/-/-/-/ <<< ((( ((( /\ ))) ))) >>> \-\-\-\-\-\-\-- =>>-- *\
   doorblok.h

   This is the editor-side code which enforces door boundaries during
   portalization.  It does this by generating temporary terrain
   brushes matching the OBBs of the doors, using the media_op for
   blocking.

\* --<<= --\-\-\-\-\-\-\ <<< ((( ((( \/ ))) ))) >>> /-/-/-/-/-/-/-- =>>-- */

#ifndef _DOORBLOK_H_
#define _DOORBLOK_H_

EXTERN void DrBlkGenerateBrushes(void);
EXTERN void DrBlkDestroyBrushes(void);

EXTERN void DrBlkUnblockAll(void);
EXTERN void DrBlkReblockAll(void);

#endif // _DOORBLOK_H_
// $Header: r:/t2repos/thief2/src/editor/dragbox.c,v 1.53 2000/02/19 12:27:56 toml Exp $
// mouse drag box for brush creation

#include <stdlib.h>
#include <math.h>

#include <2d.h>
#include <lg.h>
#include <mprintf.h>
#include <r3d.h>
#include <event.h>
#include <kbcook.h>
#include <config.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brlist.h>
#include <gedit.h>
#include <status.h>
#include <brundo.h>

#include <viewmgr.h>
#include <viewmgr_.h>
#include <modalui.h>
#include <vslider.h>
#include <brushgfh.H>
#include <vbrush.h>
#include <guistyle.h>
#include <ccompose.h>
#include <curdat.h>

#include <gridsnap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern void vm_mouse_relativize(int, int *, int *);

mxs_vector gb_start, gb_end;
static Rect gb_drag_box;
static bool gb_drag_from_center;
static int gb_cam;
static bool gb_currently_drawn;

static editBrush *dragbox_br;

// Drag scroll code
static bool oldsynch;
//static bool oldgrid;
static int oldmode;
static int oldcam;
static void drag_setup(int c)
{
   oldcam=vm_current_camera();
   oldmode=vm_get_mode(c);
   //oldgrid=vm_show_grid;
   oldsynch = vm_get_synch(c);

   vm_set_cur_camera(c);
   vm_set_render_mode(c,RM_WIREFRAME_BRUSHES);
   //vm_show_grid=FALSE;     // for now, show current brush, grid, and camera only
   vm_set_synch(c,FALSE); // desynch for scrolling
}

static void drag_cleanup(int c)
{
   //vm_show_grid=oldgrid;
   vm_set_render_mode(c,oldmode);
   vm_set_synch(c,oldsynch);
   vm_set_cur_camera(oldcam);
   vm_redraw();
}

// ensures that x,y is on screen
static void drag_scroll(int c, int x, int y)
{
   mxs_vector delta;
   mxs_vector curloc;
   int w,h;
   float dist;
   mxs_vector xvec,yvec;

   // find out where the edges of the screen are, so to figure whether the
   // mouse is onscreen or not
   vm_camera_scr_size(c, &w, &h);
   delta.x = delta.y = delta.z = 0;
   //vm_get_camera_axis(c, &xaxis, &yaxis);
   vm_screen_axes(c, &xvec,&yvec);
   //mprintf("(%d,%d) vs (%d,%d)\n",x,y,w,h);
   if (x < 0)
   {
      dist = x * 1.0F;
      if (dist > 5.0F)
         dist = 5.0F;
      gb_drag_box.ul.x -= (int)dist;
      mx_scale_addeq_vec(&delta,&xvec,dist);
   }
   if (y < 0)
   {
      dist = y * 1.0F;
      if (dist > 5.0F)
         dist = 5.0F;
      gb_drag_box.ul.y -= (int)dist;
      mx_scale_addeq_vec(&delta,&yvec,dist);
   }
   if (x > w)
   {
      dist = (x-w) * 1.0F;
      if (dist > 5.0F)
         dist = 5.0F;
      gb_drag_box.ul.x -= (int)dist;
      mx_scale_addeq_vec(&delta,&xvec,dist);
   }
   if (y > h)
   {
      dist = (y-h) * 1.0F;
      if (dist > 5.0F)
         dist = 5.0F;
      gb_drag_box.ul.y -= (int)dist;
      mx_scale_addeq_vec(&delta,&yvec,dist);
   }
   
   if (vm_get_3d(c))
    { Status("Cant scroll 3d cameras"); return; }

   curloc =*vm_get_loc_2d(c);
   //mprintf("curloc = %g, %g, %g\n",curloc.x,curloc.y,curloc.z);

   mx_addeq_vec(&curloc,&delta);
   vm_set_location(c,&curloc);
   vm_render_camera(c);

}

void brush_vs_update(void)
{
   GFHUpdate(GFH_MINIMAL);
   gedit_raw_change_brush(dragbox_br,FALSE,FALSE,FALSE);
   vm_render_cameras();
}

  // start drawing a box with a click in any TL corner
void gb_start_box_corner(int camera, int x, int y)
{
   gb_cam = camera;
   gb_drag_box.ul.x = x;
   gb_drag_box.ul.y = y;
   gb_drag_box.lr.x = x;
   gb_drag_box.lr.y = y;

   gb_currently_drawn = FALSE;
   gb_drag_from_center = FALSE;

   vm_map_screen_to_world(camera, &gb_start, x, y);      
}

  // start drawing a box with a click at the center
void gb_start_box_center(int camera, int x, int y)
{
   gb_cam = camera;
   gb_drag_box.ul.x = x;
   gb_drag_box.ul.y = y;
   gb_drag_box.lr.x = x;
   gb_drag_box.lr.y = y;

   gb_currently_drawn = FALSE;
   gb_drag_from_center = TRUE;

   vm_map_screen_to_world(camera, &gb_start, x, y);      
}


void gb_box(void)
{
   int x0,y0,x1,y1;

   x0 = gb_drag_box.ul.x;
   y0 = gb_drag_box.ul.y;

   x1 = gb_drag_box.lr.x;
   y1 = gb_drag_box.lr.y;

   if (gb_drag_from_center) {
      x0 = x0*2 - x1;
      y0 = y0*2 - y1;
   }

   if (x0 > x1) { int temp = x0; x0 = x1; x1 = temp; }
   if (y0 > y1) { int temp = y0; y0 = y1; y1 = temp; }

   MouseLock++;
   compose_cursor(CURSOR_UNDRAW); 

   gr_box(x0,y0,x1,y1);

   compose_cursor(CURSOR_DRAW);
   MouseLock--;


}

void gb_update_box(int camera)
{
   int old_fill;
   bool draw_new;

   if (abs(gb_drag_box.lr.x-gb_drag_box.ul.x) < 2
        && abs(gb_drag_box.lr.y-gb_drag_box.ul.y) < 2)
      draw_new = FALSE;
   else
      draw_new = TRUE;

   if (gb_currently_drawn || draw_new) 
   {
      vm_set_region_canvas(camera);
      old_fill = gr_get_fill_type();
      gr_set_fill_type(FILL_XOR);
      gr_set_fcolor(guiStyleGetColor(NULL,StyleColorWhite)); 

      gb_box();

      gr_set_fill_type(old_fill);
      vm_unset_region_canvas();
      gb_currently_drawn = !gb_currently_drawn;
   }
}

#define DEF_DRAG_TOLERANCE 3

int gb_end_box(int camera)
{
   int drag_tol=DEF_DRAG_TOLERANCE;
   config_get_int("drag_tol",&drag_tol);

   if (config_is_defined("drag_scroll"))
      drag_cleanup(camera);

   if (gb_currently_drawn)
      gb_update_box(camera);

   if (abs(gb_drag_box.lr.x-gb_drag_box.ul.x) <= drag_tol ||
       abs(gb_drag_box.lr.y-gb_drag_box.ul.y) <= drag_tol)
      return -1;
   else {
      return vm_map_screen_to_world(camera, &gb_end,
                           gb_drag_box.lr.x, gb_drag_box.lr.y);
   }
}

uiMouseEvent *gb_mouse_event(uiEvent *ev, int camera)
{
   uiMouseEvent *mev = (uiMouseEvent *) ev;
   int x,y;
   x = mev->pos.x;
   y = mev->pos.y;
   vm_mouse_relativize(camera, &x, &y);
   if (!gb_currently_drawn) {
      gb_drag_box.lr.x = x;
      gb_drag_box.lr.y = y;
   }
   if (config_is_defined("drag_scroll"))
      drag_scroll(camera, x, y);
   mev->pos.x = x;
   mev->pos.y = y;
   return mev;
}

#define ismouse(ev) ((ev).type & (UI_EVENT_MOUSE | UI_EVENT_MOUSE_MOVE))
#define iskbd(ev)   ((ev).type == UI_EVENT_KBD_COOKED)

void select_brush(int camera, int x, int y);

#define is_Geom(type) \
 ((type==brType_TERRAIN)||(type==brType_ROOM)|| \
   (type==brType_FLOW)||(type==brType_HOTREGION))

static BOOL typeCompat(int old_type, int new_type)
{
   if (old_type==new_type)
      return TRUE;
   if (is_Geom(old_type)&&is_Geom(new_type))
      return TRUE;
   return FALSE;
}

void finishNewBrush(int xtra_axis, mxs_vector *p0, mxs_vector *p1)
{
   int i, new_type=gedit_default_brush_type();
   editBrush *us=blistGet(), *tmp;
   if (new_type==brType_TERRAIN)
      tmp=brushInstantiate(DEF_PRIMAL);
   else
      tmp=brushInstantiate(0); // we arent terrain, so primal 0
   for (i=0; i<3; i++)
      if (xtra_axis==i)    // bonus axis, look at current brush
      {
         if ((us!=NULL)&&typeCompat(brushGetType(us),new_type))
         {                 // broken if current is not our type!
            tmp->sz.el[i]=us->sz.el[i];
            tmp->pos.el[i]=us->pos.el[i];
         }
         else
         {
            tmp->sz.el[i]=1.0;
            if (us!=NULL)
               tmp->pos.el[i]=us->pos.el[i];            
         }
      }
      else
      {
         tmp->sz.el[i]=fabs(p0->el[i]-p1->el[i])/2.0;
         tmp->pos.el[i]=(p0->el[i]+p1->el[i])/2;
      }
   gedit_full_create_brush(tmp,us,GEDIT_CREATE_AT_END,new_type);
   vBrush_NewBrush(tmp);
}

#define DRAGOP_ABORT (-1)
#define DRAGOP_NOP   ( 0)
#define DRAGOP_DIDIT ( 1)

// -1 abort, 0 no brush, 1 new brush
int do_modal_drag_create(int camera, int x, int y)
{
   int rv;
   uiEvent ev;

   if (!modal_ui_start(MODAL_CHECK_LEFT))
      return DRAGOP_ABORT;

   Status("Drag to create; ESC to abort");
   gb_start_box_corner(camera, x, y);
   if (config_is_defined("drag_scroll"))
      drag_setup(camera);

   for(;;) {
      modal_ui_update();

      while (modal_ui_get_event(&ev)) {
         if (ismouse(ev)) {
            uiMouseEvent *mev = gb_mouse_event(&ev, camera);
            if (mev->action & MOUSE_LUP)
               goto mouse_up;
         } else if (iskbd(ev)) {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               goto esc;
         }
      }
      gb_update_box(camera);
   }

mouse_up:
   rv = gb_end_box(camera);
   if (rv >= 0)
      finishNewBrush(rv, &gb_start, &gb_end);
   modal_ui_end();
   return rv >= 0 ? DRAGOP_DIDIT: DRAGOP_NOP;

esc:
   gb_end_box(camera);
   modal_ui_end();
   return DRAGOP_ABORT;
}

#define CAM_SCALE_FAC (5.0)

static mxs_vector vb_delta;
mxs_vector *get_vbrush_delta(editBrush *us)
{
   if (brSelect_Flag(us)==brSelect_VIRTUAL)
   {
      editBrush *focus_br=vBrush_GetSel();
      mx_sub_vec(&vb_delta,&focus_br->pos,&us->pos);
   }
   else
      mx_zero_vec(&vb_delta);
   return &vb_delta;
}

static void keep_val_in_range(floatSlider *s)
{
   if ((*s->val)<s->lo) s->lo=*s->val;
   if ((*s->val)>s->hi) s->hi=*s->val;
}

// TODO: these compute s->scale idiotically
void *brushVSsetupCameraPos(int camera, floatSlider *s, editBrush *us, int axis, float scale)
{
   mxs_vector ul, lr, *delta;
   int w,h;
   
   VSliderfloatBuild(s);
   s->val=&us->pos.el[axis];
   vm_camera_scr_size(camera, &w, &h);
   vm_map_screen_to_world(camera,&ul,0,0);
   vm_map_screen_to_world(camera,&lr,w-1,h-1);
   delta=get_vbrush_delta(us);
   if (config_is_defined("drag_unbounded"))
   {
      s->lo = s->hi = 0;
      // goddamn this number is bogus
      s->scale*=100*scale;
   }
   else
   {
      s->lo=ul.el[axis]-delta->el[axis];
      s->hi=lr.el[axis]-delta->el[axis];
      //   s->scale*=CAM_SCALE_FAC*(s->hi-s->lo)/(float)w;
      s->scale*=6*scale;
      if (s->lo>s->hi)
       { float tmp=s->hi; s->hi=s->lo; s->lo=tmp; }
      //   mprintf("set %g (old %g) (from %g %g %d)\n",s->scale,6*scale,s->lo,s->hi,w);
      // ok, these need to be constrained to keep the val in them
      keep_val_in_range(s);
   }
   return (void *)s;
}

void *brushVSsetupPos(floatSlider *s, editBrush *us, int axis, float scale)
{
   VSliderfloatBuild(s);
   s->val=&us->pos.el[axis];
   if (config_is_defined("drag_unbounded"))
   {
      s->lo = s->hi = 0;
      // goddamn this number is bogus
      s->scale*=100*scale;
   }
   else
   {
      // ok, these need to be constrained to keep the val in them
      s->lo=us->pos.el[axis]-128*fabs(scale);  // should pick based on current zoom
      s->hi=us->pos.el[axis]+128*fabs(scale);
      s->scale*=6*scale;
      keep_val_in_range(s);
   }
   return (void *)s;
}

void *brushVSsetupSz(floatSlider *s, editBrush *us, int axis, float scale)
{
   VSliderfloatBuild(s);
   s->val=&us->sz.el[axis];
   if (config_is_defined("drag_unbounded"))
   {
      s->lo = s->hi = 0;
      // goddamn this number is bogus
      s->scale*=100*scale;
   }
   else
   {
      s->lo=0.0;
      s->hi=128*fabs(scale);
      s->scale*=6*fabs(scale);
      keep_val_in_range(s);
   }
   return (void *)s;
}

void *brushVSsetupAng(fixangSlider *s, editBrush *us, int axis)
{
   VSliderfixangBuild(s);
   s->val=&us->ang.el[axis%3];
   s->lo=0;
   s->hi=0;
   s->scale*=65536.0/32.0;     // ???????
   if (axis>=3) s->scale*=-1;
   return (void *)s;
}

#define SHIFT_STATES (KBM_LSHIFT|KBM_RSHIFT)
#define CTRL_STATES  (KBM_LCTRL|KBM_RCTRL)
#define ALT_STATES   (KBM_LALT|KBM_RALT)
#define ALL_STATES   (SHIFT_STATES|CTRL_STATES|ALT_STATES)

// in killme.c.  should fix this to be right
extern int hack_for_kbd_state(void);

// reads and returns DRAGOP_ codes
static int check_create(int camera, int x, int y)
{
   int kb_mods=hack_for_kbd_state();

   if ((kb_mods&ALL_STATES)==0)
   {
      int rv=do_modal_drag_create(camera,x,y);
      Status("");
      if (rv==DRAGOP_DIDIT)
         i_changed_the_brush(blistGet(),TRUE,TRUE,FALSE);
      return rv;
   }
   return DRAGOP_NOP;
}

// called for down events in move mode, returns whether to select
int do_brush_virtual_slider(int camera, int x, int y, bool on_axis)
{
   editBrush *us=vBrush_editBrush_Get();
   int i,j,axis[2]={-1,-1};
   float scale[2];
   void *sliders[2];
   floatSlider axsliders[2];
   fixangSlider angslider[2];
   mxs_vector axv[2];
   BOOL do_update=FALSE;
   BOOL move_mode = FALSE;
   int num_axis=1;      // default to one axis
   int kb_mods=hack_for_kbd_state();
   int vslider_ret;

   if ((kb_mods&ALL_STATES)==0)
      return DRAGOP_NOP;

   if (kb_mods&ALT_STATES)
   {
      if ((axis[0]=vm_normal_axis(camera))==-1)
         return DRAGOP_NOP;        // not in a 2d mode, this is a problem
      Status("Drag to rotate brush");
      if (!on_axis)
      {
         num_axis=2;
         sliders[0]=brushVSsetupAng(&angslider[0],us,(axis[0]+1)%6);
         sliders[1]=brushVSsetupAng(&angslider[1],us,(axis[0]+2)%6);
      }
      else
      {
         num_axis=1;
         sliders[0]=brushVSsetupAng(&angslider[0],us,axis[0]);
      }
   }
   else
   {  // returns the size, in world space, of a pixel
      if (!vm_screen_axes(camera,&axv[0],&axv[1]))   // hmmm
         return DRAGOP_NOP;  // was abort   // not in a 2d mode, that is a problem
      else                                   // interp axis
      {
         if (!on_axis)
         {
            num_axis=1;
            axis[0]=vm_normal_axis(camera);
            scale[0]=mx_mag_vec(&axv[0]);
         }
         else
         {
            num_axis=2;
            for (i=0; i<num_axis; i++)
            {
               mxs_vector *v=&axv[i];
               for (j=0; j<3; j++)
                  if (v->el[j]!=0)
                     break;
               if (j<3)
               {
                  axis[i]=j;
                  scale[i]=v->el[j];  // want to multiply by size of region, right?
               }
            }
         }
      }
      if (kb_mods&CTRL_STATES) {
         Status("Drag to stretch brush");
         for (i=0; i<num_axis; i++)
            sliders[i]=brushVSsetupSz(&axsliders[i],us,axis[i],scale[i]);
      } else {
         Status("Drag to move brush");
         move_mode = TRUE;
         for (i=0; i<num_axis; i++)
            sliders[i]=brushVSsetupCameraPos(camera,&axsliders[i],us,axis[i],scale[i]);
      }
   }  // now lets actually go do it
   editUndoStoreStart(us);
   // here is the slow setup thing, where the mouse might go up, really
   // @BUG: up event happens during redraw, then vslide punts, then we return NOP and select...
   gedit_setup_check_lazy_drag();
   dragbox_br=us;
   vslider_ret=virtual_slider(num_axis,sliders,brush_vs_update);
   if (vslider_ret==VSLIDER_CHANGED)
   {
      do_update=TRUE;
      i_changed_the_brush(us,do_update,FALSE,FALSE);
   }
   gedit_finish_check_lazy_drag();
   editUndoStoreBrush(us);
   Status("");
   
   if (vslider_ret==VSLIDER_ABORTED)
      return DRAGOP_ABORT;                       // abort means punt the event
   else
      return do_update?DRAGOP_DIDIT:DRAGOP_NOP;  // NOP means treat it as select
}

void select_brush(int camera, int x, int y)
{
   int kb_mods=hack_for_kbd_state(), flags=0;
   if (vm_get_3d(camera))         flags|=GEDIT_CLICK_IS3D;
   if ((kb_mods&SHIFT_STATES)!=0) flags|=GEDIT_CLICK_VBRUSH;
   if ((kb_mods&ALT_STATES)!=0)   flags|=GEDIT_CLICK_FANCY;
   if (gedit_click(flags,x,y,camera))
      Status("Selected brush");
   else
      Status("No brush found");
}
   
// returns FALSE if it wants the caller to do something with the event
bool brush_edit_mouse(uiMouseEvent *mev, int camera, int x, int y)
{
   if (mev->action&UI_MOUSE_LDOUBLE)
      select_brush(camera, x, y);
   else if (mev->action & (MOUSE_RDOWN|MOUSE_LDOWN))
   {
      bool left_button=mev->action&MOUSE_LDOWN;
      if (left_button)                 // left can do more stuff
         if (check_create(camera,x,y)!=DRAGOP_NOP) // NOP, so try vslide or select
            return TRUE;                 //  else we did or aborted, so we are done
      if (do_brush_virtual_slider(camera,x,y,left_button)==DRAGOP_NOP)
         if (mev->action&MOUSE_RDOWN)  // right button slides or menus
            return FALSE;       // go do the menu in viewmanager on right button
         else                          // the left buttons case can do a select
            select_brush(camera, x, y);
   }
   return TRUE;
}
// $Header: r:/t2repos/thief2/src/editor/dragbox.h,v 1.2 2000/01/29 13:11:27 adurant Exp $
#pragma once

#ifndef __DRAGBOX_H
#define __DRAGBOX_H
#include <editbr.h>
#include <vslider.h>

EXTERN void* brushVSsetupSz(floatSlider *s, editBrush* br, int axis, float scale);
EXTERN void* brushVSsetupPos(floatSlider *s, editBrush* br, int axis, float scale);
EXTERN void* brushVSsetupAng(fixangSlider *s, editBrush* br, int axis);

#endif // __DRAGBOX_H
// $Header: r:/t2repos/thief2/src/editor/edinhst.h,v 1.4 2000/01/29 13:11:28 adurant Exp $
#pragma once

//
// Inheritance editor structures
//

#ifndef __EDINHST_H
#define __EDINHST_H

#include <objtype.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commctrl.h>

//
// Inheritance Editor Flags (part of the editor descriptor)
//

enum _eInheritanceEditorFlags 
{
   kInheritanceEditNone = 0,     // no flags for now
};

// 
// Inheritance Editor Descriptor
//

struct InheritanceEditorDesc 
{
   char title[32]; // Title string appearing at top of gadget;
   eInheritanceEditorFlags flags;
};

//
// Inheritance Editor
//

struct InheritanceEditor
{
   InheritanceEditorDesc   editdesc;
   int                     mode;          // are we viewing archetypes or metaproperties?
   BOOL                    in_progress;
   BOOL                    show_concrete;
   ObjID                   root_archetype;
   HWND                    hWnd;
   HWND                    hMainWnd;
   HINSTANCE               hInst;
   HWND                    hWndTree;
   HWND                    hWndCreateButton;    // so we can disable it later
   HTREEITEM               hRootItem;
   ObjID                   sel_archetype, sel_metaproperty;    // what were they looking at last?
   BOOL                    dragging;      // are we dragging something?
   HTREEITEM               drag_item;     // what are we dragging?
   HFONT                   hWndFont;
};

#endif // __EDINHST_H
// $Header: r:/t2repos/thief2/src/editor/edinhtyp.h,v 1.2 2000/01/29 13:11:29 adurant Exp $
#pragma once

#ifndef __EDINHTYP_H
#define __EDINHTYP_H

//
// Inheritance editor forward declarations
//

// various enums for flags and field types
typedef ulong eInheritanceEditorFlags;

// actual structures used when describing structures
typedef struct InheritanceEditor InheritanceEditor;
typedef struct InheritanceEditorDesc InheritanceEditorDesc;

#endif // __EDINHTYP_H
// $Header: r:/t2repos/thief2/src/editor/editapp.c,v 1.50 2000/02/19 12:27:57 toml Exp $

#include <string.h>
#include <ctype.h>

#include <aggmemb.h>
#include <appagg.h>
#include <config.h>
#include <memstat.h>

#include <editapp.h>
#include <gameapp.h>
#include <editmode.h>
#include <init.h>
#include <contexts.h>
#include <command.h>
#include <cmdterm.h>
#include <gen_bind.h>
#include <status.h>
#include <cfgtool.h>
#include <viewmgr.h>
#include <resapp.h>
#include <preload.h>
#include <objedit.h>
#include <uiedit.h>
#include <ged_room.h>
#include <fvaredit.h>
#include <scrnedit.h>

#include <prof.h>
#include <motedit.h> // for motedit_cmd

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// Should this be here?  Probably not
void MonoDebug (void)
{
   DbgMonoConfig ();
}

////////////////////////////////////////////////////////////
// Constants
//

static const GUID* my_guid = &IID_Editor;
static char* my_name = "Editor Init";
static int my_priority = kPriorityNormal;
#define MY_CREATEFUNC EditorSysCreate

////////////////////////////////////////////////////////////
// INIT FUNC
//

void edit_setup_commands(void);

#pragma off(unreferenced)
static STDMETHODIMP _InitFunc(IUnknown* goof)
{
   extern void setup_gfh_commands(void);

   setup_gfh_commands();
   vm_init();
   vm_init_cameras();
   ged_room_init();
   initProfiler();
   edit_setup_commands();
   history_start();
   ObjEditInit();
   FileVarEditInit(); 
   ScrnEditInit(); 

   return kNoError;
}
#pragma on(unreferenced)

//////////////////////////////////////////////////////////////
// SHUTDOWN FUNC
//

#pragma off(unreferenced)
static STDMETHODIMP _ShutdownFunc(IUnknown* goof)
{
   vm_term();
   preload_free_all();
   history_free_all();
   ScrnEditTerm(); 

   return kNoError;
}
#pragma on(unreferenced)

////////////////////////////////////////////////////////////
// CONSTRAINTS
//

static sRelativeConstraint _Constraints[] =
{
   { kConstrainBefore, &IID_Game},
   { kConstrainAfter,  &IID_Res},
   { kNullConstraint, }
};

////////////////////////////////////////////////////////////
// Commands
//

extern void enter_edit_mode(char*);


EXTERN void texture_pal_cmd(void);

static Command commands[] =
{
   { "edit_mode", FUNC_STRING, enter_edit_mode, "Switch to editor mode: edit_mode <wid>,<hgt>", HK_ALL},
   { "mono_debug", FUNC_VOID, MonoDebug, "Enter monochrome debug screen", HK_ALL},
   { "texture_pal", FUNC_VOID, texture_pal_cmd, "Bring up the texture palette", HK_EDITOR}, 
   { "motedit", FUNC_VOID, motedit_cmd, "Bring up the motion editor", HK_EDITOR}, 
   { "redraw_all", FUNC_VOID, redraw_all_cmd, "Redraw the editor screen", HK_EDITOR}, 
   CONFIG_SET_CMD("set"),
   CONFIG_GET_CMD("get"),
   CONFIG_EVAL_CMD("eval"),
   CONFIG_IFDEF_CMD("ifdef"),
   CONFIG_IFNDEF_CMD("ifndef"),
   CONFIG_UNSET_CMD("unset"),

};

void edit_setup_commands(void)
{
   COMMANDS(commands,HK_ALL);
}

////////////////////////////////////////////////////////////
// Everything below here is boiler plate code.
// Nothing needs to change, unless you want to add postconnect stuff
////////////////////////////////////////////////////////////

#pragma off(unreferenced)
static STDMETHODIMP NullFunc(IUnknown* goof)
{
   return kNoError;
}
#pragma on(unreferenced)

#pragma off(unreferenced)
static void STDMETHODCALLTYPE FinalReleaseFunc(IUnknown* goof)
{
}
#pragma on(unreferenced)

//////////////////////////////////////////////////////////////
// SysCreate()
//
// Called during AppCreateObjects, adds the uiSys system anonymously to the
// app aggregate
//

static struct _init_object
{
   DECLARE_C_COMPLEX_AGGREGATE_CONTROL();
} InitObject;

void LGAPI MY_CREATEFUNC(void)
{
   sAggAddInfo add_info = { NULL, NULL, NULL, NULL, 0, NULL} ;
   IUnknown* app = AppGetObj(IUnknown);
   INIT_C_COMPLEX_AGGREGATE_CONTROL(InitObject,
               FinalReleaseFunc,    // on final release
               NullFunc,      // connect
               NullFunc,      // post connect
               _InitFunc,     // init
               _ShutdownFunc,    // end
               NullFunc);     // disconnect
   add_info.pID = my_guid;
   add_info.pszName = my_name;
   add_info.pControl = InitObject._pAggregateControl;
   add_info.controlPriority = my_priority;
   add_info.pControlConstraints = _Constraints;
   _AddToAggregate(app,&add_info,1);
   SafeRelease(InitObject._pAggregateControl);
   SafeRelease(app);
}
// $Header: r:/t2repos/thief2/src/editor/editapp.h,v 1.2 2000/01/29 13:11:30 adurant Exp $
#pragma once

#ifndef __EDITAPP_H
#define __EDITAPP_H


EXTERN void LGAPI EditorSysCreate(void);
DEFINE_LG_GUID(IID_Editor, 0x28);


#endif // __EDITAPP_H

// $Header: r:/t2repos/thief2/src/editor/editbr.c,v 1.53 2000/02/19 12:27:58 toml Exp $

// Brush Manager (editbr.c)
//    this system manages the creation, parameterization, and modification
// of a single brush structure.  this includes any edits to the media, 
// surface textures/parameters, sizing and stretching of the brush
// itself.  this does not include brush lists or construction.  

#include <stdlib.h>
#include <io.h>
#include <rand.h>

#include <lg.h>
#include <lgassert.h>
#include <hheap.h>
#include <mprintf.h>
#include <command.h>

#include <uiedit.h>     // get color fixup code

#include <editbr.h>
#include <brlist.h>
#include <editbr_.h>
#include <brinfo.h>
#include <primal.h>

#include <ged_rmap.h>
#include <csgbrush.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define DEF_SIZE 2.0
#define DEF_MEDIA 1

// no id, rot 0, scale 4 (magic), u,v at 0
TexInfo defTexInf={-1,0,16,0,0};

static HheapHead brushHeap;
static int brushNextID=1;


#define DBG_BRUSHALLOC
#ifdef DBG_BRUSHALLOC
#define AllocBrush()    Malloc(sizeof(editBrush))
#define FreeBrush(br)   Free(br)
#else
#define AllocBrush()    HheapAlloc(&brushHeap)
#define FreeBrush(br)   HheapFree(&brushHeap,br)
#endif 

// sets the current heap for the brush system to use
void brushSysInit(void)
{
   primalBr_Init();
   HheapInit(&brushHeap,sizeof(editBrush),128,TRUE);
   brushNextID=0;
}

// sets the current heap for the brush system to use
void brushSysFree(void)
{
#ifdef DBG_ON
   int cnt=HheapGetNumItems(&brushHeap);
   if (cnt!=0)
      Warning(("Freeing Brush Sys with %d alloced brushes\n",cnt));
#endif   
   HheapFreeAll(&brushHeap);
   primalBr_Term();   
}

// instantiates a copy of brush_id into the edit buffer
// for now, we have no idea what brush_id is, so i always pretend its a cube?
void brushZero(editBrush *curBrush, int primal_brush)
{
   int i;

   curBrush->pos.el[0]=0.0;
   curBrush->pos.el[1]=0.0;
   curBrush->pos.el[2]=0.0;
   curBrush->ang.el[0]=0.0;
   curBrush->ang.el[1]=0.0;
   curBrush->ang.el[2]=0.0;
   curBrush->sz.x=DEF_SIZE;
   curBrush->sz.y=DEF_SIZE;
   curBrush->sz.z=DEF_SIZE;
   curBrush->tx_id=0;
   curBrush->media=DEF_MEDIA;

   curBrush->flags = kEBF_None;

   if (brushNextID>=MAX_CSG_BRUSHES)
   {
      Warning(("Compressing BrushID Space - remember this happened if you crash\n"));
      brushNextID=ged_remap_brushes();
   }

   curBrush->br_id=brushNextID++;      // this is so every brush has a unique
   curBrush->grid.grid_enabled=FALSE;  // id.  it only has to be valid from one
                             // portalization to the next, so it resets on load
   curBrush->primal_id = primal_brush;

   if (primalBr_FaceCnt(primal_brush)>EDITBR_MAX_FACES)
   {
      Warning(("Will break on %d (%d)\n",primal_brush,primalBr_FaceCnt(primal_brush)));
      curBrush->num_faces = EDITBR_MAX_FACES;
   }
   else
      curBrush->num_faces = primalBr_FaceCnt(primal_brush);
   
   curBrush->cur_face  = -1;
   for (i=0; i<curBrush->num_faces; i++)
      curBrush->txs[i]=defTexInf;  // uses global info, sets scale and rot

   curBrush->edge=0;
   curBrush->point=0;
   curBrush->use_flg=0;
   curBrush->group_id=0;

   curBrush->pad0=0;
}

// if primal_brush==DEF_PRIMAL use the global
int editbr_default_primal=PRIMAL_CUBE_IDX;
editBrush *brushInstantiate(int primal_brush)
{
   editBrush *curBrush=AllocBrush();
   if (primal_brush==DEF_PRIMAL)
      primal_brush=editbr_default_primal;
   brushZero(curBrush,primal_brush);
   return curBrush;
}

// this copies a brush into a newly allocated brush, ie. one with a new br_id
editBrush *brushCopy(editBrush *srcBrush)
{
   editBrush *dstBrush;

   dstBrush=AllocBrush();
   *dstBrush=*srcBrush;
   dstBrush->br_id=brushNextID++;
   return dstBrush;
}

// delete a brush - this doesnt get it out of list first, so you had better
bool brushDelete(editBrush *curBrush)
{
#ifdef DBG_ON
   if (blistCheck(curBrush)!=-1)
   {
      Warning(("Hey, brush %x in the current brushlist\n",curBrush));
      return FALSE;
   }
#endif
   FreeBrush(curBrush);
   return TRUE;
}

void brushClearAll(void)
{
   editBrush *brtoasted;
   CommandExecute ("unlock_all");
   while ((brtoasted=blistDelete())!=NULL)
      brushDelete(brtoasted);
   brushNextID=1;
}

bool brushWritetoFile(editBrush *brdata, int out_hnd)
{
   int sz = sizeof(editBrush) - EDITBR_MAX_FACES * sizeof(TexInfo);
   if (brushGetType(brdata)==brType_TERRAIN)
      sz+=brdata->num_faces * sizeof(TexInfo);
   return write(out_hnd,brdata,sz)==sz;
}

// warning, this returns the same address every time, really
// ie. it assumes you will then copy it to somewhere useful
editBrush *brushReadfromFile(int in_hnd)
{
   static editBrush brdata;
   int sz = sizeof(editBrush) - EDITBR_MAX_FACES * sizeof(TexInfo);
   
   if (read(in_hnd,&brdata,sz)==sz)
   {
      if (brushGetType(&brdata)==brType_TERRAIN)
         read(in_hnd,&brdata.txs,sizeof(TexInfo)*brdata.num_faces);
      return &brdata;
   } else
      return NULL;
}

editBrush *oldbrushReadfromFile(int in_hnd)
{
   static editBrush brdata;
   int sz = sizeof(editBrush) - EDITBR_MAX_FACES * sizeof(TexInfo);
   
   if (read(in_hnd,&brdata,sz)==sz)
   {
      if (brushGetType(&brdata)==brType_TERRAIN)
         read(in_hnd,&brdata.txs,sizeof(TexInfo)*brdata.num_faces);
      else
         lseek(in_hnd,sizeof(TexInfo)*brdata.num_faces,SEEK_CUR);
      return &brdata;
   } else
      return NULL;
}

// set the type of a brush, knows about the secret negative thing
int brushSetType(editBrush *br, int type)
{
   if (type!=brType_TERRAIN)
      br->media=-type;
   else if (br->media<0)
      br->media=1;
   return br->media;
}

// get the type of a brush
int brushGetType(editBrush *br)
{
   return ((br)->media>0)?brType_TERRAIN:-(br)->media;
}
// $Header: r:/t2repos/thief2/src/editor/editbr.h,v 1.17 2000/01/29 13:11:31 adurant Exp $
#pragma once

//
// Brush Manager (editbr.h)
//    this system manages the creation, parameterization, and modification
// of a single brush structure.  this includes any edits to the media, 
// surface textures/parameters, sizing and stretching of the brush
// itself.  this does not include brush lists or construction.  
//    - struct editBrush
//    * editBrush *brushInstantiate(int brush_id)
//        instantiates a copy of brush_id into the edit buffer
//    * bool brushReload(editBrush *curBrush)
//        reloads the brush with parameters in editBrush
//    * bool brushDraw(editBrush *curBrush)
//        assumes we are in an edit3d context, i guess.  hmmmmm...
//

#ifndef __EDITBR_H
#define __EDITBR_H

//////////////////////////  - split this file
// basic brush system functions/support

#include <matrixs.h>
#include <editbrs.h>

// misc constants for use in picks - distance to virtual infinity
#define DISTANCE_INF     (1.0e20)

// sets the current heap for the brush system to use
EXTERN void brushSysInit(void);

// sets the current heap for the brush system to use
EXTERN void brushSysFree(void);

// zeroes all the data in an editBrush to that primal_brush
EXTERN void brushZero(editBrush *curBrush, int primal_brush);

// instantiates a copy of brush_id into the edit buffer
#define DEF_PRIMAL (-1)
EXTERN editBrush *brushInstantiate(int brush_id);
EXTERN int editbr_default_primal;  // if you need to set this, but really, for gedit

// makes a copy of the srcBrush into edit buffer/cur brush
EXTERN editBrush *brushCopy(editBrush *srcBrush);

// delete a brush - better get it out of list first
EXTERN bool brushDelete(editBrush *curBrush);

// goes through and clears and frees all brushes in memory
EXTERN void brushClearAll(void);

// file access stuff, assumes fp is pointing at data to do, FALSE if fails
EXTERN bool brushWritetoFile(editBrush *brdata, int out_hnd);

// warning, this returns the same address every time
// returns NULL if nothing else in file
// the idea is that you will copy the data out into your own real space
EXTERN editBrush *brushReadfromFile(int in_hnd);

#endif  // __EDITBR_H
// $Header: r:/t2repos/thief2/src/editor/editbrs.h,v 1.4 2000/01/29 13:11:32 adurant Exp $
// if you just need to know about editBrushes
#pragma once

#ifndef __EDITBRS_H
#define __EDITBRS_H

typedef struct _editBrush editBrush;
typedef struct _TexInfo   TexInfo;

#endif  /* __EDITBRS_H */
// $Header: r:/t2repos/thief2/src/editor/editbr_.h,v 1.7 2000/01/29 13:11:33 adurant Exp $
#pragma once

#ifndef ___EDITBR_H
#define ___EDITBR_H

// MUST UPDATE CSGBRUSH.H if this CHANGES

#include <matrixs.h>
#include <editbrs.h>
#include <gridsnap.h>
#include <fix.h>

// _editbr.h
//  internals for edit brush
//  really just the actual structure

// this is for scale tx_scale to the floats needed by CSG
//  (we use it for the grid scale too, just for fun)

// wacky support for zany pow2 integer to float scale stuff
#define scale_pow2int_to_float(pow2i) (((float)(1<<pow2i))*(4.0/(float)(1<<16)))

#define TEXINFO_HACK_ALIGN 1  // for now, how you specify rotate to brush

struct _TexInfo
{
   short tx_id;
   fixang tx_rot;

   short tx_scale;
   
   ushort tx_x;
   ushort tx_y;
};

extern struct _TexInfo defTexInf;

enum eEditBrushFlags
{
   kEBF_None          = 0x00,
   kEBF_BeingDeleted  = 0x01,
};

#define EDITBR_MAX_FACES 12

struct _editBrush
{
      // 8
   short br_id;         // the unique runtime brush id, for CSG->brush mapping
   short timestamp;     // timestamp, filled in at CSG/build time
   int primal_id;       // what shape this is, 0==cube

      // 4
   short tx_id;         // what texture to use by default
   char  media;         // what the magic media code is
   char  flags;         // reserved for expansion

      // 24
   mxs_vector pos;      // center of the brush, for now
   mxs_vector sz;       // extents of brush

      // 8
   mxs_angvec ang;      // angular locale of brush
   short cur_face;      // after the above for alignment

      // 24
   Grid grid;
   uchar num_faces;     // number of elements in the following data

      // 8
   char edge;           // used to be "int pad0, pad1" in version <= 1.0
   char point;
   char use_flg;
   char group_id;
   int pad0;            // should we set edge and point count here? or imply?

      // ???
   TexInfo txs[EDITBR_MAX_FACES]; // textures for each face of the brush
                             // this is actually only as long as it needs
                             // to be (according to num_faces),
};

#endif
// $Header: r:/t2repos/thief2/src/editor/editgeom.c,v 1.130 2000/02/19 13:10:33 toml Exp $

// test code for geometry editor
// parses camera control keys, calls outer 3d stuff
// calls to gedit for most real stuff, i think

#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <lg.h>
#include <mprintf.h>
#include <res.h>
#include <2dres.h>
#include <r3d.h>
#include <event.h>
#include <kb.h>
#include <kbcook.h>
#include <config.h>
#include <g2pt.h>

#include <portal.h>
#include <pt.h>

#include <command.h>
#include <status.h>

#include <editbr.h>
#include <brlist.h>
#include <gedit.h>
#include <media.h>

#include <viewmgr.h>

#include <loopapi.h>
#include <dispatch.h>
#include <dispbase.h>
#include <dbasemsg.h>
#include <vismsg.h>
#include <loopmsg.h>

#include <scrnman.h>
#include <scrnloop.h>
#include <editgeom.h>
#include <gamecam.h>
#include <palette.h>
#include <brloop.h>
#include <undoredo.h>

#include <editgeo_.h>
#include <uiapp.h>
#include <objloop.h>
#include <mipmap.h>
#include <family.h>
#include <appsfx.h>
#include <plyrloop.h>
#include <prof.h>
#include <editbr_.h> // for creating initial level
#include <ged_room.h>

#include <lresname.h>
#include <texmem.h>

#include <wrloop.h>

#include <dbfile.h>
#include <dbasemsg.h>
#include <render.h>

    // hacked data file
#include <texture.h>

extern BOOL g_null_raster;

mxs_vector player_pos;
static mxs_angvec player_ang;

int scale_factor=4;

bool single_step=TRUE;

bool scene_setup(void)
{
   editBrush* tmp;

   player_pos.el[0]=0; player_pos.el[1]=0; player_pos.el[2]=0;
   player_ang.tx=player_ang.ty=player_ang.tz=0;

   tmp=brushInstantiate(DEF_PRIMAL);
   tmp->sz.el[0]*=4;
   tmp->sz.el[1]*=4;
   tmp->sz.el[2]*=4;
   tmp->tx_id=0;
   blistInsert(tmp);
   return TRUE;
}

mxs_vector last_left, last_up, last_forward;

void print_info(int vol)
{
   char *p;
   while ((p = portal_scene_info(vol)) != 0)
      mprintf("%s\n", p);
}

bool spotlight=FALSE;

#define SF   (scale_factor * 0.125)

static float editor_3d_speed_fac = 1.0;

void slew(int x)
{
   mxs_vector temp;

   temp.x = 0;
   temp.y = 0;
   temp.z = 0;

   ((mxs_real *) &temp) [ x % 3 ] = 3.0 * 0.0625 * editor_3d_speed_fac * scale_factor * (x >= 3 ? -1 : 1);
   vm_cur_slew(&temp);
}

void rot(int x)
{
   mxs_angvec temp;

   temp.tx = 0;
   temp.ty = 0;
   temp.tz = 0;

   ((mxs_ang *) &temp) [ x % 3 ] = 3.0 * 0x0100 * editor_3d_speed_fac * scale_factor * (x >= 3 ? -1 : 1);
   vm_cur_rotate(&temp);
}

void level_cam(void)
{
   vm_cur_level (1);
}

void unroll_cam(void)
{
   vm_cur_level (0);
}

void rescale(bool up)
{
   if (up) {
      if (scale_factor<1024) { scale_factor*=2; vm_scale_all(2.0); }
   } else {
      if (scale_factor>1)    { scale_factor/=2; vm_scale_all(0.5); }
   }
}


void decode_scroll(int x)
{
   switch(x) {
      case 7: vm_cur_scroll(-SF, -SF); break;
      case 8: vm_cur_scroll(  0, -SF); break;
      case 9: vm_cur_scroll( SF, -SF); break;
      case 4: vm_cur_scroll(-SF,   0); break;
      case 5: vm_cur_scroll(  0,   0); break;
      case 6: vm_cur_scroll( SF,   0); break;
      case 1: vm_cur_scroll(-SF,  SF); break;
      case 2: vm_cur_scroll(  0,  SF); break;
      case 3: vm_cur_scroll( SF,  SF); break;
   }
};



#define MAX_FAILURES  8192
Location raycast_dest[MAX_FAILURES], raycast_hit[MAX_FAILURES];
Location fail_source;
int failure_count, min_show = 0, max_show = MAX_FAILURES;
extern bool show_raycasts, show_lightmap, record_movement;

void save_failures(Location *hit, Location *dest)
{
   if (failure_count < MAX_FAILURES) {
      raycast_dest[failure_count] = *dest;
      raycast_hit[failure_count++] = *hit;
   }
}

void render_failures(void)
{
   int i;
   r3s_point source, dest, hit;

   r3_transform_point(&source, &fail_source.vec);

   for (i=0; i < failure_count; ++i) {
      if (i >= min_show && i <= max_show) {
         r3_transform_point(&hit, &raycast_hit[i].vec);
         r3_transform_point(&dest, &raycast_dest[i].vec);
         r3_set_color(1);
         if (!record_movement) {
            r3_draw_line(&source, &hit);
            r3_set_color(4);
         }
         r3_draw_line(&hit, &dest);
      }
   }
}


#if 0
extern void (*failed_light_callback)(Location *hit, Location *dest);

extern void portal_add_omni_light_perfect(float x, float y, float z, float br, LightPermanence dynamic);

void raycast_light(void)
{
   mxs_vector *loc;
   mxs_angvec *ang;

   failed_light_callback = save_failures;
   failure_count = 0;

   if (vm_spotlight_loc(&loc, &ang)) {
      MakeLocationFromVector(&fail_source, loc);
      portal_add_omni_light_perfect(loc->x, loc->y, loc->z, 64, LIGHT_DYNAMIC);
   }

   failed_light_callback = 0;
}
#endif

// stolen from Jaemz
void RenDebugShadTab(uchar *shadtab,int numentries)
{
   int i;
   int col,row;
   int x,y;
   uchar *tab;
   int rowsize;
   int w,h;

   w=grd_canvas->bm.w/64;
   h=grd_canvas->bm.h/(4*numentries);

   rowsize=numentries;
   tab=shadtab;

   for (i=0;i<256*rowsize;++i) {
      col = i%256;
      row = i/256;

      x = (col%64)*w;
      y = (col/64)*(h*rowsize+2) + row*h;

      if (tab) {
         gr_set_fcolor(tab[i]);
      } else {
         gr_set_fcolor(i);
      }
      gr_rect(x,y,x+w-1,y+h-1);
   }
}

extern void gedit_busywait(BOOL clear);
static void show_shad_tab(void)
{
   gr_clear(0);
   RenDebugShadTab(gr_get_light_tab(),16);
   gedit_busywait(TRUE);
}

extern float portal_detail_level;
extern int max_draw_polys;

void PickDistanceFunction(int which);  // Declared right below

static Command parse_keys[]=
{
     // local commands
   { "cam_rotate", FUNC_INT, rot, "rotate current camera" },
   { "cam_slew", FUNC_INT, slew, "slew current camera" },
   { "speed_fac", VAR_FLOAT, &editor_3d_speed_fac, "set speed factor of 3d move in editor" },
   { "cam_level", FUNC_VOID, level_cam, "level current camera" },
   { "cam_unroll", FUNC_VOID, unroll_cam, "unroll current camera" },
   { "num_scroll", FUNC_INT, decode_scroll, "scroll via numeric keypad" },
   { "global_scale", FUNC_BOOL, rescale, "zoom in/out & rescale" },

   { "show_raycasts", TOGGLE_BOOL, &show_raycasts, "display light raycasts" },
   { "min_show", VAR_INT, &min_show, "min id# raycast to show" },
   { "max_show", VAR_INT, &max_show, "max id# raycast to show" },
   { "record_movement", TOGGLE_BOOL, &record_movement, "show rays of samples moving" },

     // imported commands
// The following commands should all be registered
// by the systems that provide them, not here, but
// for now we'll just get it working...

   { "cam_spotlight", TOGGLE_BOOL, &spotlight, "mounted spotlight toggle" },
};

// more imported commands that should be in both editor
// and game mode.  obviously this belongs elsewhere.

extern bool surface_cache, skip_clip;
extern bool surf_256;  // false all surfaces to row == 256
extern bool show_span_lengths, show_render_times;
extern bool portal_clip_poly, portal_clip_fast, poly_clip_fast;
extern palette_light, project_space, cache_feedback;
extern float light_scale;
extern float dynamic_light_min;
extern int player_light;
extern int portal_info_volume;
extern bool keep_all_lit;
extern float max_dist_2;
extern float dot_clamp;
extern bool show_cells;
extern bool linear_map;
extern bool portal_model;
extern bool portal_object_complete_test;
extern bool portal_write_traversal;
extern bool show_split;
extern BOOL show_bbox, show_bbox_2d;
extern bool disable_topsort;

#ifndef SHIP
extern BOOL always_slow_split;
#endif

#ifdef LOUD_D3D
#define d3d_talk(x) mprintf x
#else
#define d3d_talk(x)
#endif

#include <lgd3d.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static double z_far = 200.0;
static double z_near = 1.0;

extern void SetZNearFar(double zn, double zf);

extern BOOL g_null_raster;
extern BOOL lgd3d_z_normal;
extern BOOL g_lgd3d;
extern BOOL g_zbuffer; 

static void toggle_null_raster(void)
{
   g_null_raster = !g_null_raster;
   if (g_null_raster)
      r3_use_null();
   else
      if (g_lgd3d)
         r3_use_lgd3d();
      else
         r3_use_g2();
}

extern BOOL pt_aggregate_lightmaps;

static BOOL linear=FALSE;
extern void lgd3d_set_zlinear(BOOL lin);
static void toggle_linear(void)
{
   linear=!linear;
   lgd3d_set_zlinear(linear);
}

static void znup(void)
{
   z_near *= 2.0;
   SetZNearFar(z_near, z_far);
   d3d_talk(("z_near: %g\n", z_near));
}

static void zndown(void)
{
   z_near *= 0.5;
   SetZNearFar(z_near, z_far);
   d3d_talk(("z_near: %g\n", z_near));
}

static void zfup(void)
{
   z_far *= 2.0;
   SetZNearFar(z_near, z_far);
   d3d_talk(("z_far: %g\n", z_far));
}

static void zfdown(void)
{
   z_far *= 0.5;
   SetZNearFar(z_near, z_far);
   d3d_talk(("z_far: %g\n", z_far));
}

extern BOOL lgd3d_punt_d3d;
extern BOOL rendloop_clear;
extern int portal_hack_blend;
extern BOOL portal_test_blend;

#ifndef SHIP
EXTERN void ParticleGroupCountSim(void);
extern int show_particle_counts;
#endif

static Command all_keys[]=
{
   { "blend", VAR_INT, &portal_hack_blend },
   { "test_blend", TOGGLE_BOOL, &portal_test_blend },
   { "traverse_log", TOGGLE_BOOL, &portal_write_traversal,
            "log cell traversal to traverse.log\n" },
   { "clear", TOGGLE_BOOL, &rendloop_clear, "clear framebuffer to pink" },
   { "max_polys", VAR_INT, &max_draw_polys, "maximum polygons to draw" },
   { "show_lightmap", TOGGLE_BOOL, &show_lightmap, "display light sampling" },
   { "render_info", FUNC_INT, print_info, "rendering stats at some volume" },
   { "detail_level", VAR_FLOAT, &portal_detail_level,
           "mipmap detail level (0-1)" },
   { "dot_clamp", VAR_FLOAT, &dot_clamp, "mipmap orientation limit" },
   { "surf_256", TOGGLE_BOOL, &surf_256, "surfaces are all row==256" },
   { "show_span_lengths", TOGGLE_BOOL, &show_span_lengths, 0 },
   { "show_render_times", TOGGLE_BOOL, &show_render_times, "detailed rendering timing info" },
   { "info_volume", VAR_INT, &portal_info_volume, "determine amount of rendering information" },

 // @TODO: optimize
 // when we have shippable levels, test which combination of these three
 // flags is fastest
   { "portal_clip_poly", TOGGLE_BOOL, &portal_clip_poly, 0 },
   { "portal_clip_fast", TOGGLE_BOOL, &portal_clip_fast, 0 },
   { "poly_clip_fast", TOGGLE_BOOL, &poly_clip_fast, 0 },

#ifndef SHIP
   { "always_slow_split", TOGGLE_BOOL, &always_slow_split, "force split objects to do things the hard way" },
   { "show_particle_counts", TOGGLE_INT, &show_particle_counts, "show count of particle sim/render" },
   { "show_particle_sim", FUNC_VOID, ParticleGroupCountSim, "list particle objects set to always_simulate" },
#endif

   { "cache_feedback", TOGGLE_BOOL, &cache_feedback, "get extra surface cache info" },
   { "light_scale", VAR_FLOAT, &light_scale, 0 },
   { "player_light", VAR_INT, &player_light, "attach a light to the player" },
   { "min_light", VAR_FLOAT, &dynamic_light_min, "minimum dynamic light on a surface allowed visible" },
   { "max_dist_2", VAR_FLOAT, &max_dist_2, "maximum distance dynamic light can reach" },

   { "keep_all_lit", TOGGLE_BOOL, &keep_all_lit, 0 },

   { "show_cells", TOGGLE_BOOL, &show_cells, "Display cells containing refs" },
   { "span_clip", TOGGLE_BOOL, &g2pt_span_clip, "enable span clipping in the renderer" },
   { "portal_model", TOGGLE_BOOL, &portal_model, "render models through portal tmappers" },
   { "full_obj_test", TOGGLE_BOOL, &portal_object_complete_test, "choose all/incomplete cell lists for object sort testing" },

   { "show_split", TOGGLE_BOOL, &show_split, "outline objects being split" },
   { "show_bbox", TOGGLE_BOOL, &show_bbox, "show bounding boxes around objects" },
   { "show_bbox_2d", TOGGLE_BOOL, &show_bbox_2d, "outline objects" },
   { "disable_topsort", TOGGLE_BOOL, &disable_topsort, "disable good objsort" },

   // Shading Table Fun
   { "show_shadtab", FUNC_VOID, show_shad_tab, "draw shading table" },
   { "pick_shade_dist", FUNC_INT, PickDistanceFunction, "pick which rule for distance" },

   // lgd3d hacks
   { "puntd3d", TOGGLE_BOOL, &lgd3d_punt_d3d, 0},
   { "zbuffer", TOGGLE_BOOL, &g_zbuffer, 0 },
   { "znup", FUNC_VOID, znup, 0 },
   { "zndown", FUNC_VOID, zndown, 0 },
   { "zfup", FUNC_VOID, zfup, 0 },
   { "zfdown", FUNC_VOID, zfdown, 0 },
   { "zlinear", FUNC_VOID, toggle_linear, 0 },
   { "agglight", TOGGLE_BOOL, &pt_aggregate_lightmaps, 0 },
   { "nullrast", FUNC_VOID, toggle_null_raster, 0},

 // the following flags should be desupported
//   { "asm_outer",     TOGGLE_BOOL, &asm_outer, 0 },
   { "palette_light", TOGGLE_BOOL, &palette_light, 0 },
   { "skip_clip",     TOGGLE_BOOL, &skip_clip, 0 },
   { "project_space", TOGGLE_BOOL, &project_space, 0 },
   { "linear_map",    TOGGLE_BOOL, &linear_map, "affine mapper for terrain" },
   { "surface_cache", TOGGLE_BOOL, &surface_cache, "cache lit surfaces" },

};

//////////////////////////////////////////////////


extern void brushPickColors(void);

////////////////////////////////////////////////////////////
// DATABASE EVENT HANDLERS
//



void editgeom_reset_database(void)
{




}

void editgeom_pal_change(void)
{
   brushPickColors();
   vm_pick_colors(); 
}

void editgeom_visual_message(DispatchData* msg)
{
   switch(msg->subtype)
   {
      case kPaletteChange:
         editgeom_pal_change(); 
         break;
   }
}

void editgeom_db_message(DispatchData* msg)
{
   ///   msgDatabaseData* data = (msgDatabaseData*)msg->data;
   switch(DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         editgeom_reset_database();
         break;
      case kDatabaseLoad:
         //gedit_update();
         break;

      case kDatabasePostLoad:
         if (msg->subtype & kDBMap)
         {
            if (blistCount() == 0)
               scene_setup();
            undoClearUndoStack();
         }

         if (msg->subtype & kObjPartConcrete)
            ged_room_postload(); 
         break;
      case kDatabaseDefault:
         scene_setup();
         undoClearUndoStack();
         ged_room_postload(); 
         break;
   }
}

////////////////////////////////////////////////////////////
// STARTUP/SHUTDOWN
//

static int texturefilenum;

void editgeom_init(void)
{
   texturefilenum = ResOpenFile("texture.res");
   gedit_init();
   COMMANDS(parse_keys, HK_EDITOR);
   COMMANDS(all_keys, HK_ALL);
}

void editgeom_term(void)
{
   ResCloseFile(texturefilenum);
   gedit_term();
}

////////////////////////////////////////////////////////////
// LOOPMODE HANDLERS
//

void testgeom_startup(void)
{
   gedit_full_redraw();
}

void testgeom_shutdown(void)
{
}

bool testgeom_inner(void)
{  PROF
   mxs_vector *loc;
   mxs_angvec *ang;
   bool have_spot;

   have_spot=vm_spotlight_loc(&loc, &ang);

   reset_dynamic_lights();
   if (spotlight&&have_spot)
   {
      Position pos;
      MakePositionFromVectors(&pos, loc, ang);
      gr_push_canvas(grd_canvas);
      portal_add_spotlight(100.0, &pos, 1.0, LIGHT_DYNAMIC);
      gr_pop_canvas();
   }

   if (!have_spot)
    { loc=NULL; ang=NULL; }
   SFX_Frame(loc,ang); // remove me too, please

   vm_render_cameras();
   END_PROF;
   return TRUE;
}


////////////////////////////////////////////////////////////
// LOOP CLIENT
//

typedef void Context;

typedef struct _StateRecord
{
   Context* context;
} StateRecord;



////////////////////////////////////////
//
// LOOP/DISPATCH callback
//

static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   eLoopMessageResult result = kLoopDispatchContinue;
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;

   info.raw = hdata;

   switch(msg)
   {
      case kMsgEnterMode:
      case kMsgResumeMode:
         testgeom_startup();
         editgeom_pal_change(); 
         break;

      case kMsgExitMode:
      case kMsgSuspendMode:
         testgeom_shutdown();
         break;

      case kMsgNormalFrame:
      case kMsgPauseFrame:
         testgeom_inner();
         break;

      case kMsgDatabase:
         editgeom_db_message(info.dispatch);
         break;

      case kMsgVisual:
         editgeom_visual_message(info.dispatch);
         break;

      case kMsgAppInit:
         editgeom_init();
         break;

      case kMsgAppTerm:
         editgeom_term();
         break;

      case kMsgEnd:
         Free(state);
         break;
   }
   return result;
}

extern sLoopClientDesc EditGeomBaseClientDesc;

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   sLoopClientDesc* desc = (data) ? &EditGeomClientDesc : &EditGeomBaseClientDesc;
   //   Assrt((void*)data != NULL);
   state = (StateRecord*) Malloc(sizeof(StateRecord));
   state->context = (Context*)data;

   return CreateSimpleLoopClient(_LoopFunc,state,desc);
}
#pragma on(unreferenced)

#define BASE_MSGS (kMsgDatabase|kMsgVisual|kMsgEnd|kMsgAppInit|kMsgAppTerm)

sLoopClientDesc EditGeomClientDesc =
{
   &LOOPID_EditGeom,
   "EditGeom Client",
   kPriorityNormal,
   kMsgsMode|kMsgsFrame|BASE_MSGS,

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,

   {
      { kConstrainAfter, &LOOPID_ScrnMan, kMsgsMode},
      { kConstrainAfter, &LOOPID_ObjSys, (ulong)kMsgsAll},
      { kConstrainAfter, &LOOPID_BrushList, kMsgDatabase }, 
      { kConstrainAfter, &LOOPID_Wr, kMsgDatabase},

      {kNullConstraint}
   }
};

sLoopClientDesc EditGeomBaseClientDesc =
{
   &LOOPID_EditGeom,
   "EditGeom Client",
   kPriorityNormal,
   BASE_MSGS,
   kLCF_Callback,
   
   _CreateClient,
   
   NO_LC_DATA,

   {
      { kConstrainAfter, &LOOPID_ScrnMan, kMsgsMode},
      { kConstrainAfter, &LOOPID_ObjSys, (ulong)kMsgsAll},
      { kConstrainAfter, &LOOPID_BrushList, (ulong)kMsgsAll},
      { kConstrainAfter, &LOOPID_Wr, kMsgDatabase},

      {kNullConstraint}
   }
};

// $Header: r:/t2repos/thief2/src/editor/editgeom.h,v 1.3 2000/01/29 13:11:35 adurant Exp $
#pragma once

#ifndef __EDITGEOM_H
#define __EDITGEOM_H


DEFINE_LG_GUID(LOOPID_EditGeom, 0x29);
EXTERN struct sLoopClientDesc EditGeomClientDesc;

#endif // __EDITGEOM_H

// $Header: r:/t2repos/thief2/src/editor/editgeo_.h,v 1.2 2000/01/29 13:11:36 adurant Exp $
#pragma once

#ifndef ___EDITGEO_H
#define ___EDITGEO_H

EXTERN void editgeom_init(void);
EXTERN void editgeom_term(void);


#endif // ___EDITGEO_H
// $Header: r:/t2repos/thief2/src/editor/editinh.h,v 1.3 2000/01/29 13:11:37 adurant Exp $
// Inheritance editor API
#pragma once

#ifndef __EDITINH_H
#define __EDITINH_H

#include <edinhtyp.h>
#include <objtype.h>

EXTERN InheritanceEditor* InheritanceEditorFancyCreate(ObjID id, ObjID root, BOOL concrete, BOOL to_obj, InheritanceEditorDesc* editdesc);
EXTERN InheritanceEditor* InheritanceEditorCreate(ObjID id, InheritanceEditorDesc* editdesc);
EXTERN void InheritanceEditorDestroy(InheritanceEditor* ed);

#endif // __EDITINH_H
// $Header: r:/t2repos/thief2/src/editor/editlink.cpp,v 1.14 1998/02/04 13:53:26 dc Exp $
// Object link editor

#include <stdlib.h>

#include <editlink.h>
#include <edlinkst.h>

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>

#include <link.h>
#include <linkbase.h>
#include <linkman.h>
#include <lnkquery.h>
#include <linkid.h>

#include <relation.h>

#include <objsys.h>
#include <objedit.h>

#include <mprintf.h>

// for the windows controls
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>

#include <comtools.h>
#include <wappapi.h>
#include <appagg.h>

#include <dialogs.h>

// must be last header
#include <dbmem.h>

//
// Link Editor
//

struct LinkEditor
{
   LinkEditorDesc       editdesc;
   HWND                 hWnd;
   HWND                 hMainWnd;
   HINSTANCE            hInst;
   HWND                 hWndList;
   ObjID                objid_src;
   ObjID                objid_dest;
   RelationID           relid;
   HFONT                hWndFont;
};

// property IDs
#define ID_LINKED "LinkEditor: ed"

// control IDs
#define ID_ADDBUTTON 0
#define ID_DELETEBUTTON 1
#define ID_DONEBUTTON 2
#define ID_LISTVIEW 5

// END for the windows controls

#define MAX_STRLEN 32

// add a single line (LinkID, source objid, dest objid, flavor) to the list view

static LinkID get_item_linkid(LinkEditor* ed, int idx)
{
      LV_ITEM item;  
      item.iItem = idx;
      item.iSubItem = 0;
      item.mask = LVIF_PARAM;
      if (ListView_GetItem(ed->hWndList,&item))
         return (LinkID)item.lParam;
      else 
         return LINKID_NULL;
}

extern BOOL show_internal_links = FALSE;

BOOL LinkEditorShowAllLinks(BOOL newval)
{
   BOOL old = show_internal_links;
   show_internal_links = newval;
   return old;
}

BOOL linkedit_fill_line(HWND hWnd, int index, LinkID id, sLinkAndData* link)
{
   char buf[MAX_STRLEN];
   AutoAppIPtr_(LinkManager,LinkMan);
   IRelation* rel = LinkMan->GetRelation(link->flavor);
   const char* flavor = rel->Describe()->name;

   ListView_SetItemText(hWnd, index, 0, (char*)flavor);
   sprintf(buf, "%08X", id);
   ListView_SetItemText(hWnd, index, 1, buf);

   ListView_SetItemText(hWnd, index, 2, (char*)ObjEditName(link->source));
   ListView_SetItemText(hWnd, index, 3, (char*)ObjEditName(link->dest));
   if (link->data != NULL)
   {
      AutoAppIPtr_(StructDescTools,pTools); 
      const sRelationDataDesc* ddesc = rel->DescribeData();
      const sStructDesc* sdesc = pTools->Lookup(ddesc->type);
      if (!sdesc)
         sprintf(buf,"%08X",link->data);
      else
      {
         pTools->UnparseSimple(sdesc,link->data,buf,sizeof(buf));
      }
      ListView_SetItemText(hWnd, index, 4, buf);      
   }

   SafeRelease(rel);
   return TRUE;
}




void LGAPI edit_cb(sStructEditEvent* , StructEditCBData data);

static void linkedit_edit_data(LinkEditor* ed, int idx)
{
   LinkID id = get_item_linkid(ed,idx);
   if (id == LINKID_NULL) return;

   AutoAppIPtr_(LinkManager,LinkMan);
   void* data = LinkMan->GetData(id);



   IRelation* Rel = LinkMan->GetRelation(LINKID_RELATION(id));
   const sRelationDataDesc* ddesc = Rel->DescribeData();

   if (ddesc->size <= 0)
      return;

   if (data == NULL)
   {
      char* blank = new char[ddesc->size]; 
      memset(blank,0,ddesc->size);
      Rel->SetData(id,blank);
      data = Rel->GetData(id); 
      delete blank; 
   }

   AutoAppIPtr_(StructDescTools,pTools); 

   const sStructDesc* sdesc = pTools->Lookup(ddesc->type); 
   if (sdesc)
   {
      sStructEditorDesc editdesc = { "", kStructEditAllButtons};
      strcpy(editdesc.title,ddesc->type);
      IStructEditor* sed = CreateStructEditor(&editdesc,(sStructDesc*)sdesc,data);
      sed->SetCallback(edit_cb,(StructEditCBData)ed);
      sed->Go(kStructEdModeless);
      SafeRelease(sed);
   }

   SafeRelease(Rel);
}

int linkedit_add_line(HWND hWnd, int index, LinkID id, sLinkAndData* link)
{
   LV_ITEM item;


   item.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
   item.iItem = index;
   item.iSubItem = 0;
   item.state = 0;
   item.stateMask = 0;
   item.pszText = "";
   item.cchTextMax = MAX_STRLEN;
   item.lParam = id;
   ListView_InsertItem(hWnd, &item);
   linkedit_fill_line(hWnd,index,id,link);
   return index;

}


// start at item #start (0 means start at beginning of list)
int linkedit_find_selected(HWND hWnd, int start)
{
   if (ListView_GetSelectedCount(hWnd))
      for (int i=start; i<ListView_GetItemCount(hWnd); i++)
         if (ListView_GetItemState(hWnd, i, LVIS_SELECTED))
            return i;

   return -1;
}

// this is to be filled in by the AddLinkDlgProc
// this is static because there can be only one link add dialog at a time, and we
// can't attach a LinkEditor* to the dialog
static sLinkAndData dlg_add_link;

#pragma off(unreferenced)
// add link dialog DlgProc
BOOL CALLBACK AddLinkDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
   switch (msg)
   {
      case WM_INITDIALOG:
         ILinkManager*        pLinkMan;
         const sRelationDesc* reldesc;
         sRelationIter        iter;
         RelationID           flavor;

         flavor = 0;
         pLinkMan = AppGetObj(ILinkManager);

         // go through the list of all flavors and add them to the dropdown box
         pLinkMan->IterStart(&iter);
         while (pLinkMan->IterNext(&iter, &flavor))
         {
            IRelation* pRel = pLinkMan->GetRelation(flavor);
            if (pRel)
               reldesc = pRel->Describe();
            if (show_internal_links || !(reldesc->flags & kRelationNoEdit))
            {
               int idx = SendDlgItemMessage(hDlg, IDC_FLAVORCOMBO, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)reldesc->name);
               SendDlgItemMessage(hDlg, IDC_FLAVORCOMBO, CB_SETITEMDATA, (WPARAM)idx, (LPARAM)pRel->GetID());

            }
            SafeRelease(pRel);
         }
         pLinkMan->IterStop(&iter);
         SafeRelease(pLinkMan);
         return TRUE;

      case WM_COMMAND:
         switch (LOWORD(wParam))
         {
            case IDOK:
            {
               // add the new link from the dialog
               char buf[16];

               GetDlgItemText(hDlg, IDC_FROMEDIT, buf, 15);
               dlg_add_link.source = EditGetObjNamed(buf);

               GetDlgItemText(hDlg, IDC_TOEDIT, buf, 15);
               dlg_add_link.dest = EditGetObjNamed(buf);

               dlg_add_link.data = NULL;
               int idx = SendDlgItemMessage(hDlg, IDC_FLAVORCOMBO, CB_GETCURSEL, 0, 0);
               int id = SendDlgItemMessage(hDlg, IDC_FLAVORCOMBO, CB_GETITEMDATA, (WPARAM)idx, 0);

               dlg_add_link.flavor = (RelationID)id;
               EndDialog(hDlg, TRUE);
            }
            return TRUE;

            case IDCANCEL:
               EndDialog(hDlg, FALSE);
               return FALSE;

            case IDC_DATAEDIT:
               MessageBox(hDlg, "edit data here", "Info", MB_OK | MB_ICONINFORMATION);
               break;
         }
         break;
   }

   return FALSE;
}
#pragma on(unreferenced)

// puts up the dialog to add a link and does it
void linkedit_add_link(LinkEditor* ed, HWND hWnd)
{
   sLinkAndData& link = dlg_add_link;

   memset(&link, 0, sizeof(sLinkAndData));

   if (DialogBox(ed->hInst, "AddLink", hWnd, AddLinkDlgProc))
   {
      AutoAppIPtr_(LinkManager,pLinkMan);
      const sRelationDesc* reldesc = NULL;

      if (link.flavor == 0)
      {
         MessageBeep(MB_ICONEXCLAMATION);
         MessageBox(hWnd, "Flavor is invalid!", "Add Link Error", MB_OK | MB_ICONEXCLAMATION);
         return;
      }

      // get the text description of the flavor
      pLinkMan = AppGetObj(ILinkManager);
      cAutoIPtr<IRelation> pRel (pLinkMan->GetRelation(link.flavor));
      if (pRel)
         reldesc = pRel->Describe();

      // can't link myself to myself
      if (link.source == link.dest)
      {
         MessageBeep(MB_ICONEXCLAMATION);
         MessageBox(hWnd, "Source and dest ObjID's can't be the same", "Add Link Error", MB_OK | MB_ICONEXCLAMATION);
         return;
      }
      // check for valid objids
      if (!ObjectExists(link.source))
      {
         char str[80];

         sprintf(str, "Source ObjID %d is invalid!\n", link.source);
         MessageBeep(MB_ICONEXCLAMATION);
         MessageBox(hWnd, str, "Add Link Error", MB_OK | MB_ICONEXCLAMATION);
         return;
      }
      if (!ObjectExists(link.dest))
      {
         char str[80];

         sprintf(str, "Dest ObjID %d is invalid!\n", link.dest);
         MessageBeep(MB_ICONEXCLAMATION);
         MessageBox(hWnd, str, "Add Link Error", MB_OK | MB_ICONEXCLAMATION);
         return;
      }

      LinkID id = pLinkMan->Add(link.source,link.dest,link.flavor);
      link.data = pLinkMan->GetData(id);
      int idx = linkedit_add_line(hWnd, ListView_GetItemCount(hWnd), id, &link);
      if (link.data != NULL)
         linkedit_edit_data(ed,idx);
   }
}

// called when the delete button is pressed and a link is selected
void linkedit_delete_link(LinkEditor* ed, HWND hWnd, int index)
{
   LinkID id = get_item_linkid(ed,index);
   if (id == LINKID_NULL) return;
   AutoAppIPtr_(LinkManager,LinkMan);
   LinkMan->Remove(id);
   ListView_DeleteItem(hWnd, index);
}

// finds all selected links and deletes them all
void linkedit_delete_selected(LinkEditor* ed, HWND hWnd)
{
   int num = linkedit_find_selected(hWnd, -1);
   if (num != -1)
   {
      MessageBeep(MB_ICONHAND);
      int result = MessageBox(hWnd, "Are you sure?", "Delete Link", MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
      if (result == IDYES)
      {
         do
         {
            linkedit_delete_link(ed, hWnd, num);
         }
         while ((num = linkedit_find_selected(hWnd, num)) != -1);
      }
   }
}

// add all links for one objid to the list box
void linkedit_add_all_items(HWND hWnd, ObjID objid_src, ObjID objid_dest, RelationID relid)
{
   ILinkManager*        pLinkMan = AppGetObj(ILinkManager);
   ILinkQuery*          pQuery;
   int                  index = 0;

   // add the items which match the given query
   pQuery = pLinkMan->Query(objid_src, objid_dest, relid);
   for (; !pQuery->Done(); pQuery->Next())
   {
      sLinkAndData link;
      memset(&link,0,sizeof(link));

      LinkID id = pQuery->ID();
      IRelation* rel = pLinkMan->GetRelation(LINKID_RELATION(id));
      const sRelationDesc* desc = rel->Describe();
      if (!show_internal_links && (desc->flags & kRelationNoEdit))
      {
         SafeRelease(rel);
         continue;
      }
      SafeRelease(rel);
      pQuery->Link(&link);
      link.data = pQuery->Data();
      linkedit_add_line(hWnd, index++, id, &link);
   }
   SafeRelease(pQuery);
   SafeRelease(pLinkMan);
}

// WndProc for the link editor
LRESULT CALLBACK LinkEditorWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   HWND parent;
   LinkEditor *ed;

   // get my parent so I can get the LinkEditor* from it
   parent = GetParent(hWnd);
   if (parent == NULL)
      parent = hWnd;
   ed = (LinkEditor*) GetProp(parent, ID_LINKED);
   
   switch(msg)
   {
      case WM_COMMAND:
         switch(LOWORD(wParam))
         {
            case ID_ADDBUTTON:
               linkedit_add_link(ed, ed->hWndList);
               break;

            case ID_DELETEBUTTON:
               linkedit_delete_selected(ed, ed->hWndList);
               break;

            case ID_DONEBUTTON:
               DestroyWindow(ed->hWnd);
               break;
         }

         // keep the list view active so we can see what's highlighted
         SetFocus(ed->hWndList);
         return 0;

      case WM_NOTIFY:
         NMHDR *hdr;
         hdr = (NMHDR*)lParam;
         if (hdr->code == NM_DBLCLK)
         {
            int idx = linkedit_find_selected(ed->hWndList, 0);
            if (idx != -1)
            {
               linkedit_edit_data(ed,idx);
            }
         }
         break;

      case WM_DESTROY:
         LinkEditorDestroy(ed);
         return 0;
   }

   return DefWindowProc(hWnd, msg, wParam, lParam);
}

static const char* relid_name(RelationID id)
{
   if (id == RELID_NULL) return "any";

   ILinkManager* linkman = AppGetObj(ILinkManager);
   IRelation* rel = linkman->GetRelation(id);   
   const char* out = rel->Describe()->name;
   SafeRelease(linkman);
   SafeRelease(rel);
   return out;
}

#define objid_name(obj) ((obj == LINKOBJ_WILDCARD) ? "any" : ObjEditName(obj))

static const char* default_title(ObjID src, ObjID dst, RelationID relid)
{
   static char buf[96];

   sprintf(buf,"Links: %s --[%s]--> %s",objid_name(src),relid_name(relid),objid_name(dst));

   return buf;
}

// create me a link editor for an objid
LinkEditor* LinkEditorCreate(ObjID objid_src, ObjID objid_dest, RelationID relid, LinkEditorDesc* editdesc)
{
   LinkEditor*          ed;
   const char*          szName = "Link Editor";
   WNDCLASS             wc;
   HWND                 hMainWnd;
   HINSTANCE            hMainInst;
   IWinApp*             pWA;
   LV_COLUMN            col;
   int                  width, height, left, top;

   ed = (LinkEditor*)Malloc(sizeof(LinkEditor));

   // we need the main app's HWND
   pWA = AppGetObj(IWinApp);
   hMainWnd = pWA->GetMainWnd();
   SafeRelease(pWA);

   // we also need the main app's HINSTANCE
   hMainInst = (HINSTANCE) GetWindowLong(hMainWnd, GWL_HINSTANCE);

   // set up the new window's class
   memset(&wc, 0, sizeof(WNDCLASS));
   wc.style = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc = LinkEditorWndProc;
   wc.hInstance = hMainInst;
   wc.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH);
   wc.lpszClassName = szName;

   // and register it
   RegisterClass(&wc);

   // make it so big
   width = 500;
   height = 400;
   left = (GetSystemMetrics(SM_CXSCREEN) - width) / 2;
   top = (GetSystemMetrics(SM_CYSCREEN) - height) / 2;

   //
   const char* title = editdesc->title;
   if (*title == '\0')
      title = default_title(objid_src,objid_dest,relid);

   // and create it!
   ed->hWnd = CreateWindow(szName, (char*)title, WS_OVERLAPPED, left, top, width, height,
                           hMainWnd, NULL, hMainInst, NULL);

   ShowWindow(ed->hWnd, SW_SHOWNORMAL);
   UpdateWindow(ed->hWnd);

   // Create a nice standard Windows font for the controls.
   LOGFONT logFont;
   memset(&logFont, 0, sizeof(LOGFONT));
   logFont.lfCharSet = DEFAULT_CHARSET;
   logFont.lfHeight = 12;
   strcpy(logFont.lfFaceName, "MS Sans Serif");
   ed->hWndFont = CreateFontIndirect(&logFont);

   // get our new window's HINSTANCE
   ed->hInst = (HINSTANCE) GetWindowLong(ed->hWnd, GWL_HINSTANCE);

   SetProp(ed->hWnd, ID_LINKED, (HANDLE)ed);
   ed->hMainWnd = hMainWnd;
   ed->objid_src = objid_src;
   ed->objid_dest = objid_dest;
   ed->relid = relid;

   // create some buttons
   HWND btnWnd;
   btnWnd = CreateWindow("BUTTON", "Add", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                60, 340, 65, 25, ed->hWnd, (HMENU) ID_ADDBUTTON, ed->hInst, NULL);
   if (ed->hWndFont)
      SendMessage(btnWnd, WM_SETFONT, (WPARAM)ed->hWndFont, 0);

   btnWnd = CreateWindow("BUTTON", "Delete", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                135, 340, 65, 25, ed->hWnd, (HMENU) ID_DELETEBUTTON, ed->hInst, NULL);
   if (ed->hWndFont)
      SendMessage(btnWnd, WM_SETFONT, (WPARAM)ed->hWndFont, 0);

   btnWnd = CreateWindow("BUTTON", "Done", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                375, 340, 65, 25, ed->hWnd, (HMENU) ID_DONEBUTTON, ed->hInst, NULL);
   if (ed->hWndFont)
      SendMessage(btnWnd, WM_SETFONT, (WPARAM)ed->hWndFont, 0);


   if (ed->hWndFont)
      SendMessage(btnWnd, WM_SETFONT, (WPARAM)ed->hWndFont, 0);

   // make it fill most of the window
   width = 500 - GetSystemMetrics(SM_CXFIXEDFRAME) * 2;
   height = 330;
   left = 0;
   top = 0;

   // now, let's create the list view
   ed->hWndList = CreateWindowEx(0L, WC_LISTVIEW, "", WS_VISIBLE | WS_CHILD | LVS_REPORT, top,
                                 left, width, height, ed->hWnd, (HMENU) ID_LISTVIEW, ed->hInst, NULL);

   // set up the columns
   col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
   col.fmt = LVCFMT_LEFT;
   col.cx = 125;
   col.pszText = "Flavor";
   ListView_InsertColumn(ed->hWndList, 0, &col);
   col.cx = 75;
   col.pszText = "ID";
   ListView_InsertColumn(ed->hWndList, 1, &col);
   col.cx = 100;
   col.pszText = "From";
   ListView_InsertColumn(ed->hWndList, 2, &col);
   col.pszText = "To";
   ListView_InsertColumn(ed->hWndList, 3, &col);
   col.cx = 75;
   col.fmt = LVCFMT_RIGHT;
   col.pszText = "Data";
   ListView_InsertColumn(ed->hWndList, 4, &col);

   // insert all of the items
   linkedit_add_all_items(ed->hWndList, ed->objid_src, ed->objid_dest, ed->relid);

   return ed;
}

// destroy the link editor
void LinkEditorDestroy(LinkEditor* ed)
{
   if (ed->hWndFont)
   {
      DeleteObject(ed->hWndFont);
      ed->hWndFont = 0;
   }
   SetFocus(ed->hMainWnd);
   RemoveProp(ed->hWnd, ID_LINKED);
   Free(ed);
}

static void refresh_all_fields(LinkEditor* ed)
{
   AutoAppIPtr_(LinkManager,LinkMan);
   int max = ListView_GetItemCount(ed->hWndList);
   for (int idx = 0; idx < max; idx++)
   {
      LinkID id = get_item_linkid(ed,idx);
      if (id == LINKID_NULL)
         continue;
      sLinkAndData link;
      LinkMan->Get(id,&link);
      link.data = LinkMan->GetData(id);
      linkedit_fill_line(ed->hWndList,idx,id,&link);
   }
}

static void LGAPI edit_cb(sStructEditEvent* , StructEditCBData data)
{  
   LinkEditor* ed = (LinkEditor*)data;
   refresh_all_fields(ed);
}
// $Header: r:/t2repos/thief2/src/editor/editlink.h,v 1.3 2000/01/29 13:11:39 adurant Exp $
#pragma once

#ifndef __EDITLINK_H
#define __EDITLINK_H

#include <edlnktyp.h>
#include <objtype.h>
#include <linktype.h>

EXTERN LinkEditor* LinkEditorCreate(ObjID objid_src, ObjID objid_dest, RelationID relid, LinkEditorDesc* editdesc);
EXTERN void LinkEditorDestroy(LinkEditor* ed);

EXTERN BOOL LinkEditorShowAllLinks(BOOL newval);

#endif // __EDITLINK_H
// $Header: r:/t2repos/thief2/src/editor/editmode.c,v 1.73 2000/02/19 13:10:34 toml Exp $

#include <stdio.h>
#include <time.h>

#include <lg.h>
#include <loopapi.h>
#include <appagg.h>
#include <config.h>
#include <uiapp.h>

#include <hotkey.h>
#include <menus.h>

#include <editmode.h>
#include <gamemode.h>

#include <cfgtool.h>
#include <brushgfh.h>
#include <swappnp.h>
#include <command.h>
#include <contexts.h>
#include <dispatch.h>
#include <dispbase.h>
#include <vismsg.h>
#include <editbr.h>
#include <editgeom.h>
#include <loopmsg.h>
#include <biploop.h>
#include <resloop.h>
#include <scrnloop.h>
#include <plyrloop.h>
#include <scrnmode.h>
#include <scrnman.h>
#include <status.h>
#include <testloop.h>
#include <gen_bind.h>
#include <ailoop.h>
#include <uiedit.h>
#include <uiloop.h>
#include <viewmgr.h>
#include <dispapi.h>
#include <schloop.h>
#include <backup.h>
#include <motedit.h>
#include <linkdraw.h>
#include <simman.h>
#include <dspchdef.h>
#include <simdef.h>
#include <brestore.h>
#include <palette.h>
#include <rendprop.h>
#include <pgrpprop.h>

// stuff for camera synch
#include <dbasemsg.h>
#include <dispbase.h>
#include <playrobj.h>
#include <camera.h>

// So that we can know whether we're switching into a cDarkPanel
// This wants to be handled *some* other way in the long run:
// #include <drkpanid.h>

#include <gametool.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// convienience, since doug is lazy, and gedit.h uses vectors and stuff
// these are in gedit.h, but i dont want to need editbr and such in editmode
extern void gedit_enter(void), gedit_exit(void);

extern void UpdateMenuCheckmarks(void);

////////////////////////////////////////
// LOOPMODE DESCRIPTOR
//

//
// Here is the list of the loop clients that this mode uses.
// Most clients are implemented in fooloop.c
//

static bool (*inpbnd_handler)(uiEvent *, Region *, void *);

#define GAMESPEC_RESERVED_CLIENT 0

static tLoopClientID* _Clients[] =
{
   &GUID_NULL,    // reserved for gamespec
   &LOOPID_Test,
   &LOOPID_ScrnMan,
   &LOOPID_UI,
   &LOOPID_Res,
   &LOOPID_Biped,
   &LOOPID_EditGeom,
   &LOOPID_Editor,
   &LOOPID_AI,
   &LOOPID_Schema,
};

//
// Here's the actual loopmode descriptor
// It gets added to the loop manager in loopapp.c
//

sLoopModeDesc EditLoopMode =
{
   { &LOOPID_EditMode, "Edit mode"}, 
   _Clients,
   sizeof(_Clients)/sizeof(_Clients[0]),
};

////////////////////////////////////////
// CONTEXT FOR LOOPMODE
//

// context for scrnman client
static sScrnMode scrnmode = 
{
   kScrnModeDimsValid|kScrnModeBitDepthValid|kScrnModeFlagsValid,
   640,480, 
   8,
   kScrnModeWindowed,
};

static ScrnManContext _scrndata = 
{ 
   { &scrnmode }, 
}; 

// context for ui client
static uiLoopContext _uidata = 
{
   "editor\\cursor",
};

// context for resource sys client
static ResLoopContext _resdata =
{ 
   { 
      "editor.res",  // a list of files to open
   }
};

static sLoopModeInitParm _EditContext[] =
{
   { &LOOPID_ScrnMan, (tLoopClientData)&_scrndata}, 
   { &LOOPID_UI, (tLoopClientData)&_uidata}, 
   { &LOOPID_Res, (tLoopClientData)&_resdata},
   { &LOOPID_EditGeom, (tLoopClientData)1},  // listen to frame events. 

   { NULL, } // terminator
};

////////////////////////////////////////////////////////////
// GAME SPEC CLIENT INSTALLATION

void EditModeSetGameSpecClient(const GUID* ID)
{
   _Clients[GAMESPEC_RESERVED_CLIENT] = ID;
}


////////////////////////////////////////
// INSTANTIATOR
//

static sLoopInstantiator _instantiator = 
{
   &LOOPID_EditMode,
   mmEditBrush,
   _EditContext,
};

//
// This function fills out and returns the instantiator for this mode, based on
// an "edit mode descriptor structure."  The point of this is to hide the list 
// of loop clients behind the "edit mode" abstraction barrier.  So a system 
// that wants to change to edit mode doesn't need to know which loop client the 
// mode uses to keep track of screen res, etc. 
// 

sLoopInstantiator* DescribeEditMode(EditMinorMode minorMode, EditModeDesc* desc)
{
   if (minorMode != mmEditNoChange)
   {
      _instantiator.minorMode = minorMode;
   }
   if (desc != NULL)
   {
      if (desc->scrnmode)
         ScrnModeCopy(&scrnmode,desc->scrnmode,kScrnModeAllValid);
   }

   return &_instantiator;
}





/////////////////////////////////////////////////////////////
// EDITOR LOOP CLIENT
////////////////////////////////////////////////////////////

// this is a generic loop client for all sorts of stuff that only happens in editor
// mode and doesn't quite merit its own loop client.

// This client has no context data.  If it did, this type would not be void.
// Your client could have any type it wants.  
typedef void Context;

// The client stores all its state here, plus a pointer to its context. 
// This client happens to have no state.

typedef struct _StateRecord
{
   Context* context;
   BOOL first_frame;
   BOOL from_game; 
   BOOL in_mode; 
} StateRecord;

////////////////////////////////////////
// Database message handler
//

static void synch_edit_camera(void)
{
   // actually write the current camera pos back into the editor spotlight
   mxs_vector *plypos;
   mxs_angvec *plyang;
   Camera* player_cam = PlayerCamera();
   if (vm_spotlight_loc(&plypos,&plyang))
      CameraGetLocation(player_cam, plypos, plyang);
}

static void db_message(DispatchData* msg)
{
   msgDatabaseData data;
   data.raw = msg->data;
   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         GFHSetCurrentBrush(NULL);
         break;
      case kDatabasePostLoad:
         if ((msg->subtype & (kObjPartConcrete|kObjPartBriefcase)) == kObjPartConcrete)
            if (!BackupLoading())
               synch_edit_camera();

         if (!(msg->subtype & kFiletypeAll))
            pal_update(); 
         break;

      case kDatabaseDefault:
         pal_update(); 
         break; 

   }
}



/*
----------------------------------------
Processes keys sent from input binder
----------------------------------------
*/
static char *ProcessEditKey (char *cmd, char *val, BOOL already_down)
{
   return CommandExecute (cmd);
}//end ProcessEditKey ()


////////////////////////////////////////
//
// LOOP/DISPATCH callback
// Here's where we do the dirty work.
//

#pragma off(unreferenced)
static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   int cookie;
   Region* root = GetRootRegion();
   // useful stuff for most clients
   eLoopMessageResult result = kLoopDispatchContinue; 
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;

   // our specific stuff
   struct tm time_of_day;
   time_t ltime;
   static bool once = FALSE;

   info.raw = hdata;

   switch(msg)
   {
      case kMsgResumeMode:
      case kMsgEnterMode:
         pal_update();  // set the palette 
         EditorCreateGUI();
         // run the scripts
         state->first_frame = TRUE;
         state->in_mode = TRUE;

         //input binding stuff
         g_pInputBinder->lpVtbl->GetHandler (g_pInputBinder, &inpbnd_handler);
         uiInstallRegionHandler (root, UI_EVENT_KBD_COOKED, inpbnd_handler, NULL, &cookie);
         g_pInputBinder->lpVtbl->SetMasterProcessCallback (g_pInputBinder, ProcessEditKey);
         g_pInputBinder->lpVtbl->SetContext (g_pInputBinder, HK_BRUSH_EDIT, TRUE);
         HotkeyContext = HK_BRUSH_EDIT;

         StatusEnable();
         gedit_enter();
         if (config_is_defined("editorcam_from_game"))
            synch_edit_camera();
         SetMainMenu("edit");
         UpdateMenuCheckmarks();
         state->from_game = IsEqualGUID(info.mode->from.pID,&LOOPID_GameMode);

         if (state->from_game)
         {
            ISimManager* pSimMan = AppGetObj(ISimManager); 
            ISimManager_SuspendSim(pSimMan); 
            SafeRelease(pSimMan); 

         }
         ParticleGroupEnterMode(); 

         break;

      case kMsgExitMode:
         if (!state->in_mode)
            break; 
      case kMsgSuspendMode:
         state->in_mode = FALSE; 
         ParticleGroupExitMode(); 
         if(g_InMotionEditor)
            MotEditClose();
         SetMainMenu(NULL);
         EditorDestroyGUI();
         StatusDisable();
         
         // Determine if we're going into game mode...
         if (IsEqualGUID(info.mode->to.pID,&LOOPID_GameMode) ||
			    GameToolIsToGameModeGUID(info.mode->to.pID))
         {
            ISimManager* pSimMan = AppGetObj(ISimManager); 
            sDispatchMsg msg = { kSimInit}; 

            gedit_exit();
            SaveBrushSelection(); 
            BackupMission(); 
            ISimManager_StartSim(pSimMan); 
            SafeRelease(pSimMan); 
         }


         break;

      case kMsgAppInit:
         InitDrawnRelations();
         break;

      case kMsgAppTerm:
         TermDrawnRelations();
         break;

      case kMsgEnd:
         Free(state);
         break;

      case kMsgNormalFrame:
         time(&ltime);
         memcpy(&time_of_day, localtime(&ltime), sizeof(struct tm));
         StatusField(SF_TIME,asctime(&time_of_day));
         StatusUpdate();
         GFHUpdate(GFH_FRAME);
         if(g_InMotionEditor)
            MotEditUpdate(info.frame->dTicks); 

         if (state->first_frame)
         {
            if (!once)
               process_config_scripts("edit_script");
            once = TRUE;
            process_config_scripts("edit_always_script");

            if (state->from_game)
            {
               RestoreMissionBackup(); 
               RemoveMissionBackup(); 
               RestoreBrushSelection(); 
            }

            state->first_frame = FALSE;

         }

         break;

      case kMsgVisual:
         uieditStyleSetup();   // recompute the guiStyle
         vm_redraw();
         uieditRedrawAll();
         StatusDrawStringAll();
         break;

      case kMsgDatabase:
         db_message(info.dispatch);
         break;
   }
   return result;
}

// 
// Loop client factory function. 
//

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   // allocate space for our state, and fill out the fields
   state = Malloc(sizeof(StateRecord));
   memset(state,0,sizeof(*state));
   state->context = (Context*)data;
   
   return CreateSimpleLoopClient(_LoopFunc,state,&EditorLoopClientDesc);
}
#pragma on(unreferenced)

//
// The loop client descriptor
// 

sLoopClientDesc EditorLoopClientDesc =
{
   &LOOPID_Editor,                        // client's guid
   "Editor client",                       // string name
   kPriorityNormal,                       // priority
   kMsgEnd | kMsgsMode | kMsgsFrame | kMsgVisual | kMsgDatabase | kMsgsAppOuter,   // messages we want

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,
   
   {
      { kConstrainAfter, &LOOPID_ScrnMan, kMsgsMode},
      { kConstrainAfter, &LOOPID_UI, kMsgsMode},
      { kConstrainAfter, &LOOPID_Res, kMsgsMode}, 
      { kConstrainAfter, &LOOPID_EditGeom, kMsgsMode}, 

      { kConstrainAfter, &LOOPID_Player, kMsgDatabase}, 
      { kConstrainBefore, &LOOPID_ScrnMan, kMsgVisual},

   //   { kConstrainAfter, &LOOPID_People, kMsgsMode}, 
      { kNullConstraint }
   }
};

////////////////////////////////////////////////////////////
// Command: edit_mode w,h
// Change to edit mode.  w,h are screen dims
// 

void enter_edit_mode(char* args)
{
   EditModeDesc adesc;
   EditModeDesc* desc = &adesc;
   sScrnMode scrnmode = { 0 };  
   int w = 0, h = 0; 

   desc->scrnmode = &scrnmode; 

   sscanf(args,"%d,%d",&w,&h);
   if (w != 0 && h != 0)
   {
      scrnmode.valid_fields |= kScrnModeDimsValid;
      scrnmode.w = w; 
      scrnmode.h = h; 
   }

   {
      ILoop* looper = AppGetObj(ILoop);
      sLoopInstantiator* loop;

      loop = DescribeEditMode(mmEditNoChange,desc);
      ILoop_ChangeMode(looper,kLoopModeSwitch,loop);

      SafeRelease(looper);
   }
}





// $Header: r:/t2repos/thief2/src/editor/editmode.h,v 1.6 2000/01/29 13:11:41 adurant Exp $
#pragma once
#ifndef __EDITMODE_H
#define __EDITMODE_H

////////////////////////////////////////////////////////////
// EDIT MODE DESCRIPTION
//
DEFINE_LG_GUID(LOOPID_EditMode, 0x22);

EXTERN struct sLoopModeDesc EditLoopMode;

//
// Editor minor modes
//


typedef enum 
{
   mmEditBrush,
   mmEditObjs,
   mmEditNoChange = -1,
   mmEditDefault = mmEditBrush,
} EditMinorMode;



typedef struct EditModeDesc
{
   struct sScrnMode* scrnmode; 
} EditModeDesc;

////////////////////////////////////////////////////////////
// GAME-SPECIFIC CLIENT INSTANTIATION
//
// Plugs a client (or a loopmode's clients) into editor mode.  Only the last call matters.
// 

EXTERN void EditModeSetGameSpecClient(const GUID* clientID);

//////////////////////////////////////////////////////////////
// Instantiate the Editor mode.
// a "null" descriptor will leave values unchanged from last time, 
// or use defaults if there was no last time.
//
EXTERN struct sLoopInstantiator* DescribeEditMode(EditMinorMode minorMode, EditModeDesc* desc);

// 
// Context data for starting the editor mode
//

  
////////////////////////////////////////////////////////////
// EDITOR LOOP CLIENT DESCRIPTION
//

DEFINE_LG_GUID(LOOPID_Editor, 0x2a);
EXTERN struct sLoopClientDesc EditorLoopClientDesc;



 
#endif // __EDITMODE_H
// $Header: r:/t2repos/thief2/src/editor/editobj.c,v 1.106 1998/10/12 00:59:01 dc Exp $
// editor object code
// specifically for render/creation

#include <stdlib.h>
#include <string.h>

#include <md.h>
#include <mlight.h>
#include <2d.h>

#include <comtools.h>
#include <appagg.h>
#include <traitman.h>

#include <mprintf.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brlist.h>
#include <gedit.h>
#include <eosapp.h>

#include <lresname.h>
#include <lress.h>

#include <refsys.h>
#include <wrobj.h>
#include <wr.h>
#include <objlight.h>

#include <physapi.h>
#include <gamespec.h>
#include <status.h>
#include <editobj.h>
#include <rendobj.h>
#include <objsys.h>
#include <osysbase.h>
#include <propbase.h>
#include <brprop.h>
#include <creatext.h>

#include <propid.h>
#include <objscale.h>
#include <scalprop.h>
#include <mnamprop.h>
#include <mnumprop.h>
#include <objshape.h>
#include <objmodel.h>
#include <propname.h>
#include <vbrush.h>
#include <linkdraw.h>

#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>

#ifdef NETWORK_ENABLED
//include <netobj.h>
#endif
#include <objpos.h>
#include <litprop.h>

#include <config.h>
#include <cfgdbg.h>

#include <ged_room.h>

#include <dbmem.h>

static PropertyID brushprop_id = PROPID_NULL;    // the brush property id

static ObjID creation_archetype = ROOT_ARCHETYPE;
static IBoolProperty* hasbrush_prop = NULL;

// so that viewmgr can keep us from doing this...
BOOL dont_redraw_on_update_brushes=FALSE;

void LGAPI editObjBrushListener(sPropertyListenMsg* msg, PropListenerData data);
void LGAPI editObjModelListener(sPropertyListenMsg* msg, PropListenerData data);


void editobjRescaleObjFromBrush(ObjID obj);
void editobjRescaleBrushFromObj(ObjID obj);

////////////////////////////////////////

#define get_brush_property(pp)  GetPropertyInterface(brushprop_id,IBrushProperty,pp)

////////////////////////////////////////

#pragma off(unreferenced)
static void obj_pos_cb(ObjID obj, const ObjPos* pos, void* data)
{
   // @TODO: write a version of this call that takes pos 
   if (pos)
      editobjUpdateBrushfromObj(obj); 
   else
      editObjDeleteObjBrush(obj); 
}
#pragma on(unreferenced) 

////////////////////////////////////////

void editObjInit(void)
{
   IProperty* prop = GetPropertyNamed(PROP_BRUSH_NAME);
   if (prop != NULL)
   {
      brushprop_id = IProperty_GetID(prop);
      IProperty_Listen(prop,kListenPropUnset ,editObjBrushListener,NULL);
   }
   SafeRelease(prop);
   PropName_Listen(PROP_MODELNUMBER_NAME,kListenPropModify,editObjModelListener,NULL);
   PropName_Listen(PROP_SCALE_NAME,kListenPropModify,editObjModelListener,NULL);
   ObjPosListen(obj_pos_cb,NULL);

   hasbrush_prop = HasBrushPropInit(); 
}

////////////////////////////////////////

void editObjTerm(void)
{
   brushprop_id = PROPID_NULL;
   SafeRelease(hasbrush_prop); 
}

////////////////////////////////////////

void editObjSetDefaultArchetype(ObjID archetype)
{
#if 0
   // Hey, this was removed because room brushes need to inherit from concretes
   if (OBJ_IS_ABSTRACT(type))
#endif

   creation_archetype = archetype;
}

////////////////////////////////////////

ObjID editObjGetDefaultArchetype(void)
{
   return creation_archetype;
}

////////////////////////////////////////

editBrush *editObjGetBrushFromObj(ObjID usID)
{
   // @OPTIMIZE: 
   //  May need to speed this up, expose back door to property.  Not yet though. 
   IBrushProperty* prop;
   
   if (get_brush_property(&prop))
   {
      editBrush* ptr = NULL;
      PROPERTY_GET(prop,usID,&ptr);
      SafeRelease(prop);
      return ptr;
   }
   return NULL;
}

// @TODO person moving stuff should be done by callback once property system is in.
bool editobjSetObjfromBrush(editBrush *us)
{
   ObjID id = brObj_ID(us);
   if (!ObjExists(id))
   {
      editObjCreateObjFromBrush(OBJ_NULL,us);
   }
   else
   {
      editobjUpdateObjfromBrush(us);
   }
   return TRUE;
}

// call this when you have a brush, and need to have an object built for it
BOOL editObjCreateObjFromBrush(ObjID archetype, editBrush *us)
{
   ObjID type = (archetype == OBJ_NULL) ? creation_archetype : archetype;
   ObjID id = BeginObjectCreate(type,kObjectConcrete);
   if (id == OBJ_NULL) return FALSE;
   brObj_ID(us)= id;
   editObjSetObjectBrush(id,us);
#ifdef NETWORK_ENABLED
   NetObjInitObj(id);
#endif

   editobjRescaleBrushFromObj(id);
   editobjSetObjfromBrush(us);
   EndObjectCreate(id);

   // If either of these is relevent, this will shine the light in
   // the world.
   ObjLightShine(id);
   ObjAnimLightShine(id);

   return TRUE;
}

BOOL editObjSetObjectBrush(ObjID id, editBrush* us)
{
   IBrushProperty* brushprop;
   if (get_brush_property(&brushprop))
   {
      if (us)
         PROPERTY_SET(brushprop,id,us);
      else
         IProperty_Delete(brushprop,id); 
      return TRUE;
   }
   return FALSE;
}



// @TODO: EVERYTHING BELOW HERE HAS NOT BEEN FULLY PROPERTIZED

// this moves an object to be in synch with a moved brush (ie. if user has moved
//  the brush with GFH or something, call this to put the obj there)
// XXX person moving stuff should be done by callback once property system is in.
bool editobjUpdateObjfromBrush(editBrush *us)
{
   ObjID obj_id = brObj_ID(us);
   BOOL isCreature=CreatureExists(obj_id);

   ObjPosUpdate(obj_id,&us->pos,&us->ang);

   editobjRescaleObjFromBrush(obj_id);

   if (ObjHasDrawnLinks(obj_id))
      gedit_full_redraw();

   return TRUE;
}

// this takes an obj that has an associated brush and puts the brush where the obj is
bool editobjUpdateBrushfromObj(int usID)
{
   editBrush* us;
   us=editObjGetBrushFromObj(usID);
   if (us==NULL) 
   {
      ConfigSpew("update_brush_spew",("obj %d has no brush\n",usID));
      return FALSE; 
   }
   else
   {
      mxs_vector oldpos=us->pos;
      mxs_angvec oldang=us->ang;
      BOOL delta=FALSE;
      ObjPos* pos = ObjPosGetUnsafe(usID); 
      Assert_(pos != NULL); 
      us->pos = pos->loc.vec;
      us->ang = pos->fac;

      mx_subeq_vec(&oldpos,&us->pos);
      delta=mx_mag2_vec(&oldpos)>0.02;
      delta|=((abs(us->ang.el[0]-oldang.el[0])>0x10)||
              (abs(us->ang.el[1]-oldang.el[1])>0x10)||
              (abs(us->ang.el[2]-oldang.el[2])>0x10));
      if (delta)
         if (vBrush_GetSel()==us)
            gedit_redraw_selection();
         else
            gedit_full_redraw();
   }

   // Update the brush size for object.
   editobjRescaleBrushFromObj(usID);

   return TRUE;
}

// Set the brush size based on the object's model and scale.
void editobjUpdateBrushFromObjScale(int brID, mxs_vector* scale)
{
   editBrush *us = editObjGetBrushFromObj(brID);
   mxs_vector dims, oldsz;

   if (us == NULL) return;

   ObjGetUnscaledDims(brID, &dims);
   if (scale!=NULL)
      mx_elmuleq_vec(&dims,scale);

   oldsz=us->sz;
   if (mx_mag_vec(&dims) == 0.0)
      us->sz.x = us->sz.y = us->sz.z = 0.5;
   else
      mx_scale_vec(&us->sz,&dims,0.5);  // brush dims are halved
   mx_subeq_vec(&oldsz,&us->sz);
   if (mx_mag2_vec(&oldsz)>0.02)
      if (vBrush_GetSel()==us)
         gedit_redraw_selection();
      else
         gedit_full_redraw();
}

void editobjRescaleBrushFromObj(ObjID obj)
{
   mxs_vector scale;
   mx_mk_vec(&scale,1.0,1.0,1.0);
   ObjGetScale(obj,&scale);
   editobjUpdateBrushFromObjScale(obj,&scale);
}

#define SCALE_TOLERANCE 0.01

void editobjRescaleObjFromBrush(ObjID obj)
{
   editBrush *br = editObjGetBrushFromObj(obj);
   mxs_vector scale,v1,dims;

   if (br == NULL) return;
   
   // don't do anything for creatures, since their bbox changes shape
   // when rotated since they only have world coord bbox info, and 
   // this cares about inherent obj-rel dimensions.
   if(CreatureExists(obj)) return;

   ObjGetUnscaledDims(obj, &dims);         // Get the model size from v2.

   scale.x = br->sz.x*2/dims.x;
   scale.y = br->sz.y*2/dims.y;
   scale.z = br->sz.z*2/dims.z;   

   // are we close enough to 1?
   mx_mk_vec(&v1,1.0,1.0,1.0);
   if (mx_dist2_vec(&v1,&scale) < SCALE_TOLERANCE*SCALE_TOLERANCE)
   {
      ObjResetScale(obj);
   }   
   else
      ObjSetScale(obj,&scale);
}

BOOL gCreateEditBrush = TRUE;

bool editobjWantsEditBrush(int usID)
{

   if (OBJ_IS_ABSTRACT(usID) || !gCreateEditBrush)
      return FALSE;

   if (ObjPosGet(usID) == NULL)
      return FALSE; 

   return ObjCanHaveBrush(usID); 
}


BOOL ObjCanHaveBrush(ObjID obj)
{
   BOOL result = TRUE; 
   PROPERTY_GET(hasbrush_prop,obj,&result);
   return result;
}

void ObjSetCanHaveBrush(ObjID obj, BOOL can_have)
{
   PROPERTY_SET(hasbrush_prop,obj,can_have); 
}

void ObjUnsetCanHaveBrush(ObjID obj)
{
   IProperty_Delete(hasbrush_prop,obj); 
}

// given a newly generate Obj this will create a brush and put it there
bool editobjCreateBrushfromObj(int usID)
{
   if (!editobjWantsEditBrush(usID))
      return FALSE;

   if (editObjGetBrushFromObj(usID) == NULL)
   {
      int type = -1;
      editBrush *us=brushInstantiate(0);
      brushSetType(us,brType_OBJECT);
      ObjGetModelNumber(usID, &type);
      brObj_Type(us)=type;

      // this is the wrong call anyway, but something better than the below would be nice, eh?
      //   gedit_place_brush(us,FALSE,FALSE);

      // now actually put the thing there
      brObj_ID(us)=usID;
      us->sz.el[0]=us->sz.el[1]=us->sz.el[2]=1.0;
      blistSeek(0,SEEK_END);     // for now, always put at the end
      blistInsert(us);           // put us in the list
      editObjSetObjectBrush(usID,us);
      vBrush_SelectBrush(us);      
      return editobjUpdateBrushfromObj(usID);
   }
   return FALSE; 
}

void editObjDeleteObjBrush(ObjID obj)
{
   PropID_Delete(brushprop_id,obj);
}

// if we were more robust, we could just scan through obj_to_brush here
// faster and easier

// fully remove refs to a given object
void editobjFullDeref(void)
{
   ObjDeleteAllRefs();
}

// add objects to the world 
void editobjFullReref(void)
{
   ObjBuildAllRefs();
}


////////////////////////////////////////////////////////////

#pragma off(unreferenced)
void LGAPI editObjBrushListener(sPropertyListenMsg* msg, PropListenerData data)
{
   if (msg->property != brushprop_id)  
      return; 

   if (msg->type & kListenPropUnset)
   {
      editBrush* tbr = (editBrush*)msg->value.ptrval;
      brObj_ID(tbr) = OBJ_NULL; 
      vBrush_DeletePtr(tbr);
   }
}

void LGAPI editObjModelListener(sPropertyListenMsg* msg, PropListenerData data)
{
   if (msg->type & kListenPropModify)
   {
      ITraitManager* traitman;
      IObjectQuery* query;

      if (OBJ_IS_CONCRETE(msg->obj))
         editobjRescaleBrushFromObj(msg->obj);            

      traitman = AppGetObj(ITraitManager);
      query = ITraitManager_Query(traitman,msg->obj,kTraitQueryAllDescendents); 

      for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
      {
         ObjID obj = IObjectQuery_Object(query);
         if (OBJ_IS_CONCRETE(obj))
            editobjRescaleBrushFromObj(obj);            
      }
      SafeRelease(query);
      SafeRelease(traitman);

   }
}
#pragma on(unreferenced)


// $Header: r:/t2repos/thief2/src/editor/editobj.h,v 1.20 2000/01/29 13:11:44 adurant Exp $
// editor object code
// specifically for render/creation
#pragma once

#ifndef __EDITOBJ_H
#define __EDITOBJ_H

#include <osystype.h>
#include <editbr.h>

////////////////////////////////////////////////////////////
// EDITOR-SPECIFIC OBJECT LAYER
//

//------------------------------------------------------------
// PROPERTY-SAVVY STUFF
//


EXTERN void editObjInit(void);
EXTERN void editObjTerm(void);

// 
// Set the archetype that will be used for subsequent object creation
//
EXTERN void  editObjSetDefaultArchetype(ObjID archetype);
EXTERN ObjID editObjGetDefaultArchetype(void);

// place and object from scratch, OBJ_NULL archetype means default
EXTERN BOOL editObjCreateObjFromBrush(ObjID archetype, editBrush *us);

// set an object's brush without syncronizing.  
EXTERN BOOL editObjSetObjectBrush(ObjID id, editBrush* us);

// Looks up an object's brush
EXTERN editBrush *editObjGetBrushFromObj(ObjID usID);


EXTERN void editObjDeleteObjBrush(ObjID obj);

//------------------------------------------------------------
// THE OLD STUFF: Yet to be propertized.
//

// Icky nasty global for if you want an edit brush to be created on obj create
EXTERN BOOL gCreateEditBrush;

// Create a brush from an object.  Should ideally be called by a property callback.
EXTERN bool editobjCreateBrushfromObj(int usID);

// update an existing obj
EXTERN bool editobjUpdateObjfromBrush(editBrush *usbr);
EXTERN bool editobjUpdateBrushfromObj(int usID);
EXTERN void editobjUpdateBrushFromObjScale(int brID, mxs_vector *scale);


// fully deref or replace all objs (for portalization)
EXTERN void editobjFullDeref(void);
EXTERN void editobjFullReref(void);

// Set whether an object can have a brush
EXTERN BOOL ObjCanHaveBrush(ObjID obj);
EXTERN void ObjSetCanHaveBrush(ObjID obj, BOOL can_have); 
EXTERN void ObjUnsetCanHaveBrush(ObjID obj); 



#endif // __EDITOBJ_H



// $Header: r:/t2repos/thief2/src/editor/editplst.cpp,v 1.14 1998/03/14 21:07:57 mahk Exp $

// Property List Editor

#include <editplst.h>
#include <editprop.h>
#include <sdesbase.h>
#include <sdesc.h>

#include <property.h>
#include <propbase.h>
#include <propman.h>
#include <propraw.h>

#include <appagg.h>
#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>
#include <iobjsys.h>
#include <objedit.h>
#include <donorq.h>
#include <label.h>


// for the windows controls
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>

#include <comtools.h>
#include <wappapi.h>
#include <appagg.h>
#include <stdlib.H>

// must be last header
#include <dbmem.h>

// control IDs
#define ID_VIEWBUTTON 0
#define ID_DELETEBUTTON 1
#define ID_DONEBUTTON 2
#define ID_PROPBOX 3
#define ID_METABOX 4

#define NUM_BUTTONS EDPLIST_NUM_BUTTONS

#define ID_PLISTED "PropertyListEditor: ed"
// END for the windows controls

static const char* button_names[] = { "Add", "Delete", "Done" };

// Dimensions

#define BUTTON_W (65 +GetSystemMetrics(SM_CXBORDER)*2)
#define BUTTON_H (25 +GetSystemMetrics(SM_CYBORDER)*2)


#define PROPBOX_W 200
#define PROPBOX_H 200

#define METABOX_W 200
#define METABOX_H 100

#define MARGIN_X 5
#define MARGIN_Y 5

#define BUTTONS_W (NUM_BUTTONS*BUTTON_W + (NUM_BUTTONS-1)*MARGIN_X)

#define WINDOW_W  (2*MARGIN_X +BUTTONS_W)
#define WINDOW_H  (MARGIN_Y+METABOX_H+MARGIN_Y+PROPBOX_H+MARGIN_Y+BUTTON_H+MARGIN_Y)

//----------------
// GLOBALS
//----------------

static int num_editors = 0;  // number of editors currently out there.

//----------------
// Prototypes
//----------------
void BuildUI(PropertyListEditor* ed, PropertyListEditorDesc* editdesc);
void PropertyListEditorDestroy(PropertyListEditor* ed);

// these flags tell PropertyListEditorFillBox which properties to display
#define kIrrelevant 0
#define kRelevant 1

static char* view_button_text[] = { "Cancel", "Add" }; 


//------------------------------------------------------------
// General ops
//

void PropertyListEditorFillBox(PropertyListEditor *ed, int mode);
void PropertyListEditorFillMetaBox(PropertyListEditor *ed, int mode);


static void change_edit_mode(PropertyListEditor* ed, int mode)
{
   if (mode == ed->mode)
      return; 

   ed->mode = mode;
   SetWindowText(ed->hWndButtons[ID_VIEWBUTTON],view_button_text[mode]);
   EnableWindow(ed->hWndButtons[ID_DELETEBUTTON], mode == kRelevant);
 
   PropertyListEditorFillBox(ed, mode);
   PropertyListEditorFillMetaBox(ed, mode);
}


//------------------------------------------------------------
// THE PROPERTY LIST BOX
//

//
// Return the string for an item, concats together string with value
//

static char* prop_item_string(ObjID obj, IProperty* prop)
{
   static char buf[80];
   sprintf(buf,"%s",prop->Describe()->name);
   
   if (!prop->IsSimplyRelevant(obj))
      return buf;

   AutoAppIPtr_(StructDescTools,pTools); 
   const sPropertyTypeDesc* tdesc = prop->DescribeType();
   const sStructDesc* sdesc = pTools->Lookup(tdesc->type); 
   if (tdesc->size > 0 && sdesc )
   {
      IPropertyRaw* raw;
      if (FAILED(COMQueryInterface(prop,IID_IPropertyRaw,(void**)&raw)))
         return buf;

      // grab the data
      char* val = new char[tdesc->size];
      raw->Get(obj,val);
      
      // add a colon and the value
      strcat(buf,": ");
      pTools->UnparseSimple(sdesc,val,buf+strlen(buf),sizeof(buf)-strlen(buf)); 
      delete val;
   }

   return buf;
}

extern "C"
{
   BOOL property_show_all = FALSE;
}

// puts all the wanted properties in a listbox
void PropertyListEditorFillBox(PropertyListEditor *ed, int mode)
{
   IPropertyManager* propMan = AppGetObj(IPropertyManager);
   sPropertyIter iter;
   IProperty* prop;

   // clear out the listbox
   SendMessage(ed->hWndPropBox, LB_RESETCONTENT, 0, 0);

   // go through all properties and put them in the list box
   propMan->BeginIter(&iter);
   while ((prop = propMan->NextIter(&iter)) != NULL)
   {
      if (!property_show_all && (prop->Describe()->flags & kPropertyNoEdit))
         continue;

      BOOL isIrrel = mode==kIrrelevant;
      if (isIrrel == !prop->IsSimplyRelevant(ed->editID))
      {
         SendMessage(ed->hWndPropBox, LB_ADDSTRING, 0, (LPARAM) prop_item_string(ed->editID,prop));
      }
      SafeRelease(prop);
   }
   SafeRelease(propMan);
}

static void proplist_edit_cb(PropEditEvent* , PropEditCBData data)
{  
   PropertyListEditor* ed = (PropertyListEditor*)data;
   PropertyListEditorFillBox(ed,ed->mode);
}



static IProperty* selected_property(PropertyListEditor* ed)
{
   char buf[80];
   AutoAppIPtr_(PropertyManager,propMan);

   int index = SendMessage(ed->hWndPropBox, LB_GETCURSEL, 0, 0);
   if (index == LB_ERR)
      return propMan->GetProperty(PROPID_NULL);
   SendMessage(ed->hWndPropBox, LB_GETTEXT, index, (LPARAM)buf);
   
   // strip off first token
   char* space = strchr(buf,':');
   if (space == NULL) space = strchr(buf,' ');
   if (space) *space = '\0';

   IProperty* prop = propMan->GetPropertyNamed(buf);

   return prop;

}

#pragma off(unreferenced)
static void handle_propbox_command(PropertyListEditor* ed, WPARAM wParam, LPARAM lParam) 
{
   switch (HIWORD(wParam))
   {
      case LBN_DBLCLK:
      {
         IProperty* prop = selected_property(ed);
         if (ed->mode == kIrrelevant)
            prop->Create(ed->editID);
         PropertyEditor* ped = PropertyEditorCreate(prop, ed->editID);
         if (ped)
         {
            // Unset the property, to make listeners & the cancel button happy 
            if (ed->mode == kIrrelevant)
               prop->Delete(ed->editID);

            PropertyEditorInstallCallback(ped,proplist_edit_cb,(PropEditCBData)ed);
         }
         // snap back to relevant mode
         change_edit_mode(ed,kRelevant);

         SafeRelease(prop);
      }
      break;

      case LBN_SELCHANGE:
      {
         int index = SendMessage(ed->hWndPropBox, LB_GETCURSEL, 0, 0);
         if (index != LB_ERR) // selection is defined
         {
            // de-select the meta prop box
            SendMessage(ed->hWndMetaBox, LB_SETCURSEL, (WPARAM)-1, 0);
         }
      }
      break;
   }
}
#pragma on(unrefereced)

//------------------------------------------------------------
// THE METAPROPERTY LIST BOX
//


#define MAKE_META_DATA(pri,obj)  (((pri)<< 16) | ((obj) & 0xFFFF))
#define META_DATA_OBJ(dat)       (short)((dat) & 0xFFFF)
#define META_DATA_PRI(dat)       (tDonorPriority)((dat) >> 16)

static void PropertyListEditorFillMetaBox(PropertyListEditor* ed, int mode)
{
   

   IObjectQuery* donors;
   IDonorQuery* dq = NULL;
   AutoAppIPtr_(TraitManager,traitman);
   AutoAppIPtr_(ObjectSystem,objsys);

   // clear out the listbox
   SendMessage(ed->hWndMetaBox, LB_RESETCONTENT, 0, 0);

   // metaproperties can't have metaproperties, sorry
   if (mode == kIrrelevant && traitman->IsMetaProperty(ed->editID))
      return; 

   if (mode == kRelevant)
   {
      donors = traitman->Query(ed->editID,kTraitQueryDonors);
      COMQueryInterface(donors,IID_IDonorQuery,(void**)&dq);
   }
   else
   {
      donors = traitman->Query(traitman->RootMetaProperty(),kTraitQueryAllDescendents);
   }
   
   for (; !donors->Done(); donors->Next())
   {
      ObjID obj= donors->Object();
      if (mode == kIrrelevant && !traitman->IsMetaProperty(obj))
         continue;

      const Label* name = objsys->GetName(obj);
      Assert_(name);
      int index = SendMessage(ed->hWndMetaBox, LB_INSERTSTRING, (WPARAM)-1, (LPARAM) name->text);

      tDonorPriority pri = (dq) ? dq->Priority() : 0;
      SendMessage(ed->hWndMetaBox, LB_SETITEMDATA, (WPARAM)index, (LPARAM) MAKE_META_DATA(pri,obj));
   }

   SafeRelease(dq);
   SafeRelease(donors);
}

static ObjID selected_metaproperty(PropertyListEditor* ed)
{
   //   char buf[80];

   int index = SendMessage(ed->hWndMetaBox, LB_GETCURSEL, 0, 0);
   long data = SendMessage(ed->hWndMetaBox, LB_GETITEMDATA, index, 0);

   return META_DATA_OBJ(data);
#ifdef PARSE_METAPROP
   AutoAppIPtr(ObjectSystem);

   Label label;
   strncpy(label.text,buf,sizeof(label.text));  
   label.text[sizeof(label.text)-1] = '\0';
      
   
   return pObjectSystem->GetObjectNamed(&label);
#endif 

}



BOOL confirm(HWND hWnd, const char* question);

void remove_selected_metaproperty(PropertyListEditor* ed)
{
   int index = SendMessage(ed->hWndMetaBox, LB_GETCURSEL, 0, 0);
   if (index == LB_ERR)
      return; 
   long data = SendMessage(ed->hWndMetaBox, LB_GETITEMDATA, index, 0);

   if (confirm(ed->hWnd,"Delete metaproperty?"))
   {
      AutoAppIPtr_(TraitManager,traitMan);
      traitMan->RemoveObjMetaPropertyPrioritized(ed->editID,META_DATA_OBJ(data),META_DATA_PRI(data));
      PropertyListEditorFillMetaBox(ed, ed->mode);
   }
}

#pragma off(unreferenced)
static void handle_metabox_command(PropertyListEditor* ed, WPARAM wParam, LPARAM lParam) 
{
   switch (HIWORD(wParam))
   {
      case LBN_DBLCLK:
      {

         ObjID mprop = selected_metaproperty(ed);
         if (mprop == OBJ_NULL) break;

         if (ed->mode == kRelevant)
         {
            PropertyListEditorDesc edesc = { "" };
            PropertyListEditorCreate(mprop, &edesc);
         }
         else
         {
            AutoAppIPtr_(TraitManager,traitman);
            traitman->AddObjMetaProperty(ed->editID,mprop);
            // snap back to relevant mode
            change_edit_mode(ed,kRelevant);
         }
      }
      break;

      case LBN_SELCHANGE:
      {
         int index = SendMessage(ed->hWndMetaBox, LB_GETCURSEL, 0, 0);
         if (index != LB_ERR) // selection is defined
         {
            // de-select the prop box
            SendMessage(ed->hWndPropBox, LB_SETCURSEL, (WPARAM)-1, 0);
         }
      }
      break;
   }
}
#pragma on(unreferenced)

//------------------------------------------------------------
// RANDOM UI TOOLS
//
static BOOL confirm(HWND hWnd, const char* question)
{
   MessageBeep(MB_ICONHAND);
   int result = MessageBox(hWnd, question, "Confirm:" , MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
   return result == IDYES;
}


//------------------------------------------------------------
// WndProc for PropertyListEditor
//
LRESULT CALLBACK PropertyListEditorWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   HWND parent;
   PropertyListEditor *ed;

   // get the PropertyListEditor* from the parent window
   parent = GetParent(hWnd);
   if (parent == NULL)
      parent = hWnd;
   ed = (PropertyListEditor*) GetProp(parent, ID_PLISTED);
   
   switch(msg)
   {
      case WM_COMMAND:
         switch(LOWORD(wParam))
         {
            case ID_VIEWBUTTON:
               // switch from add mode to view mode
               change_edit_mode(ed,!ed->mode);

               break;

            case ID_DELETEBUTTON:
            {
               IProperty* prop = selected_property(ed);

               // delete the currently selected property
               if (prop->GetID() != PROPID_NULL)
               {
                  if (confirm(hWnd, "Remove property?"))
                  {
                     prop->Delete(ed->editID);
                     PropertyListEditorFillBox(ed, ed->mode);
                  }
               }
               else
               {
                  remove_selected_metaproperty(ed);
               }

               SafeRelease(prop);

            }
            break;

            case ID_DONEBUTTON:
               DestroyWindow(ed->hWnd);
               return 0;

            case ID_PROPBOX:
               handle_propbox_command(ed,wParam,lParam);
               break;

            case ID_METABOX:
               handle_metabox_command(ed,wParam,lParam);
               break;

         }
         return 0;

      case WM_DESTROY:
         PropertyListEditorDestroy(ed);
         return 0;
   }

   return DefWindowProc(hWnd, msg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// Present a view with a list of all the properties for an object.  Each
// property can then be edited with the property editor.
//-----------------------------------------------------------------------------
PropertyListEditor* PropertyListEditorCreate(ObjID editID, PropertyListEditorDesc* editdesc)
{
   PropertyListEditor *ed;

   ed = (PropertyListEditor*)Malloc(sizeof(PropertyListEditor));
   memset(ed, 0, sizeof(PropertyListEditor));

   ed->editID = editID;
   ed->mode = kRelevant;
   
   num_editors++;
   BuildUI(ed, editdesc);
   SetProp(ed->hWnd, ID_PLISTED, (HANDLE)ed);
   PropertyListEditorFillBox(ed, ed->mode);
   PropertyListEditorFillMetaBox(ed, ed->mode);

   return ed;
}

//
// Create default title
//

static const char* default_title(ObjID obj)
{
   static char buf[80];
   sprintf(buf,"Properties for %s",ObjEditName(obj));
   return buf;
}
   
//-----------------------------------------------------------------------------
// Create all the GUI elements needed to show the property list.
//-----------------------------------------------------------------------------
void BuildUI(PropertyListEditor* ed, PropertyListEditorDesc* editdesc)
{
   IWinApp*    pWA;
   WNDCLASS    wc;
   HINSTANCE   hMainInst;
   const char* szName = "Property List Editor";
   int         width, height, top, left;

   // we need the main app's HWND
   pWA = AppGetObj(IWinApp);
   ed->hMainWnd = pWA->GetMainWnd();
   SafeRelease(pWA);

   // we also need the main app's HINSTANCE
   hMainInst = (HINSTANCE) GetWindowLong(ed->hMainWnd, GWL_HINSTANCE);

   // set up the new window's class
   memset(&wc, 0, sizeof(WNDCLASS));
   wc.style = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc = PropertyListEditorWndProc;
   wc.hInstance = hMainInst;
   wc.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH);
   wc.lpszClassName = szName;

   // and register it
   RegisterClass(&wc);

   RECT r; 
   GetWindowRect(ed->hMainWnd,&r);

   // make it so big
   width = WINDOW_W + GetSystemMetrics(SM_CXBORDER)*2;
   height = WINDOW_H + GetSystemMetrics(SM_CYBORDER)*2 + GetSystemMetrics(SM_CYCAPTION);

   // chose top left so that not all property editors start in the same place
   left = (r.left+r.right)/4 + num_editors*MARGIN_X;
   top = r.top + num_editors*(MARGIN_Y+GetSystemMetrics(SM_CYCAPTION));

   const char* title = editdesc->title;
   if (*title == '\0')
      title = default_title(ed->editID);

   // and create it!
   ed->hWnd = CreateWindow(szName, title, WS_OVERLAPPED, left, top, width, height,
                           ed->hMainWnd, NULL, hMainInst, NULL);

   ShowWindow(ed->hWnd, SW_SHOWNORMAL);
   UpdateWindow(ed->hWnd);

   // Create a nice standard Windows font for the controls.
   LOGFONT logFont;
   memset(&logFont, 0, sizeof(LOGFONT));
   logFont.lfCharSet = DEFAULT_CHARSET;
   logFont.lfHeight = 12;
   strcpy(logFont.lfFaceName, "MS Sans Serif");
   ed->hWndFont = CreateFontIndirect(&logFont);

   left = MARGIN_X;
   top = MARGIN_Y;

   // get our new window's HINSTANCE
   ed->hInst = (HINSTANCE) GetWindowLong(ed->hWnd, GWL_HINSTANCE);

   // now, let's create the meta property box
   ed->hWndMetaBox = CreateWindow("LISTBOX", "MetaProperties", WS_VISIBLE | WS_CHILD | LBS_STANDARD,
                                  left, top, METABOX_W, METABOX_H, ed->hWnd, (HMENU) ID_METABOX, 
                                  ed->hInst, NULL);
   top += METABOX_H + MARGIN_Y;

   if (ed->hWndFont)
      SendMessage(ed->hWndMetaBox, WM_SETFONT, (WPARAM)ed->hWndFont, 0);

   // now, let's create the property box
   ed->hWndPropBox = CreateWindow("LISTBOX", "Properties", WS_VISIBLE | WS_CHILD | LBS_STANDARD,
                                  left, top, PROPBOX_W, PROPBOX_H, ed->hWnd, (HMENU) ID_PROPBOX, 
                                  ed->hInst, NULL);
   top += PROPBOX_H + MARGIN_Y;

   if (ed->hWndFont)
      SendMessage(ed->hWndPropBox, WM_SETFONT, (WPARAM)ed->hWndFont, 0);

   // compute first button position
   left = (width - BUTTONS_W)/2;

   // create some buttons
   for (int i = 0; i < NUM_BUTTONS; i++, left += BUTTON_W + MARGIN_X)
   {
      ed->hWndButtons[i] 
         = CreateWindow("BUTTON", button_names[i], WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                left, top, BUTTON_W, BUTTON_H, ed->hWnd, (HMENU) i, ed->hInst, NULL);
      if (ed->hWndFont)
         SendMessage(ed->hWndButtons[i], WM_SETFONT, (WPARAM)ed->hWndFont, 0);
   }
}

//-----------------------------------------------------------------------------
// Tears down all the GUI stuff, after "Done" is clicked.
//-----------------------------------------------------------------------------
void PropertyListEditorDestroy(PropertyListEditor* ed)
{
   // Tear down our UI.
   if (ed)
   {
      if (ed->hWndFont)
      {
         DeleteObject(ed->hWndFont);
         ed->hWndFont = 0;
      }
      ed->hWnd = 0;
      ed->hInst = 0;
      SetFocus(ed->hMainWnd);
      Free(ed);
      num_editors--;
   }
   else
      Warning(("PropertyListEditorDestroy: Not editing an object!\n"));
}
#pragma once
#ifndef EDITPLST_H
#define EDITPLST_H

#include <objtype.h>
#include <editprop.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

struct PropertyListEditorDesc
{
   char title[32];
   ulong flags;      // no flags yet
};

#define EDPLIST_NUM_BUTTONS 3


struct PropertyListEditor
{
   ObjID             editID;
   int               mode;
   HWND              hWnd;
   HINSTANCE         hInst;
   HWND              hMainWnd;
   HWND              hWndPropBox;
   HWND              hWndMetaBox;
   HWND              hWndButtons[EDPLIST_NUM_BUTTONS];
   HFONT             hWndFont;
};

typedef struct PropertyListEditorDesc PropertyListEditorDesc;
typedef struct PropertyListEditor PropertyListEditor;

// Show list of properties for selected object.
EXTERN PropertyListEditor* PropertyListEditorCreate(ObjID editID, PropertyListEditorDesc* editdesc);

#endif









// $Header: r:/t2repos/thief2/src/editor/editprop.c,v 1.9 2000/02/19 13:10:35 toml Exp $

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>

#include <editprop.h>

#include <property.h>
#include <propbase.h>
#include <propname.h>
#include <propraw.h>

#include <editprst.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// callback for the property editor (installed in a structure editor)
static void LGAPI edit_prop_cb(sStructEditEvent *event, StructEditCBData data)
{
   PropertyEditor *ped = (PropertyEditor*)data;

   if (ped == NULL)
      return;

   switch (event->kind)
   {
      case kStructEdApply:
      case kStructEdOK:
         IPropertyRaw_Set(ped->propraw, ped->objid, ped->struc);
         if (ped->cb)
         {
            PropEditEvent event;

            event.type = kPropEdEventDone;
            event.editor = ped;
            event.eventdata = NULL;

            ped->cb(&event, ped->cbdata);
         }

         if (event->kind == kStructEdOK)
            PropertyEditorDestroy(ped);
         else
            IPropertyRaw_Get(ped->propraw,ped->objid,ped->struc);
         break;


      case kStructEdCancel:
         if (ped->cb)
         {
            PropEditEvent event;

            event.type = kPropEdEventCancel;
            event.editor = ped;
            event.eventdata = NULL;

            ped->cb(&event, ped->cbdata);
         }
   
         PropertyEditorDestroy(ped);
         break;

   }
}

// create a property editor for a named property
PropertyEditor* PropertyEditorCreate(IProperty* prop, ObjID objid)
{
   PropertyEditor *ped;
   static sStructDesc *desc = NULL;
   IPropertyRaw* propraw;
   ulong size;
   void* struc;
   const char* name = NULL;


   if (IProperty_GetID(prop) == PROPID_NULL)
   {
      Warning(("Attempt to edit nonexistent property\n"));
      return NULL;
   }

   name = IProperty_Describe(prop)->name;

   if (SUCCEEDED(COMQueryInterface(prop, IID_IPropertyRaw, (void**)&propraw)))
   {
      IStructDescTools* pTools = AppGetObj(IStructDescTools); 
      const sPropertyTypeDesc * propdesc = IProperty_DescribeType(prop);

      desc = COMCall1(pTools,Lookup,propdesc->type);
      SafeRelease(pTools); 
      
      if (desc == NULL)
      {
         Warning(("PropertyEditorCreate: Property '%s' doesn't have an sdesc!\n", name));
         SafeRelease(propraw);
         return NULL;
      }

      size = IPropertyRaw_Size(propraw);
      if (size == 0)
      {
         Warning(("PropertyEditorCreate: Property '%s' is zero bytes long!\n", name));
         SafeRelease(propraw);
         return NULL;
      }

      struc = Malloc(size);

      // Get the initial value
      IPropertyRaw_Get(propraw, objid, struc);


      {
         IStructEditor* sed;
         sStructEditorDesc editdesc;

         ped = Malloc(sizeof(PropertyEditor));
         memset(ped, 0, sizeof(PropertyEditor));

         ped->struc = struc;
         ped->size = size;
         ped->objid = objid;
         ped->propraw = propraw;

         strncpy(editdesc.title, name, sizeof(editdesc.title));
         editdesc.flags = kStructEditAllButtons;
         sed = CreateStructEditor(&editdesc, desc, struc);

         if (sed)
         {
            IStructEditor_SetCallback(sed, edit_prop_cb, ped);
            ped->sed = sed;
            //            IStructEditor_Go(sed,kStructEdModeless);
         }
         else
         {
            Warning(("PropertyEditorCreate: can't create a StructEditor!\n"));
            ped->sed = NULL;
            PropertyEditorDestroy(ped);
            return NULL;
         }
      }
   }
   else
      Warning(("PropertyEditorCreate: '%s' doesn't have an IPropertyRaw!\n", name));

   return ped;
}

// install a user callback on a property editor
void PropertyEditorInstallCallback(PropertyEditor* ped, PropEditCB cb, PropEditCBData data)
{
   if (ped == NULL)
   {
      Warning(("PropertyEditorInstallCallback: NULL editor passed!\n"));
      return;
   }

   if (ped->cb)
   {
      Warning(("PropertyEditorInstallCallback: There is already a callback installed for this editor!\n"));
      return;
   }
   else
   {
      ped->cb = cb;
      ped->cbdata = data;
   }

   // @HACK: Modeless struct editors have tab-key problems right now, so I'm adding this so 
   // that it will be modal
   IStructEditor_Go(ped->sed,kStructEdModal);

}

// given a property editor, kill it!
void PropertyEditorDestroy(PropertyEditor *ed)
{
   if (ed)
   {
      SafeRelease(ed->sed);
      SafeRelease(ed->propraw);
      Free(ed->struc);
      Free(ed);
   }
   else
      Warning(("PropertyEditorDestroy: NULL editor!\n"));
}







// $Header: r:/t2repos/thief2/src/editor/editprop.h,v 1.5 2000/01/29 13:11:49 adurant Exp $
#pragma once

#ifndef __EDITPROP_H
#define __EDITPROP_H

#include <comtools.h>
#include <objtype.h>

//
// Object property editor UI
//

F_DECLARE_INTERFACE(IProperty);

typedef struct PropertyEditor PropertyEditor;
typedef struct PropEditEvent PropEditEvent;

typedef ulong ePropEditEventType;

//
// Callback stuff - one callback per PropertyEditor, please
//

typedef struct PropEditEvent PropEditEvent;
typedef void* PropEditCBData;
typedef void (*PropEditCB)(PropEditEvent* event, PropEditCBData data);

// Create a property editor for a property
EXTERN PropertyEditor* PropertyEditorCreate(IProperty* prop, ObjID objid);

// Install a callback for a property editor
EXTERN void PropertyEditorInstallCallback(PropertyEditor* ped, PropEditCB cb, PropEditCBData data);

// Destroy a property editor
EXTERN void PropertyEditorDestroy(PropertyEditor *ped);


#endif   // __EDITPROP_H
// $Header: r:/t2repos/thief2/src/editor/editprst.h,v 1.5 2000/01/29 13:11:50 adurant Exp $
#pragma once

#ifndef __EDITPRST_H
#define __EDITPRST_H

#include <objtype.h>
#include <propstor.h>
#include <isdescty.h>

//
// Callback events
//

enum _ePropEditEventType
{
   kPropEdEventDone,        // We're done
   kPropEdEventCancel,      // We've been cancelled.
};

struct PropEditEvent
{
   ePropEditEventType type;   // what happened?
   PropertyEditor* editor;    // to whom?
   void* eventdata;           // event-type-specific info
};

//
// The actual property editor
//

struct PropertyEditor
{
   void*          struc;
   ulong          size;
   ObjID          objid;
   IPropertyStore*  propraw;
   IStructEditor*  sed;
   PropEditCB     cb;
   PropEditCBData cbdata;
};

#endif   // __EDITPRST_H


// $Header: r:/t2repos/thief2/src/editor/editsave.c,v 1.35 2000/02/19 13:10:37 toml Exp $
// editorlevel file format and save/load code

// the editor level part .COW file contains the following tags and info
//  Tag: Brushes       (BRLIST)
//    contains all actual brushes in the level, w/o any interpretation data
//  Tag: Obj Models    (OBJ MD)
//    contains a header with count info, then names of objects
//  Tag: Brush Header  (BRHEAD)
//    contains various info on username, skies used, and so on
//  Tag: Flow Texture Indices  (FLOW_TEX)
//    RGB and entry and exit texture indices for each flow group

#include <lg.h>
#include <mprintf.h>
#include <timer.h>

#include <lresdisk.h>

#include <tagfile.h>
#include <vernum.h>

#include <family.h>
#include <csg.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brrend.h>
#include <brlist.h>
#include <saveload.h>
#include <vbrush.h>
#include <gridsnap.h>
#include <gedit.h>
#include <edmedmo.h>
#include <areapnp.h>
#include <status.h>
#include <texprop.h>

#include <appagg.h>
#include <iobjsys.h>

#include <objtype.h>
#include <objdef.h>
#include <objnotif.h>
#include <objpos.h>
#include <objquery.h>
#include <editobj.h>
#include <dbfile.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <propface.h>
#include <property.h>
#include <propbase.h>
#include <missrend.h>

//#include <propfac_.h>
//#include <property.h>
//#include <dbtagfil.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// controls whether we load texture data or not
bool _editor_loadNoTextures=FALSE;

// holds current tagfile for use in all single element callbacks
// thus used by brushes, objmodels
static ITagFile  *_brTagFile=NULL;

IBoolProperty *gFromBriefcaseProp;

/////////////////////////
// Brushes:
static TagVersion BrushVer={1,0};
static TagFileTag BrushTag={"BRLIST"};

// SAVE
// callback for brush save
static bool _saveSingleBrush(editBrush *us, int sz)
{
   return ITagFile_Write(_brTagFile,(char*)us,sz) == sz;
}

// saves all brushes out, by setting curlocaltagfile then calling saveload sys
static BOOL _saveAllBrushes(ITagFile *file, int groupFilter)
{
   HRESULT result=ITagFile_OpenBlock(file,&BrushTag,&BrushVer);
   BOOL rv=FALSE;
   if (result==S_OK)
   {
      _brTagFile=file;
      rv=saveloadWriteBrushes(_saveSingleBrush,groupFilter);
      ITagFile_CloseBlock(_brTagFile);
      _brTagFile=NULL;
   }
   return rv;
}

// LOAD
static loadBrushNewGroup=0;   // another hack for save load mini brush list

// callback for brush load, fills in newbr or returns FALSE if it cant
static bool _loadSingleBrush(editBrush *newbr)
{
   int base_sz = sizeof(editBrush) - EDITBR_MAX_FACES * sizeof(TexInfo);
   
   if (ITagFile_Read(_brTagFile,(char *)newbr,base_sz)==base_sz)
   {
      if (brushGetType(newbr)==brType_TERRAIN)
      {
         int xtra_sz=sizeof(TexInfo)*newbr->num_faces;
         if (ITagFile_Read(_brTagFile,(char *)&newbr->txs,xtra_sz)!=xtra_sz)
            return FALSE;
      }
      if (loadBrushNewGroup)
         brSelect_Group(newbr)=loadBrushNewGroup;
      return TRUE;
   }
   else
      return FALSE;
}

static BOOL _loadAllBrushes(ITagFile *file, BOOL preserve_id)
{
   TagVersion LocalVer=BrushVer;
   HRESULT result=ITagFile_OpenBlock(file,&BrushTag,&LocalVer);
   BOOL rv=FALSE;

   if (result==S_OK)
   {
      _brTagFile=file;
      rv=saveloadReadBrushes(_loadSingleBrush,SAVELOAD_NO_COUNT,preserve_id);
      ITagFile_CloseBlock(_brTagFile);
      _brTagFile=NULL;
   }
   return rv;
}

/////////////////////////
// multibrush-objs

int vbr_filter_group;
static BOOL LGAPI vbr_partition_func(ObjID obj, const sObjPartitionFilter *f )
{
   // okay, do we have an editor brush that corresponds to us as an object?
   editBrush *us;
   
   us = editObjGetBrushFromObj(obj);

   // if so, does it match our group?
   if (us != NULL)
   {
      if (brSelect_Group(us) == vbr_filter_group)
      {
         return(TRUE);
      }
   }
   return(FALSE);
}

extern edbFiletype dbSaveTagFile(ITagFile* file, edbFiletype filetype);
extern edbFiletype dbMergeLoadTagFile(ITagFile* file, edbFiletype filetype);

static BOOL _saveAllObjs(ITagFile *file, int group)
{
   //ObjPos *opos;
   IObjectQuery* query;
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   ObjID obj;

   // register the filter that describes the "briefcase" sub-partition 
   sObjPartitionFilter filter = { vbr_partition_func}; 
   IObjectSystem_SetSubPartitionFilter(pObjSys,kObjPartBriefcase,&filter); 
   vbr_filter_group = group;

   query = IObjectSystem_Iter(pObjSys,kObjectConcrete); 
   for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
   {
      obj = IObjectQuery_Object(query);
      if (vbr_partition_func(obj, NULL))
      {
         /*
         opos = ObjPosGet(obj);
         UpdateChangedLocation(&opos->loc);
         */

         // flag it as being in the briefcase so that we can go 
         // know that later when we retrieve from briefcase
         PROPERTY_SET(gFromBriefcaseProp, obj, TRUE);
      }
   }

   // save the "briefcase" sub-partition 
   dbSaveTagFile(file,kObjPartConcrete|kObjPartBriefcase); 

   query = IObjectSystem_Iter(pObjSys,kObjectConcrete); 
   for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
   {
      obj = IObjectQuery_Object(query);
      if (vbr_partition_func(obj, NULL))
      {
         IProperty_Delete(gFromBriefcaseProp, obj);
      }
   }
   return TRUE;
}

static BOOL _loadAllObjs(ITagFile *file)
{
   IObjectQuery* query;
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   ObjID obj;
   editBrush *newbr;
   BOOL val;

   dbMergeLoadTagFile(file,kObjPartConcrete|kObjPartBriefcase); 

   query = IObjectSystem_Iter(pObjSys,kObjectConcrete); 

   for (; !IObjectQuery_Done(query); IObjectQuery_Next(query))
   {
      obj = IObjectQuery_Object(query);
      newbr = editObjGetBrushFromObj(obj);
      if (IProperty_IsRelevant(gFromBriefcaseProp, obj))
      {
         PROPERTY_GET(gFromBriefcaseProp, obj, &val);

         if (val)
         {
            if (loadBrushNewGroup)
               brSelect_Group(newbr)=loadBrushNewGroup;
         }
         IProperty_Delete(gFromBriefcaseProp, obj);
      }
   }
   return TRUE;
}

/////////////////////////
// generic block header stuff for lists of same size records

// put at the top of each string block
typedef struct {
   int size_per;
   int elem_cnt;
} blockHeader;

// SAVE
static BOOL _saveGenericBlocked(ITagFile *file, blockHeader *hdr, void *mem, TagFileTag *tag, TagVersion *ver)
{
   int write_sz;
   BOOL rv=FALSE;
   
   if (ITagFile_OpenBlock(file,tag,ver)!=S_OK) return FALSE;
   write_sz=hdr->elem_cnt*hdr->size_per;
   if (ITagFile_Write(file,(char*)hdr,sizeof(blockHeader))==sizeof(blockHeader))
      if (ITagFile_Write(file,mem,write_sz)==write_sz)
         rv=TRUE;
   ITagFile_CloseBlock(file);
   return rv;
}

// LOAD
static void *_loadGenericBlocked(ITagFile *file, TagFileTag *tag, TagVersion *ver, TagVersion *newver, blockHeader *hdr)
{
   void *mem=NULL;

   if (ITagFile_OpenBlock(file,tag,newver)!=S_OK) return NULL;
   if (ITagFile_Read(file,(char*)hdr,sizeof(blockHeader))==sizeof(blockHeader))
   {
      int read_sz=hdr->elem_cnt*hdr->size_per;
      mem=Malloc(read_sz);
      if (mem!=NULL)
         if (ITagFile_Read(file,mem,read_sz)!=read_sz)
         {
            Free(mem);    // we are gonna return failure
            mem=NULL;     // but lets free our memory block first
         }
   }
   ITagFile_CloseBlock(file);
   return mem;
}

/////////////////////////
// Family List:
static TagVersion FamilyVer={1,0};
static TagFileTag FamilyTag={"FAMILY"};

// SAVE
static BOOL _saveAllFamilies(ITagFile *file)
{
   blockHeader theHdr;
   void *mem=family_name_block_build(&theHdr.elem_cnt,&theHdr.size_per);
   if (mem)
   {
      BOOL rv=_saveGenericBlocked(file,&theHdr,mem,&FamilyTag,&FamilyVer);
      Free(mem);  // allocated by block build
      return rv;
   }
   return FALSE;
}

// LOAD
static BOOL _loadAllFamilies(ITagFile *file)
{
   TagVersion LocalVer=FamilyVer;
   blockHeader theHdr;
   void *mem=NULL;

   mem=_loadGenericBlocked(file,&FamilyTag,&FamilyVer,&LocalVer,&theHdr);
   if (mem!=NULL)
   {
      BOOL rv=family_name_block_parse(theHdr.elem_cnt,theHdr.size_per,mem);
      Free(mem);
      return rv;
   }
   return FALSE;
}

/////////////////////////
// Textures:
static TagVersion TextureVer={1,0};
static TagFileTag TextureTag={"TXLIST"};

// SAVE
static BOOL _saveAllTextures(ITagFile *file)
{
   void *mem=familyDiskTexBlockBuild();
   if (mem!=NULL)
   {
      BOOL rv;
      int size=ResBlockSize(mem);
      if (ITagFile_OpenBlock(file,&TextureTag,&TextureVer)!=S_OK) return FALSE;
      rv=(ITagFile_Write(file,(char*)mem,size)==size);
      ITagFile_CloseBlock(file);
      Free(mem);
      return rv;
   }
   return FALSE;
}

// LOAD
static BOOL _loadAllTextures(ITagFile *file)
{
   TagVersion LocalVer=TextureVer;
   BOOL rv=FALSE;
   void *mem;
   int size;
   
   if (ITagFile_OpenBlock(file,&TextureTag,&LocalVer)!=S_OK) return FALSE;
   size=ITagFile_BlockSize(file,ITagFile_CurrentBlock(file));
   mem=(void *)Malloc(size);
   rv=(ITagFile_Read(file,(char *)mem,size)==size);
   Assrt(size==ResBlockSize(mem));
   ITagFile_CloseBlock(file);
   if (rv)           // successfully read the data, now lets try to load
      rv=familyDiskTexBlockLoad(mem);  // the resnameblock in for real...
   Free(mem);  // since we malloced it and dont need it any more
   return rv;
}

/////////////////////////
// Header:

typedef struct {
   levelNameInfo names;                // nice-o name 
   int   ambient;                      // the rest are editor state fields
   int   grid_pow2;
} old_brHeader;

typedef struct {
   levelNameInfo names;                // nice-o name 
   int   ambient;                      // the rest are editor state fields
   int   grid_pow2;
   int   brush_pos;
   int   color_state;
   int   vBrush_info;
   bool  use_grid;
   bool  hots_state;
   short pad;
   int   edit_time;
} brHeader;

static TagVersion HeaderVer={9,sizeof(brHeader)};
static TagFileTag HeaderTag={"BRHEAD"};

// for timing silliness - ie. length of time level has been being run
static int last_edit_time=0, cur_total_time=0;

static brHeader theHdr;

// for now, should really fix at some point, since it is such a stupid hack
extern void grid_pow2_scale(int pow2);
extern int  get_pow2_scale(void);

#define ms_to_sec(ms_val) ((ms_val/1000)%60)
#define ms_to_min(ms_val) (((ms_val/1000)/60)%60)
#define ms_to_hr(ms_val)  ((((ms_val/1000)/60)/60)%24)
#define ms_to_day(ms_val)  ((((ms_val/1000)/60)/60)/24)

void _editsave_text_info(char *buf)
{
   int cur_time=(last_edit_time)?tm_get_millisec_unrecorded()-last_edit_time:0;
   int ms_cur;

   strcat(buf,"\nCreated by ");
   strcat(buf,theHdr.names.creator);
   strcat(buf," last save ");
   strcat(buf,theHdr.names.user);
   strcat(buf,"\n Total time ");
   ms_cur=cur_total_time+cur_time;
   sprintf(buf+strlen(buf),"%d:%2.2d:%2.2d:%2.2d",ms_to_day(ms_cur),ms_to_hr(ms_cur),ms_to_min(ms_cur),ms_to_sec(ms_cur));
   strcat(buf," this session ");
   ms_cur=cur_time;
   sprintf(buf+strlen(buf),"%d:%2.2d:%2.2d:%2.2d",ms_to_day(ms_cur),ms_to_hr(ms_cur),ms_to_min(ms_cur),ms_to_sec(ms_cur));   
}

// SAVE
static BOOL _saveBrushHeader(ITagFile *file)
{
   int delta_time=last_edit_time?tm_get_millisec_unrecorded()-last_edit_time:0;
   BOOL rv;

   if (ITagFile_OpenBlock(file,&HeaderTag,&HeaderVer)!=S_OK) return FALSE;
   strcpy(saveloadLevelInfo.user,saveloadGetUser());
   if (saveloadLevelInfo.creator[0]==0)  // no creator string, so it must be us
      strcpy(saveloadLevelInfo.creator,saveloadGetUser());
   memcpy(&theHdr.names,&saveloadLevelInfo,sizeof(levelNameInfo));
   theHdr.grid_pow2=get_pow2_scale();
   theHdr.vBrush_info=vBrushGetSaveData();
   theHdr.brush_pos=blistSeek(0,SEEK_CUR);
   theHdr.hots_state=renderHotsOnly;
   theHdr.color_state=editbr_color_mode;
   theHdr.use_grid=cur_global_grid.grid_enabled;

   cur_total_time+=delta_time;      // timing hacks
   theHdr.edit_time=cur_total_time;
//   mprintf("Total time now %d from %d\n",theHdr.edit_time,delta_time);
   last_edit_time=tm_get_millisec_unrecorded();
   
   rv=(ITagFile_Write(file,(char *)&theHdr,sizeof(brHeader))==sizeof(brHeader));
   ITagFile_CloseBlock(file);
   return rv;
}

// LOAD
static BOOL _loadBrushHeader(ITagFile *file)
{
   TagVersion LocalVer=HeaderVer;
   BOOL rv=FALSE;                   // hack as i didnt start with the
   int hdrSz=sizeof(old_brHeader);  //    minor version is size thing till version 2

   if (ITagFile_OpenBlock(file,&HeaderTag,&LocalVer)!=S_OK) return FALSE;
   if (LocalVer.major>1) hdrSz=LocalVer.minor;
   memset(&theHdr,0,sizeof(brHeader));
   if (ITagFile_Read(file,(char *)&theHdr,hdrSz)>=sizeof(old_brHeader))
   {
      memcpy(&saveloadLevelInfo,&theHdr.names,sizeof(levelNameInfo));
      grid_pow2_scale(theHdr.grid_pow2);
      // Cleanup from old versions of the header to brush list
      if (LocalVer.major>1)
      {
         cur_global_grid.grid_enabled=theHdr.use_grid;
         editbr_color_mode=theHdr.color_state;
      }
      else
      {
         saveloadZeroAllGroups();
         saveloadCleanVer1File();
      }
      if (LocalVer.major<3)
      {
         saveloadFixAlignmentFields();
         theHdr.edit_time=0;
      }
      if (LocalVer.major<4)
         saveloadFixIntPrimalIDs();
      if (LocalVer.major<5)
         saveloadFixNonTerrPrimalIDs();
      if (LocalVer.major<6)
         AreaPnP_Names_Fixup();
      if (LocalVer.major<8)
         saveloadFixFlagField();
      if (LocalVer.major<9)
      {
         sMissionRenderParams parms;
         parms = *GetMissionRenderParams();
         parms.ambient_light.x = theHdr.ambient/256.0;
         parms.ambient_light.y = theHdr.ambient/256.0;
         parms.ambient_light.z = theHdr.ambient/256.0;
         SetMissionRenderParams(&parms);
      }

      vBrushParseLoadData(theHdr.vBrush_info);
      blistSeek(theHdr.brush_pos,SEEK_SET);
      renderHotsOnly=theHdr.hots_state;
      rv=TRUE;
   }
   vBrush_SelectBrush(blistGet());
   ITagFile_CloseBlock(file);
   last_edit_time=tm_get_millisec_unrecorded();
   cur_total_time=theHdr.edit_time;
   return rv;
}

// for minibrushes (i.e. multibrush files)

typedef struct {
   int   flags;
} miniHeader;

static TagVersion MiniHeaderVer={1,sizeof(miniHeader)};
static TagFileTag MiniHeaderTag={"MBHEAD"};

static BOOL _saveMiniBrushHeader(ITagFile *file)
{
   static miniHeader mHeader;
   BOOL rv;

   if (ITagFile_OpenBlock(file,&MiniHeaderTag,&MiniHeaderVer)!=S_OK) return FALSE;
   mHeader.flags=0;
   rv=(ITagFile_Write(file,(char *)&mHeader,sizeof(miniHeader))==sizeof(miniHeader));
   ITagFile_CloseBlock(file);
   return rv;
}

static BOOL _loadMiniBrushHeader(ITagFile *file)
{
   static miniHeader mHeader;
   TagVersion LocalVer=MiniHeaderVer;
   BOOL rv=FALSE;                  
   int hdrSz;

   memset(&mHeader,0,sizeof(mHeader));
   if (ITagFile_OpenBlock(file,&MiniHeaderTag,&LocalVer)!=S_OK)
      saveloadFixFlagField();  // non-existant
   else
   {
      hdrSz=LocalVer.minor;
      if (ITagFile_Read(file,(char *)&mHeader,hdrSz)>=sizeof(miniHeader))
         rv=TRUE;   // it worked
   }

   // parse any flags or anything

   ITagFile_CloseBlock(file);
   return rv;
}

/////////////////////////
// Flow Texture Indices:
static TagVersion FlowTexVersion = {1, 3};
static TagFileTag FlowTexTag = {"FLOW_TEX"};

static BOOL _saveFlowTextureIndices(ITagFile *file)
{
   HRESULT result = ITagFile_OpenBlock(file, &FlowTexTag, &FlowTexVersion);
   BOOL rv = FALSE;

   if (result == S_OK) {

      ITagFile_Write(file, (char *) &g_aEdMedMoSurface[0],
                     sizeof(g_aEdMedMoSurface[0]) * MAX_CELL_MOTION);
      ITagFile_CloseBlock(file);

   }
   return rv;
}

static BOOL _loadFlowTextureIndices(ITagFile *file)
{
   TagVersion found_version = FlowTexVersion;
   HRESULT result = ITagFile_OpenBlock(file, &FlowTexTag, &found_version);
   BOOL rv = FALSE;

   if (result == S_OK
    && found_version.major == FlowTexVersion.major
    && found_version.minor == FlowTexVersion.minor) {

      ITagFile_Read(file, (char *) &g_aEdMedMoSurface[0],
                    sizeof(g_aEdMedMoSurface[0]) * MAX_CELL_MOTION);
      ITagFile_CloseBlock(file);

   }
   return rv;
}


////////////////////////
// MAIN STUFF
// these are the actual calls made by the outside world

BOOL editor_SaveCow(ITagFile *file)
{
   BOOL rv = TRUE;
   rv |= AreaPnP_Names_Save(file);
   rv |= vBrush_NameSave(file);
   rv |= _saveAllBrushes(file, 0);
   rv |= _saveBrushHeader(file);
   rv |= _saveFlowTextureIndices(file);
   if (!rv)
      Warning(("Some component of the COW file saved incorrectly"));
   return rv;
}

BOOL editor_LoadCow(ITagFile *file)
{
   BOOL rv = TRUE;
   rv |= AreaPnP_Names_Load(file);
   rv |= vBrush_NameLoad(file);
   rv |= _loadAllBrushes(file, TRUE);
   rv |= _loadBrushHeader(file);
   rv |= _loadFlowTextureIndices(file);
   if (!rv)
      Warning(("Some component of the COW file loaded incorrectly"));
   return rv;
}

BOOL editor_PostLoadCow(void)
{
   saveloadPostLoadBrushes();
   return TRUE; 
}

BOOL editor_SaveMiniBrush(char *fname, int group)
{
   ITagFile *file;
   BOOL rv=TRUE;

   if ((file=TagFileOpen(fname,kTagOpenWrite))==NULL) return FALSE;
   rv|=_saveAllBrushes(file,group);
   rv|=_saveMiniBrushHeader(file);
   // now save out any objects as a briefcase within the file
   rv|=_saveAllObjs(file,group);
   SafeRelease(file);   
   return rv;
}

BOOL editor_LoadMiniBrush(char *fname, int new_group)
{
   ITagFile *file;   
   BOOL rv=TRUE;

   if ((file=TagFileOpen(fname,kTagOpenRead))==NULL) return FALSE;
   loadBrushNewGroup=new_group;
   rv|=_loadAllBrushes(file,FALSE);
   rv|=_loadMiniBrushHeader(file);
   rv|=_loadAllObjs(file);
   loadBrushNewGroup=0;
   SafeRelease(file);
   return rv;
}

static sPropertyDesc FromBriefcaseDesc =
{
   "FromBriefcase", 0, 
   NULL, 0, 0, // constraints, versions
   { "Engine Features", "From Briefcase?" },
};

void VbrushSaveLoadInit()
{
   gFromBriefcaseProp = CreateBoolProperty(&FromBriefcaseDesc, kPropertyImplDense);
}
// $Header: r:/t2repos/thief2/src/editor/editsave.h,v 1.6 2000/01/29 13:11:51 adurant Exp $
// editor and save load 
#pragma once

#ifndef __EDITSAVE_H
#define __EDITSAVE_H

// save out the editor components of a Cow
EXTERN BOOL editor_SaveCow(ITagFile *file);
EXTERN BOOL editor_LoadCow(ITagFile *file);
EXTERN BOOL editor_PostLoadCow(void); 

// save out minibrush (ie. multibrush brush only) info
EXTERN BOOL editor_SaveMiniBrush(char *fname, int group);
EXTERN BOOL editor_LoadMiniBrush(char *fname, int new_group);

// dump stats to text buffer
EXTERN void _editsave_text_info(char *buf);

// say NO to textures
EXTERN bool _editor_loadNoTextures;

EXTERN void VbrushSaveLoadInit();

#endif  // __EDITSAVE_H
// $Header: r:/t2repos/thief2/src/editor/edittul_.h,v 1.2 1997/10/16 18:19:07 mahk Exp $
#pragma once  
#ifndef __EDITTUL__H
#define __EDITTUL__H

#include <edittool.h>

class cEditTools : public IEditTools
{
   DECLARE_AGGREGATION(cEditTools);

public:
   cEditTools(IUnknown* pOuter);
   virtual ~cEditTools();

   //
   // IEditTools Methods
   //

   STDMETHOD_(const char*,ObjName)(ObjID obj);
   STDMETHOD_(ObjID,GetObjNamed)(const char* name) ; 
   STDMETHOD(EditTypedData)(const char* title, const char* type, void* data);


protected:
   // Aggie protocol
   HRESULT Init();
   HRESULT End();

private:
   // As if we had private members

};


#endif // __EDITTUL__H
// $Header: r:/t2repos/thief2/src/editor/edlinkst.h,v 1.4 2000/01/29 13:11:53 adurant Exp $
#pragma once

#ifndef __EDLINKST_H
#define __EDLINKST_H

#include <linkbase.h>
#include <objtype.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

//
// Link Editor Flags (part of the editor descriptor)
//

enum _eLinkEditorFlags 
{
   kLinkEditDoneButton    = (1 << 0),  // Add a "Done" button
   kLinkEditCancelButton  = (1 << 1),  // Add a "Cancel" button
   kLinkEditApplyButton   = (1 << 2),  // Add an "Apply" button
};

#define kLinkEditAllButtons (kLinkEditDoneButton | kLinkEditCancelButton | kLinkEditApplyButton)

// 
// Link Editor Descriptor
//

struct LinkEditorDesc 
{
   char title[32]; // Title string appearing at top of gadget;
   eLinkEditorFlags flags;
};



#endif // __EDLINKST_H
// $Header: r:/t2repos/thief2/src/editor/edlnktyp.h,v 1.2 2000/01/29 13:11:56 adurant Exp $
#pragma once

#ifndef __EDLNKTYP_H
#define __EDLNKTYP_H

//
// Link editor forward declarations
//

// various enums for flags and field types
typedef ulong eLinkEditorFlags;

// actual structures used when describing structures
typedef struct LinkEditor LinkEditor;
typedef struct LinkEditorDesc LinkEditorDesc;

typedef struct LinkQueue LinkQueue;
typedef struct IDQueue IDQueue;

#endif // __EDLNKTYP_H
// $Header: r:/t2repos/thief2/src/editor/edmedmo.c,v 1.20 2000/02/19 13:10:38 toml Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   edmedmo.c

   Here be editor kindsa stuff for water motion structures.  The
   centerpieces are the routines which propagate textures and motion
   through the world rep, and the SDESC.  There's some accessory stuff
   for clearing the database when we load a level.

   See medmotn* for the game-time part of this story (updating water
   texture (u, v)s per frame), and gedmedmo for the connection to the
   brush database.

   See editsave.c for loading and saving of g_aEdMedMoSurface.

   We use motion index 0 as stillness.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <stdio.h>
#include <string.h>

#include <lg.h>
#include <matrix.h>
#include <mprintf.h>
#include <cfgdbg.h>

#include <portal.h>
#include <wr.h>
#include <wrdbrend.h>

#include <cvtbrush.h>
#include <lresname.h>
#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>
#include <texmem.h>

#include <winui.h>
#include <medmotns.h>
#include <medmotn.h>
#include <edmedmo.h>
#include <family.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


// global weirdnesses for speed in our recursion
static mxs_vector g_seed_pos;
static uchar g_medium;
static uchar g_motion_index;
static bool (*g_bounding_function)(mxs_vector *sample_point);
static short g_texture_above;
static short g_texture_below;

// Here are the texture assignments and RGBs.
sEdMedMoSurface g_aEdMedMoSurface[MAX_CELL_MOTION];

// Here's how we know where we've already been when we're propagating.
// With this limit we could probably traverse Lake Superior.
#define MAX_CELLS_TO_MARK 10000
static int *marked_cell_list;
static int marked_cell_count;


// return values for CellStatus, below
#define CELL_READY_FOR_ROCKING  0
#define CELL_ALREADY_VISITED    1
#define CELL_WRONG_MEDIUM       2
#define CELL_OUTSIDE_VOLUME     3



/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   We mark every cell we visit, not just the ones of the right medium.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void MarkCell(int cell_index)
{
   if (marked_cell_count == MAX_CELLS_TO_MARK)
      Warning(("edmedmo: tried to mark more than %d cells\n",
               marked_cell_count));
   else {
      marked_cell_list[marked_cell_count++] = cell_index;
      WR_CELL(cell_index)->flags |= CELL_TRAVERSED;
   }
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   We unmark the whole bunch at once, after the main work.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void UnmarkAllCells(void)
{
   int i;

   for (i = 0; i < marked_cell_count; ++i)
      WR_CELL(marked_cell_list[i])->flags &= ~CELL_TRAVERSED;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This tells us whether we want to mark a given cell; and if not, why
   not.  Note that the order in which we perform the tests is
   important; if we reach a cell which is both the wrong medium and
   has been traversed, we want to treat it as the wrong medium so we
   can still set the media of its portals.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static int CellStatus(PortalCell *cell, mxs_vector *middle)
{
   if (ConvertFindFinalMedium(cell->medium) != g_medium)
      return CELL_WRONG_MEDIUM;

   if (!g_bounding_function(middle))
      return CELL_OUTSIDE_VOLUME;

   if (cell->flags & CELL_TRAVERSED)
      return CELL_ALREADY_VISITED;

   return CELL_READY_FOR_ROCKING;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is the recursive core of our cell marking.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static int SetCells(int cell_index, int prev_cell_index)
{
   int i;
   mxs_vector middle;
   int status;
   PortalCell *cell = WR_CELL(cell_index);
   int num_vertices = cell->num_vertices;
   mxs_vector *vertex = cell->vpool;
   int num_portals = cell->num_portal_polys;
   int num_solid_polys = cell->num_polys - num_portals;
   int num_render_portals = cell->num_render_polys - num_solid_polys;
   PortalPolygonCore *portal = cell->portal_poly_list;
   PortalPolygonRenderInfo *portal_render
      = cell->render_list + num_solid_polys;
   int portals_set = 0;

   // The middle of the cell is the average of the vertices.
   // This is meant for good-nuffness more than perfection.
   mx_zero_vec(&middle);

   for (i = 0; i < num_vertices; i++) {
      mx_addeq_vec(&middle, vertex);
      vertex++;
   }
   mx_scaleeq_vec(&middle, 1.0 / (float) num_vertices);

   status = CellStatus(cell, &middle);
   MarkCell(cell_index);

   if (status == CELL_READY_FOR_ROCKING) {
      cell->motion_index = g_motion_index;

      portals_set = 1;

      for (i = 0; i < num_portals; i++) {
         if (i < num_render_portals) {
            portal_render->texture_id = g_texture_below;
            portal->motion_index = g_motion_index;
         }

         portals_set += SetCells(portal->destination, cell_index);
         portal++;
         portal_render++;
      }
   }

   // If this cell is, say, air next to water, it's still got a portal
   // into this cell, and that surface should move.
   if (status == CELL_WRONG_MEDIUM) {
      portals_set = 1;

      for (i = 0; i < num_portals; i++) {
         if (portal->destination == prev_cell_index) {
            if (i < num_render_portals) {
               portal_render->texture_id = g_texture_above;
               portal->motion_index = g_motion_index;
            }
         }
         portal++;
         portal_render++;
      }
   }

   return portals_set;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   Go look for water textures prefix "prefix".  fill in in_hnd,out_hnd
   returns TRUE if they work, else FALSE if one or both wasnt found

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
BOOL GetWaterTexIDs(char *prefix, short *in_hnd, short *out_hnd)
{
   int handles[2]; 
   if (family_find_water(prefix,handles,2))
   {
      *in_hnd = (short)handles[0]; 
      *out_hnd = (short)handles[1]; 
      return TRUE; 
   }  
   return FALSE; 
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is called for each volume we're dealing with (in practic, each
   flow brush).

   It sets the medium for all cells which
    * are flagged by our bounding function;
    * can be reached from our seed point; and
    * have the given medium, or one will turn into it (this lets us
      flood temporary media like door brushes).

   We return the number of cells marked.  This is 0 if the coordinates
   do not map to a cell, or the one they map to is outside the
   bounding box or has the wrong medium.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
int EdMedMoSetCells(mxs_vector *seed_pos,
                    uchar medium, uchar motion_index,
                    bool (*bounding_function)(mxs_vector *sample_point))
{
   int seed_status;
   int cell_index;
   int portals_set;
   PortalCell *cell;
   Location loc;

   MakeLocationFromVector(&loc, seed_pos);
   cell_index = CellFromLoc(&loc);
   if (cell_index == CELL_INVALID) {
      ConfigSpew("FlowSpew",
                 ("EdMedMoSetCells: seed not in WR at (%g %g %g)\n",
                  seed_pos->x, seed_pos->y, seed_pos->z));
      return 0;
   }

   g_seed_pos = *seed_pos;
   g_medium = medium;
   g_motion_index = motion_index;
   g_bounding_function = bounding_function;

   // defaults, just in case...
   g_texture_above = WATERIN_IDX;
   g_texture_below = WATEROUT_IDX;

   if (g_aEdMedMoSurface[motion_index].texture_name_base[0] != 0) {
      if (!GetWaterTexIDs(g_aEdMedMoSurface[motion_index].texture_name_base,
                          &g_texture_above, &g_texture_below)) {
      ConfigSpew("FlowSpew",
                 ("Cannot find water textures from %s for flow group %d\n",
                  g_aEdMedMoSurface[motion_index].texture_name_base,
                  motion_index));
      }
   }

   // We want our seed to be inside the world, with a different motion
   // index from ours, and with the given medium.  We treat the seed
   // cell differently from the ones we spread out to in that it's
   // compared using the seed point rather than the average point of
   // its vertices.
   cell = WR_CELL(cell_index);
   seed_status = CellStatus(cell, seed_pos);

   if (seed_status == CELL_READY_FOR_ROCKING) {
      marked_cell_list = Malloc(sizeof(int) * MAX_CELLS_TO_MARK);
      marked_cell_count = 0;

      portals_set = SetCells(cell_index, CELL_INVALID);

      UnmarkAllCells();
      Free(marked_cell_list);
   } else {
      portals_set = 0;
      switch (seed_status) {
         case CELL_WRONG_MEDIUM:
            ConfigSpew("FlowSpew",
                       ("EdMedMoSetCells: seed cell is wrong medium: %d\n",
                        cell->medium));
            break;

         case CELL_ALREADY_VISITED:
            ConfigSpew("FlowSpew",
                       ("EdMedMoSetCells: seed cell already marked?\n"));
            break;

         case CELL_OUTSIDE_VOLUME:
            ConfigSpew("FlowSpew",
                       ("EdMedMoSetCells: seed not in brush at (%g %g %g)\n",
                        seed_pos->x, seed_pos->y, seed_pos->z));
            break;
      }
   }

   return portals_set;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   BRUTE FORCE!  BRUTE!  FORCE!

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void EdMedMoClearMediumMotionInPortals(void)
{
   int i, p;
   int num_portals;
   PortalPolygonCore *portal;
   PortalCell *cell;

   for (i = 0; i < wr_num_cells; i++) {
      cell = WR_CELL(i);

      portal = cell->portal_poly_list;
      num_portals = cell->num_portal_polys;

      for (p = 1; p < num_portals; p++) {
         portal->motion_index = 0;
         portal++;
      }
   }
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   Nuke them from orbit.  It's the only way.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void EdMedMoClearMediumMotion(void)
{
   int i;

   memset(&g_aMedMoCellMotion[0], 0,
          sizeof(g_aMedMoCellMotion[0]) * MAX_CELL_MOTION);

   memset(&portal_cell_motion[0], 0,
          sizeof(portal_cell_motion[0]) * MAX_CELL_MOTION);

   memset(&g_aEdMedMoSurface[0], 0,
          sizeof(g_aEdMedMoSurface[0]) * MAX_CELL_MOTION);

   for (i = 0; i < MAX_CELL_MOTION; ++i) {
      // By default, we expect all motion to be horizontal.
      portal_cell_motion[i].major_axis = MEDIUM_AXIS_Z;
      portal_cell_motion[i].in_motion = TRUE;
      g_aEdMedMoSurface[i].texture_above = WATERIN_IDX;
      g_aEdMedMoSurface[i].texture_below = WATEROUT_IDX;
   }
}


// internal SDESC struct
typedef struct sMotionEdit {
   int index;
   float x, y, z, theta;
   float dx, dy, dz, dtheta;
   uint major_axis;
   char texture_name_base[kMedmoSurfaceFilenameLength];
   BOOL in_motion;
} sMotionEdit;

static sFieldDesc gMotionEdit[] = {
   { "anchor x", kFieldTypeFloat, FieldLocation(sMotionEdit, x) },
   { "anchor y", kFieldTypeFloat, FieldLocation(sMotionEdit, y) },
   { "anchor z", kFieldTypeFloat, FieldLocation(sMotionEdit, z) },
   { "angle (0-360)", kFieldTypeFloat, FieldLocation(sMotionEdit, theta) },

   { "x change/sec.", kFieldTypeFloat, FieldLocation(sMotionEdit, dx) },
   { "y change/sec.", kFieldTypeFloat, FieldLocation(sMotionEdit, dy) },
   { "z change/sec.", kFieldTypeFloat, FieldLocation(sMotionEdit, dz) },
   { "angle change/sec.", kFieldTypeFloat, FieldLocation(sMotionEdit, dtheta)},

   { "axis: 0=x 1=y 2=z", kFieldTypeInt, 
     FieldLocation(sMotionEdit, major_axis)},

   { "texture name", kFieldTypeString, 
     FieldLocation(sMotionEdit, texture_name_base) },


   { "used?", kFieldTypeBool, FieldLocation(sMotionEdit, in_motion)}
};


// desc job
static sStructDesc Desc_Desc
  = StructDescBuild(sMotionEdit, kStructFlagNone, gMotionEdit);

// the structure we edit
static sMotionEdit popup_sMotionEdit;

// temporary storage so we can cancel editing within SDESC
static sMotionEdit temp_sMotionEdit;


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This sets up our sMotionEdit for editing.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void SetSDESCFromMotionStructures(int index, sMotionEdit *data)
{
   data->index = index;

   data->x = portal_cell_motion[index].center.x;
   data->y = portal_cell_motion[index].center.y;
   data->z = portal_cell_motion[index].center.z;
   data->theta
      = (((float) portal_cell_motion[index].angle * 360.0) / 65536.0);

   data->dx = g_aMedMoCellMotion[index].center_change.x;
   data->dy = g_aMedMoCellMotion[index].center_change.y;
   data->dz = g_aMedMoCellMotion[index].center_change.z;
   data->dtheta
      = (((float) g_aMedMoCellMotion[index].angle_change * 360.0) / 65536.0);

   data->major_axis = (uint) portal_cell_motion[index].major_axis;

   strncpy(data->texture_name_base, 
           g_aEdMedMoSurface[index].texture_name_base,
           kMedmoSurfaceFilenameLength);


   data->in_motion = (BOOL) portal_cell_motion[index].in_motion;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This applies the result of the user's changes to the actual data
   structures.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void SetMotionStructuresFromSDESC(sMotionEdit *data)
{
   int index = data->index;

   portal_cell_motion[index].center.x = data->x;
   portal_cell_motion[index].center.y = data->y;
   portal_cell_motion[index].center.z = data->z;
   portal_cell_motion[index].angle
      = (mxs_ang)((data->theta * 65536.0) / 360.0);

   g_aMedMoCellMotion[index].center_change.x = data->dx;
   g_aMedMoCellMotion[index].center_change.y = data->dy;
   g_aMedMoCellMotion[index].center_change.z = data->dz;
   g_aMedMoCellMotion[index].angle_change
      = (mxs_ang)((data->dtheta * 65536.0) / 360.0);

   data->texture_name_base[kMedmoSurfaceFilenameLength-1]='\0';
   strncpy(g_aEdMedMoSurface[index].texture_name_base,data->texture_name_base,
           kMedmoSurfaceFilenameLength);

   if (!GetWaterTexIDs(data->texture_name_base,
                       &g_aEdMedMoSurface[index].texture_above,
                       &g_aEdMedMoSurface[index].texture_below))
   {
      Warning(("No such water texture as %s\n",data->texture_name_base)); 
   }


   if (data->major_axis > 2)
      portal_cell_motion[index].major_axis = 2;
   else
      portal_cell_motion[index].major_axis = data->major_axis;

   portal_cell_motion[index].in_motion = data->in_motion;
}


// This is from gedmedmo.c.
extern void GEdMedMoMarkWaterAllBrushes(void);

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is called from the wide world of SDESC.  No matter the event
   we update the textures in the world.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void LGAPI SDESCCallback(sStructEditEvent *event, StructEditCBData data)
{
   sMotionEdit *result = (sMotionEdit *) data;

   switch (event->kind) {
      case kStructEdOK:
         {
            SetMotionStructuresFromSDESC(result);
            break;
         }
      case kStructEdCancel:
         {
            *result = temp_sMotionEdit;
            SetMotionStructuresFromSDESC(result);
            break;
         }
      case kStructEdApply:
         {
            SetMotionStructuresFromSDESC(result);
            break;
         }
   }
   GEdMedMoMarkWaterAllBrushes();
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   Our SDESC pop-up lets you change the anchor and delta of any medium
   motion index.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
BOOL EdMedMoSDESC(int motion_index)
{
   IStructEditor *sed;
   sStructEditorDesc editdesc;

   sprintf(editdesc.title, "flow group %d", motion_index);
   editdesc.flags = kStructEditNoApplyButton;

   SetSDESCFromMotionStructures(motion_index, &popup_sMotionEdit);
   SetSDESCFromMotionStructures(motion_index, &temp_sMotionEdit);

   sed = CreateStructEditor(&editdesc, &Desc_Desc, &popup_sMotionEdit);
   if (sed) 
   {
      IStructEditor_SetCallback(sed, SDESCCallback, &popup_sMotionEdit);
      IStructEditor_Go(sed,kStructEdModeless);
      SafeRelease(sed);
      return TRUE;
   } else
      return FALSE;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   Admittedly, this is a lot of fuss for traversing an array.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void EdMedMoSurfaceIterInit(tEdMedMoSurfaceIter *i)
{
   *i = 0;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This iterator finds those sEdMedMoSurfaces which have nonempty
   texture_name_base fields.  NULL means there's no more.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
sEdMedMoSurface *EdMedMoSurfaceIterNext(tEdMedMoSurfaceIter *i)
{
   while (*i < MAX_CELL_MOTION) {
      if (g_aEdMedMoSurface[*i].texture_name_base[0]) {
         *i += 1;
         return &g_aEdMedMoSurface[*i];
      }
      *i += 1;
   }

   return NULL;
}
// $Header: r:/t2repos/thief2/src/editor/edmedmo.h,v 1.4 2000/01/29 13:11:58 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   edmedmo.h

   export for marking cells in the world with the appropriate medium
   motion indices

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _EDMEDMO_H_
#define _EDMEDMO_H_

#include <lg.h>
#include <portal.h>
#include <texmem.h>
#include <edmedmos.h>

// In which we plow through the world rep and clear the motion_index
// field of every cell.
EXTERN void EdMedMoClearMediumMotionInPortals(void);

// When we start the editor or clear the level, we reset the medium
// motion structures, both inside portal and on our side.
EXTERN void EdMedMoClearMediumMotion(void);

// This is called for each water motion brush ("flow brush"?).
// It sets the medium for all cells which
//  * are flagged by our bounding function;
//  * can be reached from our seed point; and
//  * have the given medium, or one will turn into it (this lets us
//     flood temporary media like door brushes).
//
// We return the number of cells marked.
EXTERN int EdMedMoSetCells(mxs_vector *seed_pos, uchar medium,
                           uchar motion_index,
                           bool(*bounding_function)(mxs_vector *sample_point));

// pop up editing of position and motion for medium indices--
// the return value just tells us whether it worked
EXTERN BOOL EdMedMoSDESC(int motion_index);

EXTERN sEdMedMoSurface g_aEdMedMoSurface[MAX_CELL_MOTION];

// This iterator finds those sEdMedMoSurfaces which have nonempty
// texture_name_base fields.  NULL means there's no more.
EXTERN void EdMedMoSurfaceIterInit(tEdMedMoSurfaceIter *i);
EXTERN sEdMedMoSurface *EdMedMoSurfaceIterNext(tEdMedMoSurfaceIter *i);

// Look up water textures 
EXTERN BOOL GetWaterTexIDs(char *prefix, short *in_hnd, short *out_hnd);



#endif // ~_EDMEDMO_H_
// $Header: r:/t2repos/thief2/src/editor/edmedmos.h,v 1.4 2000/01/29 13:11:59 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   edmedmos.h

   This is the part of the medium motion data which is needed by the
   editor but not by the game.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _EDMEDMOS_H_
#define _EDMEDMOS_H_

#include <edmedmot.h>
#include <lress.h>

#define kMedmoSurfaceFilenameLength (RN_NAME_LEN + 1)

// The _change fields are for making the water move: dposition/second.
struct sEdMedMoSurface {
   short texture_above;
   short texture_below;
   char texture_name_base[kMedmoSurfaceFilenameLength];
   char pad[12];   // pad, used to be rgb stuff 
};

#endif // ~_EDMEDMOS_H_
// $Header: r:/t2repos/thief2/src/editor/edmedmot.h,v 1.2 2000/01/29 13:12:00 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   edmedmot.h

   This is the part of the medium motion data which is needed by the
   editor but not by the game.  Well, actually, it's just the typedef.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _EDMEDMOT_H_
#define _EDMEDMOT_H_

// The _change fields are for making the water move: dposition/second.
typedef struct sEdMedMoSurface sEdMedMoSurface;

typedef int tEdMedMoSurfaceIter;

#endif // ~_EDMEDMOT_H_
// $Header: r:/t2repos/thief2/src/editor/famedit.cpp,v 1.9 1998/10/04 02:17:24 dc Exp $
// editor only family management code

#include <stdlib.h>
#include <string.h>

#include <mprintf.h>

#include <lresname.h>

#include <editbr_.h>
#include <editbr.h>
#include <brinfo.h>
#include <brlist.h>

#include <family_.h>
#include <famedit.h>

#include <brushgfh.h>
#include <command.h>
#include <texmem.h>
#include <palmgr.h>
#include <status.h>

// for reporting on location of texture 0
#include <portal.h>
#include <portal_.h>
#include <wrdbrend.h>
#include <wrdb.h>
#include <anim_txt.h>
#include <render.h>

#include <report.h>

#include <dbmem.h>

// i am happy this isnt in stdlib, and thus not ruining the purity of cplusplus
#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b) )
#endif

// do we need to do this swap?
static BOOL check_swap(int *map_table, short *val, int cnt)
{
   int nval=0;
   if ((*val)==-1) return FALSE;
   if (((*val)>=WATERIN_IDX)&&((*val)<=255)) // hateful initial check to save sky_tex
      return FALSE;
   else if (((*val)>=0)&&((*val)<cnt))
      nval=map_table[*val];

   if (nval==-1) nval=0;   // since we dont want -1 if there is no texture
   if (nval!=(*val))
   {
      *val=(short)nval;
      return TRUE;
   }
   return FALSE;
}

// remap the current brush texture handles
BOOL _familyRemapBrushes(int *tex_swap, int cnt)
{
   editBrush *us;
   bool chg=FALSE;
   int i, hIter;

   us=blistIterStart(&hIter);
   tex_swap[BACKHACK_IDX]=BACKHACK_IDX;
   while (us!=NULL)
   {
      if (brushGetType(us)==brType_TERRAIN)
      {
         chg|=check_swap(tex_swap,&us->tx_id,cnt);
         for (i=0; i<us->num_faces; i++)
            chg|=check_swap(tex_swap,&us->txs[i].tx_id,cnt);
      }
      us=blistIterNext(hIter);
   }
   return chg;
}

// compress out unused family elements
static void family_cmd_compress(char *str)
{
   fam_record *toast_rec=NULL;
   int i, targ_loadid, hIter;
   int texs_used[TEXMEM_MAX];
   editBrush *us;
   
   if (stricmp("all",str)==0)
      targ_loadid=-1;
   else if (stricmp("anon",str)==0)
      targ_loadid=TEXMEM_LOADID_ANON;
   else
   {
      toast_rec=_fam_lookup_record(str);
      if (toast_rec)
         targ_loadid=toast_rec->load_id;
      else    // just remove this family
      {
         Status("No such family to compress");
         return;
      }
   }
   // scan through all textures, build count list for each texture
   memset(texs_used,0,sizeof(int)*TEXMEM_MAX);
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (brushGetType(us)==brType_TERRAIN)
      {
         if ((us->tx_id==-1)||(us->tx_id>=TEXMEM_MAX))
            Warning(("Brush id %d texture has id %d\n",us->br_id,us->tx_id));
         else
            texs_used[us->tx_id]++;
         for (i=0; i<us->num_faces; i++)
         {
            int val=us->txs[i].tx_id;
            if (val!=-1)
               if (val>=TEXMEM_MAX) // this shouldnt be possible
                  Warning(("Brush id %d texture has id %d on face %d\n",us->br_id,us->tx_id,i)); 
               else
                  texs_used[val]++;
         }
      }
      us=blistIterNext(hIter);      
   }
   // once done, for each unused, see if they match our loadid
   for (i=1; i<TEXMEM_MAX; i++)  // @TODO: get rid of ugly start at 1 due to secret knowledge hack
      if ((texs_used[i]==0)&&(i<texmemGetMax()))
         if ((targ_loadid==-1)||(texmem_loadid[i]==targ_loadid))
            texmemFreeSingle(i);
   if (toast_rec!=NULL)
      toast_rec->load_id=TEXMEM_LOADID_NULL;
   else if (targ_loadid==-1)
      _fam_clear_records();
   _fam_synch(TRUE);
}

// draw the histogram for this cnt element array, offset is "real" index of 0
static void _draw_histo(int *histo, int cnt, int offset, BOOL xtras, char **report_str, BOOL totals)
{
   int i, j, mem_used[2]={0,0}, usages_per=10;
   char buf[80*256], *p; // hey, editor only, woo-woo
   p=buf;
   for (i=0; i<cnt; i++)
   {
      IRes *me=texmemGetHandle(i+offset);
      int frames=0;
      int size=ectsAnimTxtGetRawSize(me,&frames);      
      if (histo[i])
      {
         if (xtras&&(i+offset>0))
         {
            grs_bitmap *bm=texmemGetTexture(i+offset);
            if ((size>128*128)&&histo[i]<16&&((i+offset)<250))
               if (frames>1)
                  rsprintf(&p,"WARNING: txt %s only %d uses, is %d frames %d by %d big (%dKb)\n",
                           me?me->GetName():"Unknown",histo[i],frames,bm?bm->w:0,bm?bm->h:0,size/1024);
               else
                  rsprintf(&p,"WARNING: txt %s only %d uses, is %d by %d big (%dKb)\n",
                           me?me->GetName():"Unknown",histo[i],bm?bm->w:0,bm?bm->h:0,size/1024);
            if (frames>1)
               rsprintf(&p," f%1.1d",frames);
            else
               rsprintf(&p,"   ");
            rsprintf(&p," %8.8s %3.3dx%3.3d  ",me?me->GetName():"Unknown",bm?bm->w:0,bm?bm->h:0);
            mem_used[0]+=size*4/3;
         }
         rsprintf(&p,"%3d|%5d>",i+offset,histo[i]);
         for (j=0; j<min((9+histo[i])/usages_per,xtras?46:66); j++)
            rsprintf(&p,"#");
         rsprintf(&p,"\n");
      }
      else if (i+offset>0)  // if not, we cant tell, so, oh well
         if (me)
         {
            grs_bitmap *bm=texmemGetTexture(i+offset);            
            mem_used[1]+=size*4/3;
            if (frames>1)
               rsprintf(&p," f%1.1d",frames);
            else
               rsprintf(&p,"   ");
            rsprintf(&p," %8.8s %3.3dx%3.3d  Is Unused\n",me?me->GetName():"Unknown",bm?bm->w:0,bm?bm->h:0);
         }
   }
   rsprintf(&p,"note: a single # represents a group of %d usages\n",usages_per);
   if (totals)
      rsprintf(&p,"Texture RAM in use in WR ~%dKb, ~%dKb loaded but not in world\n",mem_used[0]/1024,mem_used[1]/1024);
   if (report_str)
      rsprintf(report_str,buf);
   else
      mprint(buf);
}

// should look at something, someday
#define DoWeUseSky() GetSkyMode()==kSkyModeTextures?1:0

// look for this ID
static void family_find_tmap_id(int tmap_id)
{
   int i, used_this_face, hIter;
   int histo[257];
   char tmp[128];
   editBrush *us;
   int cnt[3];

   cnt[0]=cnt[1]=cnt[2]=0;
   memset(histo,0,sizeof(int)*257);
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (brushGetType(us)==brType_TERRAIN)
      {
         used_this_face=0;
         for (i=0; i<us->num_faces; i++)
         {
            if (us->txs[i].tx_id==-1)
               used_this_face++;
            else if (us->txs[i].tx_id==tmap_id)
               cnt[1]++;
            histo[us->txs[i].tx_id+1]++;
         }
         if (used_this_face>0)
         {
            if (us->tx_id==tmap_id)
            {
               cnt[0]++;
               cnt[2]+=used_this_face;
            }
            histo[us->tx_id+1]+=used_this_face;
         }
      }
      us=blistIterNext(hIter);
   }
   histo[250]=histo[251]=histo[252]=histo[253]=histo[254]=histo[255]=DoWeUseSky();
   sprintf(tmp,"Faces: %d Br: %d",cnt[1]+cnt[2],cnt[0]);
   Status(tmp);
   mprintf("TmapID %d: ",tmap_id);
   mprintf("%d brushes, %d face overrides, %d faces use it as brush base\n",cnt[0],cnt[1],cnt[2]);
   _draw_histo(histo,257,-1,TRUE,NULL,TRUE);
}

////////////////
// usage in WR, not brush list
static void texture_wr_usage_count(int tmap_id, char **rep_str)
{
   int histo[256];
   PortalCell *p;
   int ci, i;

   memset(histo,0,sizeof(int)*256);
   for (ci=0; ci<wr_num_cells; ci++)
      if ((p=wr_cell[ci])!=NULL)
         for (i=0; i<p->num_render_polys; i++)
            histo[p->render_list[i].texture_id]++;
   histo[250]=histo[251]=histo[252]=histo[253]=histo[254]=histo[255]=DoWeUseSky();
   if (tmap_id)
   {
      char buf[128];
      if (histo[tmap_id])
         sprintf(buf,"Tmap %d used %d times",tmap_id,histo[tmap_id]);
      else
         sprintf(buf,"Tmap %d not used");
      Status(buf);
   }
   else
      _draw_histo(histo,256,0,TRUE,rep_str,TRUE);
}

static void wr_usage_count_cmd(int tmap_id)
{
   texture_wr_usage_count(tmap_id,NULL);
}

//////////////
// find texture zero usages in the WR
static void texture_wr_find_zero(char **rep_str)
{
   char *b, *m=NULL;  // ?????
   PortalCell *p;
   int ci, i, zeroes_found=0;

   if (rep_str)
      b=*rep_str;
   else
   {
      b=m=(char *)Malloc(16384);
      m[0]='\0';
   }


   for (ci=0; ci<wr_num_cells; ci++)
      if ((p=wr_cell[ci])!=NULL)
      {
         int voff=0;
         for (i=0; i<p->num_render_polys; i++)
         {
            PortalPolygonCore *poly=&p->poly_list[i];
            if (p->render_list[i].texture_id==0)
            {
               int k, n=poly->num_vertices;
               zeroes_found++;
               rsprintf(&b,"Cell %d poly %d uses texture 0\n",ci,i);
               for (k=0; k<n; k++)
                  rsprintf(&b," %.2f %.2f %.2f%s",
                          p->vpool[p->vertex_list[voff+k]].el[0],
                          p->vpool[p->vertex_list[voff+k]].el[1],
                          p->vpool[p->vertex_list[voff+k]].el[2],
                           (k==(n-1))?"\n":" :");
            }
            voff+=poly->num_vertices;
         }
      }
   rsprintf(&b,"Found %d zero textures in level\n",zeroes_found);
   if (m)
   {
      mprint(m);
      Free(m);
   }
   else
      *rep_str=b;
}

static void wr_find_zero_cmd(void)
{
   texture_wr_find_zero(NULL);
}

// bridge over to the palmgr counter functions
static void pal_bridge_func(BOOL spew)
{
   int cnt=palmgr_get_current_count(spew);
   char buf[20];

   sprintf(buf,"Using %d pals",cnt);
   Status(buf);
}

///////////////////////
// report functions for textures/WR

#ifdef REPORT
static void _textures_report(int WarnLevel, void *data, char *buffer)
{
   char *p=buffer;

   rsprintf(&p,"\nWorld Rep Textures\n");

   // first lets scan for warnings
   texture_wr_find_zero(&p);

   // now lets check for grim scenes
   if (WarnLevel>=kReportLevel_Info)
      texture_wr_usage_count(0,&p);
}
#endif
 
// editor only family commands 
static Command family_commands[]=
{
   { "compress_family", FUNC_STRING, family_cmd_compress, "remove unused textures from family or <all>" },
   { "texture_usage_count", FUNC_INT, family_find_tmap_id, "get usage count for this texture" },
   { "texture_wr_usage_count", FUNC_INT, wr_usage_count_cmd, "get wr usage for tmap_id, or histo if 0" },
   { "texture_wr_find_zero", FUNC_VOID, wr_find_zero_cmd, "find texture zero in the world" },   
   { "palmgr_count", FUNC_BOOL, pal_bridge_func },
};

// start up the famedit stuff
void family_edit_init(void)
{
   COMMANDS(family_commands,HK_EDITOR);
   ReportRegisterGenCallback(_textures_report,kReportWorldDB,"Textures",NULL);   
}

void family_edit_term(void)
{
   ReportUnRegisterGenCallback(_textures_report,kReportWorldDB,NULL);   
}
// $Header: r:/t2repos/thief2/src/editor/famedit.h,v 1.1 1998/04/12 17:16:08 mahk Exp $
#pragma once  
#ifndef __FAMEDIT_H
#define __FAMEDIT_H

#ifdef EDITOR
EXTERN BOOL _familyRemapBrushes(int *tex_swap, int cnt); 
EXTERN void family_edit_init(void); 
#else
#define _familyRemapBrushes(foo,bar) TRUE
#define family_edit_init()
#endif 


#endif // __FAMEDIT_H
// $Header: r:/t2repos/thief2/src/editor/filemenu.cpp,v 1.5 1998/10/17 19:28:42 dc Exp $

#include <lg.h>
#include <comtools.h>
#include <filemenu.h>
#include <str.h>
#include <dbfile.h>

// for the windows controls
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commdlg.h>

#include <wappapi.h>
#include <loopapi.h>
#include <appagg.h>

// must be last header
#include <dbmem.h>

char* FileDialog(eFileMenuMode mode, sFileMenuFilter* pFilters, const char* def_ext, char* buffer, int buflen)
{
   // we need the main app's HWND
   AutoAppIPtr_(WinApp,pWA);

   buffer[buflen-1] = '\0';

   // clear out and init the Open Common Dialog information
   OPENFILENAME ofn;
   memset(&ofn, 0, sizeof(OPENFILENAME));
   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = pWA->GetMainWnd();
   ofn.hInstance = pWA->GetInstance();
   
   // build filters
   cStr filterstring = "";
   sFileMenuFilter* f;
   int idx = 0; 
   int i;
   int extlen = strlen(def_ext);

   for (i = 1, f = pFilters; f != NULL && f->text != NULL; f++, i++)
   {
      filterstring += f->text;
      filterstring += '\0';
      filterstring += f->pattern;
      filterstring += '\0';

      // look for def_ext inside pattern, in order to figure out default pattern.
      if (idx == 0)
         for (char* s = f->pattern; *s != '\0'; s++)
            if (strnicmp(s,def_ext,extlen) == 0)
            {
               idx = i; 
               break;
            }
   }

   filterstring += '\0';
   filterstring += '\0';
   const char* fstring = filterstring;
   
   ofn.lpstrFilter = (char*)fstring;
   ofn.lpstrDefExt = def_ext;
   ofn.nFilterIndex = idx; 
   ofn.lpstrFile = buffer;
   ofn.nMaxFile = buflen;
   ofn.Flags = OFN_NOCHANGEDIR|OFN_HIDEREADONLY; 
   if (mode == kFileMenuLoad)
      ofn.Flags |= OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;

   // do the load or save (NOTE: we only get the file name here -- the actual loading and
   // saving is done in load_world or save_world)
   BOOL found = FALSE;
   switch (mode)
   {
      case kFileMenuLoad:
         found = GetOpenFileName(&ofn);
         break;
      case kFileMenuSave:
         found = GetSaveFileName(&ofn);
         break;
   }

   return (found) ? buffer : NULL;   
}

#ifdef EDITOR

////////////////////////////////////////

#define ID_LOAD   0
#define ID_SAVE   1
#define ID_CLEAR  2

// our stupid static storage
static HWND hMainWnd, hConWnd = NULL;

// in dbfile.c 
EXTERN void load_file(char *str);
EXTERN void save_world(char *arg);

// the WndProc for the file menu - this only gets messages for this small file menu
LRESULT CALLBACK FileMenuWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   int result;

   switch(msg)
   {
      case WM_COMMAND:
         switch(LOWORD(wParam))
         {
            case ID_LOAD:
               load_file(NULL);
               break;

            case ID_SAVE:
               save_world(NULL);
               break;

            case ID_CLEAR:
               result = MessageBox(hConWnd, "Are you sure?", "Clear World", MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
               if (result == IDYES)
                  dbBuildDefault();
               break;
         }

         // restore the focus to the parent window
         SetFocus(hWnd);
         break;

      case WM_CLOSE:
         // on close, make the main app window active
         SetFocus(hMainWnd);
         hConWnd = NULL;
         break;
   }

   return DefWindowProc(hWnd, msg, wParam, lParam);
}

//
// create a new little file menu window and put some buttons on it
//

void FileMenu(void)
{
   IWinApp* pWA;
   HINSTANCE hMainInst, hConInst;
   WNDCLASS wc;
   static char *szName = "File menu";
   int top, left, width, height;

   // are we already active?
   if (hConWnd)
   {
      Warning(("FileMenu: already active!\n"));
      return;
   }

   // we need the main app's HWND
   pWA = AppGetObj(IWinApp);
   hMainWnd = IWinApp_GetMainWnd(pWA);
   SafeRelease(pWA);

   // we also need the main app's HINSTANCE
   hMainInst = (HINSTANCE) GetWindowLong(hMainWnd, GWL_HINSTANCE);

   // set up the new window's class
   memset(&wc, 0, sizeof(WNDCLASS));
   wc.style = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc = FileMenuWndProc;
   wc.hInstance = hMainInst;
   wc.hbrBackground = (HBRUSH) GetStockObject(LTGRAY_BRUSH);
   wc.lpszClassName = szName;

   // and register it
   RegisterClass(&wc);

   // make it so big
   width = 140;
   height = 160;
   top = (GetSystemMetrics(SM_CXSCREEN) - width) / 2;
   left = (GetSystemMetrics(SM_CYSCREEN) - height) / 2;

   // and create it!
   hConWnd = CreateWindow(szName, "File menu", WS_OVERLAPPED | WS_SYSMENU, top, left, width, height,
                          hMainWnd, NULL, hMainInst, NULL);

   ShowWindow(hConWnd, SW_SHOWNORMAL);
   UpdateWindow(hConWnd);

   // get our new window's HINSTANCE
   hConInst = (HINSTANCE) GetWindowLong(hConWnd, GWL_HINSTANCE);

   // and create the buttons on it
   CreateWindow("BUTTON", "Load world", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                25, 20, 90, 25, hConWnd, (HMENU) ID_LOAD, hConInst, NULL);
   CreateWindow("BUTTON", "Save world", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                25, 55, 90, 25, hConWnd, (HMENU) ID_SAVE, hConInst, NULL);
   CreateWindow("BUTTON", "Clear world", WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON,
                25, 90, 90, 25, hConWnd, (HMENU) ID_CLEAR, hConInst, NULL);
}

#endif
// $Header: r:/t2repos/thief2/src/editor/filemenu.h,v 1.2 2000/01/29 13:12:03 adurant Exp $
#pragma once

#ifndef __FILEMENU_H
#define __FILEMENU_H

////////////////////////////////////////////////////////////
// FILE GUI API
//

//
// File dialog open modes
//

enum eFileMenuMode 
{
   kFileMenuLoad,
   kFileMenuSave,
};

typedef enum eFileMenuMode eFileMenuMode;

//
// filter for file names
//

struct sFileMenuFilter 
{
   char* text;  // text filter description
   char* pattern; // wildcarded file patter
};

typedef struct sFileMenuFilter sFileMenuFilter;

// 
// put up a file dialog, returns the selected file name
// takes a null-terminated list of filters
//

EXTERN char* FileDialog(eFileMenuMode mode, sFileMenuFilter* pFilters, const char* defaultExtension, char* fnamebuf, int buflen);

//
// Bring up a little menu of load and save buttons
// 

EXTERN void FileMenu(void);


#endif // __FILEMENU_H
// $Header: r:/t2repos/thief2/src/editor/flowpnp.cpp,v 1.9 2000/02/19 13:10:39 toml Exp $
// flow PnP gadget

#include <config.h>
#include <gadblist.h>
#include <lgsprntf.h>

#include <command.h>

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <gedit.h>
#include <edmedmo.h>
#include <gedmedmo.h>

#include <brushGFH.h>
#include <PnPtools.h>

#include <appagg.h>
#include <flowarch.h>
#include <propman.h>
#include <iobjed.h>
#include <objedbas.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 *
 *        0 pic?
 *
 *    1  [ group ]  
 *    2  [ edit group ]
 *    3  [ update in world ]
 */

#define NUM_BUTTONS 5
static Rect flowPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (flowPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 0
#define BTN_BELOW 4
#define VERT_DIV  3
#define HORIZ_DIV 0

void flowPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,HORIZ_DIV,1,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,0,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[1].ul.y-2;
}

// actual setup for the PnP
static editBrush *flowPnP_br=NULL;
static _PnP_GadgData flowPnP;
static int _local_index;
static IFlowGroupProperty* flowprop = NULL; 

#define DO_GROUP 0
#define DO_EDIT 1
#define DO_UPDATE_WORLD 2
#define DO_EDIT_OBJ 3

// update means the world should be set from the vars, else the opp
static void flowPnP_setvars(editBrush *br, bool update)
{
   flowPnP_br=br;
   if (br==NULL) return;
   if (update)
   {
      brFlow_Index(br)=_local_index;
      i_changed_the_brush(br,FALSE,FALSE,FALSE);
   }
   else
   {
      _local_index=brFlow_Index(br);
   }
}

// Here's what mouse clicks do.
static void flowPnP_DoGroupClick(int button)
{  
   switch (button)
   {
      case DO_EDIT:
      {
         EdMedMoSDESC(brFlow_Index(flowPnP_br));
         break;
      }

      case DO_UPDATE_WORLD:
      {
         GEdMedMoMarkWaterAllBrushes();
         break;
      }

      case DO_EDIT_OBJ:
      {
         ObjID obj = flowprop->GetObj(brFlow_Index(flowPnP_br)); 

         sObjEditorDesc objeddesc = { "" }; 
         AutoAppIPtr_(ObjEditors,pEditors);
         IObjEditor* ed = pEditors->Create(&objeddesc,obj); 

         ed->Go(kObjEdModal);

         SafeRelease(ed); 
         break; 
      }
   }
}

static void flowPnP_IntFrob(PnP_SliderOp op, Rect *where, int val, int data)
{
   if (op==PnP_SliderUpdateOp)
      flowPnP_setvars(flowPnP_br,TRUE);
}

// Hey, this is a lot smaller than the 256 possible flow groups.  
// If we discover that this is enough, maybe we should shrink the db. 
#define MAX_FLOW_INDEX 64

EXTERN void Create_flowPnP(LGadRoot* root, Rect* bounds, editBrush *br)
{
   GFHSetCoordMask(GFH_ALL_COORDS);
   flowPnP_buildRects(bounds);
   PnP_GadgStart(&flowPnP,root);   
   flowPnP_setvars(br,FALSE);
   PnP_PictureBox(getRect(0), NULL, 0); // making this a bool * is super icky
   PnP_SliderInt(getRect(1),"Group", 1, MAX_FLOW_INDEX, 1,
                 &_local_index, flowPnP_IntFrob, DO_GROUP, PNP_SLIDER_VSLIDE);
   PnP_ButtonOneShot(getRect(2), "Edit Group", flowPnP_DoGroupClick, DO_EDIT);
   PnP_ButtonOneShot(getRect(3), "Update In World", flowPnP_DoGroupClick, 
                     DO_UPDATE_WORLD);
   PnP_ButtonOneShot(getRect(4), "Properties", flowPnP_DoGroupClick, 
                     DO_EDIT_OBJ);

   AutoAppIPtr_(PropertyManager,pPropMan); 
   cAutoIPtr<IProperty> prop ( pPropMan->GetPropertyNamed(PROP_FLOW_GROUP_NAME)); 
   Verify(SUCCEEDED(prop->QueryInterface(IID_IFlowGroupProperty,(void**)&flowprop))); 
   

}

EXTERN void Destroy_flowPnP(void)
{
   PnP_GadgFree(&flowPnP);
   flowPnP_br=NULL;
   SafeRelease(flowprop); 
}

EXTERN void Update_flowPnP(GFHUpdateOp op, editBrush *br)
{
   flowPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      PnP_FullRedraw(&flowPnP);
}

// $Header: r:/t2repos/thief2/src/editor/fvaredit.cpp,v 1.3 2000/02/19 13:10:40 toml Exp $

#include <appagg.h>
#include <filevar.h>
#include <fvaredit.h>
#include <command.h>
#include <simpwrap.h>
#include <dynarray.h>

#include <sdestool.h>
#include <edittool.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

typedef cDynArray<cFileVarBase*> cVarArray; 
typedef cDynArray<const char*> cStringArray; 

static const char* titles[] = { "Misson Variables", "GameSys Variables", "Campaign Variables" }; 

static void edit_filevar_type(int file)
{
   cVarArray vars;
   cStringArray names; 
   int n = 0; 

   AutoAppIPtr_(StructDescTools,pSdescTools);
   AutoAppIPtr(EditTools); 

   cFileVarList* list = cFileVarBase::AllFileVars(); 

   if (list != NULL)
      for (cFileVarList::cIter iter = list->Iter(); !iter.Done(); iter.Next())
      {
         cFileVarBase* fv = iter.Value(); 
         if (fv->mDesc->file == file && pSdescTools->Lookup(fv->mDesc->type))
         {
            n++;
            vars.Append(fv);
            names.Append(fv->mDesc->friendly_name); 
         }
      }

   if (n == 0)
   {
      n++; 
      names.Append("<No vars>"); 
   }

   int i = PickFromStringList((char*)titles[file],names,n); 

   if (i >= 0 && i < vars.Size())
   {
      cFileVarBase* fv = vars[i]; 
      if (pEditTools->EditTypedData(names[i],fv->mDesc->type,fv->mBlock) == S_OK)
         fv->Update(); 
   }
}


//
// Command list 
//

static Command commands[] = 
{
   { "edit_file_vars", FUNC_INT, edit_filevar_type, "0 = mission vars, 1 = gamesys vars, 2 = cmpaign vars" }, 
};

void FileVarEditInit(void)
{
   COMMANDS(commands,HK_EDITOR); 
}

void FileVarEditTerm(void)
{
}
// $Header: r:/t2repos/thief2/src/editor/fvaredit.h,v 1.1 1998/07/13 14:26:16 mahk Exp $
#pragma once  
#ifndef __FVAREDIT_H
#define __FVAREDIT_H

//
// File Variable Editor
//

EXTERN void FileVarEditInit(void); 
EXTERN void FileVarEditTerm(void); 

#endif // __FVAREDIT_H
// $Header: r:/t2repos/thief2/src/editor/gedit.c,v 2.10 2000/02/18 17:20:57 MAT Exp $

// gedit.c
// contains functionality for test program

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>

#include <lg.h>
#include <mprintf.h>
#include <appagg.h>
#include <r3d.h>
#include <lgd3d.h>
#include <md.h>
#include <star.h>
#include <dump.h>
#include <event.h>
#include <config.h>
#include <kbcook.h>
#include <appagg.h>

#include <portal.h>
#include <command.h>
#include <cfgtool.h>

#include <objpos.h>
#include <objedit.h>
#include <osysbase.h>

#include <animlgt.h>
#include <cvtbrush.h>
#include <editbr.h>
#include <editbr_.h>
#include <primal.h>
#include <brlist.h>
#include <brinfo.h>
#include <brobjpro.h>
#include <brrend.h>
#include <vbrush.h>
#include <editobj.h>
#include <csg.h>
#include <csgbrush.h>
#include <viewmgr.h>
#include <status.h>
#include <undoredo.h>
#include <brundo.h>
#include <brquery.h>
#include <gridsnap.h>
#include <gedit.h>
#include <ged_rend.h>
#include <ged_undo.h>
#include <ged_csg.h>
#include <ged_line.h>
#include <winui.h>
#include <ged_room.h>
#include <animlit.h>
#include <family.h>     // for texture family loads and unloads, commands
#include <texprop.h>
#include <media.h>
#include <mediaop.h>
#include <editobj.h>
#include <filetool.h>
#include <vumanui.h>
#include <gamecam.h>
#include <appsfx.h>
#include <scrnman.h>
#include <skyrend.h>
#include <texmem.h>
#include <txtpnp.h>
#include <objlight.h>
#include <wrmem.h>
#include <preload.h>
#include <modalui.h>
#include <starhack.h>
#include <bldstair.h>
#include <hilight.h>
#include <gedmedmo.h>
#include <doorphys.h>
#include <iobjsys.h>
#include <physapi.h>
#include <missrend.h>
#include <pgrpprop.h>
#include <saveload.h>

#include <resapi.h>
#include <imgrstyp.h>

#include <prof.h>
#include <objshape.h>
#include <objmodel.h>
#include <editsave.h>

#include <rendobj.h>    // for rendobj_name_color

#include <comtools.h>
#include <traitman.h>

#include <dbmem.h>      // last included file

extern BOOL g_lgd3d;

extern int scale_factor;

int TERRAIN_ID = 0xFFFF;
int MAX_LOCKED_BRUSHES = 50;

ObjID gLockedBrushes [50];
BOOL brushIsLocked (editBrush* brush);
void UpdateMenuCheckmarks (void);

Grid cur_global_grid = { 4.0, { 0,0,0 }, { 0,0,0 }, TRUE};

void gedit_register(void);

// initialize geom editor, specifically brush lists
void gedit_init(void)
{
   gedit_register();
   undoStackInit();
   gedLineInit();
}

void gedit_full_redraw(void)
{
   vm_redraw();
}

void gedit_redraw_3d(void)
{
   vm_redraw_from_new3d();
}

void gedit_term(void)
{
   undoStackFree();
   gedLineTerm();
}

static editBrush *gedit_find_point(int camera, int x, int y)
{
   editBrush *us, *winner=NULL;
   int useFlag=brFlag_COLOR_NONE, hIter;
   float best_dist=DISTANCE_INF;  // bigger than x+y screen coordinates

   if (!vm_get_3d(camera)) useFlag|=brFlag_IsoView;
   brushSetupDraw(useFlag,camera);
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      float dist=brushClickCheck(us,x,y);
      if (dist<best_dist)
      {
         winner=us;
         best_dist=dist;
      }
      us=blistIterNext(hIter);
   }
   return winner;
}

BOOL gedit_click(int flags, int x, int y, int camera)
{
   editBrush *us;
   BOOL rv=FALSE;
   int brush, face;

   if (flags&GEDIT_CLICK_IS3D)
      rv=vm_pick_camera(camera,x,y,&brush,&face);

   if (rv)  // if it wasnt 3d, rv is always false here
   {   // this is only taken on 3d cameras which vm can pick for (ie. solid)
      int cur_txt;
      us=csg_brush[brush];

      if ((us)&&(brushGetType(us)!=brType_HOTREGION))
      {
         BOOL do_select=TRUE;
         // some autotexture if palette up thing here....?
         cur_txt=txtPnP_pal_query();
         if (cur_txt!=TXTPNP_NO_PAL_UP)
         {
            int old_face=us->cur_face;  // save face, cause we dont want to change selection
            us->cur_face=face;          //    in tpal mode
            gedit_texture_brush(us,cur_txt);
            us->cur_face=old_face;
            do_select=config_is_defined("txtrpal_select");
            if (txtPnP_attached())
            {
               if (!config_is_defined("txtrpal_no_detach"))
                  txtPnP_detach(); // people hate this....
               if (txtPnP_attached())
                  do_select=TRUE;
            }

         }
         if (do_select)
         {
				us->cur_face=face;
            flags&=~GEDIT_CLICK_FANCY;  // cant be a fancy click in 3d scene
            flags|=GEDIT_CLICK_NOTOGGLE;
            brSelect_Flag(us)&=~brSelect_COMPLEX;
            vBrush_click(us,flags,x,y);   // needs xy for fancy clicks
         }
      }
      else
         rv=FALSE;
   }                              // or should fancy clicks autotexture?
   else
   {
      vm_set_camera_canvas(camera);
      vm_start_3d(camera);
      us=gedit_find_point(camera,x,y);
      if (us)
      {
         vBrush_click(us,flags,x,y);   // needs xy for fancy clicks
         rv=TRUE;
      }
      vm_end_3d(camera);
      vm_unset_camera_canvas();
   }
   return rv;
}

// get the maximal extent of a level
mxs_vector *gedit_get_extent(BOOL hot_region_p)
{
   static mxs_vector bounds[2];
   int hot_found=0, hIter;
   editBrush *us;

   mx_mk_vec(&bounds[0],0.0,0.0,0.0);
   mx_mk_vec(&bounds[1],0.0,0.0,0.0);
   brushConvertStart();
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (hot_region_p)
      {
         if (brushGetType(us)==brType_HOTREGION)
         {
            brushCheckExtents(us,bounds);
            hot_found++;
         }
      }
      else
         brushCheckExtents(us,bounds);
      us=blistIterNext(hIter);
   }
   brushConvertEnd();
   if (hot_region_p&&hot_found==0)
   {  // bounds are still 0, since we saw nothing, so lets just go do everything
      brushConvertStart();
      us=blistIterStart(&hIter);
      while (us!=NULL)
      {
         brushCheckExtents(us,bounds);
         us=blistIterNext(hIter);
      }
      brushConvertEnd();
      Warning(("no hot region\n"));
   }
   return &bounds[0];
}

// if you need to take all objects out and put them back in?
static void gedit_replace_all_objs(void)
{
   editobjFullDeref();
   editobjFullReref();
}

static int focus_br_id=-1;

// inside gedit, we want non scripted lights, so this deals
void gedit_enter(void)
{
#ifdef FAST_DYNAMIC_LIGHTING
   gedcsg_relight_level();
#endif
   if (focus_br_id!=-1)
      vBrush_SelectBrush(brFind(focus_br_id));
   editUndoSuspend(FALSE);
   vm_resume(); 
}

void gedit_exit(void)
{
   if (gedit_editted)
   {
      if (winui_GetYorN("Portalization Not Up to Date.  Reportalize?"))
         build_level();
   }
   else if (!gedcsg_lighting_ok)
      if (winui_GetYorN("Lighting Not Up to Date.  Relight?"))
         gedcsg_relight_level();

   if (!g_RoomsOK)
   {
#if 0
      if (winui_GetYorN("Room database Not Up to Date.  Recompile?"))
#endif
         ged_compile_rooms();
   }

#ifdef FAST_DYNAMIC_LIGHTING
   gedcsg_relight_level();
#endif
   editUndoSuspend(TRUE);
   undoClearUndoStack();
   focus_br_id=vBrush_GetSel()->br_id;
   vm_suspend(); 
}

///////////////////
// snapping control

// this is to make following brush getting code easier/smaller (and backwards compatible, to boot)
#define cur vBrush_editBrush_Get

#define FLOAT_SNAP_TOL 0.00001
static float  gedit_snap_pos=0.5, gedit_snap_sz=0.5;
static fixang gedit_snap_ang=0x1000;
static BOOL   gedit_snap_placement=TRUE;

// returns whether or not it snapped, in its mind
BOOL _floatSnap(float *val, float snap)
{
   float newval=floor(((*val)+snap/2) / snap) * snap;
   float oldval=*val;
   *val=newval;
   return newval!=oldval;
}

BOOL _fixangSnap(fixang *val, fixang snap)
{
   fixang toround=(*val)+snap/2;
   fixang newval=toround-(toround%snap);
   fixang oldval=*val;
   *val=newval;
   return newval!=oldval;
}

BOOL _gedit_float_snap(float *val)
{
   return _floatSnap(val,cur_global_grid.line_spacing);
}

static mxs_vector vbrush_hack_delta;

static void delta_snap_op(editBrush *us)
{
   mx_addeq_vec(&us->pos,&vbrush_hack_delta);
}


BOOL snap_brush_by_vertex_hack(editBrush *us)
{
   int i;
   BOOL snapped = FALSE;
   mxs_vector bounds[2];
   mxs_vector size;
   float r;

   brushConvertStart();
   mx_copy_vec(&bounds[0],&us->pos);
   mx_copy_vec(&bounds[1],&us->pos);
   brushCheckExtents(us,bounds);
   brushConvertEnd();
   mx_sub_vec(&size,&bounds[1],&bounds[0]);
   mx_diveq_vec(&size,2.0F);
   for (i=0; i<3; i++)
   {
      // okay, now figure out whether to snap real or half
      r = (float)fmod((double)size.el[i],(double)cur_global_grid.line_spacing);
      // if we were 1.0 aligned, center must also be 1.0 aligned
      if (r <= cur_global_grid.line_spacing / 4) // if exact match, 1.0 aligned
      {
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing);
      }
      else
      {
         // if we were 0.5 aligned, center must also be 0.5 aligned, but NOT 1.0 aligned
         us->pos.el[i] += cur_global_grid.line_spacing / 2; // first put it off by 0.5
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing); // then "1.0" align
         us->pos.el[i] -= cur_global_grid.line_spacing / 2; // now restore from offset
      }
   }

   return(snapped);
}

BOOL gedit_snap_brush(editBrush *us)
{
   BOOL snapped=FALSE;
   int i;

   if (!cur_global_grid.grid_enabled)
      return FALSE;
   if (us==NULL)
      us=cur();
   if (brSelect_Flag(us)==brSelect_VIRTUAL)
   {
      // note that vbrush snap only defined for positioning, 
      // not angle or size, is this OK?
      if (config_is_defined("vbrush_snap"))
      {
         editBrush *mbsel;
         mxs_vector oldpos;

         // record old data
         mbsel = vBrush_GetSel();
         mx_copy_vec(&oldpos, &mbsel->pos);

         // snap center point
         snap_brush_by_vertex_hack(mbsel);

         // note delta and restore
         mx_sub_vec(&vbrush_hack_delta,&mbsel->pos,&oldpos);
         mx_copy_vec(&mbsel->pos,&oldpos);

         // apply delta to all brushes individually
         // since we have no mechanism for passing data into this we stuff
         // the translation factor into the aptly named vbrush_hack_delta
         vBrush_GroupOp(FALSE, delta_snap_op);

         return snapped;
      }
      else
         return FALSE;
   }
   if (!((brushGetType(us)==brType_TERRAIN)||(brushGetType(us)==brType_ROOM)))
      return FALSE;

   if (config_is_defined("new_snap"))
   {
      for (i=0; i<3; i++)
      {  
         // note we snap size first to keep the game from resizing already happily sized brushes
         // find the closest size that can be 0.5 or 1.0 aligned
         snapped|=_floatSnap(&us->sz.el[i],cur_global_grid.line_spacing/2);
      }
      snapped |= snap_brush_by_vertex_hack(us);
      for (i=0; i < 3; i++)
         snapped|=_fixangSnap(&us->ang.el[i],gedit_snap_ang);
   }
   else
   {
      for (i=0; i<3; i++) {
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing);
         snapped|=_floatSnap(&us->sz.el[i],cur_global_grid.line_spacing);
         snapped|=_fixangSnap(&us->ang.el[i],gedit_snap_ang);
      }
   }
   return snapped;
}

void gedit_snap_object (editBrush *us)
{
   int i;
   Location objLoc, newLoc;
   mxs_vector minv, maxv;
   mxs_vector minSnap, maxSnap;
   mxs_vector minOffset, maxOffset;
   
   //  Snap objects by their closest vertex
   //
   ObjGetObjOffsetBBox(brObj_ID(us), &minv, &maxv);
   mx_add_vec (&minv, &minv, &us->pos);
   mx_add_vec (&maxv, &maxv, &us->pos);
   minSnap = minv;
   maxSnap = maxv;

   for (i=0; i<3; i++)
   {  
       _floatSnap (&minSnap.el[i], cur_global_grid.line_spacing);
       _floatSnap (&maxSnap.el[i], cur_global_grid.line_spacing);
   }

   mx_sub_vec (&minOffset, &minSnap, &minv);
   mx_sub_vec (&maxOffset, &maxSnap, &maxv);

   for (i=0; i<3; i++)
   {
       us->pos.el[i] += (fabs(minOffset.el[i]) < fabs(maxOffset.el[i])) ? minOffset.el[i] : maxOffset.el[i];
   }

   objLoc = ObjPosGet(brObj_ID(us))->loc;
   MakeHintedLocationFromVector (&newLoc, &us->pos, &objLoc);
   ObjPosSetLocation (brObj_ID(us), &newLoc);
}

void gedit_set_snaps(float snap_pos, float snap_sz, fixang snap_ang)
{
   if (snap_pos>0) gedit_snap_pos=snap_pos;
   if ( snap_sz>0) gedit_snap_sz =snap_sz;
   if (snap_ang>0) gedit_snap_ang=snap_ang;  // 1 really means no snap
}

////////////////////
/// grid stuff

void grid_get_from_current(void)
{
   cur_global_grid = cur()->grid;
   gedit_full_redraw();
}

void grid_set_from_current(void)
{
   cur()->grid = cur_global_grid;
}

void grid_toggle(void)
{
   cur_global_grid.grid_enabled = !cur_global_grid.grid_enabled;
   gedit_full_redraw();
}

void grid_scale(float scale)
{
   cur_global_grid.line_spacing *= scale;
   gedit_full_redraw();
}

void grid_abs_scale(float scale)
{
   cur_global_grid.line_spacing = scale;
   gedit_full_redraw();
}

void grid_pow2_scale(int pow2)
{
   float real_scale=scale_pow2int_to_float(pow2);
   grid_abs_scale(real_scale);
}

// this, sadly, needs to convert the scale (currently a spacing float) to a pow2 rep
// so we do the stupid thing, cause we are, as they say... stupid
int get_pow2_scale(void)
{
   float val;
   int i;

   for (i=8; i<18; i++)
   {
      val=scale_pow2int_to_float(i);
      if (val>=cur_global_grid.line_spacing)
         return i;
   }
   return 16;  // default, since we dont know
}

//////////////
// brush build/control stuff

int brush_build_type=brType_TERRAIN;

// if build_type is -1, then if old that is type, else type is left alone, else use build_type
// if old is non-Null, then misc_settings (old format) are assumed, and old is passed down to field_update
// at_end means place new brush at end, else place at current
BOOL gedit_full_create_brush(editBrush *new_br, editBrush *old, ulong flags, int build_type)
{
   IObjectSystem *pObjSys = AppGetObj(IObjectSystem);
   BOOL at_end = flags & GEDIT_CREATE_AT_END;
   ulong field_flags = brField_New;

   IObjectSystem_Lock(pObjSys);

   if (build_type!=-1)
      brushSetType(new_br,build_type);
   else if (old)
      brushSetType(new_br,brushGetType(old));

   if (flags & GEDIT_CREATE_CLONE)
      field_flags |= brField_Clone;
   brush_field_update(new_br,old,field_flags);      // copy over relevant settings - we are always a new brush

   blistSeek(0,at_end?SEEK_END:SEEK_CUR);    // now actually put the thing there
   blistInsert(new_br);                      // put us in the list
   editUndoStoreCreate(new_br);
   if (brushGetType(new_br)==brType_TERRAIN)
      gedit_db_update(FALSE);
   gedit_full_redraw();

   IObjectSystem_Unlock(pObjSys);
   SafeRelease(pObjSys);

   return TRUE;
}

void gedit_set_default_brush_type(int br_type)
{
   brush_build_type=br_type;
}

int gedit_default_brush_type(void)
{
   return brush_build_type;
}

///////////////////
// status and control

static BOOL auto_portalize;
static BOOL auto_roombuild;

BOOL gedit_editted=TRUE;

void gedit_db_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_portalize)
   {
      build_level();
      gedit_redraw_3d();
   }
   else
   {
      gedit_editted=TRUE;
      StatusField(SF_FILESTATE,"*");
   }
}

void gedit_light_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_portalize)
   {
      gedcsg_relight_level();
      gedit_redraw_3d();
   }
   else
   {
      gedcsg_lighting_ok=FALSE;
      StatusField(SF_FILESTATE,"*");
   }
}

void gedit_room_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_roombuild)
      ged_compile_rooms();
   else
   {
      g_RoomsOK = FALSE;
      StatusField(SF_FILESTATE,"*");
   }
}

// @VBRUSH
// fully general find a brush, move it to n
// kinda icky since all brush ops op on current, so it is a mess
// i should just go do this right
bool set_brush_to_time_n(editBrush *br, int n)
{
   editBrush *old_Curs=blistGet();
   int oldPos=blistCheck(br);
   bool is_us=(br==old_Curs), rv=TRUE;

   if (oldPos==-1) return FALSE;
   if (oldPos==n)  return TRUE;
   if (!is_us)
      blistSetPostoBrush(br);
#ifdef DBG_ON
   if (br!=blistDelete())
      Warning(("Hey delete didnt delete us???"));
#else
   blistDelete();
#endif
   //   if ((n<oldPos)&&(n>0)) n--;   // ????
   if (n>0) n--;
   if (!blistSeek(n,SEEK_SET))
   {
      rv=FALSE;
      Warning(("Hey, couldnt seek to new time"));
   }
   blistInsert(br);
   blistSetPostoBrush(is_us?br:old_Curs);
   if (brushGetType(br)==brType_TERRAIN)   // if we are terrain, the db needs to rebuild now
      gedit_db_update(FALSE);
   return rv;
}

// @TODO: undo support for these!!
static void move_brush_to_end_of_time(void)
{
   editBrush *modBrush=blistDelete();          // delete the existing place for the brush
   blistSeek(0,SEEK_END);                      //   get to the end of time
   blistInsert(modBrush);                      //   put us back in the list
   brush_field_update(modBrush,NULL,brField_Old);    // update any field data
   if (brushGetType(modBrush)==brType_TERRAIN) // if we are terrain, the db needs to rebuild now
      gedit_db_update(FALSE);
}

static void move_brush_to_time_n(int n)
{
   set_brush_to_time_n(cur(),n);
}

/////////////////////////////
// texture control

short *_geditGetTxPtr(editBrush *br)
{
   short *tx;
   if (br->cur_face == -1)     // global texture, or per face
      tx=&br->tx_id;
   else
      tx=&br->txs[br->cur_face].tx_id;
   return tx;
}

// this is incomplete
// it needs to have real code for multiwallset
bool geditTxCycle(editBrush *br, int cycle)
{
   short *tx=_geditGetTxPtr(br);

   if (*tx+cycle>=texmemGetMax())
      *tx=0;
   else if (*tx+cycle<0)
      *tx=texmemGetMax()-1;
   else
      *tx=*tx+cycle;

   return TRUE;
}

// returns if it made the change
BOOL gedit_reassign_texture(editBrush *br, BOOL texture_only)
{
   if (gedit_editted)
      Status("Must reportalize to see texture.");
   else
      ReassignTexture(br->br_id,texture_only);
   return !gedit_editted;
}

static void _tex_finish(editBrush *br)
{
   if (gedit_reassign_texture(br,TRUE))
      gedit_redraw_3d();
   editUndoStoreBrush(br);
}

static void cycle_tex(int dir)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   geditTxCycle(modBrush, dir);
   _tex_finish(modBrush);     // does the undo
}


void gedit_texture_brush(editBrush *br, int new_tx)
{
   short *tx;
   editUndoStoreStart(br);
   tx=_geditGetTxPtr(br);
   *tx=new_tx;
   _tex_finish(br);     // does the undo
}

static void gedit_set_brush_tx(int new_tx)
{
   gedit_texture_brush(cur(),new_tx);
}

static void gedit_reset_br_textures(int new_tx)
{
   editBrush *modBrush=cur();
   short *tx;
   int i;

   if (new_tx==-1) { Warning(("Given -1 as new_tx\n")); new_tx=0; }
   editUndoStoreStart(modBrush);
   modBrush->cur_face=-1;     // set to default face
   tx=_geditGetTxPtr(modBrush);
   *tx=new_tx;
   for (i=0; i<modBrush->num_faces; i++)
   {
      modBrush->cur_face=i;
      tx=_geditGetTxPtr(modBrush);
      *tx=-1;
      if (gedit_reassign_texture(modBrush,TRUE))
         gedit_redraw_3d();
   }
   //   _tex_finish(modBrush);     // does the undo - but a reassign as well?
   editUndoStoreBrush(modBrush);
}

static void sky_tex(void)
{
   editBrush *modBrush=cur();
   short *tx=_geditGetTxPtr(modBrush);
   editUndoStoreStart(modBrush);
   *tx = 249;
   _tex_finish(modBrush);     // does the undo
}

static void hack_align_texture(void)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   if (modBrush->cur_face == -1)
   {
      int i;
      for (i=0; i<modBrush->num_faces; i++)
         modBrush->txs[i].tx_rot = TEXINFO_HACK_ALIGN;
   } else
      modBrush->txs[modBrush->cur_face].tx_rot = TEXINFO_HACK_ALIGN;
   _tex_finish(modBrush);
}

//////////////////////
// media control

static void media_change(editBrush *modBrush, int med)
{
   editUndoStoreStart(modBrush);
   modBrush->media = med;
   editUndoStoreBrush(modBrush);
   gedit_db_update(FALSE);
}

static void cycle_media(int dir)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
      media_change(modBrush,(modBrush->media + dir + num_media_ops) % num_media_ops );
}

static void set_medium(int med)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
      media_change(modBrush,med);
}

///////////////
// misc hacks start around here..

#define SKYBOX_VIEWS 5

// arrays for skybox
static mxs_angvec g_aCamAngle[SKYBOX_VIEWS]
= { {0, 0, 32768},
    {0, 0, 16384},
    {0, 0, 0},
    {0, 0, 49152},
    {0, 49152, 16384},
};

static char g_achSuffix[SKYBOX_VIEWS]
= {'n', 'e', 's', 'w', 't'};

void gedit_make_skybox(char *pszArg)
{
   int i, iOldW = grd_bm.w, iOldH = grd_bm.h;

   if (!g_lgd3d)
      return;

   if (!pszArg || !pszArg[0]) {
      mprintf("Please give me a base for the filenames.\n");
      mprintf("You could, for example, type: skybox myname.\n");
      mprintf("            Sincerely and devotedly yours,\n");
      mprintf("                                   Skybox.\n");
      return;
   }

   mprintf("gedit: Starting skybox...\n");

   // cheat wildly: give us a square image
   grd_bm.w = grd_bm.h = 256;

   for (i = 0; i < SKYBOX_VIEWS; ++i) {
      g2s_point pt[4], *vlist[4] = { pt, pt + 1, pt + 2, pt + 3};
      char aszFilename[256];
      mxs_vector DummyPos;
      mx_mk_vec(&DummyPos, 0, 0, 0);

      r3_start_frame();
      r3_set_view_angles(&DummyPos, g_aCamAngle + i, R3_DEFANG);
      r3_set_space(R3_PROJECT_SPACE);

      // clear the rectangle
      pt[0].sx = pt[3].sx = pt[0].sy = pt[1].sy = fix_make(-1, 0);
      pt[1].sx = pt[2].sx = pt[2].sy = pt[3].sy = fix_make(256, 0);
      lgd3d_set_z(1);
      lgd3d_set_texture(NULL);
      lgd3d_g2upoly(4, vlist);

      SkyRendererRender();
      r3_end_frame();

      // make sure all our polygons made it to the screen
      ScrnLockDrawCanvas();
      ScrnUnlockDrawCanvas();

      // set filename & take our shot
      sprintf(aszFilename, "%s%c.bmp", pszArg, g_achSuffix[i]);
      dmp_bmp_dump_screen(aszFilename);
   }

   // try to restore order in wake of wild cheating
   grd_bm.w = iOldW;
   grd_bm.h = iOldH;

   mprintf("gedit: skybox done.\n");
}

// if im a terrain brush, change me to a room
void gedit_brush_to_room(float grow_pct)
{
   editBrush *tmp;
   editBrush *modBrush = cur();
   if ((brushGetType(modBrush)!=brType_TERRAIN)&&(brushGetType(modBrush)!=brType_HOTREGION))
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }
   /*
   // this removed to allow area & funky shaped brushes to room-ize, though they
   // do so a little oddly, it can still be useful.  Xemu 5/14/98
   if (modBrush->primal_id!=PRIMAL_CUBE_IDX)
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }
   */
   if (brSelect_Flag(modBrush)==brSelect_VIRTUAL)
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }

   tmp=brushInstantiate(PRIMAL_CUBE_IDX);
   tmp->pos=modBrush->pos;
   tmp->sz=modBrush->sz;
   tmp->ang=modBrush->ang;
   if (grow_pct>0.01)
      mx_scaleeq_vec(&tmp->sz,1.0+(grow_pct/100.0));
   gedit_full_create_brush(tmp,modBrush,GEDIT_CREATE_AT_END,brType_ROOM);
   vBrush_NewBrush(tmp);
}

// if im a terrain brush, do appropriate parameter adoption to rest of selection
void gedit_brush_adopt(int which_val)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
   {

   }
}

static int prim_cur_sides=4, prim_cur_type=0, prim_cur_face=0;


static char *prim_side_name[USED_PRIMAL_TYPES]
= {
   "Cube", "Cylinder", "Pyramid", "Corner pyramid"
};

static int prim_side_limit[USED_PRIMAL_TYPES]
= { USED_PRIMAL_SIDES,
    USED_PRIMAL_SIDES - 2,
    USED_PRIMAL_SIDES - 1,
    USED_PRIMAL_SIDES - 1
};

// make sure the number of sides is valid for this type of primitive--
// if the number is invalid we slam prim_cur_sides
static void prim_side_constrain(void)
{
   if (prim_cur_sides < 3) {
      Warning(("gedit: Too few sides for shape.  Setting to 3.\n"));
      prim_cur_sides = 3;
   }
   else if (prim_cur_sides > prim_side_limit[prim_cur_type]) {
      Warning(("gedit: %s limited to %d sides.\n",
               prim_side_name[prim_cur_type], prim_side_limit[prim_cur_type]));
      prim_cur_sides=prim_side_limit[prim_cur_type];
   }
}

static void prim_finish(void)
{
   prim_side_constrain();

   if (prim_cur_type==0)
      editbr_default_primal=PRIMAL_CUBE_IDX;
   else
      editbr_default_primal=primalID_FullMake(prim_cur_type,prim_cur_face,prim_cur_sides);
   gedit_set_default_brush_type(brType_TERRAIN);
}

void gedit_set_primal_sides(int n)
{
   prim_cur_sides=n;
   prim_finish();
}

extern void SetRadioCheckmark (int menu, int firstPos, int lastPos, int checkPos);

// 0 is cube, 1 cyl, 2 pyr, 3 corner pyr
void gedit_set_primal_type(int t)
{
    if ((t<0)||(t>=PRIMAL_TYPE_MAX))
        Warning(("Invalid primal type\n"));
    else
    {
        prim_cur_type=t;
        prim_finish();
        
        UpdateMenuCheckmarks();
    }
}

// are we face or vertex aligned
void gedit_set_primal_facevertex(bool use_face)
{
   prim_cur_face=use_face?PRIMAL_ALIGN_FACE:0;
   prim_finish();
}

// hmmmm....
void gedit_set_cube(void)
{
   editbr_default_primal=PRIMAL_CUBE_IDX;
   gedit_set_default_brush_type(brType_TERRAIN);
   
   UpdateMenuCheckmarks();
}

void gedit_set_special(int spectype)
{
   editbr_default_primal=primalID_Make(PRIMAL_TYPE_SPECIAL,spectype);
   gedit_set_default_brush_type(brType_TERRAIN);

   UpdateMenuCheckmarks();
}

static void reset(void)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   modBrush->ang.tx = modBrush->ang.ty = modBrush->ang.tz = 0;
   editUndoStoreBrush(modBrush);
   gedit_db_update(TRUE);
}

void fit_world(bool mode)
{
   mxs_vector *res = gedit_get_extent(mode);
   if (res)
      vm_fit_cameras_to_region(res,res+1);
   gedit_full_redraw();
}

void gedit_cam_to_brush(void)
{
   static int which_ang[]={2,2,2,2,1,1};
   static int what_to_add[]={0x8000,0xC000,0,0x4000,0xC000,0x4000};
   mxs_vector *pos;
   mxs_angvec *ang;
   editBrush *br=blistGet();

   if (br!=NULL)
      if (vm_spotlight_loc(&pos,&ang))
         if ((pos!=NULL)&&(ang!=NULL))
         {
            *pos=br->pos;
            *ang=br->ang;
            if (brushGetType(br)==brType_TERRAIN)
               if (br->cur_face!=-1)
                  ang->el[which_ang[br->cur_face]]+=what_to_add[br->cur_face];
            vm_redraw_from_camera();
         }
}

static bool gedit_allow_lazy_updates=FALSE;
static bool gedit_lazy_oldstate;
static BOOL gedit_drag_happening=FALSE;
static BOOL cur_sel_changed=FALSE;

BOOL gedit_is_drag_in_prog(void)
{
   return gedit_drag_happening;
}

void gedit_setup_check_lazy_drag(void)
{
   if (!gedit_allow_lazy_updates)
   {
      gedrend_show_current=FALSE;
      vm_redraw();
      vm_render_cameras();
      gedrend_show_current=TRUE;
      vm_redraw_from_select();
      vm_render_cameras();
   }
   gedit_lazy_oldstate=gedit_allow_lazy_updates;
   gedit_allow_lazy_updates=TRUE;
   gedit_drag_happening=TRUE;
}

void gedit_finish_check_lazy_drag(void)
{
   gedit_allow_lazy_updates=gedit_lazy_oldstate;
   if (!gedit_allow_lazy_updates)
      gedit_full_redraw();  // really should look at lazy update i guess....?
   gedit_drag_happening=FALSE;
}

// will not bother redrawing, unless user has turned on no_lazy_updates
static void gedit_lazy_update(editBrush *br)
{  // shouldnt be blistGet, should be multibrush compatible!!
   if ((br!=vBrush_editBrush_Get())||!gedit_allow_lazy_updates)
      gedit_full_redraw();      // anal mode, always redraw
   else
      vm_redraw_from_select();  // of course, lazy update may have already flagged it all to redraw...
}

// @TODO: rethink this when i can think
// raw change and refresh
void gedit_raw_change_brush(editBrush *us, BOOL is_new, BOOL change_world, BOOL change_db)
{
   if (brSelect_Flag(us) == brSelect_VIRTUAL)  // do we need this???
   {
      gedit_lazy_update(us);
   }
   else
   if (brushGetType(us) == brType_TERRAIN)
   {
      if (change_db)
         gedit_db_update(FALSE);
   }
#ifdef INCREMENTAL_FLOW_UPDATE
   else
   if (brushGetType(us) == brType_FLOW)
   {
      change_world = TRUE;
      GEdMedMoMarkWaterAllBrushes();
   }
#endif
   else
   if ((brushGetType(us) == brType_LIGHT)||
       ((brushGetType(us) == brType_OBJECT) && (brObjProp_getLightLevel(brObj_ID(us)) >= 0.0)))
   {
      if (!is_new)
      {
         if (change_db)
            gedit_light_update(FALSE);
      }
      else
         change_world=TRUE;
   }
   else
   if ((brushGetType(us) == brType_OBJECT) && IsDoor(brObj_ID(us)))
   {
      UpdateDoorBrush(brObj_ID(us));
      gedit_lazy_update(us);
   }
   else
   if (brushGetType(us) == brType_ROOM)
   {
      change_world = TRUE;
      if (change_db)
         gedit_room_update(FALSE);
   }
   else
      gedit_lazy_update(us);

   //   vm_redraw_from_select();  // of course, lazy update may have already flagged it all to redraw...
   gedit_lazy_update(us);
   if (change_world || (brushGetType(us) == brType_OBJECT))
      gedit_redraw_3d();    // this still isnt quite right - we still do this too much
   cur_sel_changed=TRUE;
}

// @VBRUSH: should this go in vbrush, perhaps?
// call me when you change a brush, really
void i_changed_the_brush(editBrush *us, BOOL snap, BOOL is_new, BOOL change_world)
{
   if (us==NULL)
      return;

	brush_field_update(us,NULL,brField_Old);
	if (snap)
    {
        if (config_is_defined("hens_changes") && brushGetType(us)==brType_OBJECT && is_new)
            gedit_snap_object(us);
        else
            gedit_snap_brush(us);
    }
	gedit_raw_change_brush(us,is_new,change_world,TRUE);
}

void gedit_change_selection(void)
{  // really needs to know if brush selection was changed
   if (cur_sel_changed&&gedit_allow_lazy_updates)
      vm_redraw();
   else
      vm_redraw_from_select();
   cur_sel_changed=FALSE;
}

void gedit_redraw_selection(void)
{
   vm_redraw_from_select();
}

// says - ok - data has changed - set me to changed, but dont do much else
void gedit_change_current_brush(void)
{
   if (gedit_allow_lazy_updates)
   {
      vm_redraw_from_select();
      cur_sel_changed=TRUE;
   }
   else
   {
      vm_redraw();
      cur_sel_changed=FALSE;
   }
}

/////////////////
// moving brushes around

static void stretch(int axis)
{
   editBrush *modBrush=cur();
   float amt = 0.125 * scale_factor;
   if (axis >= 3) { amt = -amt; axis -= 3; }
   if (axis >= 0 && axis < 3) {
      // don't allow a brush to be shrunk to nothing
      if (amt < 0 && modBrush->sz.el[axis] <= -amt)
         return;
      editUndoStoreStart(modBrush);
      modBrush->sz.el[axis] += amt;
      i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
      editUndoStoreBrush(modBrush);
   }
}

void translate(int axis)
{
   editBrush *modBrush = cur();
   float amt;
   if (config_is_defined("translate_by_grid"))
   {
      amt = cur_global_grid.line_spacing;
      //mprintf("spacing = %g\n",cur_global_grid.line_spacing);
   }
   else
      amt = 0.125 * scale_factor;
   if (axis >= 3) { amt = -amt; axis -= 3; }
   if (axis >= 0 && axis < 3) {
      editUndoStoreStart(modBrush);
      modBrush->pos.el[axis] += amt;
      i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
      editUndoStoreBrush(modBrush);
   }
}

static void rotate(int axis)
{
   editBrush *modBrush = cur();
   int amt = 0x100 * scale_factor;
	if (axis >= 3) { amt = -amt; axis -= 3; }
   editUndoStoreStart(modBrush);
   switch (axis) {
      case 0: modBrush->ang.tx += amt; break;
      case 1: modBrush->ang.ty += amt; break;
      case 2: modBrush->ang.tz += amt; break;
   }
   i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
   editUndoStoreBrush(modBrush);
}

// if current brush is an object, floor it correctly
void gedit_floor_brush(editBrush *us, mxs_vector *dir)
{
   Location cur_loc, down_loc, bbox_hit_loc, phys_hit_loc;
   mxs_vector minv,maxv;
   mxs_vector down;
   ObjPos *cur_pos;
   ObjID obj_id;
   mxs_vector new_vec;
   int i;

   BOOL bbox_hit = FALSE;
   BOOL phys_hit = FALSE;

   mxs_vector bbox_offset;
   mxs_vector phys_offset;

   if (brushGetType(us)!=brType_OBJECT) return;   // needs to be an object
   if (brSelect_Flag(us)&brSelect_VIRTUAL) return; // and to be real

   // do the real work
   mx_copy_vec(&down, dir);

   obj_id=brObj_ID(us);
   cur_pos=ObjPosGet(obj_id);
   if (cur_pos==NULL)  // hmmm... cant find us
   {
      Warning(("Tried to floor a non-existant object\n"));
      return;
   }
   cur_loc=cur_pos->loc;
   if ((cur_loc.vec.x!=us->pos.x)||(cur_loc.vec.y!=us->pos.y)||(cur_loc.vec.z!=us->pos.z))
      Warning(("Brush isnt where object is\n"));

   ObjGetObjOffsetBBox(obj_id,&minv,&maxv);
   mx_addeq_vec(&down,&cur_loc.vec);  // bottom of case
   MakeHintedLocationFromVector(&down_loc,&down,&cur_loc);

   if (!PortalRaycast(&cur_loc, &down_loc, &bbox_hit_loc, 0))
   {
      bbox_hit = TRUE;
    
      mx_sub_vec(&bbox_offset, &bbox_hit_loc.vec, &cur_loc.vec);

      for (i=0; i<3; i++)
      {
         if (dir->el[i] > 0)
            bbox_offset.el[i] -= maxv.el[i];
         else
         if (dir->el[i] < 0)
            bbox_offset.el[i] -= minv.el[i];
      }
   }

   if (!PhysObjMoveDir(brObj_ID(us), &cur_loc, &down_loc, &phys_hit_loc))
   {
      phys_hit = TRUE;

      mx_sub_vec(&phys_offset, &phys_hit_loc.vec, &cur_loc.vec);
   }

   if (bbox_hit && phys_hit)
   {
      if (mx_mag2_vec(&bbox_offset) < mx_mag2_vec(&phys_offset))
         mx_add_vec(&new_vec, &cur_loc.vec, &bbox_offset);
      else
         mx_add_vec(&new_vec, &cur_loc.vec, &phys_offset);
   }
   else
   if (bbox_hit)
   {
      mx_add_vec(&new_vec, &cur_loc.vec, &bbox_offset);
   } 
   else
   if (phys_hit)
   {
      mx_add_vec(&new_vec, &cur_loc.vec, &phys_offset);
   }
   else
   {
      Warning(("cound't find the ground!\n"));
      return;
   }

   us->pos = new_vec;
   i_changed_the_brush(us, FALSE, FALSE, TRUE);
   editUndoStoreBrush(us);
}

void gedit_floor_me(void)
{
   mxs_vector down;
   down.x = 0; down.y = 0; down.z = -20.0;
   gedit_floor_brush(cur(),&down);
}

void gedit_ceil_me(void)
{
   mxs_vector up;
   up.x = 0; up.y = 0; up.z = 20.0;
   gedit_floor_brush(cur(),&up);
}

void gedit_wall_me(void)
{
   mxs_vector walldir,unitvec;
   mxs_matrix rotmat;
   ObjID obj_id;
   ObjPos *cur_pos;

   obj_id=brObj_ID(cur());
   if (obj_id == OBJ_NULL)
      return;

   cur_pos=ObjPosGet(obj_id);

   // reverse our orientation vector
   mx_ang2mat(&rotmat, &cur_pos->fac);
   unitvec.x = -20.0F; unitvec.y = 0; unitvec.z = 0;
   mx_mat_mul_vec(&walldir, &rotmat, &unitvec);

   gedit_floor_brush(cur(),&walldir);
}

/////////////////////////

void gedit_info_window(void)
{
   char *info=(char *)Malloc(1024);
   editBrush *loop;
   int br_per_type[brType_ROOM-brType_TERRAIN+1];
   int act_hr=0, me_only=0;
   int hIter;

   // gather brush stats   
   memset(br_per_type,0,sizeof(br_per_type));
   loop=blistIterStart(&hIter);
   while (loop!=NULL)      // go through and make any other MeOnly's active
   {
      br_per_type[brushGetType(loop)-brType_TERRAIN]++;
      if (brushGetType(loop)==brType_HOTREGION)
         if (brHot_IsMEONLY(loop))   // this was a meonly
            me_only++;
         else if (brHot_Status(loop)==brHot_ACTIVE)   // this was a meonly
            act_hr++;
      loop=blistIterNext(hIter);
   }
   strcpy(info,"Brush Counts\n");
   sprintf(info+strlen(info),"%d Terrain ",br_per_type[brType_TERRAIN-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Object\n",br_per_type[brType_OBJECT-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Light ",br_per_type[brType_LIGHT-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Room\n",br_per_type[brType_ROOM-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Flow ",br_per_type[brType_FLOW-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Area -",br_per_type[brType_HOTREGION-brType_TERRAIN]);
   if (me_only)
      strcat(info,"MeOnly'd");
   else
      sprintf(info+strlen(info)," %d active\n",act_hr);
   _editsave_text_info(info);
   winui_Text(info);
   Free(info);
}

void gedit_brush_to_mono(int brush_id)
{
   editBrush *br;
   char buf[200];
   if (brush_id==0)
      br=cur();
   else
      br=brFind(brush_id);
   mprintf("Brush %d (0x%x)\n",br->br_id,br->br_id);
   sprintf(buf,"  Pos: %.9f %.9f %.9f\n",br->pos.el[0],br->pos.el[1],br->pos.el[2]);
   mprintf(buf);
   sprintf(buf,"   Sz: %.9f %.9f %.9f\n",br->sz.el[0],br->sz.el[1],br->sz.el[2]);
   mprintf(buf);
   sprintf(buf,"  Ang: %x %x %x\n",br->ang.el[0],br->ang.el[1],br->ang.el[2]);
   mprintf(buf);
}

/////////////////////////

editBrush *gedit_get_meonly_brush(void)
{
   editBrush *loop;
   int hIter;

   loop=blistIterStart(&hIter);
   while (loop!=NULL)      // go through and make any other MeOnly's active
   {
      if (brushGetType(loop)==brType_HOTREGION)
         if (brHot_IsMEONLY(loop))   // this was a meonly
            break;
      loop=blistIterNext(hIter);
   }
   if (loop!=NULL)
      blistIterDone(hIter);
   return loop;
}

static void gedit_go_to_meonly(void)
{
   editBrush *br=gedit_get_meonly_brush();
   if (br)
      vBrush_SelectBrush(br);
   else
      Status("No MeOnly brush");
}

static void gedit_hots_state(int new_state)
{
   editBrush *us=cur();

   if (brushGetType(us)!=brType_HOTREGION)
      return;   // we arent a hot region, so go home
   // parse the toggles first
   if (new_state==brHot_TOGMEONLY)
   {
      if (brHot_IsMEONLY(us))              // we are the meonly, so we just need
         new_state=brHot_GetBase(us);      // to revert to our base type
      else                                 // else we need to go check if there is
      {                                    // a meonly and clear it, then set us
         editBrush *old_meonly=gedit_get_meonly_brush();
         new_state=brHot_GetBase(us)|brHot_MEONLY;
         if (old_meonly)
            brHot_Status(old_meonly)&=brHot_BASEMASK;  // so filter the meonly out
      }
   }
   else if (new_state==brHot_TOGACTIVE)
   {
      new_state=(brHot_GetBase(us)==brHot_ACTIVE)?brHot_INACTIVE:brHot_ACTIVE;
      if (brHot_IsMEONLY(us)) new_state|=brHot_MEONLY;
   }
   brHot_Status(us)=new_state;
   gedit_full_redraw();
}

///////////////////////////
// busywait/full screen mode

// lifted from dragbox, perhaps they should be in some header?
#define ismouse(ev)     ((ev).type & (UI_EVENT_MOUSE | UI_EVENT_MOUSE_MOVE))
#define iskbd(ev)       ((ev).type == UI_EVENT_KBD_COOKED)

extern void redraw_all_cmd(void);

// do a busywait in modal ui for next event we care about
void gedit_busywait(BOOL clear)
{
   uiEvent ev;

   modal_ui_start(MODAL_CHECK_NONE);
   while (1)
   {
      if (modal_ui_get_event(&ev))
         if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               break;
         }
      modal_ui_update();
   }
   modal_ui_end();
   if (clear) gr_clear(0);
   redraw_all_cmd();
}

// show an image file
static void gedit_show_image(char *str)
{
   IResMan *pResMan = AppGetObj(IResMan);
   IRes *pRes = IResMan_Bind(pResMan, str, RESTYPE_IMAGE, NULL, NULL, 0);

   if (pRes)
   {  // really should check screen size and mode here, maybe switch in and out
      grs_bitmap *bm=(grs_bitmap *) IRes_Lock(pRes);
      gr_clear(0);
      gr_bitmap(bm, 0, 0);
      gedit_busywait(TRUE);
      IRes_Unlock(pRes);
      SafeRelease(pRes);
   }
   else
      Warning(("Cant find %s\n",str));

   SafeRelease(pResMan);
}

static void gedit_get_pixel_color(char *str)
{
   uiEvent ev;

   if (str && *str!='\0')
   {
      int x=1,y=1, c;
      sscanf(str,"%d %d",&x,&y);
      c=gr_get_pixel(x,y);
      mprintf("Pixel at %d,%d is color %d (0x%x) (%d %d %d)\n",x,y,c,c,grd_pal[c*3],grd_pal[c*3+1],grd_pal[c*3+2]);
      return;
   }
   // unhide mouse here?? - if we support game mode, or something?
   uiShowMouse(NULL);
   modal_ui_start(MODAL_CHECK_NONE);
   while (1)
   {
      if (modal_ui_get_event(&ev))
         if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               break;
         }
         else if (ismouse(ev))
         {
            uiMouseEvent *mev=(uiMouseEvent *)&ev;
            if (mev->action&(MOUSE_LUP|MOUSE_RUP))
            {
               int x=mev->pos.x, y=mev->pos.y, c;
               c=gr_get_pixel(x,y);
               mprintf("Pixel at %d,%d is color %d (0x%x) (%d %d %d)\n",x,y,c,c,grd_pal[c*3],grd_pal[c*3+1],grd_pal[c*3+2]);
               if (mev->action&MOUSE_LUP)  // left button breaks out
                  break;                   // right button keeps going
            }
         }
      modal_ui_update();
   }
   modal_ui_end();
   uiHideMouse(NULL);
}

// preload a sound
static void gedit_preload_snd(char *str)
{
   preload_data(PRELOAD_SOUND,str,NULL);
}

// preload a sound
static void gedit_preload_mot(char *str)
{
   preload_data(PRELOAD_BIN,str,"motions/");
}

extern void preload_dump_stats(void);

#ifdef DBG_ON

static void showPalette(void)
{
   static bool display=TRUE;
   static LGadRoot *root;
   static Rect *box;
   uchar const *use_ipal=ScrnGetInvPalette();
   int x, y;

   if (display)
   {
      root = vmGrabViews(vmGrabSingle);
      box = LGadBoxRect(root);

      // do the palette first
      for (y=0; y<16; y++)
         for (x=0; x<16; x++)
         {
            gr_set_fcolor(x+y*16);
            gr_rect(x*8+box->ul.x, y*8+box->ul.y, x*8+8+box->ul.x, y*8+8+box->ul.y);
         }

      // next, show the ipal
      for (y=0; y<16; y++)
         for (x=0; x<16; x++)
         {  // get an 888 rgb value
            long rgb = grd_pal[(x+y*16)*3];
            rgb |= grd_pal[(x+y*16)*3+1] << 8;
            rgb |= grd_pal[(x+y*16)*3+2] << 16;
            gr_set_fcolor(use_ipal[gr_index_lrgb(rgb)]);
            gr_rect(x*8+box->ul.x + 150, y*8+box->ul.y, x*8+8+box->ul.x + 150, y*8+8+box->ul.y);
         }

#ifdef SHOW_PCX
      {
         // *If* firetile is already loaded, then fetch it and show it.
         grs_bitmap *bm;
         IResMan *pResMan = AppGetObj(pResMan);
         IRes *pRes = IResMan_Lookup(pResMan, 
                                     "firetile.pcx", 
                                     RESTYPE_IMAGE,
                                     NULL);
         if (pRes)
         {
            bm = (grs_bitmap *) IRes_DataPeek(pRes);
            if (bm)
            {
               gr_bitmap(bm, x*8+box->ul.x, box->ul.y);
            }
         }
      }
#endif
   }
   else
      vmReleaseViews(root);

   display = !display;
}

#endif

void gedit_run_script_hack(char *script_name)
{
   char buf[256];
   find_file_in_config_path(buf,script_name,"script_path");
   CommandRunScript(buf);
}

void set_ambient(char *arg)
{
   sMissionRenderParams parms;
   parms = *GetMissionRenderParams();

   if (arg==NULL || strlen(arg)==0) {
      char s[256];
      sprintf(s, "ambient: %.3f %.3f %.3f", parms.ambient_light.x * 255.0,
              parms.ambient_light.y * 255.0, parms.ambient_light.z * 255.0);
      mprintf("%s\n", s);
   } else {
      mxs_vector rgb;
      mx_mk_vec(&rgb, -11, -11, -11);// try to tell if we've got too few numbers
      sscanf(arg, "%f %f %f", &rgb.x, &rgb.y, &rgb.z);
      if (rgb.x != -11 && rgb.y != -11 && rgb.z != -11) {
         mx_scale_vec(&parms.ambient_light, &rgb, 1.0 / 255.0);
         SetMissionRenderParams(&parms);
      } else
         Warning(("Pssst!  Try typing it like this: ambient r g b\n"));
   }
}

extern BOOL loud_flag_clear;

void gedit_saveload_flag_hack(void)
{
   BOOL old_flag=loud_flag_clear;
   loud_flag_clear=TRUE;
   saveloadFixFlagField();
   loud_flag_clear=old_flag;
}

// split every model into every cell - not sure if still supported
#ifndef SHIP
extern BOOL always_split_all_models;
#endif

// are hotregions actively put in the portalizations, or just a filter
extern bool passive_hotregions;

#ifdef SEAN_STUFF
extern bool debug_cell_traversal;
#endif

Command gedit_edit_only_keys[] =
{
   { "refresh_particle_links", FUNC_VOID, ParticleGroupRefreshLinks, "Update all ParticleAttachement links" },

   { "cycle_tex", FUNC_INT, cycle_tex },
   { "sky_tex", FUNC_VOID, sky_tex },
   { "align_tex", FUNC_VOID, hack_align_texture },
   { "cycle_media", FUNC_INT, cycle_media },
   { "set_debug_tex", FUNC_INT, objmodel_set_debug_tex },

   { "reset_brush", FUNC_VOID, reset },
   { "brush_stretch", FUNC_INT, stretch, "stretch current brush" },
   { "brush_rotate", FUNC_INT, rotate, "rotate current brush" },
   { "brush_translate", FUNC_INT, translate, "translate current brush" },
   { "floor_object", FUNC_VOID, gedit_floor_me },
   { "wall_object", FUNC_VOID, gedit_wall_me },
   { "ceil_object", FUNC_VOID, gedit_ceil_me },
   { "fit_cameras", FUNC_BOOL, fit_world, "fit cameras to world/hot region" },
   { "auto_portalize", TOGGLE_BOOL, &auto_portalize },
   { "auto_roombuild", TOGGLE_BOOL, &auto_roombuild },

   { "go_to_meonly", FUNC_VOID, gedit_go_to_meonly },

   { "brush_to_room", FUNC_FLOAT, gedit_brush_to_room, "terrain->room (grow by arg on all axis)" },
   { "brush_adopt", FUNC_INT, gedit_brush_adopt, "all brushes adopt from us (arg for which parameter)" },

   { "spiral_serf", FUNC_INT, spiral_stair_cmd, "build spiral stair, 0 for dialog" },
   { "stair_serf", FUNC_INT, straight_stair_cmd, "build straight stair, 0 for dialog" },

   { "ambient", FUNC_STRING, set_ambient, "give this three values 0-255: r g b" },
   { "snap_placement", TOGGLE_BOOL, &gedit_snap_placement },
   { "clear_brushes", FUNC_VOID, brushClearAll, "clear all brushes" },
   { "set_medium", FUNC_INT, set_medium, "set brush medium" },

   { "blist_dump", FUNC_VOID, blistDump },

   { "get_grid", FUNC_VOID, grid_get_from_current, "get grid from brush" },
   { "set_grid", FUNC_VOID, grid_set_from_current, "force brush to grid" },
   { "grid_toggle", FUNC_VOID, grid_toggle, "turn grid on off" },
   { "grid_scale", FUNC_FLOAT, grid_scale, "rescale the master grid" },
   { "grid_abs_scale", FUNC_FLOAT, grid_abs_scale, "set absolute scale of master grid" },
   { "brush_go_last", FUNC_VOID, move_brush_to_end_of_time, "move current brush to temporal last" },
   { "brush_set_time", FUNC_INT, move_brush_to_time_n, "move current brush to time n" },
   { "load_object", FUNC_STRING, objmodel_command, "load 3d object" },

   { "preload_sound", FUNC_STRING, gedit_preload_snd },
   { "preload_motion", FUNC_STRING, gedit_preload_mot },
   { "preload_stats", FUNC_VOID, preload_dump_stats },

#ifdef DBG_ON
   { "show_pal", FUNC_VOID, showPalette },
   { "primal_mprint", FUNC_INT, primalBr_mprint },
#endif

   { "brush_color", VAR_INT, &editbr_color_mode },
   { "brush_filter", VAR_INT, &editbr_filter },
   { "hots_filter", TOGGLE_BOOL, &renderHotsOnly },
   { "hots_state", FUNC_INT, gedit_hots_state },
   { "time_filter_lo", VAR_INT, &editbr_filter_time_lo },
   { "time_filter_hi", VAR_INT, &editbr_filter_time_hi },
   { "size_filter", VAR_FLOAT, &editbr_filter_size },

   { "set_brush_tx", FUNC_INT, gedit_set_brush_tx },
   { "set_brush_type", FUNC_INT, gedit_set_default_brush_type },
   { "reset_brush_tx", FUNC_INT, gedit_reset_br_textures },
   { "cam_to_brush", FUNC_VOID, gedit_cam_to_brush, "move camera to look at cur brush" },
   { "obj_ambient", VAR_FLOAT, &mdd_lt_amb },
   { "obj_diffuse", VAR_FLOAT, &mdd_lt_diff },

   { "zap_brush_flags", FUNC_VOID, gedit_saveload_flag_hack, "secret clear flags stuff" },
   { "loud_zap_flags", VAR_INT, &loud_flag_clear, "talk about flags you clear" },

#ifdef SEAN_STUFF
   { "debug_cell", TOGGLE_BOOL, &debug_cell_traversal },
#endif

   { "info_window", FUNC_VOID, gedit_info_window },

   { "lazy_update", TOGGLE_BOOL, &gedit_allow_lazy_updates, "do we update instantly, or only on new brush selection" },
   { "run_cmd_script", FUNC_STRING, gedit_run_script_hack },

   { "set_primal", VAR_INT, &editbr_default_primal, "set default primal" },
   { "prim_sides", FUNC_INT, gedit_set_primal_sides, "# of sides on primals" },
   { "prim_type", FUNC_INT, gedit_set_primal_type, "1=cyl, 2=pyr, 3=cpyr, 0=cube " },
   { "prim_facealign", FUNC_BOOL, gedit_set_primal_facevertex, "are we face aligned" },
   { "cube", FUNC_VOID, gedit_set_cube, "set cube" },
   { "prim_special", FUNC_INT, gedit_set_special, "set 'special' primal type" },
   { "brush_to_mono", FUNC_INT, gedit_brush_to_mono, "show brush info on mono" },

#ifndef SHIP
   { "obj_split", TOGGLE_BOOL, &always_split_all_models, "always portal split objects" },
#endif
   { "obj_re_place", FUNC_VOID, gedit_replace_all_objs, "replace all objects in world" },
   { "passive_hotregions", TOGGLE_BOOL, &passive_hotregions, "are hotregions in the CSG, or just filters" },

   // these want to make it down to the list below - but arent ready for it yet - as does obj_pal
   { "show_image", FUNC_STRING, gedit_show_image, "load image from disk" },
};

// for keys you want to work in game mode as well, but ONLY In editor builds
// really, this should probably go somewhere else at some point
Command gedit_all_mode_keys[] =
{
#ifndef SHIP
   { "skybox", FUNC_STRING, gedit_make_skybox, "make skyhack texures"},
   { "play_sfx", FUNC_STRING, SFX_command },
#endif
   { "get_pixel_color", FUNC_STRING, gedit_get_pixel_color, "click on pixel, get told color" },
   { "heapchk", FUNC_VOID, &_heapchk, "Test the heap, if debugging heap enabled" },
   { "monodebug", TOGGLE_BOOL, &mono_to_debugger, "output mono to Windows debug stream" },
#ifdef RN_STATS
   { "rn_stat_clear", FUNC_VOID, rnStatClear },
   { "rn_stat_show", FUNC_VOID, rnStatShow },
#endif
};


// register all of the subsystems here as well
void gedit_register(void)
{
   COMMANDS(gedit_edit_only_keys, HK_BRUSH_EDIT);
   COMMANDS(gedit_all_mode_keys, HK_ALL);
   gedcsgCommandRegister();
   gedundoCommandRegister();
   hilightCommandRegister();
}

//	Returns whether the given brush has been locked
//
BOOL brushIsLocked (editBrush* brush)
{
	BOOL isLocked = FALSE;
    BOOL unlock = FALSE;
	ITraitManager* traitMan;
    int i;

    if (!config_is_defined ("hens_changes"))
        return FALSE;

	traitMan = AppGetObj (ITraitManager);
    for (i = 0; i < MAX_LOCKED_BRUSHES; i++)
    {
        if (gLockedBrushes[i] != 0)
        {
            if (gLockedBrushes[i] == TERRAIN_ID)
            {
                if (brushGetType(brush) == brType_TERRAIN)
                {
                    isLocked = TRUE;
                    break;
                }
            }
            else if (ITraitManager_ObjHasDonor(traitMan, brObj_ID(brush), gLockedBrushes[i]))
            {
                isLocked = TRUE;
                break;
            }
        }
    }
	SafeRelease (traitMan);
	
    return isLocked;
}

void UpdateMenuCheckmarks (void)
{
    int menu, firstPos, lastPos;
    int type;

    //  Brush shapes
    //
    menu = 4;
    firstPos = 0;
    lastPos = 5;
    
    type = primalID_GetType(editbr_default_primal);
    switch (type)
    {
        case PRIMAL_TYPE_CYLINDER:
        case PRIMAL_TYPE_PYRAMID:
        case PRIMAL_TYPE_CORNERPYR:
            SetRadioCheckmark (menu, firstPos, lastPos, type);
            break;

        case PRIMAL_TYPE_SPECIAL:
        {
            if (editbr_default_primal == PRIMAL_WEDGE_IDX)
                SetRadioCheckmark (menu, firstPos, lastPos, 4);
            else if (editbr_default_primal == PRIMAL_DODEC_IDX)
                SetRadioCheckmark (menu, firstPos, lastPos, 5);
            else
                SetRadioCheckmark (menu, firstPos, lastPos, 0);     //  Cube
            break;
        }
    }

    //  Lighting mode
    //
    menu = 5;
    firstPos = 9;
    lastPos = 11;
    
    if (gedcsg_light_objcast)
        SetRadioCheckmark (menu, firstPos, lastPos, 11);
    else if (gedcsg_light_raycast)
        SetRadioCheckmark (menu, firstPos, lastPos, 10);
    else
        SetRadioCheckmark (menu, firstPos, lastPos, 9);
}

// $Header: r:/t2repos/thief2/src/editor/gedit.h,v 1.38 2000/01/29 13:12:06 adurant Exp $
#pragma once

// gedit.c -  geometry editing tools

#ifndef __GEDIT_H
#define __GEDIT_H

#include <editbrs.h>

///////////////////
// initialize geom editor, specifically brush lists
EXTERN void gedit_init(void);
EXTERN void gedit_term(void);

// mode enter and exit, for when you enter and exit edit mode
EXTERN void gedit_enter(void);
EXTERN void gedit_exit(void);

///////////////////
// update/expose controls

// reportalize level if in auto-portalize mode, else set "editted"
EXTERN void gedit_db_update(BOOL redraw);  // redraw as well always

// so you can tell things they need to redraw
EXTERN void gedit_full_redraw(void);
// you changed to a new selection
EXTERN void gedit_change_selection(void);
// redraw selected brush, assuming no material changes (ie. selection changes only)
EXTERN void gedit_redraw_selection(void);
// for making changes which affect the world look, but not the brush look
EXTERN void gedit_redraw_3d(void);
// causes brush to know it needs to redraw, ie. material changes to cur brush
EXTERN void gedit_change_current_brush(void);

// teleport the camera to the current brush
EXTERN void gedit_cam_to_brush(void);

// if you need to know if the database has been editted
#ifdef EDITOR
EXTERN BOOL gedit_editted;
#else
#define gedit_editted FALSE
#endif 
// is the user allowing "lazy" updates, or are they anal
EXTERN bool gedit_allow_lazy_updates;

// these are basic hacks to set up lazy checked drags
// in particular, they check for lazy, and redraw main view without current brush
EXTERN void gedit_setup_check_lazy_drag(void);
EXTERN void gedit_finish_check_lazy_drag(void);

//////////////////
// actual brush/environment change controls

// raw change and refresh
EXTERN void gedit_raw_change_brush(editBrush *us, BOOL is_new, BOOL change_world, BOOL change_db);

// when you change a brush you really had better call this!!!
EXTERN void i_changed_the_brush(editBrush *us, BOOL snap, BOOL is_new, BOOL change_world);

// tell brush br you changed textures or alignments, returns whether it could change the db
EXTERN BOOL gedit_reassign_texture(editBrush *br, BOOL texture_only);
   
// brush size snapping wackiness, Null for current
EXTERN BOOL gedit_snap_brush(editBrush *us);   
EXTERN void gedit_set_snaps(mxs_real snap_pos, mxs_real snap_sz, mxs_ang snap_ang);

// call to see if the value in question is snapped on the current grid
EXTERN BOOL _gedit_float_snap(float *val);

// misc_setting means whether to go fill def fields, use_type cur create brush type
EXTERN BOOL gedit_place_brush(editBrush *us, BOOL misc_setting, BOOL use_type);

// if build_type is -1, then if old is non-null, use old's type, else type is left alone, else use build_type
// if old is non-Null, then misc_settings (old format) are assumed, and old is passed down to field_update

#define GEDIT_DEFAULT_BRTYPE -1
#define GEDIT_CREATE_AT_CUR (0)
#define GEDIT_CREATE_AT_END (1 << 0) // at_end means place new brush at end, else place at current
#define GEDIT_CREATE_CLONE  (1 << 1) // clone old brush, else create new using old as hint


EXTERN BOOL gedit_full_create_brush(editBrush *new_br, editBrush *old, ulong flags, int build_type);

// set current texture on an explicitly noted brush
EXTERN void gedit_texture_brush(editBrush *br, int new_tx);

//////////////////
// misc stuff

// sizing up the world
EXTERN mxs_vector *gedit_get_extent(BOOL hot_region_p);

// woo woo - select on click maybe
EXTERN BOOL gedit_click(int flags, int x, int y, int camera);
#define GEDIT_CLICK_IS3D      (1<<0)
#define GEDIT_CLICK_VBRUSH    (1<<1)
#define GEDIT_CLICK_FANCY     (1<<2)
#define GEDIT_CLICK_NOTOGGLE  (1<<3)

// return the default brush type, used for creation of new brushes
EXTERN int gedit_default_brush_type(void);

// set the same
EXTERN void gedit_set_default_brush_type(int type);

// if current brush is an object, floor it correctly
EXTERN void gedit_floor_brush(editBrush *us, mxs_vector *down);

////////////////
// 

#endif // __GEDIT_H
// $Header: r:/t2repos/thief2/src/editor/gedmedmo.c,v 1.3 2000/02/19 13:10:42 toml Exp $

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   gedmedmo.c

   Here's the part of water motion editing which hooks into the
   wonderful world of brushes.

   We can set the motion_index for each PortalCell right after we
   portalize, or when a flow brush is moved.

   We do this for one brush by comparing the middle (the average of
   the vertices) of every cell in the world rep to the brush.  This is
   GEdMedMoMarkWaterOneBrush.

   When we've just portalized, we have to traverse the whole brush
   database.  This would be GEdMedMoMarkWaterAllBrushes.  This also
   calls EdMedMoClearMediumMotionInPortals, which sets all of the motion
   indices to 0.

   Note that we expect motion index 0 to be something safe, like water
   which is not moving.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#include <matrix.h>

#include <editbr_.h>
#include <brinfo.h>
#include <brlist.h>
#include <edmedmo.h>
#include <media.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


// For now, we're only expecting six-sided OBBs.
#define MAX_PLANES_IN_BRUSH 6
static mxs_vector brush_plane_vector[MAX_PLANES_IN_BRUSH];
static mxs_real brush_plane_constant[MAX_PLANES_IN_BRUSH];

// This is pretty damn silly.  But it could let us be flexible later.
static int brush_plane_count = 6;


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   Here's the function we pass in to EdMedMoSetCells in edmedmo.c.  It
   tells use whether a given point is within a the bounding box set up
   by SetBrushBounds, below.  Note that planes face outwards.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static bool PointWithinBrush(mxs_vector *point)
{
   int i;

   for (i = 0; i < brush_plane_count; i++) {
      if ((mx_dot_vec(point, &brush_plane_vector[i])
         + brush_plane_constant[i]) > 0.0)
         return FALSE;
   }

   return TRUE;
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This is swiped wholesale from Chris's OBB code.  If we want
   anything besides OBBs, we should generalize this to handle
   arbitraray polyhedra.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
static void SetBrushBounds(editBrush *brush)
{
   mxs_matrix R;           // rotation matrix of brush
   mxs_vector u;           // normal before rotation
   mxs_vector point;       // point on plane of brush
   int i;

   // find rotation matrix for brush orientation
   mx_ang2mat(&R, &(brush->ang));

   // iterate through faces of the brush
   for (i = 0; i < 6; ++i) {

      // generate unit vector on given axis
      mx_unit_vec(&u, i % 3);
      if (i >= 3)
         mx_scaleeq_vec(&u, -1.0);

      // rotate to brush orientation
      mx_mat_mul_vec(&brush_plane_vector[i], &R, &u);

      // find point on plane of face 
      mx_scale_add_vec(&point, &(brush->pos), 
                       &brush_plane_vector[i], brush->sz.el[i % 3]);

      // here's our plane constant
      brush_plane_constant[i] = -mx_dot_vec(&brush_plane_vector[i], &point);
   }
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   This spreads the effect of a single brush through the world
   database.

   When we change a flow brush, we want to call it first with the
   brush's previous geometry and medium index 0 to clear things out.
   Then with the new geometry and real index.  But that code's not
   here.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void GEdMedMoMarkWaterOneBrush(editBrush *brush, mxs_vector *seed)
{
   uchar medium_motion = brFlow_Index(brush);

   sEdMedMoSurface* info = &g_aEdMedMoSurface[medium_motion]; 

   if (!GetWaterTexIDs(info->texture_name_base,
                       &info->texture_above,
                       &info->texture_below))
      Warning(("No such water texture as %s\n",info->texture_name_base)); 

   SetBrushBounds(brush);
   EdMedMoSetCells(seed, MEDIA_WATER, medium_motion, &PointWithinBrush);
}


/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\

   When we want to set the motion for every cell in the world rep,
   using all the brushes which do that sort of thing, we do this.

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */
void GEdMedMoMarkWaterAllBrushes(void)
{
   editBrush *b;
   int hIter;

   EdMedMoClearMediumMotionInPortals();

   b = blistIterStart(&hIter);

   while (b != NULL) {
      if (brushGetType(b) == brType_FLOW)
         GEdMedMoMarkWaterOneBrush(b, &(b->pos));
      b = blistIterNext(hIter);
   }
}
// $Header: r:/t2repos/thief2/src/editor/gedmedmo.h,v 1.3 2000/01/29 13:12:07 adurant Exp $
#pragma once

/* ----- /-/-/-/-/-/-/-/-/ <<< (((((( /\ )))))) >>> \-\-\-\-\-\-\-\-\ ----- *\
   gedmedmo.h

   export for gedmedmo.c

\* ----- \-\-\-\-\-\-\-\-\ <<< (((((( \/ )))))) >>> /-/-/-/-/-/-/-/-/ ----- */


#ifndef _GEDMEDMO_H_
#define _GEDMEDMO_H_

// We use this when only one brush has changed.  We want to call it
// first with the brush's previous geometry and medium index 0 to
// clear things out.  Then with the new geometry and real index.
EXTERN void GEdMedMoMarkWaterOneBrush(editBrush *brush, mxs_vector *seed);

// When we want set the motion for every cell in the world rep, using
// all the brushes which do that sort of thing, we do this.
EXTERN void GEdMedMoMarkWaterAllBrushes(void);

#endif // ~ _GEDMEDMO_H_
// $Header: r:/t2repos/thief2/src/editor/ged_csg.cpp,v 1.53 2000/02/19 13:10:43 toml Exp $
// layout: interface to brushes during csg, then support calls, then portalization calls themselves

#include <string.h>

#include <lg.h>
#include <appagg.h>
#include <lgassert.h>
#include <matrixs.h>
#include <config.h>
#include <prof.h>
#include <mprintf.h>

#include <editbr.h>
#include <brlist.h>
#include <brinfo.h>
#include <brrend.h>

#include <csg.h>
#include <portal.h>
#include <media.h>
#include <mediaop.h>
#include <cvtbrush.h>
#include <gedit.h>
#include <ged_csg.h>
#include <csgbrush.h>
#include <objlight.h>
#include <animlit.h>
#include <animlgt.h>
#include <hilight.h>
#include <missrend.h>
#include <roomtowr.h>
#include <editobj.h>  // for now, for full deref/reref
#include <primal.h>
#include <phref.h>
#include <prcniter.h>

#include <iobjsys.h>
#include <osysbase.h>
#include <property.h>
#include <propbase.h>

#include <litprop.h>
#include <textarch.h>
#include <rendprop.h>
#include <status.h>
#include <command.h>
#include <appsfx.h>
#include <undoredo.h>
#include <wrmem.h>
#include <dbfile.h>
#include <dbasemsg.h>
#include <gedmedmo.h>
#include <ged_rmap.h>
#include <doorblok.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//////////////////////////
// interface to csg process itself

// for csg
struct _editBrush *csg_brush[MAX_CSG_BRUSHES];

// interface to CSG, should probably go somewhere else, really
int gedcsgGetFaceTexture(int x, int y)
{
   editBrush *curBrush;
   short tx_id;

   curBrush=csg_brush[x];
   tx_id=curBrush->txs[y].tx_id;
   if (tx_id==-1)
      tx_id=curBrush->tx_id;
   return tx_id;
}

TexInfo *gedcsgGetFaceTexInfo(int x, int y)
{
   TexInfo *this_face;
   editBrush *curBrush;

   curBrush=csg_brush[x];
   this_face=&curBrush->txs[y];
   return this_face;
}

EXTERN BOOL get_uv_align(editBrush *br, int face, mxs_vector *u, mxs_vector *v);

BOOL gedcsgGetFaceTextureAligned(int x, int y, mxs_vector *u, mxs_vector *v)
{
   editBrush *curBrush = csg_brush[x];
   if (curBrush->txs[y].tx_rot == TEXINFO_HACK_ALIGN)
      return get_uv_align(curBrush, y, u, v);
   else
      return FALSE;
}

// for now only on a per texture type basis, i guess
BOOL gedcsgGetFaceTextureSelfLit(int x, int y)
{
   editBrush *curBrush = csg_brush[x];

   short tx_id;
   ObjID text_obj; 

   curBrush=csg_brush[x];
   tx_id=curBrush->txs[y].tx_id;
   if (tx_id==-1)
      tx_id=curBrush->tx_id;
   
   text_obj = GetTextureObj(tx_id); 

   return ObjRenderType(text_obj) == kRenderUnlit;
}

static float tex_scale_override=1.0;
float gedcsgGetFaceScale(int x, int y)
{
   int scale = get_face(x, y)->tx_scale;

   if (scale == 0)
   {
      editBrush *curBrush = csg_brush[x];
      Warning(("0 texture scale for brush %d, face %d.  Overriding to 1.\n", x, y));
      Warning(("  Type %d, br_id %d\n",brushGetType(curBrush),curBrush->br_id));
      return 1.0;
   }
   return scale_pow2int_to_float(scale)*tex_scale_override;
}

/////////////////////////
// tools for csg to inform game systems about problems

static BOOL csg_auto_hilight=TRUE;
static int  csg_hilight_cnt=0;

EXTERN void gedcsgHilightBr(int br_id)
{
   hilight_array[br_id]|=PORTAL_HILIGHT_BIT;
   csg_hilight_cnt++;
}

// setup highlights for portal usage
EXTERN void gedcsgClrHilights(void)
{
   csg_hilight_cnt=0;   
   hilightClearBits(PORTAL_HILIGHT_BIT);
}

EXTERN void gedcsgCheckHilights(void)
{
   if (csg_hilight_cnt && (csg_auto_hilight))
      hilight_active=PORTAL_HILIGHT_BIT;
}

//////////////////////////////////
//////////////////////////////////
// PORTALIZATION
//////////////////////////////////
//////////////////////////////////

#define DONE_PORTAL_SND "portalized_sound"
#define DONE_LIT_SND    "lit_sound"

//////////////////////
// light animation system stuck here for now

#define ON_NOW()             '1', 0
#define OFF_NOW()            '0', 0
#define ON(x)                '1', x, ON_NOW()
#define OFF(x)               '0', x, OFF_NOW()
#define BRIGHT(x)            'b', x
#define WAIT(x)              'w', x
#define CONTINUE()           'c', 0
#define SKIP(x)              's', (x)*255/100
#define STOP()               '.', 0
#define RANDOM_WAIT(x,y)     'r', x, 'w', y
#define RANDOM_BRIGHT(x,y)   'r', x, 'b', y, '1', 0
#define RANDOM_FADE_ON(x,y)  'r', x, '1', y, '1', 0
#define RANDOM_FADE_OFF(x,y) 'r', x, '0', y, '0', 0
// jump is signed, relative to current location (JUMP(0) is infinite loop)
#define JUMP(x)              'j', x

static uchar pulse[] =
{
   ON(40),
   OFF(40),
   CONTINUE()
};

static uchar flicker[] =
{
   RANDOM_BRIGHT(0,240),
   WAIT(5),  // 20 fps
   CONTINUE()
};

uchar *light_script[] =
{
   0,
   pulse,
   flicker
};

#define MAX_LIGHT_SCRIPTS  (sizeof(light_script)/sizeof(light_script[0])+1)

int max_light_scripts = MAX_LIGHT_SCRIPTS;

///////////////////////
// brush media ops stuck here for now

int num_media_ops = 10;
#define NUM_MEDIA num_media_ops

char *mediaop_names[] =
{
   "fill solid",
   "fill air",
   "fill water",
   "flood",
   "evaporate",
   "solid->water",
   "solid->air",
   "air->solid",
   "water->solid",
   "blockable"
};

MediaOp media_op[MAX_OP] =
{
   // solid
   { MEDIA_SOLID, MEDIA_SOLID, MEDIA_SOLID,
     MEDIA_SOLID, MEDIA_SOLID, MEDIA_SOLID },

   // air
   { MEDIA_AIR, MEDIA_AIR, MEDIA_AIR,
     MEDIA_AIR_PERSIST, MEDIA_AIR_PERSIST, MEDIA_AIR_PERSIST },

   // water
   { MEDIA_WATER, MEDIA_WATER, MEDIA_WATER,
     MEDIA_WATER_PERSIST, MEDIA_WATER_PERSIST, MEDIA_WATER_PERSIST },

   // flood
   { MEDIA_SOLID, MEDIA_WATER, MEDIA_WATER,
     MEDIA_SOLID_PERSIST, MEDIA_WATER_PERSIST, MEDIA_WATER_PERSIST },

   // evaporate
   { MEDIA_SOLID, MEDIA_AIR, MEDIA_AIR,
     MEDIA_SOLID_PERSIST, MEDIA_AIR_PERSIST, MEDIA_AIR_PERSIST },

   // solid->water
   { MEDIA_WATER, MEDIA_AIR, MEDIA_WATER,
     MEDIA_WATER_PERSIST, MEDIA_AIR_PERSIST, MEDIA_WATER_PERSIST },

   // solid->air
   { MEDIA_AIR, MEDIA_AIR, MEDIA_WATER,
     MEDIA_AIR_PERSIST, MEDIA_AIR_PERSIST, MEDIA_WATER_PERSIST },

   // air->solid
   { MEDIA_SOLID, MEDIA_SOLID, MEDIA_WATER,
     MEDIA_SOLID_PERSIST, MEDIA_SOLID_PERSIST, MEDIA_WATER_PERSIST },

   // water->solid
   { MEDIA_SOLID, MEDIA_AIR, MEDIA_SOLID,
     MEDIA_SOLID_PERSIST, MEDIA_AIR_PERSIST, MEDIA_SOLID_PERSIST },

   // blockable -- Notice that we can't get persistant solids from
   // blockable brushes.  This lets us clip doorway blockers by simply
   // adding masonry and so forth and whichwhat around them.
   { MEDIA_SOLID, MEDIA_AIR_PERSIST, MEDIA_WATER_PERSIST,
     MEDIA_SOLID, MEDIA_AIR_PERSIST, MEDIA_WATER_PERSIST }
};

EXTERN void write_cell(FILE *f, PortalCell *p);

BOOL gedcsg_save_world_rep(char *fname)
{
   FILE *f = fopen(fname, "wb");
   int i;
   if (!f) return FALSE;

   fwrite(&wr_num_cells, sizeof(wr_num_cells), 1, f);
   for (i=0; i < wr_num_cells; ++i)
      write_cell(f, WR_CELL(i));
   fclose(f);
   return TRUE;
}

//////////////////////
// actual calls to build/modify/maintain world rep

// first, some externs which should be in a header file somewhere
EXTERN bool merge_nodes;
EXTERN bool optimize_bsp;
EXTERN void portal_shine_omni_light(int light_index, Location *loc, uchar dynamic);
#ifdef RGB_LIGHTING
EXTERN void portal_set_normalized_color(int rm, int gm, int bm);
#endif

BOOL gedcsg_light_objcast = FALSE;
BOOL gedcsg_light_raycast = FALSE;
BOOL gedcsg_light_quad; // controls all terrain lights, but not object lights

// publicly visible state of the database
BOOL gedcsg_level_valid=TRUE, gedcsg_lighting_ok=FALSE;

// parse a single light brush, can be a sort of auto-auto-portalize, as we add it as we go
BOOL gedcsg_parse_light_brush(editBrush *us, uchar dynamic)
{
   int lt, lt_index;
   float bright = brLight_Bright(us);
#ifdef RGB_LIGHTING
   int r,g,b;

   portal_convert_hsb_to_rgb(&r, &g, &b, brLight_Hue(us), brLight_Saturation(us));
   portal_set_normalized_color(r,g,b);
#endif

   if (brushGetType(us) != brType_LIGHT)
      return FALSE;

   if (brLight_Handle(us) != 0)
      if (is_object_light_defined(brLight_Handle(us) - 1))
         return FALSE;

   clear_surface_cache();

#ifdef RGB_LIGHTING
   {
      rgb_vector temp;
      temp.x = bright * r / 255.0;
      temp.y = bright * g / 255.0;
      temp.z = bright * b / 255.0;
      lt_index = add_object_light(&us->pos, &temp, 0);
   }
#else
   lt_index = add_object_light(&us->pos, bright, 0);
#endif
   brLight_Handle(us) = lt_index + 1;

#if 0
   if (brLight_isSpot(us)) {
      Position pos;
      MakePositionFromVectors(&pos, &us->pos, &us->ang);
      lt = portal_add_spotlight(bright, &pos, brLight_Focal(us), 0);
   } else
#endif
   {
      Location loc;
      MakeLocationFromVector(&loc, &us->pos);

      lt = portal_add_omni_light(bright, 0, &loc, dynamic, 0, 0);
      if (lt > 0)
         portal_shine_omni_light(lt_index, &loc, dynamic);
   }

#if 0
   // Huh?  What's this do? -- sb
   if (bright==255.0)
      LightSetBrightness(lt, brLight_Bright(us));
#endif

   return TRUE;
}

static void gedcsg_clear_light_brush(editBrush *us)
{
   brLight_Handle(us)=0;
}

ObjID *g_pObjCastList = NULL;
int    g_ObjCastListSize;

EXTERN void reset_object_lighting(void);

void gedcsg_relight_level(void)
{
   int light_count=0, obj_light_count, anim_obj_light_count;
   int total_light_count;
   int hIter;
   uchar lighting_type = 0;
   char lit_snd[64];
   editBrush *us;

   if (gedcsg_light_objcast)
      lighting_type = LIGHT_OBJCAST;
   else
   if (!gedcsg_light_raycast)
      lighting_type = LIGHT_QUICK;
   else
      // Weirdly, we only really apply quad lighting if objcast
      // lighting is also on.
      if (gedcsg_light_quad && gedcsg_light_objcast)
         lighting_type |= LIGHT_QUAD;

   mprintf("...let\'s light, eh? (type %x)",lighting_type);
   Status("Lighting....");
   AnimLightClear();
   clear_surface_cache();
   reset_lighting();   // really dont need to do this, if just portalized
   reset_object_lighting();

   if (gedcsg_light_objcast)
   {
      IObjectSystem *pObjSys;
      IProperty *pImmobileProp;
      ObjID obj;

      // Build list of objects to cast against
      Assert_(g_pObjCastList == NULL);

      g_pObjCastList = (ObjID *)malloc(gMaxObjID * sizeof(ObjID));
      g_ObjCastListSize = 0;

      pObjSys = AppGetObj(IObjectSystem);
      pImmobileProp = pObjSys->GetCoreProperty(kImmobilityProperty);

      cConcreteIter iter(pImmobileProp);

      iter.Start();
      while (iter.Next(&obj))
      {
         if (OBJ_IS_CONCRETE(obj))
         {
            if (pObjSys->ObjIsImmobile(obj))
            {
               g_pObjCastList[g_ObjCastListSize] = obj;
               g_ObjCastListSize++;
               Assert_(g_ObjCastListSize < gMaxObjID);
            }
         }
      }
      iter.Stop();

      SafeRelease(pImmobileProp);
      SafeRelease(pObjSys);
   }

   DrBlkUnblockAll();
   brushConvertStart();
   brushConvertEnd();   // ok, this is ultra - dorky, but might work...

   // Is there sunlight?
   const sMissionRenderParams *pMRP = GetMissionRenderParams();
   if (pMRP->use_sun && (gedcsg_light_raycast || gedcsg_light_objcast)) {
      Status("Applying sunlight...");

      int r, g, b;
      int type = 0;
      if (pMRP->sunlight_quad && gedcsg_light_objcast)
         type |= LIGHT_QUAD | LIGHT_OBJCAST;

      portal_convert_hsb_to_rgb(&r, &g, &b, pMRP->sun_h, pMRP->sun_s);
      portal_set_normalized_color(r, g, b);
      portal_shine_sunlight(&pMRP->sunlight_vector, pMRP->sun_b, 0, type);
   }

   Status("Applying brush lights...");
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (brushGetType(us) == brType_LIGHT)
         if (brushConvertTest(us))
         {
            gedcsg_clear_light_brush(us);  // since we reset object lighting right above this
            if (gedcsg_parse_light_brush(us, lighting_type))
               light_count++;
         }
      us=blistIterNext(hIter);
   }

   DrBlkReblockAll();

   anim_obj_light_count = ObjAnimLightLightLevel(lighting_type);
   obj_light_count = ObjLightLightLevel(lighting_type);
   total_light_count = light_count + obj_light_count + anim_obj_light_count;

   mprintf("...we inserted %d light%s\n", total_light_count,
            total_light_count!=1?"s":"");
   mprintf("   including %d regular from objects, %d animated\n",
           obj_light_count, anim_obj_light_count);

   Status("Done");
   gedit_redraw_3d();
   gedcsg_lighting_ok=TRUE;
   if (config_get_raw(DONE_LIT_SND,lit_snd,64))
      SFX_Play_Raw(SFX_STATIC,NULL,lit_snd);

   if (gedcsg_light_objcast)
   {
      Assert_(g_pObjCastList != NULL);

      free(g_pObjCastList);

      g_pObjCastList = NULL;
      g_ObjCastListSize = 0;
   }
}

EXTERN bool optimize_bsp;
EXTERN void cid_register_brush_planes(void *);
   
void register_brush_planes(void)
{
   editBrush *us;
   void *phedra;
   int hIter;

   brushConvertStart();
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if ((phedra=brushConvertPortal(us))!=NULL)
         cid_register_brush_planes(phedra);
      us=blistIterNext(hIter);
   }
   brushConvertEnd();
}

bool cow_autosaves=TRUE;
static BOOL doing_opt=FALSE;
EXTERN void cid_register_start(void);
EXTERN void fix_tjoints(void);
static bool fixup_tjoints=TRUE;
BOOL doing_opt_pass1=FALSE;

static editBrush hotregion_hack_brush;

void build_level(void)
{
   char portal_snd[64];
   int i=1, hIter;
   editBrush *us;
   void *ph;

   if (!doing_opt)
      gedcsgClrHilights();

   if (!config_get_raw("portalized_sound",portal_snd,64))
      portal_snd[0]='\0';

   FreeWR();     // TODO: ahh, this is a horrible hack - would be nice to put it somewhere real

   if (cow_autosaves)
   {
      Status("Saving out p_portal");
      gedit_editted=TRUE;                  // hack to make sure it doesnt bother saving out the 
      dbSave("p_portal.cow",kFiletypeAll); //   about to be destroyed world rep data
   }

   gedcsg_level_valid = TRUE;
   gedit_editted=FALSE;
   StatusField(SF_FILESTATE," ");
   Status("Converting Brushes....");

   editobjFullDeref();

   cid_register_start();
   // if optimizing, supply CSG with all the brush planes up front,
   // so it can match up the bsp planes from the optimizer
   if (optimize_bsp)
      register_brush_planes();

   init_csg_internal_database();
   csg_num_brushes=0;
   memset(csg_brush,0,sizeof(struct _editBrush *)*MAX_CSG_BRUSHES);

   DrBlkGenerateBrushes();
   brushConvertStart();
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if ((ph=brushConvertPortal(us))!=NULL)
      {
         us->timestamp=i++;
         if (brushGetType(us)==brType_TERRAIN)
            csg_brush[us->br_id] = us;
         else
            csg_brush[us->br_id] = &hotregion_hack_brush;
         cid_insert_brush(us->br_id,ph);
         if (us->br_id>csg_num_brushes)
            csg_num_brushes=us->br_id;
      }
      us=blistIterNext(hIter);      
   }
   brushConvertEnd();
   mprintf("Setup %d brush level (%d brushes total)...\n",i,blistCount());
   csg_num_brushes++;         // it is now max brush id + 1, for looping in csg
   Status("Portalizing....");
   portalize_csg_internal_database();
   if (optimize_bsp && fixup_tjoints) {
      Status("Tjoint Fix....");
      fix_tjoints();
   }

   DrBlkDestroyBrushes();
   ConvertPersistantCells(CELL_CAN_BLOCK_VISION);
   mprintf("Portalized...");
   if ((portal_snd[0]!='\0')&&(config_is_defined(DONE_LIT_SND)))
     SFX_Play_Raw(SFX_STATIC,NULL,portal_snd);
   Status("Lighting...");
   editobjFullReref();
   if (!doing_opt_pass1) 
      gedcsg_relight_level();
   PhysRefSystemClear(); 
   PhysRefSystemResize(); 
   PhysRefSystemRebuild();
   Status("Setting up world database from brushes (water flow, etc.)...");
   GEdMedMoMarkWaterAllBrushes();
   RoomToWRProcess();
   Status("Done");
   gedit_redraw_3d();
   undoClearUndoStack();   // punt any undo info during portalization
   if ((portal_snd[0]!='\0')&&(!config_is_defined(DONE_LIT_SND)))
      SFX_Play_Raw(SFX_STATIC,NULL,portal_snd);
   if (!doing_opt)
      gedcsgCheckHilights();
}

EXTERN bool coplanar;
EXTERN float REAL_EPSILON;

void optimize_level(void)
{
   bool old_merge = merge_nodes;
   bool old_coplanar = coplanar;
   bool old_raycast = gedcsg_light_raycast;

   gedcsgClrHilights();
   doing_opt=TRUE;

   // rebuild level with correct polygons

   coplanar = TRUE;
   optimize_bsp = FALSE;
   gedcsg_light_raycast = FALSE;
   doing_opt_pass1 = TRUE;
   build_level();
   doing_opt_pass1 = FALSE;

   // save world rep to temp file
   gedcsg_save_world_rep("temp.wr");

   mprintf("Computing optimized BSP... this may take a while.\n");

   // shell to csgmerge
   {
      char buf[64];
      sprintf(buf, "csgmerge -e%lg temp.wr", REAL_EPSILON);
      system(buf);
   }

   // turn on optimizations
   optimize_bsp = TRUE;
   merge_nodes = old_merge;
   coplanar = old_coplanar;
   gedcsg_light_raycast = old_raycast;

   build_level();

   mprintf("All future level builds will be \"optimized\", "
        "until you disable 'optimize_bsp'\n");
   mprintf("Rerun 'optimize' for a fully optimized one.\n");

   gedcsgCheckHilights();
   doing_opt=FALSE;
}

extern "C" void UpdateMenuCheckmarks (void);

void set_lighting_mode(int mode)
{
   switch (mode)
   {
      case 0:
      {
         gedcsg_light_raycast = FALSE;
         gedcsg_light_objcast = FALSE;
         mprintf("Lighting mode: Quick\n");
         break;
      }

      case 1:
      {
         gedcsg_light_raycast = TRUE;
         gedcsg_light_objcast = FALSE;
         mprintf("Lighting mode: Raycast\n");
         break;
      }

      case 2:
      {
         gedcsg_light_raycast = FALSE;
         gedcsg_light_objcast = TRUE;
         mprintf("Lighting mode: Objcast\n");
         break;
      }
      
      default:
      {
         Warning(("Unknown lighting mode: %d\n", mode));
         break;
      }
   }
   
   UpdateMenuCheckmarks();
}

///////////////////////////////
// commands

// various csg things which need to be commanded from somewhere, i guess
EXTERN bool split_polys;
EXTERN bool merge_polys;
EXTERN int show_debug;
//EXTERN bool decal_hack;
EXTERN int _watch_light;

Command gedcsg_keys[] =
{
   { "watch_light", VAR_INT, &_watch_light },

   { "optimize", FUNC_VOID, optimize_level, "build optimized portalization" },
   { "portalize", FUNC_VOID, build_level, "recompute world terrain" },
   { "relight_level", FUNC_VOID, gedcsg_relight_level, "relight the level" },
   { "save_wr", FUNC_STRING, gedcsg_save_world_rep,"save world rep to file"},
   { "compress_br_ids", FUNC_VOID, ged_remap_brushes, "compact brush ids" },
   { "merge_node", TOGGLE_BOOL, &merge_nodes, "build faster imperfect level" },
   { "optimize_bsp", TOGGLE_BOOL, &optimize_bsp },
   { "set_lighting_mode", FUNC_INT, set_lighting_mode, "Set lighting mode (0, 1, 2)", },
   { "quad_lighting", TOGGLE_BOOL, &gedcsg_light_quad, "oversampled raycast lighting" },
   { "auto_hilight", TOGGLE_BOOL, &csg_auto_hilight, "automatically hilight any bad brushes after portalization" },
   { "split_polys", TOGGLE_BOOL, &split_polys, "force coplanar poly splits" },
   { "merge_polys", TOGGLE_BOOL, &merge_polys, "merge coplanar polys" },
//   { "decal_hack", TOGGLE_BOOL, &decal_hack },
   { "coplanar", TOGGLE_BOOL, &coplanar, "correctly handle coplanar polys" },
   { "csg_epsilon", VAR_FLOAT, &REAL_EPSILON, "set voodoo epsilon value" },
   { "show_debug", VAR_INT, &show_debug, "set split# to debug, -1 for all #s" },
   { "tex_scale_override", VAR_FLOAT, &tex_scale_override, "set texture scale override factor" },
   { "profile", FUNC_STRING, writeProfile, "write out sProf profile" },
   { "autosaves", TOGGLE_BOOL, &cow_autosaves, "do we autosave exit and p_portal" },
   { "tjoint", TOGGLE_BOOL, &fixup_tjoints, "fix tjoints when portalizing" },
};
   
void gedcsgCommandRegister(void)
{
   COMMANDS(gedcsg_keys, HK_BRUSH_EDIT);
   // horrible hack for hotregion custom media strangeness
   brushZero(&hotregion_hack_brush,PRIMAL_CUBE_IDX);
   brushSetType(&hotregion_hack_brush,brType_HOTREGION);
   if (config_is_defined("no_pportal"))
      cow_autosaves=FALSE;
}
// $Header: r:/t2repos/thief2/src/editor/ged_csg.h,v 1.10 2000/01/29 13:12:09 adurant Exp $
#pragma once

#ifndef __GED_CSG_H
#define __GED_CSG_H

#include <matrixs.h>
#include <editbr_.h>  // for TexInfo

#include <objtype.h>
#include <mediaop.h>

//////////////////////
// interface to csg brush callbacks

EXTERN int gedcsgGetFaceTexture(int x, int y);
EXTERN TexInfo *gedcsgGetFaceTexInfo(int x, int y);
EXTERN BOOL gedcsgGetFaceTextureAligned(int x, int y, mxs_vector *u, mxs_vector *v);
EXTERN BOOL gedcsgGetFaceTextureSelfLit(int x, int y);
EXTERN float gedcsgGetFaceScale(int x, int y);

/////////////////////
// tools for csg to inform game systems about problems
EXTERN void gedcsgHilightBr(int br_id); // hilight brush br_id
EXTERN void gedcsgClrHilights(void);    // clear out old hilights
EXTERN void gedcsgCheckHilights(void);  // check to see if there are any, if so show them

/////////////////////
// internal state/control/protos for ged_Csg itself
// invocation/creation of portalized world rep

// current state of level build and lighting

#ifdef EDITOR 

EXTERN BOOL gedcsg_level_valid, gedcsg_lighting_ok;
#define gedcsg_lighting_changed() gedcsg_lighting_ok = FALSE

#define ged_validate_level(b) \
do { gedit_editted = !(b); gedcsg_level_valid = (b); gedcsg_lighting_ok = (b); } while(0)

#else 

#define gedcsg_level_valid TRUE
#define gedcsg_lighting_ok TRUE
#define gedcsg_lighting_changed() 
#define ged_validate_level(b) 
#endif 


// level lighting flags
EXTERN BOOL gedcsg_light_objcast, gedcsg_light_raycast, gedcsg_light_quad;

// mostly internal incremental do one light operation
EXTERN BOOL gedcsg_parse_light_brush(editBrush *us, uchar dynamic);

// do the whole thing, relight, build, or optimize it all
EXTERN void gedcsg_relight_level(void);
EXTERN void build_level(void);
EXTERN void optimize_level(void);

////////////////////
// mediaop info for others
EXTERN char *mediaop_names[]; // if you want to name media-ops
EXTERN int   num_media_ops;

// register commands for the system
EXTERN void gedcsgCommandRegister(void);

EXTERN ObjID *g_pObjCastList;
EXTERN int    g_ObjCastListSize;

EXTERN BOOL doing_opt_pass1;

#endif  // __GED_CSG_H






// $Header: r:/t2repos/thief2/src/editor/ged_line.c,v 1.8 2000/02/19 13:10:45 toml Exp $
// line overlay system for gedit

// this system is responsible for overlaying lines in ged wireframe views
// it contains methods for adding lines to current lists, activating and deactivating them,
//   writing lists to files, reading from files, and so on

#include <stdio.h>
#include <string.h>

#include <lg.h>
#include <matrix.h>
#include <mprintf.h>

#include <command.h>
#include <brrend.h>
#include <gedit.h>
#include <ged_line.h>
#include <uiedit.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// what channel do new lines go to
int ged_line_load_channel=0;
// what channels are currently being watched
int ged_line_view_channels=1;
// do we auto add the current channel on loads
bool ged_line_autoremote=TRUE;

// internal flags
#define LINE_FLG_USER_MASK (0x0fff)
#define LINE_FLG_POINT (1<<14)  // just a point... woo woo
#define LINE_FLG_INUSE (1<<15)  // not a straight line, but a curved one

typedef struct {
   mxs_vector src, dst;        // start and end of line
   uchar      r,g,b;           // rgb colors
   int        pal;             // cur palettized value
   short      flags;           // someday, we might use these...
   short      channel;         // which channel is this line in?
} gedLineData;                 // look, 32 bytes a piece

static gedLineData *allLines=NULL;
static int          allLineLen=0, allLineAlloced=0;
#define LINE_ALLOC_SIZE 128

#define lineCurChannel(p) (((p)->channel)&(ged_line_view_channels))
#define lineInUse(p)      (((p)->flags)&LINE_FLG_INUSE)
#define lineIdxToPtr(i)   (&(allLines[i]))

////////////////////
// file interface

// load a line data file into channel
int gedLineReadFileToChannel(char *fname)
{
   FILE *fp;

   if ((fp=fopen(fname,"r"))==NULL)
      return -1;
   if (ged_line_autoremote)
      ged_line_view_channels=(1<<ged_line_load_channel);
   while (!feof(fp))
   {
      mxs_vector v1, v2;
      int color=0, flags=0, cnt, c1, c2, c3, s1;

      cnt=fscanf(fp,"GlN:%f %f %f  %f %f %f  %d %d %d %d\n",&v1.x,&v1.y,&v1.z,&v2.x,&v2.y,&v2.z,&s1,&c1,&c2,&c3);
      flags&=LINE_FLG_USER_MASK;
      if (cnt<3)
         continue;
      if (cnt<6)
      {
         flags|=LINE_FLG_POINT;
         gedLineAddPal(&v1,NULL,flags,color);
      }
      else
      {
         if (cnt==7) // just a color
            gedLineAddPal(&v1,&v2,flags,s1);
         else if (cnt==8) // just flags and single color - treat as pal entry
            gedLineAddPal(&v1,&v2,s1,c1);
         else if (cnt==9) // just an rgb
            gedLineAddRGB(&v1,&v2,flags,s1,c1,c2);
         else if (cnt==10)
            gedLineAddRGB(&v1,&v2,s1,c1,c2,c3);
         else
            Warning(("What is up? cnt>10 in gedLineReadFileToChannel\n"));
      }
   }
   fclose(fp);
   return ged_line_load_channel;  // channel used
}

////////////////////
// writing out data

// dump channels to a file
int gedLineWriteChannelsToFile(int channel_mask, char *fname)
{
   FILE *fp;
   int i;

   if ((fp=fopen(fname,"w"))==NULL)
      return -1;
   
   for (i=0; i<allLineLen; i++)
   {
      gedLineData *rv=lineIdxToPtr(i);
      if (lineInUse(rv)&&(channel_mask&(1<<rv->channel)))
      {  // now - the gruesome what type of line so output what stuff
         if (rv->flags&LINE_FLG_POINT)  // first, the base
            fprintf(fp,"GlN:%f %f %f",rv->src.x,rv->src.y,rv->src.z);
         else
            fprintf(fp,"GlN:%f %f %f  %f %f %f",rv->src.x,rv->src.y,rv->src.z,rv->dst.x,rv->dst.y,rv->dst.z);
         fprintf(fp,"%d",rv->flags);
         if ((rv->r|rv->g|rv->b)==0) // all zeroes
            fprintf(fp,"%d",rv->pal);
         else
            fprintf(fp,"%d %d %d",rv->r,rv->g,rv->b);
         fprintf(fp,"\n");
      }
   }
   fclose(fp);
   return channel_mask;
}

////////////////////
// current list maintenance

// internal tool to find a free line to use
static gedLineData *find_free_line(void)
{
   gedLineData *rv=NULL;
   int i;
   
   for (i=0; i<allLineLen; i++)
      if (lineInUse(lineIdxToPtr(i))==0)
      {
         rv=lineIdxToPtr(i);
         break;
      }
   if (rv==NULL)   // none free, need to pick a new one, or allocate more
   {
      if (allLineLen>=allLineAlloced)
      {
         allLineAlloced+=LINE_ALLOC_SIZE;
         if (allLineLen==0)
            allLines=(gedLineData *)Malloc(sizeof(gedLineData)*allLineAlloced);
         else
            allLines=(gedLineData *)Realloc(allLines,sizeof(gedLineData)*allLineAlloced);
      }
      rv=lineIdxToPtr(allLineLen);
   }
   memset(rv,0,sizeof(gedLineData));
   rv->flags|=LINE_FLG_INUSE;
   if (i==allLineLen)
      allLineLen++;
   return rv;
}

// pretty tough one, eh... maybe make this a #define at some point
static void remove_line(int idx)
{
   lineIdxToPtr(idx)->flags&=~LINE_FLG_INUSE;
}

static gedLineData *_gedLineInternalAdd(const mxs_vector *p1, const mxs_vector *p2, int flags)
{
   gedLineData *us=find_free_line();
   us->src=*p1;
   us->dst=*p2;
   us->flags|=flags;
   us->channel=(1<<ged_line_load_channel);
   return us;
}

// external API to add a line - need to set global channel first
void gedLineAddPal(const mxs_vector *p1, const mxs_vector *p2, int flags, int color)
{
   gedLineData *us=_gedLineInternalAdd(p1,p2,flags);
   us->pal=color;
   us->r=0x00; us->g=0x00; us->b=0x00;
}

void gedLineAddRGB(const mxs_vector *p1, const mxs_vector *p2, int flags, int r, int g, int b)
{
   gedLineData *us=_gedLineInternalAdd(p1,p2,flags);
   us->pal=gedLineConvertRGB(r,g,b);
   us->r=r; us->g=g; us->b=b;
}

int gedLineConvertRGB(int r, int g, int b)
{
   return uieditFixupColor(uiRGB(r,g,b));
}

////////////////////
// channel/setup control

void gedDeleteChannelLines(int channel)
{
   int i;
   for (i=0; i<allLineLen; i++)
      if (lineInUse(lineIdxToPtr(i)))
         if (lineIdxToPtr(i)->channel==channel)
            remove_line(i);
}

/////////////////////
// actual rendering

// uses current active channel list, iterates over all lines, rendering
// called from w/in a 3d context/brush draw setup
void gedLineRenderAll(void)
{
   int i;
   for (i=0; i<allLineLen; i++)
   {
      gedLineData *rv=lineIdxToPtr(i);
      if (lineInUse(rv)&&lineCurChannel(rv))
      {
         brushLineDraw(&rv->src,&rv->dst,rv->pal);

         // draw arrow
         if (rv->flags & LINE_FLG_DIR)
         {
            mxs_vector arrow_point;
            mxs_vector arrow_dir;
            mxs_vector arrow_base;
            mxs_vector arrow_width;
            mxs_vector arrow_end;
            mxs_vector z_axis;

            mx_add_vec(&arrow_point, &rv->src, &rv->dst);
            mx_scaleeq_vec(&arrow_point, 0.5);

            mx_sub_vec(&arrow_dir, &rv->dst, &rv->src);
            
            if (mx_mag2_vec(&arrow_dir) < 0.001)
               continue;

            mx_normeq_vec(&arrow_dir);
            mx_scale_add_vec(&arrow_base, &arrow_point, &arrow_dir, -2.0);

            mx_unit_vec(&z_axis, 2);

            mx_cross_vec(&arrow_width, &z_axis, &arrow_dir);

            mx_add_vec(&arrow_end, &arrow_base, &arrow_width);
            brushLineDraw(&arrow_point, &arrow_end, rv->pal);

            mx_scaleeq_vec(&arrow_width, -1.0);

            mx_add_vec(&arrow_end, &arrow_base, &arrow_width);
            brushLineDraw(&arrow_point, &arrow_end, rv->pal); 
         }
      }
   }
}

void gedLinePick(void)
{
   // hmmmmmmm
}

////////////////////
// setup/closedown

static void do_switch_channel(int channel_id)
{
   ged_line_view_channels=(1<<channel_id);
}

static void do_load_file(char *fname)
{
   gedLineReadFileToChannel(fname);
}

static void do_clear_channel(int channel_id)
{
   gedDeleteChannelLines(channel_id);
}

static Command gedLineKeys[]=
{
   { "line_autoremote", TOGGLE_BOOL, &ged_line_autoremote, "toggle autochannel switch in line display" },
   { "line_switchchannel", FUNC_INT, do_switch_channel, "set view to single channel id" },
   { "line_viewchannel", VAR_INT, &ged_line_view_channels, "set bitmask of currently visible line channels" },
   { "line_loadchannel", VAR_INT, &ged_line_load_channel, "set channel id to load to" },
   { "line_clearchannel", FUNC_INT, do_clear_channel, "clear all lines in channel id" },
   { "line_loadfile", FUNC_STRING, do_load_file, "load a file to current line channel" },
};

void gedLineInit(void)
{
   COMMANDS(gedLineKeys,HK_BRUSH_EDIT);
}

void gedLineTerm(void)
{
   if (allLineAlloced)
      Free(allLines);
   allLines=NULL;
   allLineLen=allLineAlloced=0;
}
// $Header: r:/t2repos/thief2/src/editor/ged_line.h,v 1.6 2000/01/29 13:12:11 adurant Exp $
// line overlay system for gedit
#pragma once

// this system is responsible for overlaying lines in ged wireframe views
// it contains methods for adding lines to current lists, activating and deactivating them,
//   writing lists to files, reading from files, and so on

#ifndef __GED_LINE_H
#define __GED_LINE_H

#include <matrixs.h>

// preset channels
#define LINE_CH_USER      1
#define LINE_CH_REND      4
#define LINE_CH_SOUND     6
#define LINE_CH_PHYS      8
#define LINE_CH_LINKS    10
#define LINE_CH_AI       12
#define LINE_CH_ROOM     14

// public flags
#define LINE_FLG_DIR    (1<<0)  // this line is directional (somehow)
#define LINE_FLG_NO3D   (1<<1)  // dont draw in 3d views
#define LINE_FLG_NO2D   (1<<2)  // dont draw in 2d views
#define LINE_FLG_OVER   (1<<3)  // draw even if out of current hotregion
#define LINE_FLG_CURVE  (1<<4)  // not a straight line, but a curved one

// what channel do new lines go to
EXTERN int  ged_line_load_channel;
// what channels are currently being watched
EXTERN int  ged_line_view_channels;
// do we auto add the current channel on loads
EXTERN bool ged_line_autoremote;

// startup/slowdown
EXTERN void gedLineInit(void);
EXTERN void gedLineTerm(void);

// get a color from an RGB?
EXTERN int gedLineConvertRGB(int r, int g, int b);

// add to line setup
EXTERN void gedLineAddPal(const mxs_vector *p1, const mxs_vector *p2, int flags, int color);
EXTERN void gedLineAddRGB(const mxs_vector *p1, const mxs_vector *p2, int flags, int r, int g, int b);

// delete all lines in this channel
EXTERN void gedDeleteChannelLines(int channel);

// render all the lines in the setup
EXTERN void gedLineRenderAll(void);

// load a line data file into channel
EXTERN int gedLineReadFileToChannel(char *fname);

#endif  // __GED_LINE_H
// $Header: r:/t2repos/thief2/src/editor/ged_rend.c,v 1.10 2000/02/19 13:10:46 toml Exp $

#include <g2.h>
#include <r3d.h>
#include <prof.h>

#include <ged_rend.h>
#include <ged_line.h>
#include <viewmgr.h>
#include <editbr.h>    // should change to brrend soon
#include <vbrush.h>
#include <brrend.h>
#include <brlist.h>

//#include <vumanui.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// am i supposed to be showing the current selection?
BOOL gedrend_show_current=TRUE;


// silly callback function of correct type so i can do this idiotic
// group op silliness
static void wrapBrushDraw(editBrush *us) { brushDraw(us); }

// render the current brush list
void gedrendRenderView(int flags, int camera)
{  PROF
   editBrush *us;
   mxs_vector *cam_pos;
   mxs_angvec *cam_ang;

//   mprintf("grv %d w/%x\n",camera,flags);
   vm_get_3d_camera_loc(&cam_pos,&cam_ang);
   if (flags&GEDREND_FLAG_CURSORONLY)
      if (!gedrend_show_current)
         return;
      else
         flags|=brFlag_COLOR_NONE;
   else
      flags|=brFlag_NO_SELECTION;
   brushSetupDraw(flags,camera);
   if (flags&GEDREND_FLAG_CURSORONLY)
   {  // really need a multibrush solution here... eh?
      if (vBrush_inCurGroup(blistGet()))
         vBrush_GroupOp(FALSE,wrapBrushDraw);  // @TODO: remember how to do this cast... argh
      else
         brushDraw(blistGet());
   }
   else
   {
      editBrush *avoid=blistGet();
      int hIter;

      us=blistIterStart(&hIter);
      while (us!=NULL)
      {
         if ( gedrend_show_current ||
             (!vBrush_inCurGroup(us) && (us!=avoid)) )
            brushDraw(us);
         us=blistIterNext(hIter);
      }
      gedLineRenderAll();
   }
   END_PROF;
}

//                     BBGGRR
#define CAMERA_COLOR 0xF020E0 
int gedrend_camera_pos_color=0x1;

// Show the position of the main camera in a 2D view
void gedrendRenderCameraLoc (mxs_vector *cam_pos, mxs_angvec *cam_ang, mxs_real scale)
{
   r3s_point cam_start, cam_end; // begin and end of line representing camera
   mxs_vector origin, unit;      // same, in "camera space"

   // bind the camera color right now
   // @OPTIMIZE: precompute this
   gedrend_camera_pos_color = gr_make_screen_fcolor(CAMERA_COLOR);  

   mx_zero_vec (&origin);
   mx_unit_vec (&unit, 0);
   unit.x = 3.0;                 // ad hoc

   r3_start_object_angles (cam_pos, cam_ang, R3_DEFANG);
   r3_start_block ();
   {
      r3_transform_point (&cam_start, &origin);
      r3_transform_point (&cam_end,   &unit);

      r3_set_color (gedrend_camera_pos_color);
      r3_draw_line (&cam_start, &cam_end);     // this overflows if too close

      gr_set_fcolor (gedrend_camera_pos_color);
      gr_circle (cam_start.grp.sx, cam_start.grp.sy, FIX_UNIT / 80);
   }
   r3_end_block ();
   r3_end_object ();
}
// $Header: r:/t2repos/thief2/src/editor/ged_rend.h,v 1.3 2000/01/29 13:12:12 adurant Exp $
#pragma once

#ifndef __GED_REND_H
#define __GED_REND_H

////////////////////////
// actual brush renderer

// do i show the current selection?
EXTERN BOOL gedrend_show_current;
// render a brush list from camera, flags as "filter"
EXTERN void gedrendRenderView(int flags, int camera);
// these are really taken in the call - most are in brrend
#define GEDREND_FLAG_CURSORONLY (0x10000)  // bottom 16 bits are brFLAG controls


///////////////////////
// camera circle renderer

EXTERN int gedrend_camera_pos_color;
EXTERN void  gedrendRenderCameraLoc (mxs_vector *cam_pos, mxs_angvec *cam_ang, mxs_real scale);

#endif  // __GED_REND_H
// $Header: r:/t2repos/thief2/src/editor/ged_rmap.c,v 1.2 2000/02/19 13:10:47 toml Exp $
// support for remapping the brush ids

#include <string.h>
#include <lg.h>

#include <editbr.h>
#include <brlist.h>
#include <brinfo.h>

#include <csg.h>
#include <csgbrush.h>
#include <ged_rmap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define MAX_CALLBACKS 16

static ged_remap_callback remap_callbacks[MAX_CALLBACKS];

BOOL ged_remap_add_callback(ged_remap_callback cb)
{
   int i;
   for (i=0; i<MAX_CALLBACKS; i++)
      if (remap_callbacks[i]==NULL)
      {
         remap_callbacks[i]=cb;
         return TRUE;
      }
   return FALSE;
}

BOOL ged_remap_rem_callback(ged_remap_callback cb)
{
   int i;
   for (i=0; i<MAX_CALLBACKS; i++)
      if (remap_callbacks[i]==cb)
      {
         remap_callbacks[i]=NULL;
         return TRUE;
      }
   return FALSE;
}

// @TODO: make this have an installable callback for all systems who care
// compress brush id space, build new csg_brush list
int ged_remap_brushes(void)
{
   int newid=1, hIter, i, max_id=0;
   editBrush *us;
   int *mapping;

   us=blistIterStart(&hIter);
   while (us!=NULL)
   {  // check brush_id
      if (us->br_id>max_id) max_id=us->br_id;
      us=blistIterNext(hIter);
   }
   AssertMsg(max_id<MAX_CSG_BRUSHES,"Too Many Brushes in Level");
   mapping=(int *)Malloc(sizeof(int)*MAX_CSG_BRUSHES);
   memset(mapping,0xff,sizeof(int)*MAX_CSG_BRUSHES);
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {  // check brush_id
      editBrush *nxt=blistIterNext(hIter);
      if (us->br_id<MAX_CSG_BRUSHES)
      {
         mapping[us->br_id]=newid;     // this mapping is 
         csg_brush[newid]=us;
         if (us->br_id>newid)          // if under newid, we have already remapped
            csg_brush[us->br_id]=NULL; //   so dont step on it
         us->br_id=newid++;
      }
      else
      {
         Warning(("Punting brush %d\n",us->br_id));
         // should somehow delete it, eh?
      }
      us=nxt;
   }
   for (i=0; i<MAX_CALLBACKS; i++)
      if (remap_callbacks[i]!=NULL)
         (*remap_callbacks[i])(mapping);
   remap_csg_database(mapping);  // this will TRASH mapping
   // @TODO: wake up the GFH
   Free(mapping);
   return newid;   // new max
}

// $Header: r:/t2repos/thief2/src/editor/ged_rmap.h,v 1.2 2000/01/29 13:12:14 adurant Exp $
// remap brush horror
#pragma once

#ifndef __GED_RMAP_H
#define __GED_RMAP_H

typedef void (*ged_remap_callback)(int *mapping);

// go compress br_id space
EXTERN int ged_remap_brushes(void);

// add and remove remap callbacks
EXTERN BOOL ged_remap_add_callback(ged_remap_callback cb);
EXTERN BOOL ged_remap_rem_callback(ged_remap_callback cb);

#endif  // __GED_RMAP_H
// $Header: r:/t2repos/thief2/src/editor/ged_room.cpp,v 1.24 1999/12/01 09:25:43 MAT Exp $
// room database gediting

#include <lg.h>
#include <iobjsys.h>
#include <objsys.h>
#include <objtype.h>
#include <objpos.h>
#include <objquery.h>

#include <editobj.h>   // gCreateEditBrush
#include <traitman.h>
#include <traitprp.h>
#include <traitbas.h>
#include <rendprop.h>

#include <brlist.h>
#include <brinfo.h>
#include <brrend.h>
#include <editbr_.h>
#include <editobj.h>

#include <gedit.h>
#include <ged_room.h>
#include <ged_line.h>

#include <roomsys.h>
#include <roomutil.h>
#include <roomeax.h>
#include <roomprop.h>
#include <rooms.h>
#include <room.h>
#include <rportal.h>
#include <doorphys.h>
#include <mprintf.h>
#include <roomtowr.h>
#include <psnd.h>

#include <config.h>
#include <command.h>
#include <hilight.h>
#include <wr.h>
#include <vbrush.h>

// Must be last header
#include <dbmem.h>

static ged_default_room = -1;

void ged_compile_rooms(void)
{
   ConvertRoomBrushes();
   RoomToWRProcess();
}

void ged_hilight_room(int roomID)
{
   editBrush *cur_edit_brush;
   int iter;

   hilight_begin();

   cur_edit_brush = blistIterStart(&iter);
   while (cur_edit_brush != NULL)
   {
      if (brushGetType(cur_edit_brush) == brType_ROOM)
      {
         if (brRoom_InternalRoomID(cur_edit_brush)  == roomID)
         {
            hilightAddByBrushId(cur_edit_brush->br_id);
            break;
         }
      }

      cur_edit_brush = blistIterNext(iter);
   }

   hilight_end(kHilightDone);
}

ObjID ged_get_room_named(char *name)
{
   AutoAppIPtr_(ObjectSystem, pObjSys);

   return pObjSys->GetObjectNamed(name);
}

ObjID ged_create_room_obj(char *name, ObjID archetype, BOOL concrete)
{
   AutoAppIPtr_(TraitManager, pTM);
   ObjID new_room;

   if (concrete)
   {
      gCreateEditBrush = FALSE;
      new_room = pTM->CreateConcreteArchetype(name, archetype);
      gCreateEditBrush = TRUE;   
   }
   else
   {
      new_room = pTM->CreateArchetype(name, archetype);
   }

   return new_room;
}

void ged_make_room_obj(ObjID objID)
{
   if (OBJ_IS_CONCRETE(objID))
      ObjSetRenderType(objID, kRenderNotAtAll);
}

ObjID ged_room_get_root(void)
{
   ObjID rootRoom;

   // Do we have a root room?
   rootRoom = ged_get_room_named(ROOT_ROOM_NAME);
   Assert_(rootRoom != OBJ_NULL); 

   return rootRoom;
}

ObjID ged_room_get_default(void)
{
   // Do we have a default room?
   ObjID defaultRoom = ged_get_room_named(DEFAULT_ROOM_NAME);
   Assert_(defaultRoom != OBJ_NULL);

   return defaultRoom;
}

void ged_room_postload(void)
{
   ObjID rootRoom = ged_get_room_named(ROOT_ROOM_NAME); 
   if (rootRoom == OBJ_NULL)
      rootRoom = ged_create_room_obj(ROOT_ROOM_NAME, ROOT_ARCHETYPE, FALSE);

   AutoAppIPtr_(TraitManager, pTM);
   pTM->SetArchetype(rootRoom, OBJ_NULL);
      
   // make sure rooms don't have brushes
   ObjSetCanHaveBrush(rootRoom,FALSE); 
   ObjSetRenderType(rootRoom, kRenderNotAtAll);

   ObjID defaultRoom = ged_get_room_named(DEFAULT_ROOM_NAME);
   if (defaultRoom == OBJ_NULL)
      defaultRoom = ged_create_room_obj(DEFAULT_ROOM_NAME, rootRoom, TRUE);

   ged_default_room = defaultRoom;

   // Oh boy is this dorky.  
   // go through all rooms and make sure none have brushes
   cAutoIPtr<IObjectQuery> query (pTM->Query(rootRoom,kTraitQueryAllDescendents));
   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object(); 
      if (OBJ_IS_CONCRETE(obj))
         editObjDeleteObjBrush(obj); 
   }

}

BOOL ged_is_room(ObjID objID)
{
   AutoAppIPtr_(TraitManager, pTM);
   ObjID root_room = ged_room_get_root();
   BOOL value;

   value = pTM->ObjHasDonor(objID, root_room);

   return value;
}

void ged_room_set_default_arch(ObjID objID)
{
   Assert_(ged_is_room(objID));
   
   ged_default_room = objID;
}

ObjID ged_room_get_default_arch(void)
{
   return ged_default_room;
}

ObjID ged_room_get_parent(ObjID objID)
{
   AutoAppIPtr_(TraitManager, pTM);

   return pTM->GetArchetype(objID);
}

int ged_room_get_depth(ObjID objID)
{
   AutoAppIPtr_(TraitManager, pTM);
   ObjID parent;
   ObjID root_room = ged_room_get_root();
   int   depth = 1;

   if (pTM->ObjHasDonor(objID, root_room))
   {
      parent = pTM->GetArchetype(objID);
      while (parent != root_room)
      {
         depth++;
         parent = pTM->GetArchetype(parent);
      }
   }
   else
      return -1;

   return depth;
} 

void ged_room_draw_connections(short roomID, BOOL clear)
{
   if (clear)
      gedDeleteChannelLines(1 << LINE_CH_ROOM);

   if ((!g_RoomsOK) || (roomID >= g_pRooms->GetNumRooms()))
   {
      ged_compile_rooms();
      return;
   }

   if (roomID != -1)
   {
      ged_line_load_channel = LINE_CH_ROOM;
      ged_line_view_channels |= (1 << LINE_CH_ROOM);

      cRoom *pRoom = g_pRooms->GetRoom(roomID);

      if (pRoom != NULL)
      {
         cRoomPortal *pRPortal;

         for (int i=0; i<pRoom->GetNumPortals(); i++)
         {
            pRPortal = pRoom->GetPortal(i);
    
            gedLineAddPal(&pRoom->GetCenterPt(), &pRPortal->GetCenter(), 0, 127);
            gedLineAddPal(&pRPortal->GetCenter(), &pRPortal->GetFarRoom()->GetCenterPt(), 0, 127);
         }
      }
   }

   if (clear)
      gedit_full_redraw();
}

void ged_room_draw_all_connections(BOOL state)
{
   gedDeleteChannelLines(1 << LINE_CH_ROOM);

   if (!g_RoomsOK)
      ged_compile_rooms();

   brushConvertStart();
   if (state == TRUE)
   {
      editBrush *editbr;
      int        iter_handle;

      editbr = blistIterStart(&iter_handle);
      while (editbr != NULL)
      {
         if ((brushGetType(editbr) == brType_ROOM) && brushConvertTest(editbr))
            ged_room_draw_connections(brRoom_InternalRoomID(editbr), FALSE);
         editbr = blistIterNext(iter_handle);
      }
   }
   brushConvertEnd();
   gedit_full_redraw();
}

void FixRooms()
{
   editBrush *cur_edit_brush;
   int iter;

   cur_edit_brush = blistIterStart(&iter);
   while (cur_edit_brush != NULL)
   {
      if (brushGetType(cur_edit_brush) == brType_ROOM)
      {
         if (!ged_is_room(brRoom_ObjID(cur_edit_brush)))
            brRoom_ObjID(cur_edit_brush) = ged_room_get_default();
      }

      cur_edit_brush = blistIterNext(iter);
   }

   ConvertRoomBrushes();
}

////////////////////////////////////////

void CheckRooms()
{
   cRoom     *pRoom;
   cRoom     *pCurRoom;
   editBrush *cur_edit_brush;
   int count = 0;
   int iter;

   if (!g_RoomsOK)
      ConvertRoomBrushes();

   hilight_begin();

   cur_edit_brush = blistIterStart(&iter);
   while (cur_edit_brush != NULL)
   {
      if (brushGetType(cur_edit_brush) == brType_ROOM)
      {
         if (brRoom_InternalRoomID(cur_edit_brush) < g_pRooms->GetNumRooms())
            pRoom = g_pRooms->GetRoom(brRoom_InternalRoomID(cur_edit_brush));
         else
            pRoom = NULL;

         if (pRoom)
         {
            for (int i=0; i<g_pRooms->GetNumRooms(); i++)
            {
               pCurRoom = g_pRooms->GetRoom(i);

               if (pCurRoom == pRoom)
                  continue;

               if (pCurRoom->PointInside(pRoom->GetCenterPt()))
               {
                  count++;

                  hilightAddByBrushId(cur_edit_brush->br_id);
               }
            }
         }
      }
     
      cur_edit_brush = blistIterNext(iter);
   }

   if (count != 0)
   {
      hilight_end(kHilightDone);
      mprintf("Room brushes with centers inside other room brushes have been hilighted.\n");
      return;
   }

   cur_edit_brush = blistIterStart(&iter);
   while (cur_edit_brush != NULL)
   {
      if (brushGetType(cur_edit_brush) == brType_ROOM)
      {
         if (brRoom_InternalRoomID(cur_edit_brush) < g_pRooms->GetNumRooms())
            pRoom = g_pRooms->GetRoom(brRoom_InternalRoomID(cur_edit_brush));
         else
            pRoom = NULL;

         if (pRoom)
         {
            for (int i=0; i<pRoom->GetNumPortals(); i++)
            {
               Location loc;
               MakeLocationFromVector(&loc, &pRoom->GetPortal(i)->GetCenter());

               if (CellFromLoc(&loc) == CELL_INVALID)
               {
                  count++;
  
                  hilightAddByBrushId(cur_edit_brush->br_id);
               }
            }
         }
      }
     
      cur_edit_brush = blistIterNext(iter);
   }

   if (count != 0)
   {
      hilight_end(kHilightDone);
      mprintf("Room brushes with portal centers outside the world have been hilighted.\n");
      return;
   }
   else
      hilight_end(kHilightCancel);
}


////////////////////////////////////////////////////////////////////////////////
//
// Convert the level's roombrushes to rooms and portals
//

static cDynArray<editBrush *> hb_list;
static cDynArray<editBrush *> obj_list;

BOOL ConvertRoomBrushes(void)
{
   editBrush   *cur_edit_brush;
   tOBB         obb1, obb2;
   cRoom       *pRoom;
   cRoom       *pRoomNear, *pRoomFar;
   cRoomPortal *pRoomPortal1, *pRoomPortal2;
   tPlane       portal_plane;
   tPlane       portal_edge_list[8];
   tPlane       plane_list[6];
   mxs_vector   obb_sum_scale;
   mxs_real     obbs_dist2;
   int          portal_edge_size;
   mxs_vector   portal_center;
   int          iter;
   int          num_portals;
   int          i, j;

   AutoAppIPtr(ObjectSystem);

   // Clear out any existing rooms
   ClearRooms();

   // Build list of room brushes & objects
   brushConvertStart();
   cur_edit_brush = blistIterStart(&iter);
   while (cur_edit_brush != NULL)
   {
      if (brushConvertTest(cur_edit_brush))
      {
         if (brushGetType(cur_edit_brush) == brType_ROOM)
            hb_list.Append(cur_edit_brush);

         if (brushGetType(cur_edit_brush) == brType_OBJECT)
            obj_list.Append(cur_edit_brush);
      }

      cur_edit_brush = blistIterNext(iter);
   }
   brushConvertEnd();

   // Bail if no rooms
   if (hb_list.Size() == 0)
   {
      obj_list.SetSize(0);
      return TRUE;
   }

   mprintf("Building rooms...\n");

   num_portals = 0;
   for (i=0; i<hb_list.Size(); i++)
   {
      // Convert first edit brush into OBB
      mx_copy_vec(&obb1.pos.loc.vec, &hb_list[i]->pos);
      mx_copy_vec(&obb1.scale, &hb_list[i]->sz);
      obb1.pos.fac = hb_list[i]->ang;

      // Create the room
      GetOBBPlanes(obb1, plane_list);      

      pRoom = new cRoom(pObjectSystem->GetName(brRoom_ObjID(hb_list[i])), 
                        brRoom_ObjID(hb_list[i]), plane_list, hb_list[i]->pos);
      g_pRooms->AddRoom(pRoom);

      brRoom_InternalRoomID(hb_list[i]) = pRoom->GetRoomID();

      // Check for portals 
      for (j=0; j<i; j++)
      {
         // Convert other edit brush into OBBs
         mx_copy_vec(&obb2.pos.loc.vec, &hb_list[j]->pos);
         mx_copy_vec(&obb2.scale, &hb_list[j]->sz);
         obb2.pos.fac = hb_list[j]->ang;

         // Check bounding sphere intersection
         obbs_dist2 = mx_dist2_vec(&obb1.pos.loc.vec, &obb2.pos.loc.vec);
         mx_add_vec(&obb_sum_scale, &obb1.scale, &obb2.scale);
         if (obbs_dist2 > (mx_mag2_vec(&obb_sum_scale)))
            continue;

         // Check for intersection
         if (OBBsIntersect(obb1, obb2))
         {
            cRoom *i_Room = g_pRooms->GetRoom(brRoom_InternalRoomID(hb_list[i]));
            cRoom *j_Room = g_pRooms->GetRoom(brRoom_InternalRoomID(hb_list[j]));

            // Build the portal between them
            FindOBBPortal(obb1, obb2, &portal_plane, portal_edge_list, &portal_edge_size, &portal_center);

            // Ignore degenerate intersections (edge-edge, etc)
            if (portal_edge_size == 0)
               continue;

            // Determine near and far rooms
            if (PointPlaneDist(portal_plane, i_Room->GetCenterPt()) < ON_PLANE_EPSILON)
            {
               pRoomNear = i_Room;
               pRoomFar  = j_Room;
            }
            else
            {
               pRoomNear = j_Room;
               pRoomFar  = i_Room;
            }

            // Add portal to first room
            pRoomPortal1 = new cRoomPortal(portal_plane, portal_edge_list, portal_edge_size, 
                                           portal_center, pRoomNear, pRoomFar);
            pRoomNear->AddPortal(pRoomPortal1);
            g_pRooms->AddPortal(pRoomPortal1);

            // Flip the normal
            mx_scaleeq_vec(&portal_plane.normal, -1.0);
            portal_plane.d *= -1.0;

            // Add portal to second room
            pRoomPortal2 = new cRoomPortal(portal_plane, portal_edge_list, portal_edge_size, 
                                           portal_center, pRoomFar, pRoomNear);
            pRoomFar->AddPortal(pRoomPortal2);
            g_pRooms->AddPortal(pRoomPortal2);

            pRoomPortal1->SetFarPortal(pRoomPortal2);
            pRoomPortal2->SetFarPortal(pRoomPortal1);

            num_portals += 2;
         }
      }
   }

   // Add any objects in the room
   for (i=0; i<obj_list.Size(); i++)
      g_pRooms->FindObjRoom(brObj_ID(obj_list[i]), ObjPosGet(brObj_ID(obj_list[i]))->loc.vec);

   mprintf(" %d rooms, %d portals, %g average portals per room\n", hb_list.Size(), 
           num_portals, ((float)num_portals) / ((float)hb_list.Size()));

   hb_list.SetSize(0);
   obj_list.SetSize(0);

   // Build EAX sound properties
   g_pRoomEAX->Build();

   g_pPropSnd->ClearBlockingFactors();
   GenerateAllDoorRooms();

   g_RoomsOK = TRUE;

   if (config_is_defined("check_rooms"))
      CheckRooms();

   return FALSE;
}

static Command g_RoomCommands[] = 
{
   {"rooms_build",     FUNC_VOID, ConvertRoomBrushes, "Convert rooms to internal rep",    HK_ALL},
   {"fix_rooms",       FUNC_VOID, FixRooms,           "Fix dangling room pointers",       HK_ALL},
   {"hilight_room_id", FUNC_INT,  ged_hilight_room,   "Hilight the specified room brush", HK_ALL},
};

void ged_room_init()
{
   COMMANDS(g_RoomCommands,HK_ALL);
}
// $Header: r:/t2repos/thief2/src/editor/ged_room.h,v 1.8 2000/01/29 13:12:15 adurant Exp $
#pragma once

#ifndef __GED_ROOM_H
#define __GED_ROOM_H


#define ROOT_ROOM_NAME     "Base Room"
#define DEFAULT_ROOM_NAME  "Default Room"


// is room database up-to-date?
EXTERN g_RoomsOK;

// Use to compile rooms and set status flags
EXTERN void ged_compile_rooms(void);

// Get the object id of a room named
EXTERN ObjID ged_get_room_named(char *name);

// Create a new room object
EXTERN ObjID ged_create_room_obj(char *name, ObjID archetype, BOOL concrete);

// Make an object a room object
EXTERN void ged_make_room_obj(ObjID objID);

// Get the root and default room ids (creates if necessary)
EXTERN ObjID ged_room_get_root(void);
EXTERN ObjID ged_room_get_default(void);

// Is the object a room?
EXTERN BOOL ged_is_room(ObjID objID);

EXTERN void  ged_room_set_default_arch(ObjID objID);
EXTERN ObjID ged_room_get_default_arch(void);

// Get the object's parent's id
EXTERN ObjID ged_room_get_parent(ObjID objID);

// Get the depth of the object in the room subtree (-1 if fails)
EXTERN int ged_room_get_depth(ObjID objID);

// Draw room-portal connection lines for specified room
EXTERN void ged_room_draw_connections(short roomID, BOOL clear);

// Draw room-portal connection lines for all rooms (or turn off)
EXTERN void ged_room_draw_all_connections(BOOL state);

EXTERN void ged_room_init(void); 

// post-load rooms (also do this on build default) 
EXTERN void ged_room_postload(void);


#endif  // __GED_ROOM_H

// $Header: r:/t2repos/thief2/src/editor/ged_undo.c,v 1.3 2000/02/19 13:10:48 toml Exp $
// undo support

#include <string.h>
#include <stdlib.h>

#include <lg.h>

#include <editbr.h>
#include <editbr_.h>
#include <undoredo.h>
#include <brinfo.h>
#include <brundo.h>
#include <gedit.h>
#include <ged_undo.h>
#include <vbrush.h>

#include <status.h>
#include <command.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/// absolutely hideous editbr_ specific craziness

#define _DELTA_TX_ID     0
#define _DELTA_POS_X     1
#define _DELTA_POS_Y     2
#define _DELTA_POS_Z     3
#define _DELTA_SZ_X      4
#define _DELTA_SZ_Y      5
#define _DELTA_SZ_Z      6
#define _DELTA_ANG_X     7
#define _DELTA_ANG_Y     8
#define _DELTA_ANG_Z     9
#define _DELTA_TEXBASE  10
#define _DELTA_TOFF_ID   0
#define _DELTA_TOFF_ROT  1
#define _DELTA_TOFF_SC   2
#define _DELTA_TOFF_X    3
#define _DELTA_TOFF_Y    4
#define _DELTA_TOFF_CNT  5
#define MAX_DELTAS     (_DELTA_TEXBASE + (EDITBR_MAX_FACES*_DELTA_TOFF_CNT))

static int get_delta_info(int delta_code, int *size, editBrush *br)
{
   if (delta_code>=_DELTA_TEXBASE)
   {
      int which_face;
      delta_code-=_DELTA_TEXBASE;
      which_face=(delta_code/5);
      delta_code%=5;
      *size=2;  // since i happen to know sizeof(fixang=short=ushort)==2
      switch (delta_code)
      {
         case _DELTA_TOFF_ID:  return (int)(((uchar *)&br->txs[which_face].tx_id)-(uchar *)br);
         case _DELTA_TOFF_ROT: return (int)(((uchar *)&br->txs[which_face].tx_rot)-(uchar *)br);
         case _DELTA_TOFF_SC:  return (int)(((uchar *)&br->txs[which_face].tx_scale)-(uchar *)br);
         case _DELTA_TOFF_X:   return (int)(((uchar *)&br->txs[which_face].tx_x)-(uchar *)br);
         case _DELTA_TOFF_Y:   return (int)(((uchar *)&br->txs[which_face].tx_y)-(uchar *)br);
      }
   }
   else if (delta_code==_DELTA_TX_ID)
   {
      *size=sizeof(short);
      return (int)((uchar *)&br->tx_id-(uchar *)br);
   }
   else if (delta_code<=_DELTA_SZ_Z)
   {
      *size=sizeof(mxs_real);
      return (int)((uchar *)(((float *)(&br->pos.el[0]))+delta_code-_DELTA_POS_X)-(uchar *)br);
   }
   else  // for now, this means an angle
   {
      *size=sizeof(mxs_ang);
      return (int)((uchar *)(((mxs_ang *)(&br->ang.el[0]))+delta_code-_DELTA_ANG_X)-(uchar *)br);
   }
   return 0;
}

static int get_max_deltas(editBrush *br)
{
   if (brushGetType(br)!=brType_TERRAIN)
      return _DELTA_TEXBASE-1;
   else
      return _DELTA_TEXBASE-1+(br->num_faces*_DELTA_TOFF_CNT);
}

// returns number of entries it filled of buf, where each is a #def for which field is changed
static int get_delta_list(char *buf, editBrush *b1, editBrush *b2)
{
   int max=get_max_deltas(b1), i;
   int sz, cnt=0, offset;
   for (i=0; i<max; i++)
   {
      offset=get_delta_info(i,&sz,b1);
      if (memcmp(((uchar *)b1)+offset,((uchar *)b2)+offset,sz)!=0)
         buf[cnt++]=(char)i;
   }
   return cnt;
}

// called from within undo/redo to make decisions about what to do
BOOL gedundo_check_brush_delta(editBrush *new_ver, editBrush *old_ver, editBrush *base_ver)
{  
   int real_size=sizeof(editBrush)-(EDITBR_MAX_FACES*sizeof(TexInfo));
   char delta_1[MAX_DELTAS], delta_2[MAX_DELTAS];
   int delta_1_cnt, delta_2_cnt;
   editBrush tmp=*new_ver;
   
   if (brushGetType(&tmp)==brType_TERRAIN)
      real_size+=tmp.num_faces*(EDITBR_MAX_FACES*sizeof(TexInfo));
   tmp.cur_face=old_ver->cur_face;  // move across all data we dont care about diffs in
   tmp.edge=old_ver->edge; tmp.point=old_ver->point; tmp.use_flg=old_ver->use_flg;
   if (memcmp(&tmp,old_ver,real_size)==0)   // for what we care about - these two brushes are the same
      return FALSE;
   if (base_ver==NULL) return TRUE;         // w/o base, any diff is a real diff
   if (base_ver->br_id!=new_ver->br_id) return TRUE; // different brush ids, any diff is a real diff
   if (base_ver->num_faces!=new_ver->num_faces)
   {
      Warning(("Whoa! this shouldnt be different: faces %d %d %d\n",base_ver->num_faces,old_ver->num_faces,new_ver->num_faces));
      return TRUE; // something
   }
   delta_1_cnt=get_delta_list(delta_1,base_ver,old_ver); // what diffs from base->old
   delta_2_cnt=get_delta_list(delta_2,old_ver,new_ver);  // what diffs from old->new
   if (delta_1_cnt!=delta_2_cnt) return TRUE;            // different number of them, bad day
   //   if (delta_1_cnt>1) return TRUE;                     // this would be for not allowing common multi-axis undo
   return memcmp(delta_1,delta_2,delta_1_cnt)!=0;        // if the delta are the same, punt
}

static BOOL tdelta_texture_only;
BOOL gedundo_check_texture_delta(editBrush *new_ver, editBrush *old_ver)
{
   BOOL txt_diff, align_diff=FALSE;
   int i;
   
   txt_diff=(new_ver->tx_id!=old_ver->tx_id);
   for (i=0; i<min(new_ver->num_faces,old_ver->num_faces); i++)
      if (memcmp(&new_ver->txs[i].tx_rot,&old_ver->txs[i].tx_rot,sizeof(TexInfo)-sizeof(short))!=0)
         align_diff=TRUE;
      else if (new_ver->txs[i].tx_id!=old_ver->txs[i].tx_id)
         txt_diff=TRUE;
   tdelta_texture_only=!align_diff;
   return (align_diff||txt_diff);
}

void gedundo_do_texture_delta(editBrush *us)
{
   gedit_reassign_texture(us,tdelta_texture_only);
}

// utilities
static BOOL temp_safety_hack_abort(editBrush *p)
{
#ifdef NO_MBRUSH_UNDO   
   if (brSelect_Flag(p)&brSelect_VIRTUAL)
   {
      Status("Sorry, Multibrush Undo broken");
      return TRUE;
   }
#endif   
   return FALSE;
}

//#define UNDO_STACK_TRACE
#ifdef UNDO_STACK_TRACE
#define traceUndoStack() editUndoStackPrint()
#else
#define traceUndoStack()
#endif

// undo-redo UI
static void gedundo_undo(int count)
{  // 0 or 1 means 1
   bool rv=TRUE;
   if (temp_safety_hack_abort(vBrush_editBrush_Get()))
      return;
   do {
      traceUndoStack();
      rv&=editUndoDoUndo();
      traceUndoStack();      
   } while (--count>0);
   if (rv) Status("Undo!");
   else    Status("No more Undo information.");
   if (rv||(count>1))
      gedit_full_redraw();
}

static void gedundo_redo(int count)
{  // 0 or 1 means 1
   bool rv=TRUE;
   if (temp_safety_hack_abort(vBrush_editBrush_Get()))
      return;
   do {
      traceUndoStack();      
      rv&=editUndoDoRedo();
      traceUndoStack();      
   } while (--count>0);
   if (rv) Status("Redo!");
   else    Status("No more Redo information.");
   if (rv||(count>1))
      gedit_full_redraw();   
}

/////////////////////////////
// command declaration

#ifdef DBG_ON
static void gedit_undo_stack_trace(void) { editUndoStackPrint(); }
#endif

Command gedundo_keys[] =
{
   { "undo", FUNC_INT, gedundo_undo },
   { "redo", FUNC_INT, gedundo_redo },
#ifdef DBG_ON
   { "show_undo_stack", FUNC_VOID, gedit_undo_stack_trace },
#endif   
};

void gedundoCommandRegister(void)
{
   COMMANDS(gedundo_keys, HK_BRUSH_EDIT);
}
// $Header: r:/t2repos/thief2/src/editor/ged_undo.h,v 1.2 2000/01/29 13:12:16 adurant Exp $
#pragma once

#ifndef __GED_UNDO_H
#define __GED_UNDO_H

#include <editbrs.h>

// command interface for gedit init
EXTERN void gedundoCommandRegister(void);

///////////////////
// various undo support

// classify the delta between new and old relative to base
EXTERN BOOL gedundo_check_brush_delta(editBrush *new_ver, editBrush *old_ver, editBrush *base_ver);

// check the textures between a newly restored undo/redo brush and current existing one
EXTERN BOOL gedundo_check_texture_delta(editBrush *new_ver, editBrush *old_ver);
// if the check returned true, call this with the new brush to make it so
EXTERN void gedundo_do_texture_delta(editBrush *us);

#endif  // __GED_UNDO_H
// $Header: r:/t2repos/thief2/src/editor/gfhfrobs.c,v 1.15 2000/02/19 13:10:50 toml Exp $

#include <string.h>

#include <lg.h>
#include <mprintf.h>

#include <cmdbutts.h>
#include <command.h>
#include <pnptools.h>
#include <swappnp.h>
#include <brushgfh.h>
#include <gadblist.h>

#include <brlist.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <brinfo.h>
#include <vbrush.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* top region looks like
 * 0  GridSz   < val >
 * 2  [Show]  3 [Use]
 *
 * bot region
 * 4  Time    < val >   6 [Create] 7 [Select]
 * 8  brid? 9 [toend]   A [swap3]  B [Scroll]
 */

#define NUM_BUTTONS 0xC
static Rect GFHFrobs_rects[NUM_BUTTONS];
#define OUR_RECTS (GFHFrobs_rects)
#define getRect(n) (&OUR_RECTS[n])

#define TOGGLE_GRID_SHOW     1
#define TOGGLE_GRID_USE      2

#define BUTTON_TIME_TOEND    3

#define STRING_BRUSHID       8

#define FROBS_TIME           9
#define FROBS_GRID           10

#define NUM_OWNED           (FROBS_GRID+1)

extern Grid cur_global_grid;
extern void grid_pow2_scale(int pow2);
extern bool vm_show_grid, vm_show_grid_3d;

static int pnpOwners[NUM_OWNED];

// local data
static editBrush *GFHFrobs_br=NULL;
static char brushIDstr[8];
static _PnP_GadgData GFHFrobs;

static int o_time, g_size, o_brid, o_grp;
static bool useGrid, showGrid;
static LGadButtonList swaplist;

static int _get_grid_inv_val(float scale)
{
   int i=0;
   float base=scale_pow2int_to_float(i);
   while ((base<scale)&&(i<32))
   {
      base*=2;
      i++;
   }
   return i;
}

// the update call
// have to get grid/show/use from the world
// and brush id and time
static void GFHFrobs_setvars(editBrush *br, bool update)
{
   BOOL change=FALSE;
   int l_sc;
   
   if (br==NULL)     br=GFHFrobs_br;
   else if (!update) GFHFrobs_br=br;

   PnP_SetCurrent(&GFHFrobs);

   _varforPnP_synch(cur_global_grid.grid_enabled,useGrid,update,pnpOwners[TOGGLE_GRID_USE],change);

   if (showGrid!=(vm_show_grid||vm_show_grid_3d))
   {
      if (update)
         vm_show_grid=vm_show_grid_3d=showGrid;
      else
         showGrid=(vm_show_grid||vm_show_grid_3d);
      PnP_Redraw(pnpOwners[TOGGLE_GRID_SHOW],NULL);
      change=TRUE;
   }
   
   l_sc=_get_grid_inv_val(cur_global_grid.line_spacing);
   if (l_sc!=g_size)
   {
      if (update)
         grid_pow2_scale(g_size);
      else
         g_size=l_sc;
      PnP_Redraw(pnpOwners[FROBS_GRID],NULL);
      change=TRUE;
   }
   
   if (o_time!=blistCheck(br))
   {
      if (update)
         Warning(("Update o_time in setvars? logic bug - %d %d\n",o_time,blistCheck(br)));
      else
         o_time=blistCheck(br);
      PnP_Redraw(pnpOwners[FROBS_TIME],NULL);
      change=TRUE;
   }

   if (brSelect_Flag(br)&brSelect_VIRTUAL)
   {  // -1 check makes sure we get it if we came from a non multi-brush
      if ((brSelect_Group(br)!=o_grp)||(o_brid!=-1))
      {
         o_grp=brSelect_Group(br);
         sprintf(brushIDstr,"G>  %d",o_grp);
         PnP_Redraw(pnpOwners[STRING_BRUSHID],NULL);
      }
      o_brid=-1;
   }
   else if (br->br_id!=o_brid)    // this is a read only thing, so no need to worry
   {
      itoa(br->br_id,brushIDstr,10);
      o_brid=br->br_id;
      PnP_Redraw(pnpOwners[STRING_BRUSHID],NULL);
   }

   if (!update && LGadRadioButtonSelection(&swaplist) != GFHCurrentSwappable())
   {
      LGadRadioButtonSelect(&swaplist,GFHCurrentSwappable());
   }  
   
   if (change&&update)
      gedit_full_redraw();  // well, most of this might be things like adding a grid or something
}

#define END_OF_TIME   (-2)
#define START_OF_TIME (-1)
// n of -2 means go to end of time
static bool do_time_frob(int n)
{
   bool rv;
   extern bool set_brush_to_time_n(editBrush *br, int n);
   int max_time=blistCount();  // wrong, should use the real time
   if (n==END_OF_TIME)
      vBrush_go_EOT();
   else
   {
      if (n>=max_time)
         n=max_time-1;
      rv=set_brush_to_time_n(GFHFrobs_br,n);
   }
   o_time=blistCheck(GFHFrobs_br);
   PnP_Redraw(pnpOwners[FROBS_TIME],NULL);
   return rv;
}

static void GFHFrobs_OneShots(int lid)
{
   if (lid==BUTTON_TIME_TOEND)
      do_time_frob(END_OF_TIME);
   else
      Warning(("GFHFrobs Oneshot %d- what is going on\n",lid));
}

static void GFHFrobs_Tog(Rect *where, bool val, int data)
{
   GFHFrobs_setvars(NULL,TRUE);
}

static void GFHFrobs_Update(PnP_SliderOp op, Rect *where, int val, int data)
{
   if (data==FROBS_TIME)
      do_time_frob(o_time);
   else
      GFHFrobs_setvars(NULL,TRUE);
}

#define MIN_GRID 8
#define MAX_GRID 24

#define BOT_BORDER 3

//////////////////////////////
// actual swap button area

#pragma off(unreferenced)
static bool swap_butt_cb(ushort action, int button, void* data, LGadBox* vb)
{
   if (action & (BUTTONGADG_LCLICK|BUTTONGADG_RCLICK))
      PnP_ExecCommandInt("start_swap",button);
   return TRUE;
}
#pragma on(unreferenced)

static DrawElement dvec[] = 
{ 
   { DRAWTYPE_TEXT, "Create", NULL, 0,0, BORDER(DRAWFLAG_BORDER_OUTLINE),},
   { DRAWTYPE_TEXT, "Layout", NULL, 0,0, BORDER(DRAWFLAG_BORDER_OUTLINE),},
   { DRAWTYPE_TEXT, "Scroll", NULL, 0,0, BORDER(DRAWFLAG_BORDER_OUTLINE),},
   { DRAWTYPE_TEXT, "Filter", NULL, 0,0, BORDER(DRAWFLAG_BORDER_OUTLINE),},
};

#define NUM_SWAPBUTTS (sizeof(dvec)/sizeof(dvec[0]))

static void CreateSwapButts(LGadRoot* root, Rect* rvec)
{
   LGadButtonListDesc desc;

   memset(&desc,0,sizeof(desc));
   desc.num_buttons = NUM_SWAPBUTTS;
   desc.button_rects = rvec;
   desc.button_elems = dvec;
   desc.cb = swap_butt_cb;
   desc.flags = BUTTONLIST_RADIO_FLAG;
   LGadCreateButtonListDesc(&swaplist,root,&desc);
}

static void DestroySwapButts(void)
{
   LGadDestroyButtonList(&swaplist);
}

////////////////////////
// actually do the deed
void Create_GFHFrobs(LGadRoot *root, Rect *top_r, Rect *bot_r, editBrush *br)
{
   LayoutRectangles(top_r,OUR_RECTS+0,4,MakePoint(2,2),MakePoint(2,2));
   getRect(0)->lr.x=getRect(1)->lr.x;  // horizontal merge the top of top region
   LayoutRectangles(bot_r,OUR_RECTS+4,8,MakePoint(4,2),MakePoint(2,2));
   getRect(4)->lr.x=getRect(5)->lr.x-BOT_BORDER;  // and the top of time area
   getRect(9)->lr.x-=BOT_BORDER;  // add a border tween time and swaps
   getRect(6)->ul.x+=BOT_BORDER; getRect(0xA)->ul.x+=BOT_BORDER;
   
   PnP_GadgStart(&GFHFrobs,root);
   CreateSwapButts(root,OUR_RECTS+6);
   GFHFrobs_setvars(br,FALSE);

   pnpOwners[FROBS_GRID]=PnP_SliderInt(getRect(0),"Grid Sz",MIN_GRID,MAX_GRID,1,&g_size,
                    GFHFrobs_Update,FROBS_GRID,PNP_SLIDER_CLICKS);
   pnpOwners[TOGGLE_GRID_SHOW]=
      PnP_ButtonToggle(getRect(2),"Show",NULL,&showGrid,GFHFrobs_Tog,TOGGLE_GRID_SHOW);
   pnpOwners[TOGGLE_GRID_USE]=   
      PnP_ButtonToggle(getRect(3),"Use",NULL,&useGrid,GFHFrobs_Tog,TOGGLE_GRID_USE);

   pnpOwners[FROBS_TIME]=PnP_SliderInt(getRect(4),"Time",0,65536,1,&o_time,
                    GFHFrobs_Update,FROBS_TIME,PNP_SLIDER_VSLIDE);
   pnpOwners[STRING_BRUSHID]=PnP_TextBox(getRect(8),brushIDstr);
   PnP_ButtonOneShot(getRect(9),"To End",GFHFrobs_OneShots,BUTTON_TIME_TOEND);

   // I wonder if just copying rects around works.
   *getRect(8)=*getRect(0xA);  // That's 0xA, NOT 10!
   *getRect(9)=*getRect(0xB);
}

void Destroy_GFHFrobs(void)
{
   DestroySwapButts();
   PnP_GadgFree(&GFHFrobs);
}

void Update_GFHFrobs(GFHUpdateOp op, editBrush *br)
{
   GFHFrobs_setvars(br,FALSE);   
   if (op==GFH_FORCE)
      PnP_FullRedraw(&GFHFrobs);
}
// $Header: r:/t2repos/thief2/src/editor/gfhfrobs.h,v 1.2 2000/01/29 13:12:18 adurant Exp $
#pragma once

void Create_GFHFrobs(LGadRoot *root, Rect *top_r, Rect *bot_r, editBrush *br);
void Destroy_GFHFrobs(void);
void Update_GFHFrobs(GFHUpdateOp op, editBrush *br);
// $Header: r:/t2repos/thief2/src/editor/gridpnp.c,v 1.15 2000/02/19 13:10:51 toml Exp $
// Brush Grid PnP gadget

#include <gadblist.h>
#include <lgsprntf.h>

#include <command.h>

#include <editor.h>
#include <editbr.h>

#include <brushGFH.h>
#include <PnPtools.h>
#include <swappnp.h>

#include <mprintf.h>
#include <rand.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 *           ___________
 * 1<txtr>   |0 pic of |  (txtr flips to the brush txtr pnp)
 * 2<tog>    | grid??? |  (tog toggles grid on/off, about to change)
 * 3<reset>  |_________|  (reset resets all fields to defaults)
 * 4 world     us snap
 * 5<-size-> 8<-xoffs->   (size,pos are float 0->4.0, rot angle 0-360?)
 * 6<- pos-> 9<-yoffs->     (applied to created brushes, global)
 * 7<- rot-> A<-scale->   (xoffs,yoffs,scale are per brush for snapping)
 *                               (which is currently unsupported)
 */

#define NUM_BUTTONS (0xB)
static Rect gridPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (gridPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 3
#define BTN_BELOW 3
#define VERT_DIV  4
#define HORIZ_DIV (0.50)

void gridPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,HORIZ_DIV,1,2,2);
   for (i=0; i<BTN_ABOVE; i++)
      buildYLineRect(curRect++,whole,i,HORIZ_DIV,0,2,2);
   buildYLineRect(curRect++,whole,i,0,1,2,2);   // bonus Line!!
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,0,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[3].lr.y;
}

// this would draw a picture or something, probably takes more args
// for now, probably just draw a box of Rand() color to know when it redraws
void gridPnP_Picture(int data)
{

}

#define BUTTON_TEXTURE 1
#define BUTTON_ALIGN   2
#define BUTTON_TOGGLE  3
#define BUTTON_RESET   4

#define FROBS_W_SCALE  5

//static int g_scale=16;        // is 4.0.  so 2^16 is 4, so formula
static editBrush *gridPnP_br=NULL;

static _PnP_GadgData gridPnP;

void gridPnP_setvars(editBrush *br)
{
   gridPnP_br=br;
}

// this will be called for all one shots with the final parameter
// or we could have a separate callback for each oneshot, if that is easier
void gridPnP_OneShots(int lid)
{
   switch (lid)
   {
      case BUTTON_TEXTURE:  PnP_ExecCommandInt("start_pnp", PNP_TEXTURE); break;
      case BUTTON_ALIGN:    PnP_ExecCommandInt("start_pnp", PNP_ALIGN); break;
      case BUTTON_TOGGLE:   CommandExecute("grid_toggle"); break;
      case BUTTON_RESET:    break;
   }
}

#ifdef WORKED
void gridPnP_Update(PnP_SliderOp op, Rect *where, int val, int data)
{
   extern void grid_pow2_scale(int pow2);
   if (op != PnP_SliderUpdateOp)
      return;
   switch (data)
   {
      case FROBS_W_SCALE: grid_pow2_scale(val); break;
   }
}

void gridPnP_Update_1(PnP_SliderOp op, Rect *where, float val, int data)
{
   mprintf("at %d\n",data);
}

void gridPnP_Update_2(PnP_SliderOp op, Rect *where, fixang val, int data)
{
   mprintf("at %d (%x)\n",data,val);
}

void gridPnP_Update_3(PnP_SliderOp op, Rect *where, short val, int data)
{
   mprintf("at %d (%d)\n",data,val);
}

static float gridVar;
static fixang gridVar2;
static short gridVar3;
#endif

// create a grid PnP
void Create_gridPnP(LGadRoot *root, Rect *bounds, editBrush *br)
{
   GFHSetCoordMask(GFH_ALL_COORDS);
   gridPnP_buildRects(bounds);
   PnP_GadgStart(&gridPnP,root);
   PnP_PictureBox(getRect(0),gridPnP_Picture,0);
   PnP_ButtonOneShot(getRect(1),"Texture",gridPnP_OneShots,BUTTON_TEXTURE);
   PnP_ButtonOneShot(getRect(2),"Align",gridPnP_OneShots,BUTTON_ALIGN);   
#ifdef WORKED
   PnP_ButtonOneShot(getRect(2),"Toggle",gridPnP_OneShots,BUTTON_TOGGLE);
   PnP_ButtonOneShot(getRect(3),"Reset",gridPnP_OneShots,BUTTON_RESET);
   PnP_TextBox(getRect(4),"   World  -  Us Snap  ");
   PnP_SliderInt(getRect(5),"Size",0,24,1,&g_scale,gridPnP_Update,FROBS_W_SCALE,0);
   PnP_SliderFloat(getRect(6),"Pos",0.0,4.0,0.01,&gridVar,gridPnP_Update_1,0,FALSE);
   PnP_SliderFixang(getRect(7),"Rot",0,0,&gridVar2,gridPnP_Update_2,0,FALSE);
   PnP_SliderShort(getRect(8),"XOff",0,0,&gridVar3,gridPnP_Update_3,0,FALSE);
   PnP_SliderShort(getRect(9),"YOff",0,0,&gridVar3,gridPnP_Update_3,0,FALSE);
   PnP_SliderShort(getRect(10),"Scale",0,0,&gridVar3,gridPnP_Update_3,0,FALSE);
#endif
}

void Destroy_gridPnP(void)
{
   PnP_GadgFree(&gridPnP);
   gridPnP_br=NULL;
}

void Update_gridPnP(GFHUpdateOp op, editBrush *br)
{

}

// $Header: r:/t2repos/thief2/src/editor/gridsnap.c,v 1.5 2000/02/19 13:10:53 toml Exp $

// Grid snapping code

#include <r3d.h>
#include <gridsnap.h>
#include <math.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static mxs_real quantize_point(mxs_real pt, mxs_real scale)
{
   // We want to compute a*scale+b = pt
   // where 0 <= b < scale, and return a*scale.

   // One way to do this is with modf, which
   // computes (a,b) itself.  Then we could
   // either return a*scale or pt-b.  The latter
   // will introduce rounding errors and make
   // points not quite identical.  Alternately,
   // can we be sure that a is integral, and not
   // 4.9999999 or the like?  Unclear what modf() promises.

   // If we keep our grid scales powers of two,
   // this will help a lot.

   // anyway, we also have the problem that modf
   // deals incorrectly with the negative case,
   // forming negative values of b.  So we just
   // use an explicit floor instead.

   // the rounding problems aren't as bad as they
   // sound because we also actually bias by scale/2
   // and we don't really care about consistency of
   // points right at the boundary.

   return floor((pt + scale/2) / scale) * scale;
}

void gedit_vertex_snap(Grid *g, mxs_vector *dest, mxs_vector *src)
{
   if (g->orientation.tx || g->orientation.ty || g->orientation.tz) {
      // rotated case; this code would work in the non-rotated
      // case but why be slow?

      // besides, this way we can test non-rotated first
   } else {
      // non-rotated case
      dest->x = quantize_point(src->x, g->line_spacing);
      dest->y = quantize_point(src->y, g->line_spacing);
      dest->z = quantize_point(src->z, g->line_spacing);
   }
}

// we render the 3d grid in the current r3_color.
// We assume we only need to draw the grid perpendicular
// to prime_axis.  In a 2d view, prime_axis is the depth axis,
// and thus drawing one grid layer draws them all.
//
// In a 3d view, prime_axis is determined by the user,
// and allows the user to place a visible grid in 3d.
// However, in this case the grid won't necessarily extend
// everywhere you can see, since in a 3d view you can see
// to infinity along more than one axis.
//
// We use "height" for the world location of the grid along
// the prime axis; this is only visible in a 3d view

static void render_line(mxs_vector *a, mxs_vector *b)
{
   r3s_point pts[2];

   r3_transform_point(pts, a);
   r3_transform_point(pts+1, b);

   r3_draw_line(pts, pts+1);
}

void gedit_render_grid(Grid *g, int prime_axis, mxs_real height,
                       mxs_vector *start, mxs_vector *end)
{
   mxs_vector origin;
   mxs_vector s,e;
   mxs_real temp, x, limit;
   mxs_vector pt1,pt2;
   int a0, a1;

   origin.x = origin.y = origin.z = 0;

   r3_start_object_angles(&origin, &g->orientation, R3_DEFANG);
   r3_start_block();

   r3_transform_w2o(&s, start);
   r3_transform_w2o(&e, end);

   // swap axes around so they're predictable

   if (s.x > e.x) { temp = e.x; e.x = s.x; s.x = temp; }
   if (s.y > e.y) { temp = e.y; e.y = s.y; s.y = temp; }
   if (s.z > e.z) { temp = e.z; e.z = s.z; s.z = temp; }

   // gridize those points
   
   s.x = quantize_point(s.x, g->line_spacing) - g->line_spacing;
   s.y = quantize_point(s.y, g->line_spacing) - g->line_spacing;
   s.z = quantize_point(s.z, g->line_spacing) - g->line_spacing;

   e.x = quantize_point(e.x, g->line_spacing) + g->line_spacing;
   e.y = quantize_point(e.y, g->line_spacing) + g->line_spacing;
   e.z = quantize_point(e.z, g->line_spacing) + g->line_spacing;

   // determine which axes to iterate through
   a0 = (prime_axis + 1) % 3;
   a1 = (prime_axis + 2) % 3;

   pt1.el[prime_axis] = height;
   pt2.el[prime_axis] = height;

     // draw lines parallel to a0

   pt1.el[a1] = s.el[a1];
   pt2.el[a1] = e.el[a1];

   limit = e.el[a0] + g->line_spacing/2;

   if ((limit - s.el[a0])/g->line_spacing < 100) {
      for (x=s.el[a0]; x <= limit; x += g->line_spacing) {
         pt1.el[a0] = x;     
         pt2.el[a0] = x;     
         render_line(&pt1, &pt2);
      }
   }

     // draw lines parallel to a1

   pt1.el[a0] = s.el[a0];
   pt2.el[a0] = e.el[a0];

   limit = e.el[a1] + g->line_spacing/2;

   if ((limit - s.el[a1])/g->line_spacing < 100) {
      for (x=s.el[a1]; x <= limit; x += g->line_spacing) {
         pt1.el[a1] = x;
         pt2.el[a1] = x;
         render_line(&pt1, &pt2);
      }
   }
 
   r3_end_block();
   r3_end_object();
}
// $Header: r:/t2repos/thief2/src/editor/gridsnap.h,v 1.4 2000/01/29 13:12:19 adurant Exp $
#pragma once

// grid functions

#ifndef __GRIDSNAP_H
#define __GRIDSNAP_H

typedef struct
{
   mxs_real line_spacing;
   mxs_vector phase_shift;   
   mxs_angvec orientation;
   bool grid_enabled;
} Grid;

 // @HACK: perhaps this should be less goofy than just here, eh?
EXTERN Grid cur_global_grid;

void gedit_vertex_snap(Grid *g, mxs_vector *dest, mxs_vector *src);

 //  prime_axis is axis to draw grid perpendicular to
 //  height is location along that axis at which to place grid
 //  start,end are corners of a bounding box of the area to engrid
void gedit_render_grid(Grid *g, int prime_axis, mxs_real height,
                       mxs_vector *start, mxs_vector *end);

#endif
// $Header: r:/t2repos/thief2/src/editor/hilight.c,v 1.17 2000/03/24 14:33:19 adurant Exp $
// brush highlighting system

#include <string.h>

#include <command.h>
#include <status.h>

#include <property.h>

#include <csgbrush.h>
#include <hilight.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brquery.h>
#include <brrend.h>
#include <gedit.h>
#include <vbrush.h>
#include <objpos.h>
#include <editobj.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define HILIGHT_NUM_BITS 8

// global highlight controls
uchar hilight_array[MAX_CSG_BRUSHES];
uchar hilight_active=0;               // which hilights im actually showing

// are we hilighting everything, or just rendered brushes
static BOOL hilight_global=TRUE;

//////////////////
// common core add/remove of various types
static uchar hilight_cur=1;           // what hilight im currently adding
static bool  hilight_autoclear=TRUE;  // do i reclear every time i add

BOOL hilightAddByBrushId(int brush_id)
{
   hilight_array[brush_id]|=hilight_cur;
   return TRUE;
}

BOOL hilightAddByObjId(int obj_id)
{
   editBrush *us;
   us=editObjGetBrushFromObj(obj_id);
   if (us)
      hilightAddByBrushId(us->br_id);
   return TRUE;
}

BOOL hilightAddByBrush(editBrush *br)
{
   return hilightAddByBrushId(br->br_id);
}

BOOL hilightRemoveByBrushId(int brush_id)
{
   if (hilight_array[brush_id]&hilight_cur)
   {
      hilight_array[brush_id]&=~hilight_cur;
      return TRUE;
   }
   return FALSE;
}

BOOL hilightRemoveByObjid(int obj_id)
{
   editBrush *us;
   us=editObjGetBrushFromObj(obj_id);
   if (us)
      return hilightRemoveByBrushId(us->br_id);
   return FALSE;
}

BOOL hilightRemoveByBrush(editBrush *br)
{
   return hilightRemoveByBrushId(br->br_id);
}

static void hilight_clear_all(void)
{
   memset(hilight_array,0,MAX_CSG_BRUSHES);
}

void hilightClearBits(int bitmask)
{
   int i;
   for (i=0; i<MAX_CSG_BRUSHES; i++)
      hilight_array[i]&=~bitmask;
}

//////////////////////////
// common setup/operation code for highlights

void hilight_begin(void)
{
   if ((hilight_cur&hilight_active)&&(hilight_autoclear))
   {
      hilightClearBits(hilight_cur);
      hilight_active=0;
   }
}

void hilight_end(ulong flags)
{
   if (flags & kHilightDone)
   {
      hilight_active|=hilight_cur;
      gedit_full_redraw();
   }
}

static BOOL (*_hilight_cur_check)(editBrush *br)=NULL;
static int    _hilight_cur_cnt=0;
void hilight_active_check(editBrush *br)
{
   if (_hilight_cur_check)
      if ((*_hilight_cur_check)(br))
      {
         hilightAddByBrush(br);
         _hilight_cur_cnt++;
      }
}
   
static BOOL hilight_simple_run(BOOL (*br_check)(editBrush *br))
{
   BOOL rv=TRUE;

   hilight_begin();
   if (hilight_global)
   {
      if (!brFilter(br_check,hilightAddByBrush))
      {
         Status("No matching brushes");
         rv=FALSE;
      }
   }
   else
   {
      _hilight_cur_check=br_check;
      _hilight_cur_cnt=0;
      brushRunOnActive(hilight_active_check);
      rv=_hilight_cur_cnt>0;
   }
   hilight_end((rv)? kHilightDone : kHilightCancel);

   return rv;
}

BOOL highlight_check(editBrush *br)
{
   return isActiveHighlight(br->br_id);
}

////////////////
// obj highlighting - wants to scan through all objects, checking for this property

static IProperty *pTestProp;

static BOOL property_check(editBrush *br)
{
   if (brushGetType(br)==brType_OBJECT)
      return IProperty_IsRelevant(pTestProp,brObj_ID(br));
   return FALSE;
}

static BOOL property_check_direct(editBrush *br)
{
   if (brushGetType(br)==brType_OBJECT)
      return IProperty_IsSimplyRelevant(pTestProp,brObj_ID(br));
   return FALSE;
}

static void hilight_obj_with_property(char *str)
{
   BOOL haveProp;
   if ((str==NULL)||(str[0]=='\0'))
   {
      Status("Prop menu not yet supported here");
      return;  // want to bring up dialog with which to choose a property
   }
   haveProp = GetPropertyInterfaceNamed(str,IProperty,&pTestProp);
   if (!haveProp||(pTestProp==NULL))
   {
      Status("Dont know about that property");
      return;
   }
   hilight_simple_run(property_check);
   SafeRelease(pTestProp);
}

static void hilight_obj_with_property_direct(char *str)
{
   BOOL haveProp;
   if ((str==NULL)||(str[0]=='\0'))
   {
      Status("Prop menu not yet supported here");
      return;  // want to bring up dialog with which to choose a property
   }
   haveProp = GetPropertyInterfaceNamed(str,IProperty,&pTestProp);
   if (!haveProp||(pTestProp==NULL))
   {
      Status("Dont know about that property");
      return;
   }
   hilight_simple_run(property_check_direct);
   SafeRelease(pTestProp);
}

// needs to do wacky stuff, basically
static void hilight_split_obj(void)
{
   extern BOOL hilight_split_objs;  // in eosapp, really
   if ((hilight_cur&hilight_active)&&(hilight_autoclear))
   {
      hilightClearBits(hilight_cur);
      hilight_active=0;
   }
   hilight_split_objs=TRUE;
   ObjDeleteAllRefs();     // this will cause it to call out 
   ObjBuildAllRefs();      //   since split_objs is true..
   hilight_split_objs=FALSE;
   hilight_active|=hilight_cur;
   gedit_full_redraw();
}

////////////////
// terrain highlighting
// find nonaxial stuff
static BOOL nonaxial_check(editBrush *br)
{
   if (brushGetType(br)==brType_TERRAIN)
      return ((br->ang.el[0]&0x3fff)||(br->ang.el[1]&0x3fff)||(br->ang.el[2]&0x3fff));
   return FALSE;
}

static void hilight_nonaxial_terrain(void)
{
   hilight_simple_run(nonaxial_check);
}

// find given media
static int  terr_media_target=0;
static BOOL terr_media_check(editBrush *br)
{
   if (brushGetType(br)==brType_TERRAIN)
      return br->media==terr_media_target;
   return FALSE;
}

static void hilight_media_type(int media_id)
{
   terr_media_target=media_id;
   hilight_simple_run(terr_media_check);
}

// check for terrain texture id
static int  terr_texture_target=0;
static BOOL terr_texture_check(editBrush *br)
{
   if (brushGetType(br)==brType_TERRAIN)
   {
      int i, use_default=0;
      for (i=0; i<br->num_faces; i++)
         if (br->txs[i].tx_id==-1)
            use_default++;
         else if (br->txs[i].tx_id==terr_texture_target)
            return TRUE;
      return (use_default && (br->tx_id==terr_texture_target));
   }
   return FALSE;
}

static void hilight_texture_id(int texture_id)
{
   terr_texture_target=texture_id;
   hilight_simple_run(terr_texture_check);
}

// for snap checking
static BOOL any_snap_check(editBrush *br)
{
   if (brushGetType(br)==brType_TERRAIN)
      if (!br->grid.grid_enabled)
      {
         BOOL need_snap=FALSE;
         float tmp;
         int i;
         for (i=0; i<3; i++)
         {
            tmp=br->pos.el[i]; need_snap|=_gedit_float_snap(&tmp);
            tmp=br->sz.el[i];  need_snap|=_gedit_float_snap(&tmp);
         }
         return need_snap;
      }
   return FALSE;
}

static BOOL ortho_snap_check(editBrush *br)
{
   if (brushGetType(br)==brType_TERRAIN)   
      if (!nonaxial_check(br))
         return any_snap_check(br);
   return FALSE;
}

static void hilight_check_snap(int cntrl)
{
   hilight_simple_run(cntrl?any_snap_check:ortho_snap_check);
}

static BOOL do_snap_op(editBrush *us)
{
   return gedit_snap_brush(us);
}

static void hilight_do_snap(void)
{
   brFilter(highlight_check,do_snap_op);
   gedit_full_redraw();
}

////////////////
// multibrush interface

static BOOL add_to_mbrush(editBrush *br)
{
   return vBrush_editBrush_Op(br,vBrush_OP_ADD);
}

static void multibrush_the_highlight(void)
{
   brFilter(highlight_check,add_to_mbrush);
   vBrush_getToCurGroup();
   gedit_full_redraw();
}

static IProperty* pCreateProp;

static BOOL propertize(editBrush* br)
{
   if (brushGetType(br)==brType_OBJECT)
   {
      IProperty_Create(pCreateProp,brObj_ID(br));
      return TRUE;
   }
   return FALSE;
}

static void propertize_the_highlight(char* propname)
{
   pCreateProp = GetPropertyNamed(propname);
   brFilter(highlight_check,propertize);
   SafeRelease(pCreateProp);
}

static BOOL unpropertize(editBrush* br)
{
   if (brushGetType(br)==brType_OBJECT)
   {
      IProperty_Delete(pCreateProp,brObj_ID(br));
      return TRUE;
   }
   return FALSE;
}

static void unpropertize_the_highlight(char* propname)
{
   pCreateProp = GetPropertyNamed(propname);
   brFilter(highlight_check,unpropertize);
   SafeRelease(pCreateProp);
}

//////////////////////////
// dumb really basic UI
static void hilight_use(int use)
{
   int i, bitval, hits=0;

   for (i=0, bitval=1; i<HILIGHT_NUM_BITS; i++, bitval<<=1)
      if (bitval&use)
         hits++;
   if (hits==1)
      hilight_cur=use;
   else
      Status("Poorly formed use bits");
}

static void hilight_clear(int which)
{
   if (which==0)
      hilight_clear_all();
   else
      hilightClearBits(which);
   gedit_full_redraw();
}

static void hilight_activate(int which)
{
   hilight_active|=which;
   gedit_full_redraw();   
}

static void hilight_deactivate(int which)
{
   hilight_active&=~which;
   gedit_full_redraw();   
}

static void hilight_brush(int which)
{
   BOOL full_redraw=FALSE;
   if (which==0)
   {
      editBrush *us=vBrush_GetSel();
      which=us->br_id;
      // perhaps should check if vbrush
      // if so, do fancy stuff (tm)
      full_redraw=TRUE;  // for now, since hilight doesnt seem to work right with incremental update      
   }
   else
      full_redraw=TRUE;
   hilightAddByBrushId(which);
   hilight_active|=hilight_cur;
   if (full_redraw) gedit_full_redraw();
}

static void reinstantiate_and_highlight(char *str)
{
  hilight_obj_with_property(str);
  unpropertize_the_highlight(str);
  propertize_the_highlight(str);
}

//////////////////////////
// misc ui stuff

static BOOL _list_br(editBrush* br)
{
   mprintf("Brush %d time %d\n",br->br_id,br->timestamp);
   return TRUE;
}

static BOOL _list_obj(editBrush* br)
{
   if (brushGetType(br)==brType_OBJECT)
   {
      mprintf("Obj %d brush %d\n",brObj_ID(br),br->br_id);
      return TRUE;
   }
   return FALSE;
}

static void hilight_list(BOOL all_br)
{
   brFilter(highlight_check,all_br?_list_br:_list_obj);
}

//////////////////////////
// actual key commands for highlight system
Command hilight_keys[] =
{
   { "hilight_by_prop", FUNC_STRING, hilight_obj_with_property, "give property name, highlights obj's with it" },
   { "hilight_by_prop_direct", FUNC_STRING, hilight_obj_with_property_direct, "give property name, highlights obj's with it specifically on them (not inherited)" },
   { "hilight_nonaxial", FUNC_VOID, hilight_nonaxial_terrain, "highlights any terrain with non-90 angles" },
   { "hilight_media", FUNC_INT, hilight_media_type, "highlight terrain w/media_op of type <arg>" },
   { "hilight_texture", FUNC_INT, hilight_texture_id, "highlight terrain w/texture id <arg>" },
   { "hilight_split_obj", FUNC_VOID, hilight_split_obj, "highlight objects crossing a portal" },
   { "multibrush_the_highlight", FUNC_VOID, multibrush_the_highlight, "make hilight objs the multibrush" },
   { "hilight_brush", FUNC_INT, hilight_brush, "hilight current (0) or brush_id" },
   { "hilight_check_snap", FUNC_INT, hilight_check_snap, "hilight unangled unsnapped brushes, or if (1) all unsnapped brushes" },
   { "hilight_do_snap", FUNC_INT, hilight_do_snap, "grid snap all hilight brushes..." },
   { "hilight_list", FUNC_BOOL, hilight_list, "list objs, or, if arg 1, all brush ids" },
   { "hilight_global", TOGGLE_BOOL, &hilight_global, "if true, we will hilight everything, else just active" },
   
   { "hilight_autoclear", TOGGLE_BOOL, &hilight_autoclear, "do we autoclear old hilight and make it only active" },
   { "hilight_use", FUNC_INT, hilight_use, "set which hilight bit to use (bitfield, must be just 1)" },
   { "hilight_clear", FUNC_INT, hilight_clear, "clear current highlights (all if 0, else bitfields)" },
   { "hilight_activate", FUNC_INT, hilight_activate, "turn on hilight bits" },
   { "hilight_deactivate", FUNC_INT, hilight_deactivate, "turn off hilight bits" },
   { "hilight_add_prop", FUNC_STRING, propertize_the_highlight, "Add a named property to all hilit objects"},
   { "hilight_rem_prop", FUNC_STRING, unpropertize_the_highlight, "Add a named property to all hilit objects"},

   { "hilight_render", TOGGLE_BOOL, &renderHilightOnly },
   { "hilight_reinstantiate", FUNC_STRING, reinstantiate_and_highlight, "Hilight all objects with property, then remove and readd property"},
}; // all take bitfields since while ugly it is consistent

void hilightCommandRegister(void)
{
   hilight_clear_all();
   COMMANDS(hilight_keys, HK_BRUSH_EDIT);
}
// $Header: r:/t2repos/thief2/src/editor/hilight.h,v 1.6 2000/01/29 13:12:20 adurant Exp $
// brush highlighting system
#pragma once

#ifndef __HILIGHT_H
#define __HILIGHT_H

#include <editbrs.h>

// actual hilight data
EXTERN uchar hilight_array[];
EXTERN uchar hilight_active;

// does current brush contain active highlight
#define isActiveHighlight(id) ((hilight_array[id]&hilight_active)!=0)

// clear all bits from bitfield in all hilight entries
EXTERN void hilightClearBits(int bitf);

// register commands
EXTERN void hilightCommandRegister(void);

// the horror, for use in brush queries
EXTERN BOOL highlight_check(editBrush *br);
   
// start/stop hilighting.  For commands that set hilights
EXTERN void hilight_begin(void);
EXTERN void hilight_end(ulong flags); 

enum hilight_end_flags
{
   kHilightCancel = 0,
   kHilightDone  = 1 << 0,
};

// ways to add a hilight from external systems (only should be used inside
// a begin/end pair)
EXTERN BOOL hilightAddByObjId(int obj_id);
EXTERN BOOL hilightAddByBrushId(int brush_id);
EXTERN BOOL hilightRemoveByObjId(int obj_id);
EXTERN BOOL hilightRemoveByBrushId(int brush_id);

//////////////////
// for "reserved" bits
#define PORTAL_HILIGHT_BIT (1<<7)

#endif  // __HILIGHT_H
// $Header: r:/t2repos/thief2/src/editor/isdesced.cpp,v 1.2 1998/10/05 17:26:21 mahk Exp $
#include <wtypes.h>
#include <isdesced.h>
#include <lgassert.h>

#include <dynfunc.h>

// must be last header
#include <dbmem.h>

static IStructEditor* LGAPI construct_woe(sStructEditorDesc* , sStructDesc* , void* )
{
   CriticalMsg("Could not load dialog!");
   return NULL;
}

DeclDynFunc_(IStructEditor*, LGAPI, ConstructStructEditor, (sStructEditorDesc*, sStructDesc*, void* ));
ImplDynFunc(ConstructStructEditor, "darkdlgs.dll", "_ConstructStructEditor@12", construct_woe);

#define Construct (DynFunc(ConstructStructEditor).GetProcAddress())

IStructEditor* CreateStructEditor(const sStructEditorDesc* eddesc, const sStructDesc* sdesc, void* editme)
{
   return Construct((sStructEditorDesc*)eddesc,(sStructDesc*)sdesc,editme);
}



// $Header: r:/t2repos/thief2/src/editor/isdesced.h,v 1.4 1997/11/07 18:37:12 mahk Exp $
#pragma once  
#ifndef __ISDESCED_H
#define __ISDESCED_H

#include <comtools.h>
#include <sdestype.h>
#include <isdescty.h>

////////////////////////////////////////////////////////////
// Struct Desc Editor API
//
// Mostly COM for interoperability
//

F_DECLARE_INTERFACE(IStructEditor);

enum eSdescModality_
{
   kStructEdModal,
   kStructEdModeless, 
};

typedef ulong eSdescModality;


#undef INTERFACE
#define INTERFACE IStructEditor
DECLARE_INTERFACE_(IStructEditor,IUnknown)
{
   DECLARE_UNKNOWN_PURE();

   //
   // Start the editor.  Call this one.
   // If Modal, returns TRUE iff the ok button was pushed. 
   // If Modeless, returns FALSE immediately
   //
   STDMETHOD_(BOOL,Go)(THIS_ eSdescModality modal) PURE;

#define IStructEditor_Go(p, a) COMCall1(p, Go, a) 

   //
   // Set the callback to be called when buttons get pushed
   //
   STDMETHOD(SetCallback)(THIS_ StructEditCB cb, StructEditCBData data) PURE;

#define IStructEditor_SetCallback(p, a, b) COMCall2(p, SetCallback, a, b)

   //
   // Accessors
   //
   STDMETHOD_(const sStructEditorDesc*,Describe)(THIS) PURE;
   STDMETHOD_(const sStructDesc*,DescribeStruct)(THIS) PURE;
   STDMETHOD_(void*,Struct)(THIS) PURE;

};
 
#define IStructEditor_Describe(p)         COMCall0(p, Describe)
#define IStructEditor_DescribeStruct(p)   COMCall0(p, DescribeStruct)
#define IStructEditor_Struct(p)           COMCall0(p, Struct)

#undef INTERFACE

EXTERN IStructEditor* CreateStructEditor(const sStructEditorDesc* eddesc, const sStructDesc* sdesc, void* editme); 

#endif // __ISDESCED_H
 
// $Header: r:/t2repos/thief2/src/editor/isdescst.h,v 1.3 1997/10/21 21:00:21 mahk Exp $
#pragma once  
#ifndef __ISDESCST_H
#define __ISDESCST_H

//
// Struct Editor Events
//

enum eStructEditEvent_
{
   kStructEdOK    = 1 << 0,
   kStructEdApply = 1 << 1,
   kStructEdCancel  = 1 << 2,
};

struct sStructEditEvent
{
   ulong kind;
   IStructEditor* ed;
};

//
// Struct Editor Descriptor
//

enum _eStructEditorFlags 
{
   kStructEditNoFieldNames  = (1 << 0),  // don't show field names
   kStructEditShowTypes     = (1 << 1),  // DO show types (defaults OFF!)  (NIY)
   kStructEditFriendlyTypes = (1 << 2),  // user-friendly type names (String instead of char*) (NIY)
   kStructEditNoOKButton    = (1 << 3),  // Remove the "OK" button 
   kStructEditNoCancelButton  = (1 << 4),  // Remove the "Cancel" button
   kStructEditNoApplyButton   = (1 << 5),  // Remove the "Apply" button
   kStructEditAllButtons      = 0, 
   kStructEditNoButtons       = (kStructEditNoOKButton|kStructEditNoCancelButton|kStructEditNoApplyButton), 
};

struct sStructEditorDesc
{
   char title[32]; // title string
   ulong flags;    // see above
};

#endif // __ISDESCST_H









// $Header: r:/t2repos/thief2/src/editor/isdescty.h,v 1.4 1997/10/20 18:22:40 mahk Exp $
#pragma once  
#ifndef __ISDESCTY_H
#define __ISDESCTY_H

#include <sdestype.h>
#include <comtools.h>

F_DECLARE_INTERFACE(IStructEditor);

typedef struct sStructEditorDesc sStructEditorDesc;
typedef struct sStructEditEvent sStructEditEvent;
typedef void* StructEditCBData;

typedef void (LGAPI *StructEditCB)(sStructEditEvent* event, StructEditCBData data);

#endif // __ISDESCTY_H

/*
 * $Source: r:/t2repos/thief2/src/editor/lgslider.c,v $
 * $Revision: 1.3 $
 * $Author: toml $
 * $Date: 2000/02/19 13:10:54 $
 *
 * Implements a pretty standard cup/handle type of slider gadget built on top of
 * the LGadToggle gadget.  Movement can be either horizontal or vertical and can
 * be quantized. No 'nudge' capability exists, 'cause I don't need it yet.
 *
 */

// library includes
#ifdef _WIN32
#include <comtools.h>
#include <appagg.h>
#include <dispapi.h>
#include <mprintf.h>
#endif

#undef BTYPE

#include <event.h>
#include <gadget.h>
#include <lgslider.h>
#include <hotkey.h>
#include <mouse.h>
#include <string.h>
#include <lgsprntf.h>
#include <keydefs.h>
#include <math.h>
#include <limits.h>
#include <config.h>
#include <cfg.h>
#include <rect.h>
#include <cfgdbg.h>
#include <fixreal.h> // hmmm will need to deal with this eventually

// our gadget includes
#include <drawelem.h>
#include <util2d.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern short lgad_pal_blacks[];
extern short lgad_pal_text[];
extern int root_paltype;

// Are we doing 16 bit stuff?
extern bool lgad_use_pal16;
extern Id lgad_pal_id;

extern void LGadInitToggle(LGadToggle *vt);
extern void LGadComputeVarSize(LGadToggle *vt, short *wp, short *hp);
extern void LGadComputeSize(LGadButton *vbutt, short *wp, short *hp);

static void SliderChangeValue( LGadSlider* vs )
{
   long newval;

   // Quantize the value
   // (the factor of 2 is to handle the case where increm == 1 )
   newval = (long)vs->max_val * 2 * vs->handlePos / vs->screenRange;
   newval = ((newval + vs->increm) /  (vs->increm*2)) * vs->increm;

   if ( *vs->val_ptr != newval )
   {
      *vs->val_ptr = newval;
      if (vs->buttonfunc)
	 vs->buttonfunc(0, NULL, (LGadBox*)vs);

   }
   
}

static void SliderSetGrab( LGadSlider* vs, short x, short y)
{
   Rect* r;

   r = (BOX_RECT(VB(vs)));

   x = x - r->ul.x;  // to compensate for position of gadget
   y = y - r->ul.y;

   if ( vs->orient == LGSLIDER_HORIZONTAL )
   {
      vs->grabPos = x - vs->handlePos;
   }
   else
   {
      vs->grabPos = y - vs->handlePos;
   }

}

static void SliderMoveHandle(LGadSlider* vs, short x, short y)
{
   Rect* r;

   r = (BOX_RECT(VB(vs)));

   x = x - r->ul.x;  // to compensate for position of gadget
   y = y - r->ul.y;

   if ( vs->orient == LGSLIDER_HORIZONTAL )
   {
      vs->handlePos = x;
      vs->grabPos   = vs->handleSpan / 2;
   }
   else
   {
      vs->handlePos = y;
      vs->grabPos   =   vs->handleSpan / 2;
   }

}

static bool PointOverHandle( LGadSlider* vs, short x, short y)
{
   bool retval = TRUE;
   Rect* r;

   r = (BOX_RECT(VB(vs)));

   if ( !RECT_TEST_PT(r, MakePoint(x,y) ))
      retval = FALSE;

   x = x - r->ul.x;  // to compensate for position of gadget
   y = y - r->ul.y;

   if ( vs->orient == LGSLIDER_HORIZONTAL )
   {
      if ( ( x < vs->handlePos ) || (x > vs->handlePos + vs->handleSpan ))
	 retval = FALSE;
   }
   else
   {
      if ( ( y < vs->handlePos ) || (y > vs->handlePos + vs->handleSpan ))
	 retval = FALSE;
   }

   return retval;
}


bool SliderMotionHandler(short x, short y, LGadBox *vb)
{
   LGadSlider *vs;
   Rect *r;
   bool retval = FALSE;

   vs = (LGadSlider *)vb;

   if (vs->state == LGSLIDER_SELECTED)
   {
      short closeval, closepos, notch;

      r = (BOX_RECT(vb));

      x = x - r->ul.x;  // to compensate for position of gadget
      y = y - r->ul.y;

      if ( vs->orient == LGSLIDER_HORIZONTAL )
	 vs->handlePos = x - vs->grabPos;
      else
	 vs->handlePos = y - vs->grabPos;

      if ( vs->handlePos > vs->screenRange )
         vs->handlePos = vs->screenRange;
         
      if ( vs->handlePos < 0 )
         vs->handlePos = 0;

      // Here is a little goofy bit:  If the handle, while being dragged, is
      // close to a 'detent', then move it there, just for feel.

//      pixPerNotch = (long)vs->handleRange * vs->increm / vs->max_val; 

      closeval = (long)vs->max_val * 2 * vs->handlePos / vs->screenRange;
      notch    = ((closeval + vs->increm) /  (vs->increm*2));

      closepos = ( (long)vs->screenRange * vs->increm / vs->max_val ) * notch;

      if ( abs(closepos - vs->handlePos) < vs->handleSpan)
	 vs->handlePos = closepos;

      if ( vs->handlePos != vs->oldHandlePos )
      {
	 SliderChangeValue( vs );
	 vs->oldHandlePos = vs->handlePos;
	 LGadDrawBox(vb,NULL); // redraw with new value
      }
	 
      retval = TRUE;

   }
   else  // is not selected
   {
      if ( PointOverHandle( vs, x, y ))
      {
	 if ( vs->state != LGSLIDER_HIGHLIT )
	 {
	    vs->state = LGSLIDER_HIGHLIT;
	    LGadDrawBox(vb,NULL); // redraw with new value
	    uiGrabFocus(LGadBoxRegion(vs),UI_EVENT_MOUSE_MOVE);
	 }
	 retval = TRUE; 
      }
      else
      {
	 if ( vs->state != LGSLIDER_DEFAULT )
	 {
	    vs->state = LGSLIDER_DEFAULT;
	    LGadDrawBox(vb,NULL); // redraw with new value
	    uiReleaseFocus(LGadBoxRegion(vs),UI_EVENT_MOUSE_MOVE);
	 }
      }

      // don't eat the event

   }

   return(retval);
}

bool SliderMouseHandler(short x, short y, short action, short wheel, LGadBox *vb)
{
   LGadSlider *vs;
   bool retval = FALSE;

   vs = (LGadSlider *)vb;
   // compensate for internal drawelement stuff

   if (action & MOUSE_LDOWN )
   {
      vs->state = LGSLIDER_SELECTED;

      if ( PointOverHandle( vs, x,y ) )
	 SliderSetGrab(vs,x,y);
      else // move the handle over to the mouse pointer
	 SliderMoveHandle(vs,x,y);

      LGadDrawBox(vb,NULL); // redraw (in case the up/down art is different)
      uiGrabFocus(LGadBoxRegion(vs),UI_EVENT_MOUSE);
      uiSetMouseMotionPolling(TRUE);
      retval = TRUE;

   }

   if ((action & MOUSE_LUP) && (vs->state == LGSLIDER_SELECTED))
   {
      
      SliderChangeValue(vs);

      vs->state = LGSLIDER_DEFAULT;
      uiSetMouseMotionPolling(FALSE);
      uiReleaseFocus(LGadBoxRegion(vs),UI_EVENT_MOUSE_MOVE);
      uiReleaseFocus(LGadBoxRegion(vs),UI_EVENT_MOUSE);
      LGadDrawBox((LGadBox*)vs,NULL); // redraw with new value

   }
   return(retval);
}

void SliderDraw(void *data, LGadBox *vb)
{
   int x = 0;
   int y = 0;
   LGadSlider *vs = (LGadSlider *)vb;
   Rect* r;

   r = (BOX_RECT(vb));

//  If the box is selected, the the user is dragging it, and handlePos
//  should be used to determine the position.  If it is not selected,
//  the position should be computed from the value pointer.  This allows
//  the slider to track its associated variable sort-of automagically
//  while still allowing free motion when it is being dragged

   if ( vs->state != LGSLIDER_SELECTED )
   {
      vs->handlePos = (short)((long)vs->screenRange * (*vs->val_ptr) / vs->max_val) ;
   }

   if ( vs->orient == LGSLIDER_HORIZONTAL )
      x = vs->handlePos;
   else
      y = vs->handlePos;
      

   uiHideMouse(r);
   if ( vs->suPos.x >= 0 )
      gr_bitmap( &vs->saveUnder, vs->suPos.x, vs->suPos.y );
   
   gr_get_bitmap( &vs->saveUnder, x, y);
   vs->suPos.x = x;
   vs->suPos.y = y;
   
   // note assumption that we are in a canvas just right for us to draw into
   //   ElementDraw(&LGadButtonDrawElem(vs),(void*)vs->state,x,y,grd_canvas->bm.w,grd_canvas->bm.h);
   ElementDraw(&LGadButtonDrawElem(vs),vs->state,x,y,grd_canvas->bm.w,grd_canvas->bm.h);
   uiShowMouse(r);

}
#pragma on(unreferenced)
void LGadInitSlider(LGadSlider *vs)
{
   memset(vs,0,sizeof(LGadSlider));
   LGadInitToggle((LGadToggle *)vs);
   ElementClear(&LGadButtonDrawElem(vs));
}

LGadSlider *LGadCreateSlider(LGadSlider *vs, LGadRoot *vr, short x, short y, 
			     short w, short h, char paltype)
{
   uchar* p;
   short suW = 0, suH = 0;

   if (vs == NULL)
   {
      vs = (LGadSlider *)Malloc(sizeof(LGadSlider));
      LGadInitSlider(vs);
   }
   else
   {
      if (LGadBoxFlags(vs) & BOXFLAG_ACTIVE)
      {
         Warning(("LGadCreateSlider: vs %x is already active!\n",vs));
         return(NULL);
      }
   }

   if (vs == NULL)
   {
      Warning(("LGadCreateSlider: vs is NULL after Malloc!\n"));
      return(NULL);
   }
   if (vs->max_val % vs->increm)
      Warning(("LGadCreateSlider: %d not a mult of %d!\n",vs->max_val,vs->increm));


   // Wire up data2 to variable
   switch(LGadButtonDrawElem(vs).draw_type)
   {
   case DRAWTYPE_VAR:
   case DRAWTYPE_VARSTRING:
   case DRAWTYPE_VARRES:
   case DRAWTYPE_FORMAT:
   case DRAWTYPE_FORMATREF:
      LGadButtonDrawElem(vs).draw_data2 = vs->val_ptr;
      break;
   }

   if ((w <= 0) || (h <= 0))
   {
      short elemw,elemh; 

      elemw=w;
      elemh=h;
      LGadComputeVarSize((LGadToggle *)vs,&elemw,&elemh);

      // Offset the box upper/left coords

      x -= ( elemw / 2);
      y -= ( elemh / 2);

      suH = elemh;
      suW = elemw;

      if ( vs->orient == LGSLIDER_HORIZONTAL )
      {
	 vs->handleSpan = elemw;
	 elemw += vs->screenRange;
      }
      else
      {
	 vs->handleSpan = elemh;
	 elemh += vs->screenRange;
      }

      // plug in computed vals
      if (w <= 0)
         w = elemw;
      if (h <= 0)
         h = elemh;

   }
   else
   {
      suH = h;
      suW = w;
   }

   if ( grd_mode_info[grd_mode].bitDepth == 16)
   {
      p = (uchar *)Malloc(w*h*sizeof(short));
      gr_init_bitmap(&(vs->saveUnder),p,BMT_FLAT16,0, suW, suH);
   }
   else
   {
      p = (uchar *)Malloc(w*h);
      gr_init_bitmap(&(vs->saveUnder),p,BMT_FLAT8,0, suW, suH);
   }

   vs->suPos.x = -1; // No saveunder taken yet

   LGadCreateBox((LGadBox *)vs,vr,x,y,w,h,SliderMouseHandler,NULL,SliderDraw,paltype);

   //   vs->box_flags |= BOXFLAG_DIRECT;   &&&&&&&

   LGadBoxMouseMotion((LGadBox *)vs,SliderMotionHandler);
   return(vs);
}

LGadSlider *LGadCreateSliderArgs(LGadSlider *vs, LGadRoot *vr, short x, short y, 
				 short w, short h,  DrawElement *draw, 
				 LGadButtonCallback bfunc, int *val_ptr, short max_val, 
				 short increm, short screenRange, char orient, 
				 char paltype)
{
   if (vs == NULL)
   {
      vs = (LGadSlider *)Malloc(sizeof(LGadSlider));
      LGadInitSlider(vs);
   }
   else
   {
      if (LGadBoxFlags(vs) & BOXFLAG_ACTIVE)
      {
         Warning(("LGadCreateSliderArgs: vs %x is already active!\n",vs));
         return(NULL);
      }
   }

   if (vs == NULL)
   {
      Warning(("LGadCreateSliderArgs: vs is NULL after Malloc!\n"));
      return(NULL);
   }

   vs->val_ptr = val_ptr;
   vs->max_val = max_val;
   vs->increm = increm;
   vs->screenRange = screenRange;
   vs->buttonfunc = bfunc;
   LGadButtonSetDrawElem(vs,*draw);
   vs->orient = orient;
   
   return(LGadCreateSlider(vs,vr,x,y,w,h,paltype));
}


int LGadDestroySlider(LGadSlider *vb, bool free_self)
{

   uiReleaseFocus(LGadBoxRegion(vb),ALL_EVENTS);

   if (vb->saveUnder.bits )
   {
      Free( vb->saveUnder.bits) ;
      vb->saveUnder.bits = NULL;
   }

   LGadDestroyBox((LGadBox *)vb,free_self);

   return 0;

}

#pragma once
/*
 * $Source: r:/t2repos/thief2/src/editor/lgslider.h,v $
 * $Revision: 1.2 $
 * $Author: adurant $
 * $Date: 2000/01/29 13:12:21 $
 *
 *  A lisder button gadget (works with gadget.lib)
 *
 */

#ifndef __LGSLIDER_H
#define __LGSLIDER_H

#define LGSLIDER_HORIZONTAL   0
#define LGSLIDER_VERTICAL     1

#define LGSLIDER_DEFAULT  0
#define LGSLIDER_HIGHLIT  1
#define LGSLIDER_SELECTED 2

typedef struct {
   TOGGLE_GUTS;
   short       screenRange;
   char        orient;
   int         state;
   short       handleSpan;
   // Internal stuff::
   grs_bitmap  saveUnder;
   Point       suPos;
   short       handlePos;
   short       oldHandlePos;
   short       grabPos;
} LGadSlider;


extern LGadSlider *LGadCreateSlider(LGadSlider *vs, LGadRoot *vr, short x, short y, short w, short h, char paltype);
extern LGadSlider *LGadCreateSliderArgs(LGadSlider *vs, LGadRoot *vr, short x, short y, short w, short h, 	
   DrawElement *draw, LGadButtonCallback bfunc, int *val_ptr, short max_val, 
	short increm, short screenRange, char orient, char paltype);
int LGadDestroySlider(LGadSlider *vb, bool free_self);

#endif
// $Header: r:/t2repos/thief2/src/editor/lightpnp.c,v 1.24 2000/02/19 13:10:55 toml Exp $
// lighting PnP gadget

#include <config.h>
#include <gadblist.h>
#include <lgsprntf.h>

#include <command.h>

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <brinfo.h>

#include <animlit.h>

#include <brushGFH.h>
#include <PnPtools.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 *
 *        0 pic?
 *
 *    1   [type]         (currently 0 or 1, fill in br->tx_id
 *    2<- bright ->      (currently 0.0-16.0, store in br->sz.el[0]
 *    3<- focal  ->      (currently 0.0-16.0?, store in br->sz.el[1]
 *    4<-ambient ->      (ambient for this, if an omni)
 *
 *   < r > < g > < b >    (not supported any time soon, so lets not bother)
 */

#define NUM_BUTTONS (0x5)
static Rect lightPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (lightPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 0
#define BTN_BELOW 4
#define VERT_DIV  1
#define HORIZ_DIV 0

void lightPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,HORIZ_DIV,1,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,0,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[1].ul.y-2;
}

// actual setup for the PnP
extern int global_ambient;
static bool _local_type=FALSE;
static editBrush *lightPnP_br=NULL;

static _PnP_GadgData lightPnP;

// these 2 i changed the brushes might be kinda wrong...

// update means the world should be set from the vars, else the opp
static void lightPnP_setvars(editBrush *br, bool update)
{
   lightPnP_br=br;
   if (br==NULL) return;
   if (update)
   {
      brLight_Type(br)=_local_type;
      i_changed_the_brush(br,FALSE,FALSE,FALSE);
   }
   else
   {
      _local_type=brLight_Type(br);
   }
}

#define LIGHT_BRIGHT 1

#pragma disable_message(202)
static void lightPnP_Slide(PnP_SliderOp op,Rect *where, float val, int data)
{
   if ((lightPnP_br==NULL) || (op != PnP_SliderUpdateOp))
      return;
#if 0
   if ((data==LIGHT_BRIGHT)&&(brLight_Handle(lightPnP_br) != -1))
      LightSetBrightness(brLight_Handle(lightPnP_br),(int)val);// - 1
#endif
   i_changed_the_brush(lightPnP_br,FALSE,FALSE,FALSE);
}

static void lightPnP_ChangeInt(Rect *where, bool val, int data)
{
   lightPnP_setvars(lightPnP_br,TRUE);
}
#pragma enable_message(202)

void Create_lightPnP(LGadRoot* root, Rect* bounds, editBrush *br)
{
   GFHSetCoordMask(GFH_NO_D|GFH_NO_W|GFH_NO_H);
   lightPnP_buildRects(bounds);   
   PnP_GadgStart(&lightPnP,root);   
   lightPnP_setvars(br,FALSE);
   PnP_PictureBox(getRect(0),NULL,0);       // making this a bool * is super icky
   PnP_ButtonToggle(getRect(1),"Type:Omni","Type:Spot",&_local_type,lightPnP_ChangeInt,0);
   PnP_SliderFloat(getRect(2),"Bright",1.0,1024.0,4.0,&brLight_Bright(br),
                    lightPnP_Slide,LIGHT_BRIGHT,PNP_SLIDER_VSLIDE);
   PnP_SliderFloat(getRect(3),"Hue",0,1.0,0.05,&brLight_Hue(br),lightPnP_Slide,0,PNP_SLIDER_VSLIDE);
   PnP_SliderFloat(getRect(4),"Saturation",0.0,1.0,0.05,&brLight_Saturation(br),lightPnP_Slide,0,PNP_SLIDER_VSLIDE);
}

void Destroy_lightPnP(void)
{
   PnP_GadgFree(&lightPnP);
   lightPnP_br=NULL;
}

void Update_lightPnP(GFHUpdateOp op, editBrush *br)
{
   lightPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      PnP_FullRedraw(&lightPnP);
}

////////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/editor/linkdraw.cpp,v 1.7 2000/02/11 14:27:44 bfarquha Exp $
//
// Link-drawing system
//

#include <lg.h>
#include <string.h>

#include <appagg.h>
#include <comtools.h>

#include <dlist.h>
#include <relation.h>
#include <lnkquery.h>
#include <linkbase.h>
#include <linkman.h>

#include <wrtype.h>
#include <objpos.h>

#include <ged_line.h>
#include <linkdraw.h>

#include <editbr_.h>
#include <editbr.h>
#include <brlist.h>
#include <brinfo.h>

// Must be last header
#include <dbmem.h>


class cLinkDraw;

typedef cDList<cLinkDraw, 0>     cLinkDrawList;
typedef cDListNode<cLinkDraw, 0> cLinkDrawNode;

struct sColor
{
   int r, g, b;
   sColor(int rr = 0, int gg = 0, int bb = 0) : r(rr),g(gg),b(bb) {};
};

class cLinkDraw : public cLinkDrawNode
{
public:
   char name[64];
   sColor color;
};


static cLinkDrawList LinkDrawList;

////////////////////////////////////////////////////////////////////////////////

void InitDrawnRelations()
{
   // Hey, we might want to do something here someday...
}

////////////////////////////////////////

void TermDrawnRelations()
{
   cLinkDraw *pLinkDraw;

   pLinkDraw = LinkDrawList.GetFirst();
   while (pLinkDraw != NULL)
   {
      delete LinkDrawList.Remove(pLinkDraw);
      pLinkDraw = LinkDrawList.GetFirst();
   }
}

////////////////////////////////////////

void ResetDrawnRelations()
{
   TermDrawnRelations();
   InitDrawnRelations();
}

////////////////////////////////////////////////////////////////////////////////

static cLinkDraw *GetLinkDrawNode(const char *name)
{
   cLinkDraw *pLinkDraw;

   pLinkDraw = LinkDrawList.GetFirst();
   while (pLinkDraw != NULL)
   {
      if (!strcmp(name, pLinkDraw->name))
         return pLinkDraw;

      pLinkDraw = pLinkDraw->GetNext();
   }

   return NULL;
}

////////////////////////////////////////

void AddDrawnRelation(const char *name, ubyte r, ubyte g, ubyte b)
{
   cLinkDraw *pLinkDraw;

   if (GetLinkDrawNode(name) == NULL)
   {
      pLinkDraw = new cLinkDraw;

      strncpy(pLinkDraw->name, name, 64);
      pLinkDraw->color = sColor(r,g,b);

      LinkDrawList.Append(pLinkDraw);
   }
}

////////////////////////////////////////

void AddDrawnRelationID(RelationID relationID, ubyte r, ubyte g, ubyte b)
{
   AutoAppIPtr_(LinkManager, pLinkMan);

   IRelation *rel = pLinkMan->GetRelation(relationID);

   if (rel != NULL)
      AddDrawnRelation(rel->Describe()->name, r, g, b);
   else
      Warning(("AddDrawnRelationID: Relation id %d not found!\n", relationID));

   SafeRelease(rel);
}

////////////////////////////////////////

void RemoveDrawnRelation(const char *name)
{
   cLinkDraw *pLinkDraw;

   if ((pLinkDraw = GetLinkDrawNode(name)) != NULL)
      delete LinkDrawList.Remove(pLinkDraw);
}

////////////////////////////////////////

void RemoveDrawnRelationID(RelationID relationID)
{
   AutoAppIPtr_(LinkManager, pLinkMan);

   IRelation *rel = pLinkMan->GetRelation(relationID);

   if (rel != NULL)
      RemoveDrawnRelation(rel->Describe()->name);
   else
      Warning(("RemoveDrawnRelationID: Relation id %d not found!\n", relationID));

   SafeRelease(rel);
}

////////////////////////////////////////////////////////////////////////////////

// from brrend.c:
extern "C"
{
   bool pointOBBIntersect(editBrush *point, editBrush *brush);
}

// Determine if link originates inside brush.
static BOOL LinkOriginatesInBrush(sLink *pLink, editBrush *us)
{
   editBrush point;
   point.pos = ObjPosGet(pLink->source)->loc.vec;
   return pointOBBIntersect(&point, us);
}


int g_nLinkDrawSourceId = 0;
int g_nLinkDrawSplitId = 0;


// Is this id a child of g_nLinkDrawSplitId?
// *** We're assuming there are no circular patrols that don't include startid
// To do this right, we'd need to mark previously visited nodes, but that's probably overkill
// given our problem space. Still, let's at least not crash:

static int nCrashDetector;

static BOOL IsChild(ObjID startid, ObjID id, IRelation *pRelation, int nLoopCount = 0)
{
   if (startid==id) // We've gone circular, or are just beginning.
   {
      if (nLoopCount)
      {
         nCrashDetector--;
         return FALSE;
      }
      else
         nLoopCount++;
   }

   if (nCrashDetector > 40)
      return FALSE;

   nCrashDetector++;

   ILinkQuery *query = pRelation->Query(LINKOBJ_WILDCARD, id);

   for (; !query->Done(); query->Next())
   {
      sLink link;
      query->Link(&link);
      if (link.source == g_nLinkDrawSplitId)
      {
         SafeRelease(query);
         return TRUE;
      }
      else if (IsChild(startid, link.source, pRelation, nLoopCount))
      {
         SafeRelease(query);
         return TRUE;
      }
   }

   SafeRelease(query);
   nCrashDetector--;
   return FALSE;
}


// Is this id a parent of g_nLinkDrawSplitId?
// *** We're assuming there are no circular patrols that don't include startid
// To do this right, we'd need to mark previously visited nodes, but that's probably overkill
// given our problem space.
static BOOL IsParent(ObjID startid, ObjID id, IRelation *pRelation, int nLoopCount = 0)
{
   if (startid==id) // We've gone circular, or are just beginning.
   {
      if (nLoopCount)
      {
         nCrashDetector--;
         return FALSE;
      }
      else
         nLoopCount++;
   }

   if (nCrashDetector > 40)
      return FALSE;

   nCrashDetector++;

   ILinkQuery *query = pRelation->Query(id, LINKOBJ_WILDCARD);

   for (; !query->Done(); query->Next())
   {
      sLink link;
      query->Link(&link);
      if (link.dest == g_nLinkDrawSplitId)
      {
         SafeRelease(query);
         return TRUE;
      }
      else if (IsParent(startid, link.dest, pRelation, nLoopCount))
      {
         SafeRelease(query);
         return TRUE;
      }
   }

   SafeRelease(query);
   nCrashDetector--;
   return FALSE;
}


// This is SLOW, but then again, it doesn't need to be fast.
// See if this Obj is anywhere on branching relation.
static BOOL ObjIsOnSplitPath(ObjID id, IRelation *pRelation)
{
   if (id==g_nLinkDrawSplitId)
      return TRUE;

   nCrashDetector = 0;
   if (IsParent(id, id, pRelation))
      return TRUE;

   nCrashDetector = 0;
   if (IsChild(id, id, pRelation))
      return TRUE;

   return FALSE;
}


// Go through and see if any brushes are me-only. If so, only draw links that originate within this brush.
static BOOL LinkIsDrawable(sLink *pLink, IRelation *pRelation)
{
   editBrush *us;
   int hIter;
   BOOL bFoundBrush = FALSE;

   if ((g_nLinkDrawSourceId > 0) && (pLink->source != g_nLinkDrawSourceId))
      return FALSE;

   if ((g_nLinkDrawSplitId > 0) && !ObjIsOnSplitPath(pLink->source, pRelation))
      return FALSE;

   us=blistIterStart(&hIter);
   while ((us!=NULL) && !bFoundBrush)
   {
      if ((brushGetType(us)==brType_HOTREGION) && brHot_IsMEONLY(us))
      {
         bFoundBrush = TRUE;
         blistIterDone(hIter);
      }
      else
         us=blistIterNext(hIter);
   }

   return !bFoundBrush || LinkOriginatesInBrush(pLink, us);
}



void DrawRelations()
{
   AutoAppIPtr_(LinkManager, pLinkMan);
   cLinkDraw *pLinkDraw;

   gedDeleteChannelLines(1<<LINE_CH_LINKS);

   ged_line_load_channel = LINE_CH_LINKS;
   ged_line_view_channels |= (1<<LINE_CH_LINKS);

   pLinkDraw = LinkDrawList.GetFirst();
   while (pLinkDraw != NULL)
   {
      IRelation *pRelation = pLinkMan->GetRelationNamed(pLinkDraw->name);

      if (pRelation != NULL)
      {
         ILinkQuery *query = pRelation->Query(LINKOBJ_WILDCARD, LINKOBJ_WILDCARD);

         for (; !query->Done(); query->Next())
         {
            sLink link;
            query->Link(&link);

            if (LinkIsDrawable(&link, pRelation))
               gedLineAddRGB(&ObjPosGet(link.source)->loc.vec, &ObjPosGet(link.dest)->loc.vec, LINE_FLG_DIR, pLinkDraw->color.r, pLinkDraw->color.g, pLinkDraw->color.b);
         }

         SafeRelease(query);
      }
      else
         Warning(("DrawRelations: relation %s not found!\n", pLinkDraw->name));

      SafeRelease(pRelation);

      pLinkDraw = pLinkDraw->GetNext();
   }
}

////////////////////////////////////////////////////////////////////////////////

BOOL ObjHasDrawnLinks(ObjID objID)
{
   AutoAppIPtr_(LinkManager, pLinkMan);
   cLinkDraw  *pLinkDraw;
   ILinkQuery *query;

   pLinkDraw = LinkDrawList.GetFirst();
   while (pLinkDraw != NULL)
   {
      IRelation *pRelation = pLinkMan->GetRelationNamed(pLinkDraw->name);

      if (pRelation != NULL)
      {
         query = pRelation->Query(objID, LINKOBJ_WILDCARD);

         if (!query->Done())
         {
            SafeRelease(query);
            SafeRelease(pRelation);

            return TRUE;
         }

         SafeRelease(query);

         query = pRelation->Query(LINKOBJ_WILDCARD, objID);

         if (!query->Done())
         {
            SafeRelease(query);
            SafeRelease(pRelation);

            return TRUE;
         }

         SafeRelease(query);
      }
      else
         Warning(("DrawRelations: relation %s not found!\n", pLinkDraw->name));

      SafeRelease(pRelation);

      pLinkDraw = pLinkDraw->GetNext();
   }

   return FALSE;
}



// $Header: r:/t2repos/thief2/src/editor/objedit.cpp,v 1.31 2000/02/24 23:40:12 mahk Exp $

#include <windows.h>
#include <config.h>
#include <stdio.h>
#include <stdlib.h>

#include <mprintf.h>

#include <appagg.h>
#include <iobjsys.h>
#include <osysbase.h>
#include <objedit.h>
#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>
#include <objspace.h>

#include <linkbase.h>
#include <linkman.h>
#include <relation.h>
#include <linkedit.h>
#include <linkedst.h>
#include <linkdraw.h>

#include <objhistp.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <vbrush.h>
#include <status.h>
#include <gedit.h>
#include <uiedit.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <edittool.h>

#include <command.h>

#include <ctype.h>
#include <string.h>
#include <hilight.h>
#include <iobjed.h>
#include <lnktrait.h>

#include <dialogs.h>
#include <dynfunc.h>
#include <gen_bind.h>

#include <dbmem.h>

//  Brush lock stuff
//
extern "C" int MAX_LOCKED_BRUSHES;
extern "C" int TERRAIN_ID;
extern "C" ObjID gLockedBrushes [];
extern "C" BOOL brushIsLocked (editBrush* brush);

char* TERRAIN_STRING = "all_terrain";

static void linked_woe(sLink&)
{
	CriticalMsg("Could not load dialog!");
}

//  Dynamic function to open the new link dialog
//
DeclDynFunc_(BOOL,LGAPI,DisplayLinkDialog,(sLink&));
ImplDynFunc(DisplayLinkDialog,"darkdlgs.dll","_DisplayLinkDialog@4",linked_woe);

#define AskForLink	(DynFunc(DisplayLinkDialog).GetProcAddress())

////////////////////////////////////////////////////////////
// OBJ EDITING COMMANDS
//

//
// highlight objects of type
//

static void hilight_descendents(char* donorname)
{
   ObjID donor = EditGetObjNamed(donorname);
   AutoAppIPtr_(TraitManager,TraitMan);

   hilight_begin();
   IObjectQuery* query = TraitMan->Query(donor,kTraitQueryAllDescendents);
   ulong flags = kHilightCancel;

   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();
      if (OBJ_IS_CONCRETE(obj))
      {
         hilightAddByObjId(obj);
         flags = kHilightDone;
      }
   }
   SafeRelease(query);
   hilight_end(flags);
}

static void hilight_archetype(char* donorname)
{
   ObjID donor = EditGetObjNamed(donorname);
   AutoAppIPtr_(TraitManager,TraitMan);

   hilight_begin();
   IObjectQuery* query = TraitMan->Query(donor,kTraitQueryAllDescendents);
   ulong flags = kHilightCancel;

   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();
      if (OBJ_IS_CONCRETE(obj))
      {
         // see whether we are simply descended
         if (TraitMan->ObjHasDonorIntrinsically(obj,donor))
         {
            hilightAddByObjId(obj);
            flags = kHilightDone;
         }
      }
   }
   SafeRelease(query);
   hilight_end(flags);
}

//
// Edit link data
//


#define IS_DELIM(x) ((x) == ',')
#define RELATION_ARG 2

static long parse_relation(const char* name)
{
   long id = atoi(name);
   if (id != RELID_NULL) return id;
   AutoAppIPtr_(LinkManager,LinkMan);
   cAutoIPtr<IRelation> Rel(LinkMan->GetRelationNamed(name));
   return Rel->GetID();
}


extern "C"
{
BOOL show_all_links = FALSE;
}


void edit_link_cmd(char* arg)
{
   // extract three args
   int args[3] = { LINKOBJ_WILDCARD, LINKOBJ_WILDCARD, RELID_WILDCARD } ;

   const int num_args = sizeof(args)/sizeof(args[0]);

   if (*arg == '\0')  // No args
   {
      editBrush* cur = vBrush_GetSel();
      if (brushGetType(cur) == brType_OBJECT)
         arg[0] = brObj_ID(cur);
   }
   else  // Find three args
      for (int i = 0; i < num_args; i++)
      {
         while(*arg && isspace(*arg)) arg++;

         char* delim;
         for (delim = arg; *delim && !IS_DELIM(*delim); delim++);
         char save = *delim;
         *delim = '\0';
         if (i == RELATION_ARG)
            args[i] = parse_relation(arg);
         else
            args[i] = EditGetObjNamed(arg);

         *delim = save;
         arg = delim+1;
      }

   sLinkEditorDesc desc = { "", kLinkEditAllButtons};
   if (show_all_links) desc.flags |= kLinkEditShowAll;
   EditLinks(&desc,args[0],args[1],args[2]);
}

////////////////////////////////////////


////////////////////////////////////////

static int cnt=0;
static editBrush *src, *dst;

static void getOurBrushes(editBrush *us)
{
   cnt++;
   if (us!=dst)
   {
      src=us;
   }
}

static void vbrui_build_link(char* arg)
{
   // Remove trailing whitespace;
   int len = strlen(arg);
   for (char* s = arg + len - 1; s > arg && isspace(*s); s--)
      *s = '\0';

   AutoAppIPtr_(LinkManager,pLinkMan);
   cAutoIPtr<IRelation> rel ( pLinkMan->GetRelationNamed(arg) );
   if (rel->GetID() == RELID_NULL)
   {
      Status("No such relation");
      return;
   }

   cnt=0;
   dst=vBrush_GetSel();
   if (brushGetType(dst)==brType_OBJECT)
   {
      vBrush_GroupOp(FALSE,getOurBrushes);
      if ((cnt==2)&&(brushGetType(src)==brType_OBJECT))
      {
         rel->Add(brObj_ID(src),brObj_ID(dst));
         Status("Linked");
         vBrush_editBrush_Op(src, vBrush_OP_REM);
         gedit_full_redraw();
         return;
      }
   }
   Status("Not two obj brushes");
}

static void link_two_objs(char *arg)
{
   char src[64], dst[64], flav[64];

   sscanf(arg,"%s %s %s",src,dst,flav);
   AutoAppIPtr_(LinkManager,pLinkMan);
   cAutoIPtr<IRelation> rel ( pLinkMan->GetRelationNamed(flav) );
   if (rel->GetID() == RELID_NULL)
   {
      Status("No such relation");
      return;
   }

   ObjID src_obj=EditGetObjNamed(src);
   ObjID dst_obj=EditGetObjNamed(dst);
   AutoAppIPtr_(ObjectSystem,pObjSys);
   if ((src_obj==OBJ_NULL)||(dst_obj==OBJ_NULL)||
       !pObjSys->Exists(src_obj)||!pObjSys->Exists(dst_obj))
   {
      Status("No such object");
      return;
   }
   rel->Add(src_obj,dst_obj);
   Status("Linked");
}

////////////////////////////////////////

void list_all_objs(int arg)
{
   int i, cnts[2]={0,0};

   AutoAppIPtr_(ObjectSystem,pObjSys);
   for (i=1; i<gMaxObjID; i++)
   {
      char src_str[64];
      sprintf(src_str,"%d",i);
      ObjID src_obj=EditGetObjNamed(src_str);
      if ((src_obj==OBJ_NULL)||!pObjSys->Exists(src_obj))
      {
         cnts[1]++;
      }
      else
      {
         cnts[0]++;
         if (arg>0)
            mprintf("%s\n",ObjEditName(i));
      }
   }
   mprintf("Total %d used, %d free (of %d total)\n",cnts[0],cnts[1],gMaxObjID);
}

////////////////////////////////////////

// helper for link_draw_on and link_draw_off: sanity checker/status printer
static BOOL check_link_for_drawing(char *link_name, char *operation)
{
   char status_string[120];
   BOOL rv = FALSE;

   // We'll change this if our link type exists.
   sprintf(status_string, "No link type %s.", link_name);

   ILinkManager *pLinkMan = AppGetObj(ILinkManager);
   const sRelationDesc* reldesc;
   sRelationIter iter;
   RelationID flavor;

   // Does the given link type exist?
   pLinkMan->IterStart(&iter);

   while (pLinkMan->IterNext(&iter, &flavor)) {
      IRelation* pRel = pLinkMan->GetRelation(flavor);
      if (pRel) {
         reldesc = pRel->Describe();
         if (strnicmp(link_name, reldesc->name, 31) == 0) {
            sprintf(status_string, "%s link type %s.", operation, link_name);
            rv = TRUE;
         }
      }
      SafeRelease(pRel);
   }

   pLinkMan->IterStop(&iter);
   SafeRelease(pLinkMan);

   Status(status_string);
   return rv;
}

////////////////////////////////////////

static uint link_get_color_from_config(char *link_name)
{
   char config_name[64];
   char config_data[64];
   uint r = 255, g = 255, b = 255;  // default color is white

   sprintf(config_name, "link_draw_%s", link_name);

   if (config_get_raw(config_name, config_data, 63))
      sscanf(config_data, "%d %d %d", &r, &g, &b);

   return (r << 16) + (g << 8) + b;
}

////////////////////////////////////////

static void link_draw_on(char *link_name)
{
   if (check_link_for_drawing(link_name, "drawing")) {
      uint rgb, r, g, b;
      rgb = link_get_color_from_config(link_name);

      r = rgb >> 16;
      g = (rgb >> 8) & 255;
      b = (rgb) & 255;

      AddDrawnRelation(link_name, r, g, b);
      redraw_all_cmd();
   }
}


// from linkdraw.cpp:
extern int g_nLinkDrawSourceId;
static void link_draw_from(int nFrom)
{
   g_nLinkDrawSourceId = nFrom;
}


extern int g_nLinkDrawSplitId;
static void link_draw_split(int nSplitId)
{
   g_nLinkDrawSplitId = nSplitId;
}



////////////////////////////////////////

static void link_draw_off(char *link_name)
{
   if (check_link_for_drawing(link_name, "not drawing")) {
      RemoveDrawnRelation(link_name);
      redraw_all_cmd();
   }
}

////////////////////////////////////////

//	Brings up the link dialog with the From and To fields filled in with the
//	objects in the current multibrush (To is the current selection)
//
static void link_edit_from_multibrush ()
{
    sLink link = { 0, 0, 0 };

    bool twoObjs = false;
    cnt=0;
    dst=vBrush_GetSel();
    if (brushGetType(dst)==brType_OBJECT)
    {
        vBrush_GroupOp(FALSE,getOurBrushes);
        if ((cnt==2)&&(brushGetType(src)==brType_OBJECT))
        {
            gedit_full_redraw();

            link.source = brObj_ID(src);
            link.dest = brObj_ID(dst);
            twoObjs = true;
        }
    }

	if (!twoObjs)
	{
		Status("Not two obj brushes");
		return;
	}

	//	Display the new link dialog, with the objects filled in
	//
	if (AskForLink (link))
	{
        AutoAppIPtr_(LinkManager,pLinkMan);
		pLinkMan = AppGetObj(ILinkManager);
		cAutoIPtr<IRelation> rel (pLinkMan->GetRelation(link.flavor));
		rel->Add(link.source, link.dest);
		Status("Linked");
	}

    //  Re-poll for keys to avoid 'stickyness'
    //
    g_pInputBinder->PollAllKeys();
}

////////////////////////////////////////

static char *chain_flavour;
static char chain_arg[63];
static void makeChainLink(editBrush *us)
{
    if (us!=src)
    {
        dst=us;
        sprintf (chain_arg, "%d %d %s", brObj_ID(src), brObj_ID(dst), chain_flavour);
        link_two_objs (chain_arg);
        src=us;
    }
}

//	Links together a chain of multibrushed objects
//
static void link_chain_from_multibrush (char *arg)
{
    chain_flavour = arg;
    src=vBrush_GetSel();

    vBrush_GroupOp(FALSE, makeChainLink);

    char drawString [31];
    sprintf (drawString, "link_draw_on %s", arg);
    CommandExecute (drawString);
    gedit_full_redraw();

	Status("Chain linked.");
}

////////////////////////////////////////

static void lock_brush (char *brush_name)
{
    ObjID brush;
    if (strcmp (brush_name, TERRAIN_STRING) == 0)
        brush = TERRAIN_ID;
    else
        brush = EditGetObjNamed(brush_name);

    if (brush != OBJ_NULL)
    {
        for (int i = 0; i < MAX_LOCKED_BRUSHES; i++)
        {
            if (gLockedBrushes[i] == 0)
            {
                gLockedBrushes[i] = brush;
                Status("Locked.");

                editBrush* cur = vBrush_GetSel();
                if (brushIsLocked (cur))
                    CommandExecute ("cycle_brush 1");
                return;
            }
        }
        Status("Too many locked brushes!");
    }
    else
    {
        Status("Can't find brush.");
    }
}

////////////////////////////////////////

static void unlock_brush (char *brush_name)
{
    ObjID brush;
    if (strcmp (brush_name, TERRAIN_STRING) == 0)
        brush = TERRAIN_ID;
    else
        brush = EditGetObjNamed(brush_name);

    if (brush != OBJ_NULL)
    {
        for (int i = 0; i < MAX_LOCKED_BRUSHES; i++)
        {
            if (gLockedBrushes[i] == brush)
            {
                gLockedBrushes[i] = 0;
                Status("Unlocked.");
                return;
            }
        }
        Status("Brush is not locked.");
    }
    else
    {
        Status("Can't find brush.");
    }
}

////////////////////////////////////////

static void unlock_all_brushes (void)
{
    memset (gLockedBrushes, 0, MAX_LOCKED_BRUSHES * sizeof(ObjID));
    Status("All brushes unlocked.");
}

//------------------------------------------------------------
// Struct desc for sObjBounds
//

static sFieldDesc obj_bounds_fields[] = 
{
   { "Min", kFieldTypeInt, FieldLocation(sObjBounds,min) },
   { "Max", kFieldTypeInt, FieldLocation(sObjBounds,max) },
}; 

static sStructDesc obj_bounds_sdesc = StructDescBuild(sObjBounds,0,obj_bounds_fields); 

////////////////////////////////////////

static void resize_obj_space()
{
   AutoAppIPtr(ObjIDManager); 
   sObjBounds bounds = pObjIDManager->GetObjIDBounds(); 

   AutoAppIPtr(EditTools); 
   HRESULT result = pEditTools->EditTypedData("Object ID Space Bounds","sObjBounds",&bounds); 

   if (result == S_OK)
   {
      result = pObjIDManager->ResizeObjIDSpace(bounds); 
      if (SUCCEEDED(result))
         Status("Object space resize successful"); 
      else
         Status("Object space resize failed."); 

   }
}


////////////////////////////////////////

static Command edit_mode_commands[] =
{
   { "edit_links", FUNC_STRING, edit_link_cmd,
     "edit_links [<src> [, <dest> [, <flavor>]]]", HK_EDITOR},
   { "link_show_all", VAR_BOOL, &show_all_links,
     "show links marked as hidden in the link editor" },
   { "hilight_obj_type", FUNC_STRING, hilight_descendents,
     "hilight all instances of an archetype, including descendants", HK_EDITOR},
   { "hilight_archetype", FUNC_STRING, hilight_archetype,
     "hilight all non-descendant instances of an archetype", HK_EDITOR},

   { "link_group", FUNC_STRING, vbrui_build_link, "a group of two objs get linked, select is dest, arg is relation" },
   { "link_objs", FUNC_STRING, link_two_objs, "link_objs src dst flavor" },

   // controlling which relations are drawn in editor
   { "link_draw_on", FUNC_STRING, link_draw_on,
     "show a kind of link in wireframe" },

   { "link_draw_from", FUNC_INT, link_draw_from,
     "Draw only links who's source is this" },

   { "link_draw_split", FUNC_INT, link_draw_split,
     "If link source has multple destinations, and this ID is among them, use that branch only." },

   { "link_draw_off", FUNC_STRING, link_draw_off,
     "don't show a kind of link in wireframe" },

   { "link_multi", FUNC_VOID, link_edit_from_multibrush,
     "adds a new link between two objs in a multibrush" },
   { "link_chain", FUNC_STRING, link_chain_from_multibrush,
     "adds a chain of links between objs in a multibrush" },
   { "lock", FUNC_STRING, lock_brush,
     "lock <brush type>: asks for confirmation whenever brush is changed" },
   { "unlock", FUNC_STRING, unlock_brush,
     "unlock <brush type>" },
   { "unlock_all", FUNC_VOID, unlock_all_brushes,
     "unlocks all brushes" },
   { "resize_obj_id_space", FUNC_VOID, resize_obj_space,
     "Change obj_min and obj_max on the fly." },

};

static Command all_mode_commands[] =
{
   { "list_obj", FUNC_INT, list_all_objs, "w/no arg, shows counts, w/args, lists all objs in id order" },
   { "obj_histogram_popup", FUNC_VOID, popup_obj_histogram, "Brings up obj list sorted by usage.", HK_EDITOR},
   { "obj_alpha_popup", FUNC_VOID, popup_obj_alpha, "Brings up obj list sorted alphabetically.", HK_EDITOR},
};


//------------------------------------------------------------
// Struct desc for ObjID
//

StructDescDefineSingleton(objedit_objid_sdesc, ObjID, kFieldTypeInt, 0);

//
// Add relations to object editor
//

static void create_rel_traits(void)
{
   AutoAppIPtr_(LinkManager,pLinkMan);
   AutoAppIPtr_(ObjEditors,pEdit);


   IEditTrait* trait;

   trait = CreateLinkEditTrait(RELID_WILDCARD,FALSE);
   pEdit->AddTrait(trait);
   SafeRelease(trait);

   trait = CreateLinkEditTrait(RELID_WILDCARD,TRUE);
   pEdit->AddTrait(trait);
   SafeRelease(trait);

}



////////////////////////////////////////////////////////////
// ObjEditInit
//

void ObjEditInit(void)
{
   COMMANDS(edit_mode_commands,HK_EDITOR);
   COMMANDS(all_mode_commands,HK_ALL);
   StructDescRegister(&objedit_objid_sdesc);
   StructDescRegister(&obj_bounds_sdesc); 
   create_rel_traits();
}

////////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/editor/linkdraw.h,v 1.4 2000/01/29 13:12:23 adurant Exp $
//
// Link-drawing system
//
#pragma once

#ifndef __LINKDRAW_H
#define __LINKDRAW_H

#include <objtype.h>
#include <linktype.h>

EXTERN void InitDrawnRelations();
EXTERN void TermDrawnRelations();
EXTERN void ResetDrawnRelations();

EXTERN void AddDrawnRelation(const char *name, ubyte r, ubyte g, ubyte b);
EXTERN void AddDrawnRelationID(RelationID relationID, ubyte r, ubyte g, ubyte b);
EXTERN void RemoveDrawnRelation(const char *name);
EXTERN void RemoveDrawnRelationID(RelationID relationID);

EXTERN void DrawRelations();
EXTERN BOOL ObjHasDrawnLinks(ObjID objID);

#endif // __LINKDRAW_H
// $Header: r:/t2repos/thief2/src/editor/linkedit.cpp,v 1.2 2000/02/19 13:10:57 toml Exp $
#include <wtypes.h>
#include <dynfunc.h>

#include <linkedit.h>
#include <linkedst.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


static void LGAPI linked_woe(const sLinkEditorDesc* , ObjID , ObjID , RelationID )
{
   CriticalMsg("Could not load dialog!");
}

DeclDynFunc_(void,LGAPI,DoLinkEditor,(const sLinkEditorDesc*,ObjID, ObjID ,RelationID));
ImplDynFunc(DoLinkEditor,"darkdlgs.dll","_DoLinkEditor@16",linked_woe);

#define LinkEditor    (DynFunc(DoLinkEditor).GetProcAddress())

void EditLinks(const sLinkEditorDesc* desc, ObjID src, ObjID dest, RelationID flav)
{
   LinkEditor(desc,src,dest,flav);
}

// $Header: r:/t2repos/thief2/src/editor/linkedit.h,v 1.2 1997/11/06 13:46:14 mahk Exp $
#pragma once  
#ifndef __LINKEDIT_H
#define __LINKEDIT_H

#include <objtype.h>
#include <linktype.h>

typedef struct sLinkEditorDesc sLinkEditorDesc;

// 
// Edit the links that match a pattern.
//

EXTERN void EditLinks(const sLinkEditorDesc* desc, ObjID src, ObjID dest, RelationID flavor); 

#endif // __LINKEDIT_H



#include <lnktrait.h>
#include <edtrait.h>
#include <edtraist.h>
#include <linkbase.h>
#include <linkman.h>
#include <relation.h>
#include <lnkquery.h>
#include <lazyagg.h>
#include <string.h>

#include <edittool.h>
#include <linkedit.h>
#include <linkedst.h>
#include <linkid.h>
#include <lnktrai_.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


////////////////////////////////////////////////////////////
//
// EDIT TRAIT FOR LINKS
//


//
// Link manager ptr
//

static LazyAggMember(ILinkManager) pLinkMan; 

//
// default descriptors 
//

static sEditTraitDesc def_descs[2] =
{
   // Normal
   {
      kRelationTrait,
      {
         "anylinks",
         "All Links",
         "Links", 
      },
   },
   // Hidden
   {
      kRelationTrait,
      {
         "hiddenlinks",
         "Hidden",
         "Links", 
      },
   }
};

//
// Implementation class
//



int cLinkEditTrait::LinkCount(ObjID obj)
{
   cAutoIPtr<ILinkQuery> pQuery (pLinkMan->Query(obj,LINKOBJ_WILDCARD,mID)); 
   int cnt = 0; 
   for (; !pQuery->Done(); pQuery->Next())
   {
      // special wildcard case 
      if (mID == RELID_WILDCARD)
      {
         // if invisible, only show invisible links.  Does this make sense? 
         BOOL invisible = (mDesc.flags & kTraitInvisible) != 0; 
         LinkID linkid = pQuery->ID(); 
         cAutoIPtr<IRelation> rel ( pLinkMan->GetRelation(LINKID_RELATION(linkid)) ); 
         BOOL no_edit = (rel->Describe()->flags & kRelationNoEdit) != 0; 
         if (invisible != no_edit)
            continue; 
      }

      cnt++; 
            
   }

   return cnt; 

}

void cLinkEditTrait::LinkDialog(ObjID obj)
{
   sLinkEditorDesc desc = {"", 0}; 
   if (mDesc.flags & kTraitInvisible)
      desc.flags |= kLinkEditShowAll; 
   EditLinks(&desc,obj,LINKOBJ_WILDCARD,mID); 
}


cLinkEditTrait::cLinkEditTrait(RelationID id, sEditTraitDesc* desc )
   : mID(id),
     mDesc(*desc),
     mCaps(gCaps)
{

   if (mID != LINKID_NULL)
      mCaps.flags |= kTraitCanAdd; 


}




STDMETHODIMP cLinkEditTrait::Unparse(ObjID obj, char* buf, int buflen)
{
   AutoAppIPtr_(EditTools,pTools); 

   // special "all" case

   if (mID == RELID_NULL)
   {
      sprintf(buf,"%d",LinkCount(obj));
      return S_OK; 
   }


   cAutoIPtr<ILinkQuery> pQuery (pLinkMan->Query(obj,LINKOBJ_WILDCARD,mID)); 
   char* prefix = ""; 
   buf[0] = '\0'; 

   for (; !pQuery->Done(); pQuery->Next())
   {
      int len;
      // append prefix
      len = strlen(prefix);
      if (len + 1 > buflen)
         goto too_long;
         
      strcpy(buf,prefix);
      buf += len; 
      buflen -= len; 

      // after the first time through, comma-delimit
      prefix = ", "; 
         
      // append object name
      sLink link;
      pQuery->Link(&link);
      const char* name = pTools->ObjName(link.dest); 
      len = strlen(name);
      if (len + 1 > buflen)
         goto too_long;
      strcpy(buf,name);
      buf += len;
      buflen -= len; 
   }
   return S_OK; 
         
too_long:
   if (buflen > 0)
   {
      strncpy(buf,"...",buflen); 
      buf[buflen-1] = '\0'; 
   }
   return S_OK; 

}

sEditTraitCaps cLinkEditTrait::gCaps = { kTraitCanEdit|kTraitCanUnparse};

//
// Factory
//

IEditTrait* CreateLinkEditTrait(RelationID id, BOOL hidden)
{
   sEditTraitDesc desc = def_descs[hidden != 0]; 

   cAutoIPtr<IRelation> rel = pLinkMan->GetRelation(id); 
   if (rel->GetID() != LINKID_NULL)
   {
      const sRelationDesc* reldesc = rel->Describe();

      // uniquify the name
      char uniquename[64];
      sprintf(uniquename,"L$%s",reldesc->name); 

      strncpy(desc.strings.name,uniquename,sizeof(desc.strings.name));
      desc.strings.name[sizeof(desc.strings.name)-1] = '\0'; 

      strncpy(desc.strings.friendly_name,reldesc->name,sizeof(desc.strings.friendly_name));
      desc.strings.friendly_name[sizeof(desc.strings.friendly_name)-1] = '\0'; 

      if (reldesc->flags & kRelationNoEdit)
         desc.flags |= kTraitInvisible;
   }

   if (hidden)
      desc.flags |= kTraitInvisible;


   return new cLinkEditTrait(id,&desc); 
}

// $Header: r:/t2repos/thief2/src/editor/lnktrait.h,v 1.1 1998/06/02 12:29:47 mahk Exp $
#pragma once  
#ifndef __LNKTRAIT_H
#define __LNKTRAIT_H

#include <comtools.h>
#include <linktype.h>

////////////////////////////////////////////////////////////
// LINK EDIT TRAITS
//
// Basically, adding links to the "property" editor
//

F_DECLARE_INTERFACE(IEditTrait); 

// can be LINKID_WILDCARD 
EXTERN IEditTrait* CreateLinkEditTrait(RelationID id, BOOL hidden); 


#endif // __LNKTRAIT_H
// $Header: r:/t2repos/thief2/src/editor/lnktrai_.h,v 1.1 1998/07/01 13:05:19 mahk Exp $
#pragma once  
#ifndef __LNKTRAI__H
#define __LNKTRAI__H

#include <comtools.h>
#include <edtrait.h>
#include <edtraist.h>
#include <linktype.h>

//
// Link trait impl class
//

class cLinkEditTrait : public cCTUnaggregated<IEditTrait,&IID_IEditTrait,kCTU_Default>
{

protected:
   // We use the ID instead of the IRelation so we can support wildcard
   RelationID mID;  
   sEditTraitDesc mDesc; 
   sEditTraitCaps mCaps; 

   static sEditTraitCaps gCaps;

   int LinkCount(ObjID obj);


   virtual void LinkDialog(ObjID obj);


public: 
   cLinkEditTrait(RelationID id, sEditTraitDesc* desc);



   STDMETHOD_(const sEditTraitDesc*,Describe)() 
   {
      return &mDesc; 
   }

   STDMETHOD_(const sEditTraitCaps*,Capabilities)()
   {
      return &mCaps; 
   }
   
   STDMETHOD_(BOOL,IntrinsicTo)(ObjID obj)
   {
      return LinkCount(obj) != 0; 
   }

   STDMETHOD(Add)(ObjID obj)
   {
      LinkDialog(obj);
      return S_OK; 
   }

   STDMETHOD(Remove)(ObjID )
   {
      return E_FAIL; 
   }

   STDMETHOD(Edit)(ObjID obj)
   {
      LinkDialog(obj); 
      return S_OK; 
   }

   STDMETHOD(Parse)(ObjID , const char* )
   {
      return E_FAIL; 
   }

   STDMETHOD(Unparse)(ObjID obj, char* buf, int buflen);


}; 

#endif // __LNKTRAI__H
// $Header: r:/t2repos/thief2/src/editor/medflbox.c,v 1.7 2000/02/19 13:10:59 toml Exp $

#include <mp.h>
#include <medflbox.h>
#include <2d.h>
#include <string.h>
#include <motion.h>
#include <motstruc.h>
#include <gadget.h>
#include <motedit_.h>
#include <medmenu.h>
#include <status.h>
#include <mvrflags.h>  // for start/end mot frame
#include <memall.h>
#include <dbmem.h>   // must be last header! 

EXTERN leftMark=0, rightMark=0;
static int num_slots=0;
EXTERN LGadBox *flag_box;

uint FlagBoxGetCurrentFlag()
{
   mps_motion_flag *place;
   int num_flags,i;

   if(g_MotEditMotionNum==MP_MOT_INVALID)
   {
      Warning(("no active main motion\n"));
      return 0;
   }
   place=mp_motion_list[g_MotEditMotionNum].flags;
   num_flags=mp_motion_list[g_MotEditMotionNum].num_flags;
   for(i=0;i<num_flags;i++)
   {
      if(place->frame>=g_CurMotEditFrame)
         break;
      place++;
   }
   if(i<num_flags&&place->frame==g_CurMotEditFrame) // frame already flagged
      return place->flags;
   else
      return 0;
}

static void shiftFlags(mps_motion_flag *dst, mps_motion_flag *src, int num)
{
   mps_motion_flag *tmp=Malloc(num*sizeof(*src));

   if(!tmp)
      return;

   memcpy(tmp,src,num*sizeof(*tmp));
   memcpy(dst,tmp,num*sizeof(*dst));

   Free(tmp);
}

bool FlagBoxAddFlag(ulong value)
{
   mps_motion_flag **mflag,*place;
   int *num_flags,offset;

   if(g_MotEditMotionNum==MP_MOT_INVALID)
   {
      Warning(("no active main motion\n"));
      return FALSE;
   }
   mflag=&mp_motion_list[g_MotEditMotionNum].flags;
   num_flags=&mp_motion_list[g_MotEditMotionNum].num_flags;
   place=*mflag;
   for(offset=0;offset<*num_flags;offset++,place++)
   {
      if(place->frame>=g_CurMotEditFrame)
         break;
   }
   if(offset<*num_flags&&place->frame==g_CurMotEditFrame) // frame already flagged
   {
      if(value)  // just change value
         place->flags=value;
      else           // must remove flag
      {
         (*num_flags)--;
         if(*num_flags)
         {
            shiftFlags(place,place+1,*num_flags-offset);
            *mflag=Realloc(*mflag,(*num_flags)*sizeof(mps_motion_flag));
         }
         else
         {
            mp_free((*mflag));
            *mflag=NULL;
         }
      }
   } else if(value) // add flag
   {
      (*num_flags)++;
      if(*mflag)
      {
         *mflag=Realloc(*mflag,(*num_flags)*sizeof(mps_motion_flag));
         if(offset<*num_flags-1)
         {
            shiftFlags((*mflag)+offset+1,(*mflag)+offset,*num_flags-offset-1);
         }
      } else
      {
         *mflag=mp_alloc((*num_flags)*sizeof(mps_motion_flag),__FILE__,__LINE__);
      }
      (*mflag)[offset].flags=value;
      (*mflag)[offset].frame=g_CurMotEditFrame;
   }
   if(value&MF_START_MOT)
   {
      FlagBoxSetMark(g_CurMotEditFrame,0);
   }
   if(value&MF_END_MOT)
   {
      FlagBoxSetMark(g_CurMotEditFrame,1);
   }
   LGadDrawBox(flag_box,NULL);
   return TRUE;
}

// assumes that grd_canvas is box gadget screen region.
void FlagBoxDrawCallback(void *data, LGadBox *vb)
{
   float slot_w;
   mps_motion_flag *mflag;
   int i;
   int bdepth=(grd_bpp>16)?16:grd_bpp;
   int scale=(0x1<<bdepth)/256;

   gr_clear(3);
   slot_w=((float)grd_bm.w)/num_slots;
   // draw marks (box between left and right
   if(bdepth==8)
      gr_set_fcolor(255);
   else
      gr_set_fcolor(0);
   gr_rect((ushort)(slot_w*leftMark),0,(ushort)(slot_w*(rightMark+1)),grd_bm.h);

   // draw flags
   if(g_MotEditMotionNum==MP_MOT_INVALID)
      return;
   mflag=mp_motion_list[g_MotEditMotionNum].flags;
   for(i=0;i<mp_motion_list[g_MotEditMotionNum].num_flags;i++,mflag++)
   {
      ushort l,r;

      if(bdepth==8)
      {
         gr_set_fcolor((mflag->flags)%256);
      } else
      {
         ulong base_col=(0x1<<3)|(0x1<<9)|(0x1<<13);
         gr_set_fcolor(base_col+(scale/2)*((mflag->flags)%256));
      }
      l=slot_w*mflag->frame+1;
      r=(slot_w*(mflag->frame+1)-1);
      if(r<=l+4)
         r=l+4;
      gr_rect(l,2,r,grd_bm.h-2);
   }
}

void FlagBoxResetMarks(int num_frames)
{
   if(num_frames>0)
      num_slots=num_frames;
   leftMark=0;
   rightMark=num_slots-1;
}

void FlagBoxSetMark(int frame,uchar side)
{
   char spew[60];
   char which[8];

   if(side==0)
   {
      leftMark=frame;
      sprintf(which,"start");
   } else
   {
      rightMark=frame;
      sprintf(which,"end");
   }
   sprintf(spew,"%s frame is %d",which,frame);
   Status(spew);

   if(leftMark>rightMark)
   {
      if(side==0)
         rightMark=num_slots-1;
      else
         leftMark=0;
   }
}   
// $Header: r:/t2repos/thief2/src/editor/medflbox.h,v 1.3 2000/01/29 13:12:24 adurant Exp $
#pragma once

#ifndef __MEDFLBOX_H
#define __MEDFLBOX_H

#include <gadbox.h>

EXTERN uint edit_flag;

EXTERN uint FlagBoxGetCurrentFlag();
EXTERN void FlagBoxDrawCallback(void *data, LGadBox *vb);
EXTERN void FlagBoxSetMark(int frame,uchar side);
EXTERN void FlagBoxResetMarks(int num_frames);
EXTERN bool FlagBoxAddFlag(ulong value);

#endif
// This module deals with how the major menus are layed out

#include <mediface.h>
#include <gadget.h>
#include <lgslider.h>
#include <util2d.h>
#include <gcompose.h>
#include <guistyle.h>
#include <event.h>
#include <motedit_.h>
#include <medflbox.h>
#include <medmenu.h>

#include <vumanui.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

LGadRoot *main_root;
LGadBox *main_box;

// XXX todo:  currently task exception in mouse render when switch from hires
// to lowres mode.

// The basic interface

// these bring up the major menus, and are the play button and slider
//LGadScale control_slider;
LGadSlider control_slider;
BOOL control_slider_active = FALSE;
LGadBox *flag_box;

typedef int (*ControlFunc)(void);

typedef struct {
   DrawElement draw;
   Point size;
   Point coord;
   LGadButtonCallback bfunc;
} ControlInfo;

#define STANDARD_MOTEDIT_FLAGS BORDER(DRAWFLAG_BORDER_OUTLINE)

ControlInfo control_info[] = { \
   { { DRAWTYPE_TEXT, (void *)"SAVE/LOAD",NULL,0,0,STANDARD_MOTEDIT_FLAGS }, {106, MOTEDIT_BUTTON_HEIGHT}, {0, 0}, SaveLoadButtonFunc },
   { { DRAWTYPE_TEXT, (void *)"PLAY OPTIONS",NULL,0,0,STANDARD_MOTEDIT_FLAGS }, {106, MOTEDIT_BUTTON_HEIGHT}, {106, 0}, PlayOptButtonFunc },
   { { DRAWTYPE_TEXT, (void *)"FRAME",NULL,0,0,STANDARD_MOTEDIT_FLAGS }, {106, MOTEDIT_BUTTON_HEIGHT}, {318, 0}, FrameButtonFunc },
   { { DRAWTYPE_TEXT, (void *)"HEADER",NULL,0,0,STANDARD_MOTEDIT_FLAGS }, {106, MOTEDIT_BUTTON_HEIGHT}, {530, 0}, HeaderButtonFunc },
};

ControlInfo play_button_control_info = { \
   { DRAWTYPE_TEXT, (void *)"PLAY",NULL,0,0,STANDARD_MOTEDIT_FLAGS },\
   {80, MOTEDIT_BUTTON_HEIGHT}, {0, 140}, PlayButtonFunc };

#define NUM_CONTROL_BUTTONS ((sizeof(control_info)/sizeof(control_info[0]))+1)

LGadButton *control_buttons[NUM_CONTROL_BUTTONS];

extern void LGadInitSlider(LGadSlider *vs);

bool MainMouseHandler(short x, short y, short action, short wheel, LGadBox *vb)
{
   if (!(action & (MOUSE_LUP|MOUSE_RUP)))
      return(TRUE);

   return(TRUE);
}

int minor_mode=-1;

typedef struct {
   grs_bitmap gui_bm;
   uchar *gui_bits;
} GuiInfo;
 
DrawElement control_slider_elem={DRAWTYPE_NONE,NULL,NULL,0,0,STANDARD_MOTEDIT_FLAGS};

void MainInterfaceResetBotSlider(int num_frames)
{
   Rect r;

   // store off dimensions of old slider, since want to reuse these
   r=*(BOX_RECT((LGadBox *)(&control_slider)));

   LGadDestroyBox((LGadBox *)&control_slider,FALSE);
   control_slider_active = FALSE;
   g_CurMotEditFrame=0;
   g_LastMotEditFrame=0;

#if 0
   LGadCreateScaleArgs(&control_slider,main_root,80,460,560,20,\
      &control_slider_elem,NULL,&g_CurMotEditFrame,num_frames,1,255,26,(560/num_frames)-1,20,1,SCALE_NORMAL,0,0);
#endif
   if (num_frames>1)
   {
      LGadInitSlider(&control_slider);
      LGadCreateSliderArgs(&control_slider,main_root,r.ul.x,r.ul.y,r.lr.x-r.ul.x,r.lr.y-r.ul.y,
                           &control_slider_elem,NULL,
                           &g_CurMotEditFrame,num_frames-1,1,r.lr.x-r.ul.x,LGSLIDER_HORIZONTAL,0);
      LGadDrawBox(VB(&control_slider),NULL);
      control_slider_active = TRUE;
   }    
}


void MainInterfaceRefreshFlagBox()
{
   LGadDrawBox(flag_box,NULL);
}

void CreateMotionEditorInterface()
{
   int i; // iterator
   int w,h,bot,right;
   Rect *r;

   main_root=vmGrabViews(vmGrabTwoWide);
   
   main_box=VB(main_root);
   r=LGadBoxRect(main_box);
   w=(r->lr.x-r->ul.x)/(NUM_CONTROL_BUTTONS-1);
   h=MOTEDIT_BUTTON_HEIGHT;
   bot=r->lr.y-r->ul.y;
   right=r->lr.x-r->ul.x;

   // top menu buttons
   for (i=0; i < NUM_CONTROL_BUTTONS-1; i++)
   {
      control_info[i].draw.fcolor=guiStyleGetColor(NULL,StyleColorText);
      control_buttons[i]=LGadCreateButtonArgs(NULL,main_root,\
         w*i, 0, w, h,\
         &((control_info[i]).draw),control_info[i].bfunc,0);
   }
   // play button
   play_button_control_info.draw.fcolor=guiStyleGetColor(NULL,StyleColorText);
   control_buttons[i]=LGadCreateButtonArgs(NULL,main_root,\
      0, bot-h, w, h,\
      &(play_button_control_info.draw),play_button_control_info.bfunc,0);

   // motion slider
   LGadInitSlider(&control_slider);
   control_slider_elem.fcolor=guiStyleGetColor(NULL,StyleColorText);
   control_slider_elem.bcolor=guiStyleGetColor(NULL,StyleColorDim);
   LGadCreateSliderArgs(&control_slider,main_root,w,bot-(h/2),right-w,h/2,&control_slider_elem,NULL,\
      &g_CurMotEditFrame,100,1,right-w,LGSLIDER_HORIZONTAL,0);
   control_slider_active = TRUE;
   // mark/flag view box
   flag_box=LGadCreateBox(NULL,main_root,w,bot-h,right-w,h/2,MainMouseHandler,NULL,FlagBoxDrawCallback,0);
   FlagBoxResetMarks(100);
   LGadDrawBox(main_box,NULL);
}

void DestroyMotionEditorInterface()
{
   int i; // iterator

   for (i=0; i < NUM_CONTROL_BUTTONS; i++)
   {
      LGadDestroyBox((LGadBox *)control_buttons[i],TRUE);
   }
   if (control_slider_active)
      LGadDestroyBox((LGadBox *)&control_slider,FALSE);
   LGadDestroyBox((LGadBox *)flag_box,TRUE);
   DestroyActiveMenus();

   vmReleaseViews(main_root);
}

void MainInterfaceReset()
{
   DestroyMotionEditorInterface();
   CreateMotionEditorInterface();
}

// $Header: r:/t2repos/thief2/src/editor/mediface.h,v 1.3 2000/01/29 13:12:27 adurant Exp $
#pragma once

#ifndef __MEDIFACE_H
#define __MEDIFACE_H

#include <gadget.h>

EXTERN LGadRoot *main_root;

#define MOTEDIT_BUTTON_HEIGHT 40

EXTERN void CreateMotionEditorInterface();
EXTERN void DestroyMotionEditorInterface();

EXTERN void MainInterfaceResetBotSlider(int num_frames);
EXTERN void MainInterfaceRefreshFlagBox();
EXTERN void MainInterfaceReset();

#endif
// $Header: r:/t2repos/thief2/src/editor/medmenu.cpp,v 1.7 2000/02/19 13:11:01 toml Exp $

// menu stuff for saving and loading.

#include <gadget.h>
#include <config.h>
#include <medmenu.h>
#include <motedit_.h>
#include <medplay.h>
#include <gedit.h>
#include <viewmgr.h>
#include <status.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>

#include <prompts.h>

#define EDITMODE_NONE      -1
#define EDITMODE_SAVELOAD  0
#define EDITMODE_PLAYOPT   1
#define EDITMODE_FRAME     2
#define EDITMODE_HEADER    3
#define EDITMODE_PLAY      4

// active menu stuff, for menus inside rendering area
#define MAX_ACTIVE_MENUS 4
LGadBox *activeMenus[MAX_ACTIVE_MENUS];
int numActiveMenus=0;


int current_edit_mode = EDITMODE_NONE;

LGadMenu saveloadmenu_gad;
LGadEditMenu playoptmenu_gad;
LGadMenu headermenu_gad;
LGadMenu framemenu_gad;

bool EditorEraseMinorMode(int new_mode)
{
   if (current_edit_mode == new_mode)
      return(FALSE);
   numActiveMenus=0;

   if(current_edit_mode==EDITMODE_PLAY) // stop playing motion
   {
      PlayMotionStop();
   }
   current_edit_mode = new_mode;

   return(TRUE);
}

// ******* SAVE LOAD *******

LGadEditMenu loadname_menu;
LGadEditMenu saveas_menu;

DrawElement saveloadmenu_elems[] = {
   { DRAWTYPE_TEXT, "Load Name", }, 
   { DRAWTYPE_TEXT, "Save ", },
   { DRAWTYPE_TEXT, "Quit MotEditor", },
   { DRAWTYPE_TEXT, "Done", },
};

//extern Id mainMotionID,mainCompMotionID;
extern char mainMotionName[], mainCompMotionName[];

#pragma off(unreferenced)
bool SaveLoadMenuFunc(int sel, LGadMenu *vm)
{
   switch(sel)
   {
   case 0:
      char buf[32], *res;
      res=prompt_string(g_MotEditMotionName,buf);
      if (res)
         MotEditSetEditMotion(res);
      break;
   case 1:
      MotEditFinishMotionEdit();
      break;
   case 2:
      MotEditClose();
      break;
   case 3:
      EditorEraseMinorMode(EDITMODE_NONE);
      return TRUE;
   }
   return FALSE;
}
#pragma on(unreferenced)


#pragma off(unreferenced)
bool SaveLoadButtonFunc(short action,void *data, LGadBox *b)
{
   if(!(action&MOUSE_LUP))
      return FALSE;

   if (!EditorEraseMinorMode(EDITMODE_SAVELOAD))
      return(TRUE);
   LGadCreateMenuArgs(&saveloadmenu_gad, main_root, STANDARD_ME_MENU_MARGIN, MOTEDIT_BUTTON_HEIGHT+STANDARD_ME_MENU_MARGIN, -2, -2, 
      sizeof(saveloadmenu_elems)/sizeof(DrawElement), 0, saveloadmenu_elems, SaveLoadMenuFunc,
      NULL, STANDARD_ME_MENU_FLAGS, STANDARD_ME_MENU_BORDER, NULL, 0);
   ActiveMenuAdd(VB(&saveloadmenu_gad));
   return(0);
}
#pragma on(unreferenced)


// ******* PLAY OPTIONS *******

char *playopt_loop_names[] = { "PLAY ONCE","PLAY LOOP" };
//char *playopt_which_names[] = { "MAIN ONLY", "WITH ALL MOTIONS" };
char *playopt_blend_names[] = { "NO BLENDING", "WITH BLENDING" };
char *playopt_freq_names[] = { "TIME BASED", "FRAME BASED" };

#define NUM_STRINGS(name) (sizeof(name)/sizeof(name[0]))

#define EnumStuff(name) kFieldFlagUnsigned, 0, NUM_STRINGS(name), NUM_STRINGS(name), name,

static sFieldDesc playOptions_fields[] =
{
   { "Trans Millisec", kFieldTypeFloat, FieldLocation(PlayOptions,trans_duration), },
   { "", kFieldTypeEnum, FieldLocation(PlayOptions,loop), EnumStuff(playopt_loop_names) },
   { "", kFieldTypeEnum, FieldLocation(PlayOptions,blend), EnumStuff(playopt_blend_names) },
   { "", kFieldTypeEnum, FieldLocation(PlayOptions,frame_based), EnumStuff(playopt_freq_names) },
   { "Timewarp", kFieldTypeFloat, FieldLocation(PlayOptions,timewarp), },
   { "Stretch", kFieldTypeFloat, FieldLocation(PlayOptions,stretch), },
};

static sStructDesc playOptions_desc = StructDescBuild(PlayOptions,kStructFlagNone,playOptions_fields);

#pragma off(unreferenced)
bool PlayOptButtonFunc(short action,void *data, LGadBox *b)
{
   if(!(action&MOUSE_LUP))
      return FALSE;

   if (!EditorEraseMinorMode(EDITMODE_PLAYOPT))
      return(TRUE);

   sStructEditorDesc editdesc =
   {
      "Play Options",
   };

   IStructEditor *ed = CreateStructEditor(&editdesc,&playOptions_desc,&playOptions);

   if(ed->Go(kStructEdModal))
   {
      PlayOptApply();
      EditorEraseMinorMode(EDITMODE_NONE);
   }
   SafeRelease(ed);

   return(0);
}
#pragma on(unreferenced)


// ******** Header Menus ***********

#include <motstruc.h>
#include <string.h>

mps_motion_info edit_motinfo;

LGadEditMenu headbasic_menu;

DrawElement headermenu_elems[] = {
   { DRAWTYPE_TEXT, "Basic Info" }, 
   { DRAWTYPE_TEXT, "Done"},
};

DrawElement headbasic_elems[] = {
   { DRAWTYPE_TEXT, "Name", 0, 0, 0, FORMAT(DRAWFLAG_FORMAT_LEFT) },
   { DRAWTYPE_TEXT, "Num Frames", 0, 0, 0, FORMAT(DRAWFLAG_FORMAT_LEFT) },
   { DRAWTYPE_TEXT, "Capture Frequency", 0, 0, 0, FORMAT(DRAWFLAG_FORMAT_LEFT) },
   { DRAWTYPE_TEXT, "Done", 0, 0, 0, FORMAT(DRAWFLAG_FORMAT_LEFT) },
};

DrawElement headbasic_title = { DRAWTYPE_TEXT, "Basic Motion Header", 0, 1 };

VarElem headbasic_varelems[] = {
   { (void *)(edit_motinfo.name), EDITTYPE_STRING, EDITFLAG_READONLY },
   { (void *)&(edit_motinfo.num_frames), EDITTYPE_FLOAT, EDITFLAG_READONLY },
   { (void *)&(edit_motinfo.freq), EDITTYPE_INT, EDITFLAG_READONLY },
   { (void *)ActiveMenuKill, EDITTYPE_CANCEL, },
};

// XXX to do.  Get menu "close" selection to work for header descriptor menu
// needs to copy back the motappdata array.
#pragma off(unreferenced)
bool HeaderMenuFunc(int sel, LGadMenu *vm)
{
   switch(sel)
   {
   case 0:
      if(g_MotEditMotionNum==MP_MOT_INVALID)
      {
         Warning(("No motion loaded\n"));
         break;
      }
//      memcpy(&edit_motinfo,&(mp_motion_list[g_MotEditMotionNum].info),sizeof(mps_motion_info));
      StandardEditMenu(headbasic_menu, -2, 0, headbasic_elems, &headbasic_title, headbasic_varelems);
      break;
   case 1:
      EditorEraseMinorMode(EDITMODE_NONE);
      return TRUE;
   }
   return FALSE;
}
#pragma on(unreferenced)

#pragma off(unreferenced)
bool HeaderButtonFunc(short action,void *data, LGadBox *b)
{
   if(!(action&MOUSE_LUP))
      return FALSE;

   if(!g_MotEditMotion)
   {
      Status("no motion loaded");
      return TRUE;
   }
   if (!EditorEraseMinorMode(EDITMODE_HEADER))
      return(TRUE);
   memcpy(&edit_motinfo,&g_MotEditMotion->info,sizeof(edit_motinfo));
   LGadCreateMenuArgs(&headermenu_gad, main_root, STANDARD_ME_MENU_MARGIN, MOTEDIT_BUTTON_HEIGHT+STANDARD_ME_MENU_MARGIN, -2, -2, 
      sizeof(headermenu_elems)/sizeof(DrawElement), 0, headermenu_elems, HeaderMenuFunc,
      NULL, STANDARD_ME_MENU_FLAGS, STANDARD_ME_MENU_BORDER, NULL, 0);
   ActiveMenuAdd(VB(&headermenu_gad));
   return FALSE;
}
#pragma on(unreferenced)

// ******************* FRAME MENU **************

#include <medflbox.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

EXTERN LGadBox *flag_box;
LGadEditMenu flag_menu;

DrawElement framemenu_elems[] = {
   { DRAWTYPE_TEXT, "Set Flag" }, 
   { DRAWTYPE_TEXT, "Mark Left" }, 
   { DRAWTYPE_TEXT, "Mark Right" }, 
   { DRAWTYPE_TEXT, "Clear Marks" }, 
   { DRAWTYPE_TEXT, "Done"},
};

#pragma off(unreferenced)
bool FrameMenuFunc(int sel, LGadMenu *vm)
{
   switch(sel)
   {
   case 0:
   {
      sStructEditorDesc editdesc =
      {
         "Set Flag",
      };

      // set up initial values
      sFlagValue flagValue;
      flagValue.value=FlagBoxGetCurrentFlag();

      IStructEditor *ed = CreateStructEditor(&editdesc,&frame_flag_desc,&flagValue);

      if(ed->Go(kStructEdModal))
      {
         FlagBoxAddFlag(flagValue.value);
      }
      SafeRelease(ed);

      break;
   }
   case 1:
      FlagBoxSetMark(g_CurMotEditFrame,0);
      LGadDrawBox(flag_box,NULL);
      break;
   case 2:
      FlagBoxSetMark(g_CurMotEditFrame,1);
      LGadDrawBox(flag_box,NULL);
      break;
   case 3:
      FlagBoxResetMarks(-1);
      LGadDrawBox(flag_box,NULL);
      break;
   case 4:
      EditorEraseMinorMode(EDITMODE_NONE);
      return TRUE;
   }
   return FALSE;
}
#pragma on(unreferenced)

#pragma off(unreferenced)
bool FrameButtonFunc(short action,void *data, LGadBox *b)
{
   if(!(action&MOUSE_LUP))
      return FALSE;

   if (!EditorEraseMinorMode(EDITMODE_FRAME))
      return(TRUE);

   LGadCreateMenuArgs(&framemenu_gad, main_root, STANDARD_ME_MENU_MARGIN, \
      MOTEDIT_BUTTON_HEIGHT+STANDARD_ME_MENU_MARGIN, -2, -2, \
      sizeof(framemenu_elems)/sizeof(DrawElement), 0, framemenu_elems, FrameMenuFunc, \
      NULL, STANDARD_ME_MENU_FLAGS, STANDARD_ME_MENU_BORDER, NULL, 0);
   ActiveMenuAdd(VB(&framemenu_gad));
   return(0);
}
#pragma on(unreferenced)

// ********* PLAY BUTTON ******

#pragma off(unreferenced)
bool PlayButtonFunc(short action,void *data, LGadBox *b)
{
   if(!(action&MOUSE_LUP))
      return FALSE;

   if(current_edit_mode==EDITMODE_PLAY)
   {
      PlayMotionStop();
      if(!EditorEraseMinorMode(EDITMODE_NONE))
         return(TRUE);
      return FALSE;
   }
   if (!EditorEraseMinorMode(EDITMODE_PLAY))
      return(TRUE);
   PlayMotionStart();
   return(FALSE);
}
#pragma on(unreferenced)

// ************ FRAME SLIDER **********************

// returns TRUE if slider value changed
BOOL FrameSliderUpdate()
{
   if(g_LastMotEditFrame!=g_CurMotEditFrame)
   {
      char spew[20];

      sprintf(spew,"%d\n",g_CurMotEditFrame);
      Status(spew);
      g_LastMotEditFrame=g_CurMotEditFrame;

      if(current_edit_mode!=EDITMODE_FRAME) // too annoying to have this go away
         EditorEraseMinorMode(EDITMODE_NONE);

      return TRUE;
   }
   return FALSE;
}

// ****** DRAWING STUFF FOR MENUS THAT APPEAR OVER RENDERING AREA ******

void ActiveMenuAdd(LGadBox *b)
{
   if(numActiveMenus>MAX_ACTIVE_MENUS-1)
   {
      Warning(("ActiveMenuAdd: too many active menus!\n"));
      return;
   }
   activeMenus[numActiveMenus]=b;
   numActiveMenus++;
}

#pragma off(unreferenced)
bool ActiveMenuKill(short action, void *data, LGadBox *b)
{
   int i,j;

   for(i=0;i<numActiveMenus;i++)
   {
      if(b==activeMenus[i])
         break;
   }
   if(i==numActiveMenus)
      return FALSE;
   for(j=i;j<numActiveMenus-1;j++)
   {
      activeMenus[j]=activeMenus[j+1];
   }
   activeMenus[j]=NULL;
   numActiveMenus--;
   return TRUE;
}
#pragma on(unreferenced)

// this is bad because voyGuiMethods render to screen canvas, and these
// should really render to render canvas.  Should probably make GUI methods
// work off of current canvas or something, but then how to interpret x,y
// values if current canvas is a subcanvas?
// HACK: for now, ActiveMenusDraw is called after render canvas has been blitted.
// since GDI reblits anyway, we only get flickering in direct draw mode.  Should
// fix this for real, though.
void DestroyActiveMenus()
{
   int i;

   for(i=0;i<numActiveMenus;i++)
   {
      LGadDestroyBox(activeMenus[i],FALSE);
      activeMenus[i]=NULL;
   }
   numActiveMenus=0;
   EditorEraseMinorMode(EDITMODE_NONE);
}

// $Header: r:/t2repos/thief2/src/editor/medmenu.h,v 1.3 2000/01/29 13:12:30 adurant Exp $
#pragma once

#ifndef __MEDMENU_H
#define __MEDMENU_H

#include <sdesbase.h>
#include <mediface.h>
#include <motion.h>

#define STANDARD_ME_MENU_BORDER BORDER(DRAWFLAG_BORDER_OUTLINE)
#define STANDARD_ME_MENU_FLAGS (MENU_GRAB_FOCUS|MENU_OUTER_DISMISS)

#define STANDARD_ME_MENU_MARGIN 2

struct sFlagValue
{
   ulong value;
};

EXTERN sStructDesc frame_flag_desc;

// Easy macro for standardized menus
#define StandardEditMenu(m,w,h,el,tit,varel) \
   LGadCreateEditMenuArgs(&(m),main_root,STANDARD_ME_MENU_MARGIN+200,MOTEDIT_BUTTON_HEIGHT+STANDARD_ME_MENU_MARGIN,(w),(h), sizeof((el))/sizeof(DrawElement), 0, (el), \
       STANDARD_ME_MENU_FLAGS, STANDARD_ME_MENU_BORDER, (tit), (varel), 0); \
   ActiveMenuAdd(VB(&m));

EXTERN void ActiveMenuAdd(LGadBox *b);
EXTERN bool ActiveMenuKill(short action, void *data, LGadBox *b);

EXTERN BOOL FrameSliderUpdate(); // returns TRUE if slider value changed

EXTERN bool SaveLoadButtonFunc(short action,void *data, LGadBox *b);
EXTERN bool PlayOptButtonFunc(short action,void *data, LGadBox *b);
EXTERN bool FrameButtonFunc(short action,void *data, LGadBox *b);
EXTERN bool HeaderButtonFunc(short action,void *data, LGadBox *b);
EXTERN bool PlayButtonFunc(short action,void *data, LGadBox *b);
EXTERN bool TransformButtonFunc(short action,void *data, LGadBox *b);

EXTERN void DestroyActiveMenus();

#endif
// $Header: r:/t2repos/thief2/src/editor/medplay.cpp,v 1.8 2000/02/19 13:11:04 toml Exp $
// XXX @TODO: either get rid of cur_role stuff, or make it work

#include <medplay.h>
#include <motedit_.h>
#include <medmenu.h>
#include <config.h>
#include <string.h>
#include <motion.h>
#include <multiped.h>
#include <motstruc.h>
#include <status.h>
#include <motdmnge.h>
#include <mvrutils.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

PlayOptions playOptions;

mps_motion_param playParams = {MP_BEND|MP_STRETCH|MP_VSTRETCH|MP_DURATION_SCALE, 0, 0, 1, 1};

// this will need to check various play
// option stuff, and selected regions 


int cur_role=MROLE_MAIN;
static bool stopMotion=FALSE;

void PlayOptApply()
{
   if(playOptions.which_motions==PLAY_ALL_MOTIONS)
   {
      cur_role=MROLE_MAIN;
   } else
   {
      cur_role=MROLE_MAIN;
   }
}

void PlayOptInit()
{
   memset(&playOptions,0,sizeof(playOptions));

   if(config_is_defined("TRANS_OFFSET"))
   {
      int num=1;
      config_get_value("TRANS_OFFSET",CONFIG_INT_TYPE,&playOptions.trans_offset,&num);
   }
   if(config_is_defined("TRANS_DURATION"))
   {
      int num=1,val;
      config_get_value("TRANS_DURATION",CONFIG_INT_TYPE,&val,&num);
      playOptions.trans_duration=(float)val;
   }
   if(config_is_defined("PLAY_LOOP"))
      playOptions.loop=PLAY_LOOP;
   if(config_is_defined("PLAY_ALL_MOTIONS"))
      playOptions.which_motions=PLAY_ALL_MOTIONS;
   if(config_is_defined("PLAY_NORMAL_BLEND"))
      playOptions.blend=PLAY_NORMAL_BLEND;
   if(config_is_defined("PLAY_FRAME_BASED"))
      playOptions.frame_based=PLAY_FRAME_BASED;

   playOptions.timewarp=1.0;
   playOptions.stretch=1.0;

   PlayOptApply();
}

#define SIM_FRAME_RESOLUTION 400

void PlayMotionUpdate(float dt)
{
   int i;
   int freq;
   multiped *targ;
   int flags=0;

   if(NULL==(targ=MotEditGetMultiped()))
   {
      return;
   }

   if(stopMotion)
   {
      PlayButtonFunc(MOUSE_LUP,NULL,NULL);
      stopMotion=FALSE;
      return;
   }
#if 0
   if(cur_role<0)
      return;
#endif
   if(g_MotEditMotionNum<0)
      return;

   if(!motionIsPlaying)
      return;
   if(playOptions.frame_based) // one motion frame per render frame
   {
      freq=mp_motion_list[g_MotEditMotionNum].info.freq;
      flags=mp_update(targ,1000/freq,NULL);
   } else // Frame-rate independent
   {
      for(i=SIM_FRAME_RESOLUTION;i<dt;i+=SIM_FRAME_RESOLUTION)
      {
         flags|=mp_update(targ,SIM_FRAME_RESOLUTION,NULL);
      }
      flags|=mp_update(targ,dt-(i-SIM_FRAME_RESOLUTION),NULL);
   }
   if(flags)
      MvrProcessStandardFlags(MotEditGetMotor(),NULL,flags);
}

#pragma off(unreferenced)
int PlayEnd(multiped *m,int motion_number,int frame, float time_slop, ulong flags)
{
   if(playOptions.which_motions==PLAY_ALL_MOTIONS)
   {
      cur_role=(cur_role+1)%NUM_MOTION_ROLES;
      if(playOptions.loop==PLAY_STRAIGHT)
      {
         if(!cur_role)
            cur_role=-1;
      } 
   } else {
      if (playOptions.loop==PLAY_LOOP)
         cur_role=MROLE_MAIN;
      else
         cur_role=-1;
   }
   if(0==(flags&MP_CFLAG_MOT_ABORTED)) // motion ended naturally
   {
      if(playOptions.loop==PLAY_LOOP)
         PlayMotionStart();
      else
         stopMotion=TRUE;
   }
   return 1;
}
#pragma on(unreferenced)

void PlayMotionStop()
{
   multiped *targ;

   if(!motionIsPlaying)
      return;

   motionIsPlaying=FALSE;
   if(NULL!=(targ=MotEditGetMultiped()))
   {
      mp_stop_all_motions(targ);
      mp_update(targ,0,NULL);
   }
   PlayOptApply();
   Status(""); // clear out "motion playing" spew
}

EXTERN int leftMark, rightMark;

// XXX TO DO: scale for size
BOOL PlayMotionStart()
{
   mps_start_info info;
   multiped *targ;

   // change target if necessary
   MotEditSetEditObj();

   if(g_MotEditMotionNum<0)
   {
      PlayButtonFunc(MOUSE_LUP,NULL,NULL);
      Status("no motion loaded to play");
      // XXX TO DO: warn that no motion loaded
      return FALSE;
   }
   if(NULL==(targ=MotEditGetMultiped()))
   {
      PlayButtonFunc(MOUSE_LUP,NULL,NULL);
      Status("no multiped selected");
      return FALSE;
   }

   motionIsPlaying=TRUE;

   info.motion_num=g_MotEditMotionNum;
   info.start_frame=leftMark;
   info.callback_frame=rightMark;
   info.callback=PlayEnd;
   info.params=&playParams;
   info.params->duration_scalar=playOptions.timewarp;
   info.params->stretch=playOptions.stretch;
   if(playOptions.blend)
      info.trans_duration=playOptions.trans_duration;
   else
      info.trans_duration=0;
   mp_start_motion(targ,&info);

   // @TODO: start virtual motion if editmotion is an overlay.

   if(g_MotEditMotionName)
   {
      char spew[40];

      sprintf(spew,"Playing motion %s",g_MotEditMotionName);
      Status(spew);
   } else
   {
      Status("Playing nameless motion");
   }

   return TRUE;
}

void PlayMotionPoseAtFrame(int frame)
{
   mps_motion_node node;
   multiped *targ;
   mxs_vector xlat;
   IMotor *pMotor;

   if(NULL==(targ=MotEditGetMultiped()))
      return;

   if(g_MotEditMotionNum<0)
      return;

   quat *rot=new quat[targ->num_joints+1];

   // intialize xlat and rots, in case motion is an overlay
   mx_zero_vec(&xlat);
   int i;
   for(i=0;i<targ->num_joints+1;i++)
   {
      quat_identity(&rot[i]);
   }

   memset(&node,0,sizeof(node));
   node.frame=frame;
   node.handle=g_MotEditMotionNum;

   // want these to be zero if global frame of ref
   if(((pMotor=MotEditGetMotor())!=NULL)&&pMotor->GetMotFrameOfReference()!=kMFRT_RelStart)
   {
      mx_zero_vec(&node.base_pos);
      quat_identity(&node.base_orient);
   } else
   {
      mx_copy_vec(&node.base_pos,&g_MotEditStartPos);
      quat_copy(&node.base_orient,&g_MotEditStartRot);
   }

   MotDmngeLock(g_MotEditMotionNum);
   mp_evaluate_motion(targ,&node,rot,&xlat);
   mp_apply_motion(targ,rot,&xlat,-1);
   MotDmngeUnlock(g_MotEditMotionNum);

   delete rot;
}
#pragma once
#ifndef __MEDPLAY_H
#define __MEDPLAY_H

#include <motion.h>

#define PLAY_STRAIGHT      0
#define PLAY_LOOP          1

#define PLAY_MAIN_ONLY     0
#define PLAY_ALL_MOTIONS   1

#define PLAY_NO_BLEND      0
#define PLAY_NORMAL_BLEND  1

#define PLAY_TIME_BASED    0
#define PLAY_FRAME_BASED   1

typedef struct PlayOptions
{
   float trans_duration;
   int trans_offset;
   int loop;
   int which_motions;
   int blend;
   int frame_based;
   float timewarp;
   float stretch;
} PlayOptions;

EXTERN PlayOptions playOptions;

EXTERN mps_motion_param playParams;

EXTERN void PlayOptInit();
EXTERN void PlayOptApply();
EXTERN BOOL PlayMotionStart();
EXTERN void PlayMotionStop();
EXTERN void PlayMotionUpdate(float dt);
EXTERN void PlayMotionPoseAtFrame(int frame);

#endif
///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/editor/menus.cpp,v $
// $Author: henrys $
// $Date: 1999/10/29 19:18:50 $
// $Revision: 1.7 $
//
// @Note (toml 08-03-97): This is a temporary solution that will have to be
// rethought when dynamic menus are supported. No sub-menus right now

#include <windows.h>
#include <lg.h>

#include <appagg.h>
#include <wappapi.h>

#include <dynarray.h>
#include <str.h>
#include <hashpp.h>
#include <hshpptem.h>
#include <winmenu.h>
#include <config.h>

#include <menus.h>
#include <command.h>
#include <mprintf.h>

// Must be last header
#include <dbmem.h>

///////////////////////////////////////////////////////////////////////////////

#define kMenuCommandBase 1000

class cMenuCommands
{
public:
   ~cMenuCommands();

   unsigned NewCommand(const char *);
   const char * Lookup(unsigned);
   void ClearAll();

private:
   cDynArray<const char *> m_CommandTexts;
};

///////////////////////////////////////

inline cMenuCommands::~cMenuCommands()
{
   ClearAll();
}

///////////////////////////////////////

inline unsigned cMenuCommands::NewCommand(const char * pszCommand)
{
   m_CommandTexts.Append(strdup(pszCommand));
   return kMenuCommandBase + m_CommandTexts.Size() - 1;
}

///////////////////////////////////////

inline const char * cMenuCommands::Lookup(unsigned id)
{
   unsigned index = id - kMenuCommandBase;
   if (index < m_CommandTexts.Size())
      return m_CommandTexts[index];
   else
      return NULL;
}

///////////////////////////////////////

void cMenuCommands::ClearAll()
{
   for (int i = 0; i < m_CommandTexts.Size(); i++)
      free((void *)(m_CommandTexts[i]));
   m_CommandTexts.SetSize(0);
}

///////////////////////////////////////////////////////////////////////////////

class cMenuSet
{
public:
   cMenuSet();
   ~cMenuSet();

   void BeginMenu(const char * = NULL);
   void AddItem(const char *, unsigned id);
   void AddSeparator();
   void EndMenu();

   void AttachToWindow(HWND hWnd);
   void DetachFromWindow();

   void DestroyAll();

   cWinMenu* GetMenuByNumber(int number);

private:
   HWND                  m_hWnd;
   int                   m_iCurrentMenu;
   cDynArray<cWinMenu *> m_Menus;
   cDynArray<int>        m_MenuStack;

};

///////////////////////////////////////

inline cMenuSet::cMenuSet()
 : m_hWnd(0),
   m_iCurrentMenu(-1)
{
}

///////////////////////////////////////

inline cMenuSet::~cMenuSet()
{
   DestroyAll();
}

///////////////////////////////////////

inline void cMenuSet::BeginMenu(const char * pszSubMenuName)
{
   cWinMenu * pMenu = new cWinMenu();

   pMenu->CreateMenu();
   m_Menus.Append(pMenu);

   m_MenuStack.Append(m_iCurrentMenu);

   int oldMenu = m_iCurrentMenu;

   m_iCurrentMenu = (int)m_Menus.Size() - 1;

   if (m_iCurrentMenu != 0)
      m_Menus[oldMenu]->AppendMenu(MF_POPUP, (uint)(HMENU)(*pMenu), pszSubMenuName);

}

///////////////////////////////////////

inline void cMenuSet::EndMenu()
{
   m_iCurrentMenu = m_MenuStack[m_MenuStack.Size() - 1];
   m_MenuStack.SetSize(m_MenuStack.Size() - 1);
}

///////////////////////////////////////

inline void cMenuSet::AddItem(const char * pszMenuItemName, unsigned id)
{
   if (m_Menus.Size() != 0)
      m_Menus[m_iCurrentMenu]->AppendMenu(MF_STRING, id, pszMenuItemName);
}

///////////////////////////////////////

inline void cMenuSet::AddSeparator()
{
   if (m_Menus.Size() != 0)
      m_Menus[m_iCurrentMenu]->AppendMenu(MF_SEPARATOR, 0, 0);
}

///////////////////////////////////////

void cMenuSet::AttachToWindow(HWND hWnd)
{
   if (m_Menus.Size() == 0)
      return;

   if (!hWnd)
      return;

   if (m_hWnd)
      SetMenu(m_hWnd, NULL);

   m_hWnd = hWnd;

   SetMenu(m_hWnd, *(m_Menus[0]));
}

///////////////////////////////////////

void cMenuSet::DetachFromWindow()
{
   if (m_hWnd)
      SetMenu(m_hWnd, NULL);
   m_hWnd = NULL;
}

///////////////////////////////////////

void cMenuSet::DestroyAll()
{
   if (m_Menus.Size() == 0)
      return;

   int iFirst = (m_hWnd) ? 1 : 0;

   for (int i = iFirst; i < m_Menus.Size(); i++)
   {
      delete m_Menus[i];
   }
   m_iCurrentMenu = -1;
   m_MenuStack.SetSize(0);
   m_Menus.SetSize(0);
}

///////////////////////////////////////

cWinMenu* cMenuSet::GetMenuByNumber(int number)
{
    return (m_Menus[number]);
}

///////////////////////////////////////////////////////////////////////////////

typedef cStrHashTable<BOOL> cMenusInProgress;

///////////////////////////////////////////////////////////////////////////////

static cMenuCommands g_MenuCommands;
static cMenuSet      g_MenuSet;

///////////////////////////////////////////////////////////////////////////////

#define kMaxMenuConfigEntry 512

void ParseMenu(const char * pszMenuText, const char * pszMenuTag, cMenuSet & menuSet, cMenusInProgress & menusInProgress)
{
   cStr menuDefStr;
   BOOL foundMenu = config_get_raw(pszMenuTag,
                                   menuDefStr.GetBuffer(kMaxMenuConfigEntry),
                                   kMaxMenuConfigEntry);
   menuDefStr.ReleaseBuffer();
   menuDefStr.Trim();

   if (foundMenu && !menuDefStr.IsEmpty())
   {
      if (menusInProgress.Lookup(pszMenuTag, &foundMenu))
         return;

      menusInProgress.Insert(pszMenuTag, TRUE);
      menuSet.BeginMenu(pszMenuText);

      cStr continuationMenuTag(pszMenuTag);
      int  iCurrentPart = 0;

      continuationMenuTag += "_0";

      while (foundMenu)
      {
         int  indexNextEntry = 0;
         int  indexSemicolon = 0;

         cStr menuEntry;
         cStr menuText;
         cStr menuValue;

         while (menuDefStr[indexNextEntry])
         {
            // Find semicolon
            indexSemicolon = indexNextEntry + menuDefStr.SpanExcluding("|", indexNextEntry);

            // If the string is non-zero, deal with it
            if (indexSemicolon - indexNextEntry != 0)
            {
               menuDefStr.Mid(menuEntry, indexNextEntry, indexSemicolon - indexNextEntry);

               int indexColon = menuEntry.Find(':');
               if (indexColon != -1)
               {
                  menuEntry.Mid(menuText, 0, indexColon);
                  menuEntry.Mid(menuValue, indexColon + 1, menuEntry.GetLength() - (indexColon + 1));
               }
               else
               {
                  menuText = menuEntry;
                  menuValue = menuEntry;
               }
               menuText.Trim();
               menuValue.Trim();

               if (menuValue.Find("menu_") == 0)
               {
                  ParseMenu(menuText, menuValue, menuSet, menusInProgress);
               }
               else if (menuText.Find("sep") == 0)
               {
                  menuSet.AddSeparator();
               }
               else
               {
                  menuSet.AddItem(menuText, g_MenuCommands.NewCommand(menuValue));
               }

            }

            menuEntry.Empty();
            menuText.Empty();
            menuValue.Empty();

            // Skip to the next non-semicolon
            indexNextEntry = indexSemicolon + menuDefStr.SpanIncluding("|", indexSemicolon);
         }
         iCurrentPart++;
         continuationMenuTag[continuationMenuTag.GetLength() - 1] = '0' + iCurrentPart;

         foundMenu = config_get_raw(continuationMenuTag,
                                    menuDefStr.GetBuffer(kMaxMenuConfigEntry),
                                    kMaxMenuConfigEntry);
         menuDefStr.ReleaseBuffer();
         menuDefStr.Trim();
      }
      menuSet.EndMenu();
      menusInProgress.Delete(pszMenuTag);
   }
   else
      menuSet.AddItem(pszMenuText, 0);
}

///////////////////////////////////////////////////////////////////////////////

BOOL CreateMenu(const char * pszMenuTag)
{
   cMenusInProgress menusInProgress;

   ParseMenu(NULL, pszMenuTag, g_MenuSet, menusInProgress);

   return TRUE;
}

///////////////////////////////////////////////////////////////////////////////

void SetMainMenu(const char * pszName)
{
   AutoAppIPtr(WinApp);

   HWND hWnd = pWinApp->GetMainWnd();

   g_MenuSet.DetachFromWindow();
   g_MenuSet.DestroyAll();
   g_MenuCommands.ClearAll();

   if (pszName)
   {
      cStr menuNameStr;

      menuNameStr = "menu_";
      menuNameStr += pszName;

      menuNameStr.Trim();

      CreateMenu(menuNameStr);

      g_MenuSet.AttachToWindow(hWnd);
   }
}

///////////////////////////////////////////////////////////////////////////////

void MenuCommand(unsigned id)
{
   const char * pszMenuCommand = g_MenuCommands.Lookup(id);

   if (pszMenuCommand)
   {
      CommandExecute((char *)pszMenuCommand);
   }
}

///////////////////////////////////////////////////////////////////////////////

//  Sets an exclusive radio-button style bullet beside a menu item
//
extern "C"
{
    void SetRadioCheckmark (int menu, int firstPos, int lastPos, int checkPos)
    {
        g_MenuSet.GetMenuByNumber(menu)->CheckMenuRadioItem (firstPos, lastPos, checkPos, MF_BYPOSITION);
    }
}
///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/editor/menus.h,v $
// $Author: adurant $
// $Date: 2000/01/29 13:12:32 $
// $Revision: 1.2 $
//
#pragma once

#ifndef __MENUS_H
#define __MENUS_H

EXTERN void SetMainMenu(const char * pszName);
EXTERN void MenuCommand(unsigned);

#endif /* !__MENUS_H */
// $Header: r:/t2repos/thief2/src/editor/modalui.c,v 1.5 2000/02/19 13:11:05 toml Exp $

#include <lg.h>
#include <mouse.h>

#include <stupidui.h>
#include <modalui.h>
#include <scrnman.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// doug is being lame, but im also reducing header interdependancy
extern void vBrush_FrameCallback(void);

  // assuming we start inside a ScrnStartFrame(), this
  // works fine.  If not, then start should do a ScrnStartFrame(),
  // and end should do a ScrnEndFrame()
BOOL modal_ui_start(int btn_check)
{
   if (btn_check)
   {
      bool resl=TRUE, resr=TRUE;  // assume ok
      if (btn_check&MODAL_CHECK_LEFT)  mouse_check_btn(MOUSE_LBUTTON,&resl);
      if (btn_check&MODAL_CHECK_RIGHT) mouse_check_btn(MOUSE_RBUTTON,&resr);
      if (!(resl || resr))
      {
         Warning(("neither button down in modal_ui_start\n"));
         return FALSE;
      }
   }
   stupid_ui_start();
   return TRUE;
}

void modal_ui_update(void)
{
   vBrush_FrameCallback();
   ScrnForceUpdate();
}

void modal_ui_end(void)
{
   stupid_ui_end();
}
// $Header: r:/t2repos/thief2/src/editor/modalui.h,v 1.3 2000/01/29 13:12:35 adurant Exp $
#pragma once

// Modal-UI system

#ifndef __MODALUI_H
#define __MODALUI_H

#include <stupidui.h>

// defines for ui_start's btn_check field
#define MODAL_CHECK_NONE   (0)
#define MODAL_CHECK_LEFT   (0x1)
#define MODAL_CHECK_RIGHT  (0x2)
#define MODAL_CHECK_ALL    (MODAL_CHECK_LEFT|MODAL_CHECK_RIGHT)

EXTERN BOOL modal_ui_start(int btn_check);
EXTERN void modal_ui_end(void);
EXTERN void modal_ui_update(void);

  // bool modal_ui_get_event(uiEvent *ev)
  //    returns FALSE if there are no events;
  //    and returns FALSE once per frame
  //    otherwise, stuffs the passed in structure
#define modal_ui_get_event get_stupid_ui_event

#endif
// $Header: r:/t2repos/thief2/src/editor/motedit.cpp,v 1.6 2000/02/19 13:11:06 toml Exp $
// XXX @TODO: reset globals on startup

#include <motedit.h>
#include <motedit_.h>
#include <mediface.h>
#include <medmenu.h> // for frame slider update
#include <medplay.h>
#include <motdesc.h>
#include <mp.h>
#include <datapath.h>
#include <medflbox.h>
#include <motmngr.h>

#include <objtype.h>
#include <editbr_.h>
#include <vbrush.h>
#include <brinfo.h>
#include <motrtype.h>
#include <creatapi.h>
#include <creatext.h>
#include <viewmgr.h>
#include <status.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//mps_motion_node activeMotions[NUM_MOTION_ROLES];

int g_CurMotEditFrame;
int g_LastMotEditFrame;

BOOL g_InMotionEditor=FALSE;

char *g_MotEditMotionName=NULL;

mps_motion *g_MotEditMotion=NULL;

IMotor *g_MotEditTarget=NULL;

int g_MotEditMotionNum=-1;

mxs_vector g_MotEditStartPos;
quat g_MotEditStartRot;


BOOL motionIsPlaying=FALSE;

void MotEditInit()
{
   if(g_InMotionEditor)
      return;

   g_InMotionEditor=TRUE;

   // initialize globals
   g_CurMotEditFrame=0;
   g_LastMotEditFrame=0;
   g_MotEditMotionName=NULL;
   g_MotEditMotion=NULL;
   g_MotEditTarget=NULL;
   g_MotEditMotionNum=-1;
   mx_zero_vec(&g_MotEditStartPos);
   quat_identity(&g_MotEditStartRot);

   CreateMotionEditorInterface();
   PlayOptInit();
   MotEditSetEditObj();
}    

void MotEditClose()
{
   if(g_InMotionEditor)
      DestroyMotionEditorInterface();
   g_InMotionEditor=FALSE;
}

void motedit_cmd(void)
{
   if(g_InMotionEditor)
      MotEditClose();
   else
      MotEditInit();
}

void MotEditSetEditObj()
{
   editBrush *pCur;
   ObjID obj;
   mxs_matrix mat;

   pCur=vBrush_GetSel();
   obj=brObj_ID(pCur);
   const Position *pos=ObjPosGet(obj);

   g_MotEditTarget=CreatureGetMotorInterface(obj);
   if(pos)
   {
      mx_copy_vec(&g_MotEditStartPos,&pos->loc.vec);
      mx_ang2mat(&mat,&pos->fac);
      quat_from_matrix(&g_MotEditStartRot,&mat);
   }
}

multiped *MotEditGetMultiped()
{
   if(g_MotEditTarget)
   {
      return (multiped *)g_MotEditTarget->GetMultiped();
   } else
   {
      return NULL;
   }
}

IMotor *MotEditGetMotor()
{
   return g_MotEditTarget;
}

void MotEditUpdate(float dt)
{
   if(FrameSliderUpdate())
   {
      // change target if necessary
      MotEditSetEditObj();

      // set target to desired frame
      PlayMotionPoseAtFrame(g_CurMotEditFrame);
   } else
   {
      PlayMotionUpdate(dt);
   }

   if(g_MotEditTarget)
   {
      vm_redraw();
   } 
}

/////////////////////////////////////////////////////////////////
// Motion Loading and Saving for Editor

// can only edit motions that are already loaded by game
BOOL MotEditSetEditMotion(char *motname)
{
   int num;
   char spew[80];

   if(!motname)
      return FALSE;

   num=MotDescNameGetNum(motname);
   if(num<0)
   {
      sprintf(spew,"Unable to load %s",motname);
      Status(spew);
      return FALSE;
   }
   g_MotEditMotion=mp_motion_list+num;
   g_MotEditMotionNum=num;
   g_MotEditMotionName=g_MotEditMotion->info.name;

   if(g_MotEditMotion) // check that name is consistent
   {
      if(strcmp(motname,g_MotEditMotion->info.name))      
      {
         Warning(("Inconsistent motion name: was %s but filename is %s\n",g_MotEditMotion->info.name,motname));
         sprintf(spew,"renaming motion from %s to %s",g_MotEditMotion->info.name,motname);
         Status(spew);
         strcpy(g_MotEditMotion->info.name,motname);
      }
   }

   if(g_MotEditMotion)
   {
      int left,right;

      MainInterfaceResetBotSlider(g_MotEditMotion->info.num_frames);
      FlagBoxResetMarks(g_MotEditMotion->info.num_frames);
      g_pMotionSet->GetStartEndFrames(num,&left,&right);
      FlagBoxSetMark(left,0);
      if(right>=0)
         FlagBoxSetMark(right,1);
      MainInterfaceRefreshFlagBox();
   } else
   {
      MainInterfaceResetBotSlider(0);
   }
   sprintf(spew,"%s succesfully loaded",motname);
   Status(spew);
   return TRUE;
}

void MotEditFinishMotionEdit()
{
   char fullname[30],spew[30];
   Datapath path;
   FILE *f;

   if(!g_MotEditMotionName || !g_MotEditMotion)
      return;

   // write out motion info to .mi file in local motion directory

   strcpy(fullname,"motions/");
   strncat(fullname,g_MotEditMotion->info.name,17);
   strcat(fullname,".mi");
   DatapathClear(&path);
   if(NULL!=(f=DatapathOpen(&path,fullname,"wb")))
   {
      mps_motion tmpMot;

      tmpMot=*g_MotEditMotion;

      tmpMot.components=NULL;
      tmpMot.flags=NULL;
      fwrite(&tmpMot,1,sizeof(tmpMot),f);
      fwrite(g_MotEditMotion->components,tmpMot.num_components,sizeof(mps_comp_motion),f);
      fwrite(g_MotEditMotion->flags,tmpMot.num_flags,sizeof(mps_motion_flag),f);
      fclose(f);
      sprintf(spew,"%s saved",g_MotEditMotionName);
   } else
   {
      sprintf(spew,"Unable to save %s",fullname);
   }

   Status(spew);

}
// $Header: r:/t2repos/thief2/src/editor/motedit.h,v 1.2 2000/01/29 13:12:36 adurant Exp $
// only external interface to motion editor
#pragma once

#ifndef __MOTEDIT_H
#define __MOTEDIT_H

// variable for whether or not motion editor is currently being used
EXTERN BOOL g_InMotionEditor;

// per-frame call to motion editor, where dt is elapsed millisec
EXTERN void MotEditUpdate(float dt);

// start motion editor
EXTERN void MotEditInit();

// close motion editor
EXTERN void MotEditClose();

// command to toggle motion editor on/off
EXTERN void motedit_cmd(void);

#endif
// $Header: r:/t2repos/thief2/src/editor/motedit_.h,v 1.2 2000/01/29 13:12:42 adurant Exp $
// internal motion editor header
#pragma once

#ifndef __MOTEDIT__H
#define __MOTEDIT__H

#include <multiped.h>
#include <motedit.h>

#define MROLE_MAIN 0

#define NUM_MOTION_ROLES 1

#if 0
// XXX taken out until further notice KJ 2/98
extern mps_motion_node activeMotions[NUM_MOTION_ROLES];
#endif

// global variables.  bad form, I know
EXTERN BOOL motionIsPlaying;
EXTERN int g_CurMotEditFrame;
EXTERN int g_LastMotEditFrame;
EXTERN char *g_MotEditMotionName;
EXTERN int g_MotEditMotionNum;
EXTERN mps_motion *g_MotEditMotion;
EXTERN mxs_vector g_MotEditStartPos;
EXTERN quat g_MotEditStartRot;

// functions
EXTERN void MotEditUpdate(float dt);
EXTERN BOOL MotEditSetEditMotion(char *motname);
EXTERN void MotEditFinishMotionEdit();

EXTERN void MotEditSetEditObj();

multiped *MotEditGetMultiped();

#ifdef __cplusplus
#include <motrtype.h>
IMotor *MotEditGetMotor();
#endif // cplusplus

#endif

// $Header: r:/t2repos/thief2/src/editor/namenum.c,v 1.3 2000/02/19 13:11:07 toml Exp $
// simple system for creating/tracking/looking up/and save/loading numname associations

#include <lg.h>

#include <tagfile.h>
#include <vernum.h>

#include <namenum.h>
#include <simpwrap.h>

// the "control" info for the system
struct _namenum {
   char  *sys_name; // name of the namenum system - for file tags
   int    max_size; // overall size of system - total allowed
   int    cur_size; // current valid entries - how many entries
   char **names;    // actual names of entries - index by str_hnd
   int   *tags;     // tag list - index by str_hnd
};

//    The idea is the str_hnd is given to you if you have a known
// compact ID space, or want to manage a mapping from your ID space
// to the str_hnds, and need fast access.  Or you can just pass in
// the Tag, which will be slow (linear search) but easy.

/////////////////////
// init/free

// initializes a namenum table size cnt named "sys_name"
 sNameNum *NamenumInit(char *sys_name, int cnt)
{
   sNameNum *nSys=(sNameNum *)Malloc(sizeof(sNameNum));
   nSys->sys_name=sys_name;
   nSys->max_size=cnt;
   nSys->cur_size=0;
   nSys->names=(char **)Malloc(sizeof(char *)*cnt);
   memset(nSys->names,0,sizeof(char *)*cnt); // zero out the names
   nSys->tags=(int *)Malloc(sizeof(int)*cnt);
   memset(nSys->tags,0xff,sizeof(int)*cnt);  // and the tags (-1 is "free")
   return nSys;
}

// Free the NameNum and all its data
void      NamenumFree(sNameNum *ss)
{
   int i;
   for (i=0; i<ss->max_size; i++)
      if (ss->names[i])
         Free(ss->names[i]);
   Free(ss->names);
   Free(ss->tags);
   Free(ss);
}

/////////////////////
// file code

// helper functions to read and write data to the tagfile

// integers
static BOOL write_int(ITagFile *file, int val)
{
   if (ITagFile_Write(file,(char*)&val,sizeof(int)) == sizeof(int))
      return TRUE;
   Warning(("Couldnt write int %d to tagfile in nn\n",val));
   return FALSE;
}

static int read_int(ITagFile *file)
{
   int val;
   if (ITagFile_Read(file,(char*)&val,sizeof(int)) == sizeof(int))
      return val;
   else
   {
      Warning(("Couldnt read int from TagFile in nn\n"));
      return -1;
   }
}

// variable length strings (ie. an int then var len char array)
static BOOL write_str(ITagFile *file, char *str)
{
   int len=strlen(str)+1;
   write_int(file,len);
   if (ITagFile_Write(file,str,len) == len)
      return TRUE;
   Warning(("Couldnt write string %s to tagfile in nn\n",str));
   return FALSE;
}

static BOOL read_str(ITagFile *file, char **str)
{
   int len=read_int(file);
   if (len!=-1)
   {
      *str=(char *)Malloc(len);
      if (ITagFile_Read(file,*str,len) == len)
         return TRUE;
      Free(*str);
      Warning(("Couldnt read length %d from tagfile in nn\n",len));
   }
   else
      Warning(("Couldnt read length for string from tagfile in nn\n"));
   return FALSE;
}

// File Format is
//  integer max number of elements
//  [ integer sys name size
//    char *sys_name ]
//  for each element
//    integer tag
//    [ integer str_len
//      char *name ]

// saves ss to current TagFile (tagname "nn_"sys_name)
BOOL      NamenumSave(sNameNum *ss, ITagFile *file)
{
   TagVersion NamenumVer={1,0};
   TagFileTag NamenumTag={"nn*"};
   int i;

   if (!ss)
    { Warning(("No SS in NamenumSave!!")); return FALSE; }
   memset(NamenumTag.label,0,sizeof(NamenumTag.label));
   strncat(NamenumTag.label,ss->sys_name,sizeof(NamenumTag.label)-strlen(NamenumTag.label)-2);
   if (ITagFile_OpenBlock(file,&NamenumTag,&NamenumVer)==S_OK)
   {
      write_int(file,ss->max_size);
      write_str(file,ss->sys_name);
      for (i=0; i<ss->max_size; i++)
         if (ss->tags[i]!=NAMENUM_NO_TAG)
         {
            write_int(file,ss->tags[i]);
            write_str(file,ss->names[i]);
         }
         else
            write_int(file,NAMENUM_NO_TAG);
      ITagFile_CloseBlock(file);
      return TRUE;
   }
   return FALSE;
}

// loads and initializes sys_name as a namenum system, return NULL if not found
sNameNum *NamenumLoad(char *sys_name, ITagFile *file)
{
   TagVersion NamenumVer={1,0};
   TagFileTag NamenumTag={"nn*"};
   sNameNum *ss=NULL;

   memset(NamenumTag.label,0,sizeof(NamenumTag.label));   
   strncat(NamenumTag.label,sys_name,sizeof(NamenumTag.label)-strlen(NamenumTag.label)-2);
   if (ITagFile_OpenBlock(file,&NamenumTag,&NamenumVer)==S_OK)
   {
      int max_size=read_int(file), i;
      char *blk_name;
      read_str(file,&blk_name);
      if (strcmp(blk_name,sys_name)!=0)
         Warning(("nn Found Block %s which confuses me looking for %s\n",blk_name,sys_name));
      else
      {
         ss=NamenumInit(sys_name,max_size);
         for (i=0; i<max_size; i++)
         {
            int new_tag=read_int(file);
            if (new_tag!=NAMENUM_NO_TAG)
            {
               ss->tags[i]=new_tag;
               ss->cur_size++;
               read_str(file,&ss->names[i]);
            }
         }
      }
      Free(blk_name);
      ITagFile_CloseBlock(file);
   }
   return ss;
}

/////////////////////
// store/clear

static str_hnd _GetFreeHnd(sNameNum *ss)
{
   int i;
   if (ss)
      for (i=0; i<ss->max_size; i++)
         if (ss->tags[i]==NAMENUM_NO_TAG)
            return i;
   return NAMENUM_NO_HND;
}
   
// store "str" in the system with "tag", return the handle
str_hnd   NamenumStore(sNameNum *ss, char *str, int tag)
{
   str_hnd new_hnd=_GetFreeHnd(ss);
   AssertMsg1(ss,"No ss in NamenumStore %x",tag);
   if (new_hnd!=NAMENUM_NO_HND)
   {
      ss->tags[new_hnd]=tag;
      ss->names[new_hnd]=(char *)Malloc(strlen(str)+1);
      strcpy(ss->names[new_hnd],str);
      ss->cur_size++;
   }
   return new_hnd;
}

static str_hnd _GetHndForTag(sNameNum *ss, int tag)
{
   int i;
   for (i=0; i<ss->max_size; i++)
      if (ss->tags[i]==tag)
         return i;
   return NAMENUM_NO_HND;
}

static str_hnd _GetHndForString(sNameNum *ss, char *str)
{
   int i;
   for (i=0; i<ss->max_size; i++)
      if (ss->tags[i]!=NAMENUM_NO_TAG)
         if (stricmp(ss->names[i],str)==0)
            return i;
   return NAMENUM_NO_HND;
}

// store "str" in the system with "tag", return the handle
void      NamenumClear(sNameNum *ss, str_hnd hnd)
{
   AssertMsg1(ss,"No ss in NamenumClear %x",hnd);         
   if (hnd!=NAMENUM_NO_HND)
   {
      ss->tags[hnd]=NAMENUM_NO_TAG;
      Free(ss->names[hnd]);
      ss->names[hnd]=NULL;
      ss->cur_size--;
   }
}

// store "str" in the system with "tag", return the handle
void      NamenumClearByTag(sNameNum *ss, int tag)
{
   AssertMsg1(ss,"No ss in NamenumClearByTag %x",tag);      
   NamenumClear(ss,_GetHndForTag(ss,tag));
}

/////////////////
// actual data access

// retrieve the string using the system handle given by store
char     *NamenumFetch(sNameNum *ss, str_hnd hnd)
{
   AssertMsg1(ss,"No ss in NamenumFetchByHnd %x",hnd);
   if (hnd==NAMENUM_NO_HND)
      return NULL;
   return ss->names[hnd];
}

// retrieve the string using the tag given with creation
char     *NamenumFetchByTag(sNameNum *ss, int tag)
{
   AssertMsg1(ss,"No ss in NamenumFetchByTag %x",tag);   
   return NamenumFetch(ss,_GetHndForTag(ss,tag));
}

int       NamenumFetchTagForString(sNameNum *ss, char *name)
{
   int hnd=_GetHndForString(ss,name);
   if (hnd!=NAMENUM_NO_HND)
      return ss->tags[hnd];
   return -1;
}

// returns number of entries found - _newly mallocs_ *str_list
// if tags isn't NULL, it also fills it with a malloced list of tags
// NOTE: this seemed better to me than an iterator?  maybe not
int       NamenumAll(sNameNum *ss, char ***str_list, int **tags)
{
   int i, cur_pos=0;
   char **strs;

   AssertMsg(ss,"No ss in NamenumAll");
   strs=(char **)Malloc(ss->cur_size*sizeof(char *));
   if (strs)
   {
      if (tags)
         *tags=(int *)Malloc(ss->cur_size*sizeof(int));
      for (i=0; i<ss->max_size; i++)
         if (ss->names[i])
         {
            if (tags)
               (*tags)[cur_pos]=ss->tags[i];
            strs[cur_pos++]=ss->names[i];
         }
   }
   *str_list=strs;
   return cur_pos;
}

// applys mapping to all tags in ss
void      NamenumRetag(sNameNum *ss, int *mapping)
{
   int i;
   AssertMsg(ss,"No ss in NamenumRetag");
   for (i=0; i<ss->max_size; i++)
      if (ss->tags[i]!=NAMENUM_NO_TAG)
         ss->tags[i]=mapping[ss->tags[i]];
}

#ifdef MONO_MENUS
#include <mprintf.h>
#include <prompts.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static int PickMenu(char **list, int cnt)
{
   int i, rv;
   if (cnt<1)
      return NAMENUM_NO_TAG;
   mono_clear();
   for (i=0; i<cnt; i++)
      mprintf("%d> %s\n",i,list[i]);
   rv=prompt_int(NULL);
   mprintf("Choosing %d - %s\n",rv,rv==-1?"Cancel":list[rv]);
   return rv;
}
#endif

// return -1 if abort, else tag
int        NamenumSimpleMenuChooseTag(sNameNum *ss)
{
   char **list;
   int *tags;
   int choice, cnt;

   cnt=NamenumAll(ss,&list,&tags);
#ifdef MONO_MENUS
   choice=PickMenu(list,cnt);
#else
   choice=PickFromStringList(ss->sys_name,list,cnt);
#endif
   if (choice!=NAMENUM_NO_TAG)
      choice=tags[choice];
   Free(list);
   Free(tags);
   return choice;
}
// $Header: r:/t2repos/thief2/src/editor/namenum.h,v 1.3 2000/01/29 13:12:48 adurant Exp $
// library for numname association for string tables
#pragma once

#ifndef __NAMENUM_H
#define __NAMENUM_H

#include <tagfile.h>

// forward declare it
typedef struct _namenum sNameNum;

typedef int str_hnd;

// couldnt find a handle
#define NAMENUM_NO_HND (-1)

// well, tags have to have some "no" value, in the current impl
#define NAMENUM_NO_TAG (-1)

// initializes a namenum table size cnt named "sys_name"
EXTERN sNameNum *NamenumInit(char *sys_name, int cnt);

// Free the NameNum and all its data
EXTERN void      NamenumFree(sNameNum *ss);
   
// saves ss to current TagFile (tagname "nn_"sys_name)
EXTERN BOOL      NamenumSave(sNameNum *ss, ITagFile *file);

// loads and initializes sys_name as a namenum system, return NULL if not found
EXTERN sNameNum *NamenumLoad(char *sys_name, ITagFile *file);
   
// store "str" in the system with "tag", return the handle
EXTERN str_hnd   NamenumStore(sNameNum *ss, char *str, int tag);

// clear hnd from the system
EXTERN void      NamenumClear(sNameNum *ss, str_hnd hnd);

// clear tag from the system
EXTERN void      NamenumClearByTag(sNameNum *ss, int tag);

// retrieve the string using the system handle given by store
EXTERN char     *NamenumFetch(sNameNum *ss, str_hnd hnd);

// retrieve the string using the tag given with creation
EXTERN char     *NamenumFetchByTag(sNameNum *ss, int tag);

// get the tag for this string
EXTERN int       NamenumFetchTagForString(sNameNum *ss, char *name);

// returns number of entries found - _newly mallocs_ *str_list
// if tags isn't NULL, it also fills it with a malloced list of tags
// NOTE: this seemed better to me than an iterator?  maybe not
EXTERN int       NamenumAll(sNameNum *ss, char ***str_list, int **tags);

// applys mapping to all tags in ss
EXTERN void      NamenumRetag(sNameNum *ss, int *mapping);

// return -1 if abort, else tag
EXTERN int       NamenumSimpleMenuChooseTag(sNameNum *ss);

#endif  // __NAMENUM_H
// $Header: r:/t2repos/thief2/src/editor/objed.cpp,v 1.4 1998/06/16 14:59:21 mahk Exp $

#include <wtypes.h>
#include <dynfunc.h>

#include <comtools.h>

#include <appagg.h>
#include <aggmemb.h>

#include <iobjed.h>
#include <objedbas.h>

#include <edtrait.h>
#include <edtraist.h>

#include <dynarray.h>

#include <proped.h>



// Include these last
#include <initguid.h>
#include <objediid.h>

// must be last header
#include <dbmem.h>


////////////////////////////////////////////////////////////
// IMPLEMENTATION CLASS FOR IObjEditors Agg Member


class cObjEditors : public cCTDelegating<IObjEditors>,
                   public cCTAggregateMemberControl<kCTU_Default>
{
public: 
   cObjEditors(IUnknown* pouter);

   virtual ~cObjEditors(); 

   STDMETHOD(AddTrait)(IEditTrait* trait); 
   STDMETHOD(RemoveTrait)(IEditTrait* trait); 
   STDMETHOD_(IEditTrait*, AddProperty)(IProperty* prop); 
   STDMETHOD_(IEditTrait*,FirstTrait)(sEditTraitIter* iterstate);
   STDMETHOD_(IEditTrait*,NextTrait)(sEditTraitIter* iterstate); 
   STDMETHOD_(IObjEditor*,Create)(sObjEditorDesc* desc, ObjID obj);

   STDMETHOD(End)();

protected:
   class cTraits : public cDynArray<IEditTrait*>
   {

   }; 


   cTraits Traits; 
}; 

////////////////////////////////////////////////////////////


static sRelativeConstraint Constraints[] = 
{
   { kNullConstraint } 
};

F_DECLARE_INTERFACE(IObjEditors); 

cObjEditors::cObjEditors(IUnknown* pOuter)
{
   MI_INIT_AGGREGATION_1(pOuter, IObjEditors, kPriorityNormal, Constraints);
} 

cObjEditors::~cObjEditors()
{
}

////////////////////////////////////////////////////////////

STDMETHODIMP cObjEditors::AddTrait(IEditTrait* trait)
{
   Assert_(trait); 
   
   // Search for the trait
   for (int i = 0; i < Traits.Size(); i++)
   {
      if (Traits[i] == trait)
      {
         Warning(("Added EditTrait %s twice.\n",trait->Describe()->strings.name)); 
         return S_FALSE;
      }
      if (Traits[i] == NULL)
      {
         Traits[i] = trait;
         trait->AddRef();
         return S_OK; 
      }
   }

   Traits.Append(trait); 
   trait->AddRef();
   return S_OK; 
}

STDMETHODIMP cObjEditors::RemoveTrait(IEditTrait* trait)
{
   Assert_(trait); 

   // Search for the trait
   for (int i = 0; i < Traits.Size(); i++)
   {
      if (Traits[i] == trait)
      {
         Traits[i] = NULL;
         SafeRelease(trait);
         return S_OK;
      }
   }

   Warning(("Could not remove EditTrait %s.\n",trait->Describe()->strings.name)); 

   return S_OK; 
}


STDMETHODIMP_(IEditTrait*) cObjEditors::AddProperty(IProperty* prop)
{
   IEditTrait* trait = new cSdescPropEditTrait(prop); 
   AddTrait(trait);
   return trait; 
}

////////////////////////////////////////////////////////////

STDMETHODIMP_(IEditTrait*) cObjEditors::FirstTrait(sEditTraitIter* iter)
{
   Assert_(iter); 

   for (int i = 0; i < Traits.Size() ; i++)
      if (Traits[i] != NULL)
      {
         iter->idx = i;
         Traits[i]->AddRef();
         return Traits[i]; 
      }

   // No luck
   iter->idx = i; 
   return NULL;
}


STDMETHODIMP_(IEditTrait*) cObjEditors::NextTrait(sEditTraitIter* iter)
{
   Assert_(iter); 

   for (int i = iter->idx+1; i < Traits.Size() ; i++)
      if (Traits[i] != NULL)
      {
         iter->idx = i;
         Traits[i]->AddRef();
         return Traits[i]; 
      }

   // No luck
   iter->idx = i; 
   return NULL;
}

////////////////////////////////////////////////////////////


static IObjEditor* obj_woe(const sObjEditorDesc* , ObjID obj)
{
   CriticalMsg("Could not load dialog!");
   return NULL;
}


DeclDynFunc_(IObjEditor*, LGAPI, ConstructObjEditor, (const sObjEditorDesc* , ObjID ));
ImplDynFunc(ConstructObjEditor, "darkdlgs.dll", "_ConstructObjEditor@8", obj_woe);

#define ObjEdit (DynFunc(ConstructObjEditor).GetProcAddress())

STDMETHODIMP_(IObjEditor*) cObjEditors::Create(sObjEditorDesc* desc, ObjID obj)
{
   return ObjEdit(desc,obj);  
}

STDMETHODIMP cObjEditors::End()
{
   for (int i = 0; i < Traits.Size(); i++)
   {
      SafeRelease(Traits[i]); 
   }
   return S_OK; 
}


void ObjEditorsCreate(void)
{
   AutoAppIPtr(Unknown);
   new cObjEditors(pUnknown); 
}

// $Header: r:/t2repos/thief2/src/editor/objedit.h,v 1.4 2000/01/29 13:12:49 adurant Exp $
#pragma once

#ifndef __OBJEDIT_H
#define __OBJEDIT_H

#include <objtype.h>

#ifdef __cplusplus
#include <str.h>
#define ObjWarnName(obj) ((const char *)cStr(ObjEditName(obj)))
#else
#define ObjWarnName ObjEditName
#endif

//
// ObjEditName
//
// Get an object's printable name for editing/debugging
//

EXTERN const char* ObjEditName(ObjID obj);

//
// ObjEditNamed
//
// Gets the object described by a string
//

EXTERN ObjID  EditGetObjNamed(const char* name);

//
// ObjEditInit
//
// Initialize object editing
//

EXTERN void ObjEditInit(void);

#endif // __OBJEDIT_H
// $Header: r:/t2repos/thief2/src/editor/objhistp.cpp,v 1.5 2000/02/19 13:11:08 toml Exp $

#include <appagg.h>
#include <aggmemb.h>

#include <hashpp.h>
#include <hashfunc.h>
#include <hshpptem.h>
#include <mprintf.h>

#include <traitman.h>
#include <iobjsys.h>
#include <objquery.h>
#include <simpwrap.h>
#include <objdef.h>
#include <editobj.h>

#include <objhistp.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define STRLEN    64

typedef struct {
   int count;
   ObjID arch;
} ObjHistData;

typedef cHashTableFunctions<ObjID> ObjNameHashFunctions;
typedef cHashTable<ObjID, int, ObjNameHashFunctions> cObjHistCBTable;

#ifdef _MSC_VER
template cObjHistCBTable;
#endif

static cObjHistCBTable objs_used;

int ObjHistCompare(const void *p, const void *q)
{
   ObjHistData *a = (ObjHistData *) p;
   ObjHistData *b = (ObjHistData *) q;

   if (a->count > b->count)
      return -1;
   else
      return a->count < b->count;
}

static int BuildObjData(char ***objstrings, ObjHistData **histdata)
{
   int entries;
   IObjectQuery* pQuery;
   IObjectSystem* pOS = AppGetObj(IObjectSystem);
   ITraitManager* traitman = AppGetObj(ITraitManager);
   int i,count;
   int total = 0;
   ObjID obj,arch;
   cObjHistCBTable::cIter hashiter;

   objs_used.Clear();

   // okay, sift through every object in the world and collect stats
   pQuery = pOS->Iter(kObjectConcrete);
   while (!pQuery->Done())
   {
      obj = pQuery->Object();

      // reject transients, like texture concretes
      if (pOS->ObjIsTransient(obj))
      {
         pQuery->Next();
         continue;
      }

      arch = traitman->GetArchetype(obj);
      if ((obj != OBJ_NULL) && (arch != OBJ_NULL))
      {
         count = objs_used.Search(arch);
         objs_used.Set(arch,count+1);
         ++total;
      }
      pQuery->Next();
   }

   // take those stats and generate a list
   entries = objs_used.nElems();
   // extra entry for total 
   *objstrings = (char **)Malloc(sizeof(char *) * (entries+1));
   for (i=0; i < entries+1; i++)
      (*objstrings)[i] = (char *)Malloc(sizeof(char) * STRLEN);

   *histdata = (ObjHistData *)Malloc(sizeof(ObjHistData) * entries);

   hashiter = objs_used.Iter();
   count = 0;
   while (!hashiter.Done())
   {
      (*histdata)[count].arch = hashiter.Key();
      (*histdata)[count].count = hashiter.Value();
      count++;
      hashiter.Next();
   }

   SafeRelease(pQuery);
   SafeRelease(pOS);
   return total;
}


// handy dandy object histogram palette
void popup_obj_histogram(void)
{
   int count;
   char **objstrings;
   ObjHistData *histdata;
   int entries;
   int i,choice;
   ObjID arch;
   IObjectSystem* pOS = AppGetObj(IObjectSystem);
   int total;

   total = BuildObjData(&objstrings,&histdata);

   entries = objs_used.nElems();

   // sort the list
   qsort(histdata, entries, sizeof(ObjHistData), ObjHistCompare);

   sprintf(objstrings[0],"Total %d", total);
   // form the stringlist
   for (count=0; count < entries; count++)
   {
      sprintf(objstrings[count+1],"(%02d) %03d %s",count, histdata[count].count,pOS->GetName(histdata[count].arch));
   }
   // make the selection
   choice = PickFromStringList("Object Histogram", (const char* const*)objstrings, entries+1);

   // now set the default object
   if (choice >= 0)
   {
      arch = histdata[choice].arch;
      editObjSetDefaultArchetype(arch);
   }

   // some cleanup
   for (i=0; i < entries; i++)
      Free(objstrings[i]);
   Free(objstrings);
   Free(histdata);

   SafeRelease(pOS);
}

// simple alphabetical list of placed objects
void popup_obj_alpha(void)
{
   int count;
   char **objstrings;
   ObjHistData *histdata;
   int entries;
   int i,choice;
   ObjID arch;
   IObjectSystem* pOS = AppGetObj(IObjectSystem);

   BuildObjData(&objstrings,&histdata);
   entries = objs_used.nElems();
 
   // form the stringlist
   for (count=0; count < entries; count++)
   {
      sprintf(objstrings[count],"%s %03d",pOS->GetName(histdata[count].arch),histdata[count].count);
   }

   // make the selection
   choice = PickFromStringList("Object Alpha List", (const char* const*)objstrings, entries);

   // now set the default object
   if (choice != -1)
   {
      arch = histdata[choice].arch;
      editObjSetDefaultArchetype(arch);
   }

   // some cleanup
   for (i=0; i < entries; i++)
      Free(objstrings[i]);
   Free(objstrings);
   Free(histdata);

   SafeRelease(pOS);
}
// $Header: r:/t2repos/thief2/src/editor/objhistp.h,v 1.3 2000/01/29 13:12:51 adurant Exp $
#pragma once

#ifndef __OBJHISTP_H
#define __OBJHISTP_H

EXTERN void popup_obj_histogram(void);
EXTERN void popup_obj_alpha(void);

#endif// $Header: r:/t2repos/thief2/src/editor/objpnp.c,v 1.35 2000/02/19 13:11:09 toml Exp $
// HotRegion PnP gadget

#include <gadblist.h>
#include <lgsprntf.h>

#include <command.h>

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <editobj.h>
#include <brinfo.h>
#include <gedit.h>


#include <linkedit.h>
#include <linkedst.h>

#include <iobjed.h>
#include <objedbas.h>

#include <traitman.h>
#include <otreeed.h>

#include <brushGFH.h>
#include <PnPtools.h>
#include <objsys.h>

#include <objedit.h>

#include <mnumprop.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception - is WILDLY OUT OF DATE
 *      __________
 *     |0 pretty  |
 *     |  picture |         (4 lines worth)
 *     |  of the  |
 *     |__object__|         (dclick on type should bring up pal)
 * 1{???}    4{floor me}   
 * 2{prop}   5{class}
 * 3{links}  6{update}      (bring up link manager, something else)
 */

/* correct artists conception - note 9 buttons, not 7
 *    0 { nonexistant
 *         picture }
 *    1   { name }
 *    2  xxxxx
 *
 * 3{???}    6{floor me}   
 * 4{prop}   7{class}
 * 5{links}  8{update}      (bring up link manager, something else)
 */


#define NUM_BUTTONS (0x9)
static Rect objPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (objPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 0
#define BTN_BELOW 3
#define VERT_DIV  4
#define HORIZ_DIV (0.5)

void objPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,0,1,2,2);
   buildYLineRect(curRect++,whole,3,0,1,2,2);
   buildYLineRect(curRect++,whole,4,0,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[1].ul.y-3;
   
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,0,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,1,2,2);
}

#define EDIT_XXXX    1
#define EDIT_PROP    2
#define EDIT_LINK    3
#define EDIT_FLOOR   4
#define EDIT_CLASS   5
#define EDIT_UPDATE  6

// statics for the PnP itself
static int type=0;
static editBrush *objPnP_br;
static char objPnP_buf[64];

static _PnP_GadgData objPnP;

void objPnP_setvars(editBrush *br, bool update)
{
   if (update) br=objPnP_br;
   else        objPnP_br=br;

   if (br==NULL) return;  // no data, go home

   if (update)
   {
      brObj_Type(br)=type;
      ObjSetModelNumber(brObj_ID(br), &type);
      editobjUpdateBrushfromObj(brObj_ID(br));  // Brush size might need to change.
   }
   else
      type=brObj_Type(br);
}

static void objPnP_PopUp(int data)
{
   ObjID id;
   
   if (objPnP_br==NULL) return;
   
   id = brObj_ID(objPnP_br);

   if (data==EDIT_UPDATE)
   {
      editobjUpdateObjfromBrush(objPnP_br);
      gedit_redraw_3d();
   }
   else if (data == EDIT_PROP)
   {
      sObjEditorDesc eddesc = { "" };
      IObjEditors* eds = AppGetObj(IObjEditors); 

      IObjEditor* ed = IObjEditors_Create(eds,&eddesc,id); 
      IObjEditor_Go(ed,kObjEdModal);
      SafeRelease(ed);
      SafeRelease(eds);
   }
   else if (data == EDIT_LINK)
   {
      extern BOOL show_all_links; 
      sLinkEditorDesc desc = { "", kLinkEditAllButtons};
      if (show_all_links) desc.flags |= kLinkEditShowAll; 
      EditLinks(&desc,id, LINKOBJ_WILDCARD, RELID_WILDCARD); 
   }
   else if (data==EDIT_CLASS)
   {
      ITraitManager* traitman = AppGetObj(ITraitManager);
      ObjID arch = ITraitManager_GetArchetype(traitman,id);
      SafeRelease(traitman);
      EditObjHierarchy(arch);
   }
   else if (data==EDIT_FLOOR)
   {
      mxs_vector down;
      down.x = down.y = 0; down.z = -20.0F;
      gedit_floor_brush(objPnP_br,&down);
   }
   else if (data==EDIT_XXXX)
      Warning(("Watch it... thats XXXX"));
}

void Create_objPnP(LGadRoot* root, Rect* bounds, editBrush *br)
{
   GFHSetCoordMask(0);
   objPnP_buildRects(bounds);
   PnP_GadgStart(&objPnP,root);
   objPnP_setvars(br,FALSE);
   PnP_PictureBox(getRect(0),NULL,0);

   strncpy(objPnP_buf,ObjEditName(brObj_ID(br)),sizeof(objPnP_buf));
   objPnP_buf[sizeof(objPnP_buf)-1] = '\0';

   PnP_TextBox(getRect(1),objPnP_buf);
   //   PnP_ButtonOneShot(getRect(3),"XXXX",objPnP_PopUp,EDIT_XXXX);
   PnP_ButtonOneShot(getRect(4),"Properties",objPnP_PopUp,EDIT_PROP);
   PnP_ButtonOneShot(getRect(5),"Links",objPnP_PopUp,EDIT_LINK);
   PnP_ButtonOneShot(getRect(6),"Floor Me",objPnP_PopUp,EDIT_FLOOR);
   PnP_ButtonOneShot(getRect(7),"Class",objPnP_PopUp,EDIT_CLASS);
   PnP_ButtonOneShot(getRect(8),"Update",objPnP_PopUp,EDIT_UPDATE);
}

void Destroy_objPnP(void)
{
   PnP_GadgFree(&objPnP);
   objPnP_br=NULL;
}

void Update_objPnP(GFHUpdateOp op, editBrush *br)
{
   objPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      PnP_FullRedraw(&objPnP);
}
// $Header: r:/t2repos/thief2/src/editor/otreeed.cpp,v 1.9 2000/02/19 13:11:10 toml Exp $

#include <wtypes.h>
#include <dynfunc.h>

#include <comtools.h>
#include <appagg.h>
#include <traitman.h>

#include <objtype.h>
#include <osysbase.h>
#include <osystype.h>
#include <otreeed.h>
#include <otreebas.h>

// For create archetype
#include <brtypes.h>
#include <editobj.h>
#include <gedit.h>
#include <winui.h>
#include <ged_room.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//
// Special Tree ops
//

static eTreeCBResult LGAPI arch_create(ObjID obj)
{
   editObjSetDefaultArchetype(obj); 
   gedit_set_default_brush_type(brType_OBJECT);
   return (eTreeCBResult)(kObjTreeNormal|kObjTreeQuit); 
} 


// For rooms

static eTreeCBResult LGAPI arch_add_room(ObjID obj, const char* name)
{
   AutoAppIPtr_(TraitManager, pTM);
   ObjID archetype;
   BOOL  concrete = TRUE;

   archetype = pTM->GetArchetype(obj);

   if (OBJ_IS_ABSTRACT(obj))
   {
      concrete = winui_GetYorN("Concrete room?");
      ged_create_room_obj((char *)name, archetype, concrete);
      return (eTreeCBResult)(kObjTreeChanged|kObjTreeCancel);
   }
   else
   {
      ged_make_room_obj(obj);
      return (eTreeCBResult)(kObjTreeNormal);
   }
}

static eTreeCBResult LGAPI arch_delete_room(ObjID obj)
{
   if ((obj == ged_room_get_root()) ||
       (obj == ged_room_get_default()))
      return (eTreeCBResult)(kObjTreeCancel);
   else
      return (eTreeCBResult)(kObjTreeNormal);
}

static eTreeCBResult LGAPI arch_create_room(ObjID obj)
{
   ged_room_set_default_arch(obj);
   gedit_set_default_brush_type(brType_ROOM);
   return (eTreeCBResult)(kObjTreeNormal|kObjTreeQuit);
}


//
// Here is the tree list.  Add your tree here.
//

// This is a big hack so the room tree starts up first when I want it to.

#define ARCHETYPE_TREEDESC { "Archetypes", "Object", 0, { NULL, NULL, arch_create}  }
#define METAPROP_TREEDESC  { "MetaProperties", "Metaproperty", kObjTreeNoCreateButton,  }
#define ROOM_TREEDESC      { "Rooms", "Base Room", kObjTreePermitConcretes, { arch_add_room, arch_delete_room, arch_create_room} }
#define TEXTURE_TREEDESC   { "Textures", "Texture", kObjTreeNoCreateButton|kObjTreePermitConcretes }
#define STIMULUS_TREEDESC  { "Act/React Stimuli", "Stimulus", kObjTreeNoCreateButton }
#define FLOW_TREEDESC { "Flow Groups", "Flow Group", kObjTreeNoCreateButton|kObjTreePermitConcretes }


static sObjTreeDesc trees[] = 
{
   ARCHETYPE_TREEDESC,
   METAPROP_TREEDESC,
   ROOM_TREEDESC,
   TEXTURE_TREEDESC,
   STIMULUS_TREEDESC, 
   FLOW_TREEDESC,
   
   NULL_TREEDESC  // terminator
}; 

static sObjTreeDesc room_trees[] = 
{
   ROOM_TREEDESC,
   ARCHETYPE_TREEDESC,
   METAPROP_TREEDESC,
   TEXTURE_TREEDESC,
   STIMULUS_TREEDESC, 
   FLOW_TREEDESC,

   NULL_TREEDESC
};

sObjTreeEditorDesc edit_trees = 
{
   "Object Hierarchy",   // title
   0,             // flags
   trees
};

sObjTreeEditorDesc room_edit_trees = 
{
   "Room Hierarchy",
   0,
   room_trees
};


static void tree_woe(const sObjTreeEditorDesc* , ObjID )
{
   CriticalMsg("Could not load dialog!");
}


DeclDynFunc_(void, LGAPI, DoHierarchy, (const sObjTreeEditorDesc* , ObjID ));
ImplDynFunc(DoHierarchy, "darkdlgs.dll", "_DoHierarchy@8", tree_woe);

#define ObjTree (DynFunc(DoHierarchy).GetProcAddress())


void EditObjHierarchyRoom(ObjID focus)
{
   ObjTree(&room_edit_trees, focus);
}

void EditObjHierarchy(ObjID focus)
{
   ObjTree(&edit_trees,focus); 
}



// $Header: r:/t2repos/thief2/src/editor/otreeed.h,v 1.2 1997/12/31 15:43:55 CCAROLLO Exp $
#pragma once  
#ifndef __OTREEED_H
#define __OTREEED_H

//
// Provisional Object Tree Editing API
//

// Edit the hierarchy, start focused on an obj if possible.
EXTERN void EditObjHierarchyRoom(ObjID focus);  // hack hack hack
EXTERN void EditObjHierarchy(ObjID focus);

#endif // __OTREEED_H
////////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/editor/phproped.cpp,v 1.2 1998/10/09 20:17:20 CCAROLLO Exp $
//

#include <proped.h>
#include <iobjed.h>

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>
#include <sdesbase.h>
#include <sdestool.h>

#include <phcore.h>
#include <phmods.h>
#include <phmod.h>

#include <phprop.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////////////////////////////////////////////

class cPhysAuxEditTrait: public cSdescPropEditTrait
{
public:
   cPhysAuxEditTrait(IProperty* prop, int type)
      : cSdescPropEditTrait(prop)
   {
      Caps.flags |= kTraitCanParse|kTraitCanUnparse|kTraitCanEdit;

      switch (type)
      {
         case PHYS_ATTR:
         {
            mSdescMap[0] = GetPhysAttrDesc(kPMT_OBB);
            mSdescMap[1] = GetPhysAttrDesc(kPMT_Sphere);
            mSdescMap[2] = GetPhysAttrDesc(kPMT_SphereHat);
            mSdescMap[3] = GetPhysAttrDesc(kPMT_Invalid);
            break;
         }
         case PHYS_STATE:
         {
            mSdescMap[0] = GetPhysStateDesc();
            mSdescMap[1] = GetPhysStateDesc();
            mSdescMap[2] = GetPhysStateDesc();
            mSdescMap[3] = GetPhysStateDesc();
            break;
         }
         case PHYS_CONTROL:
         {
            mSdescMap[0] = GetPhysControlDesc();
            mSdescMap[1] = GetPhysControlDesc();
            mSdescMap[2] = GetPhysControlDesc();
            mSdescMap[3] = GetPhysControlDesc();
            break;
         }
         case PHYS_DIMS:
         {
            mSdescMap[0] = GetPhysDimsDesc(kPMT_OBB);
            mSdescMap[1] = GetPhysDimsDesc(kPMT_Sphere);
            mSdescMap[2] = GetPhysDimsDesc(kPMT_SphereHat);
            mSdescMap[3] = GetPhysDimsDesc(kPMT_Invalid);
            break;
         }
         default:
         {
            Warning(("cPhysAuxEditTrait: unknown type: %d\n", type));
            return;
         }
      }
   }

   STDMETHOD(Edit)(ObjID obj)
   {
      cPhysTypeProp *pTypeProp;

      if (g_pPhysTypeProp->Get(obj, &pTypeProp))
      {
         Sdesc = mSdescMap[pTypeProp->type];
         return cSdescPropEditTrait::Edit(obj);
      }
      else
      {
         Warning(("Edit: obj %d has no phys type property!\n", obj));
         return S_FALSE;
      }
   }

   STDMETHOD(Unparse)(ObjID obj, char* buf, int buflen) 
   {
      cPhysTypeProp *pTypeProp;

      if (g_pPhysTypeProp->Get(obj, &pTypeProp))
      {
         Sdesc = mSdescMap[pTypeProp->type];
         return cSdescPropEditTrait::Unparse(obj, buf, buflen);
      }
      else
      {
         Warning(("Edit: obj %d has no phys type property!\n", obj));
         return S_FALSE;
      }
   }

private:

   sStructDesc *mSdescMap[4];
};

////////////////////////////////////////////////////////////////////////////////

void CreateAuxPhysPropEditor(IProperty *prop, int type)
{
   IObjEditors* pEditors = AppGetObj(IObjEditors);
   if (pEditors)
   {
      IEditTrait *trait = new cPhysAuxEditTrait(prop, type);
      pEditors->AddTrait(trait);
      SafeRelease(trait);
      SafeRelease(pEditors);
   }
}

////////////////////////////////////////////////////////////////////////////////






// $Header: r:/t2repos/thief2/src/editor/pnpslide.cpp,v 1.19 1997/12/22 18:24:19 mahk Exp $

#include <string.h>

#include <lg.h>
#include <gadget.h>
#include <float.h>
#include <keydefs.h>

#include <pnptools.h>
#include <cyclegad.h>
#include <vslider.h>
#include <pnpvslid.h>

extern "C" {
#include <pnptool_.h>
}

// Must be last header
#include <dbmem.h>

EXTERN DrawElement stupid_arrows[];
#pragma off(unreferenced)

#define _set_min_max(tcd,lo,hi,scale,minval,maxval) \
   if (lo==hi) \
   { \
      (tcd)->min  =  minval; \
      (tcd)->max  =  maxval; \
      (tcd)->wrap = TRUE; \
   } \
   else \
   { \
      (tcd)->min  = lo; \
      (tcd)->max  = hi; \
      (tcd)->wrap = FALSE; \
   } \
   (tcd)->delta=scale

#define _unsigned_set_min_max(tcd,lo,hi,scale,maxval) \
   _set_min_max(tcd,lo,hi,scale,0,maxval)

#define _signed_set_min_max(tcd,lo,hi,scale,maxval) \
   _set_min_max(tcd,lo,hi,scale,-(maxval),maxval)

static int _slider_build_name(Rect *space, char *name, short pad, pnp_vslider_data* data)
{
   DrawElement draw;   
   Rect r = *space;
   short w,h;
   
   // build the name box
   ElementClear(&draw);
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = name;   
   ElementSize(&draw,&w,&h);
   w+=pad;
   r.lr.x = r.ul.x;
   r.lr.x += w;
   _pnp_vslider(&r,name,data);
   return w;
}

#define PNP_CYCLE_FLAGS (CYCLE_FOCUS_FLAG|CYCLE_EDIT_FLAG|CYCLE_NOSPACE_FLAG)

////////////////////////////////////////////////////////////
// PNP SLIDER TEMPLATES 
//
// the real generic hacks are here

template <class type> struct CycleData
{
   void (*update)(PnP_SliderOp op, Rect* where, type val, int data); 
   int data; 
   BOOL send_updates;
};

//
// Dumb interface class
//


#define BuildMethods(type) \
class type##Methods { \
public: \
static void* Build(type##Slider* arg) { return VSlider##type##Build(arg);};  \
static CycleGadg* GadgCreate(CycleGadg* g, LGadRoot* r, CycleGadgDesc* desc, type##CycleGadgDesc* typedesc) { return Create##type##CycleGadg(g,r,desc,typedesc); }; \
static void GadgDestroy(CycleGadg* g) { Destroy##type##CycleGadg(g);};\
static int registry_num(void) { return PnP_REGSLIDER##type; } ; \
}; 

//
// Stupid class just to hold my functions
//

#define SLIDER_TEMPLATE template <class type, class DESC, class SLIDER, class METHODS >

#define SLIDER_INSTANCE(type) pnpSlider<type,type##CycleGadgDesc,type##Slider,type##Methods>

SLIDER_TEMPLATE 
struct pnpSlider
{
   CycleGadg _gadg;  // must be castable to a box
   CycleData<type> _data;
   pnp_vslider_data* vdata; 

   int Register(int num = -1);  // register your pnp
   static bool cycle_cb(CycleGadg* gadg, ulong action, eCyclePart part, void* var, CycleGadgDesc* desc); 
   static pnp_vslider_data* build_vslider(void* gadg, type* var, type lo, type hi, float scale);
   static void Update(void* g, void* arg);   

   pnpSlider(Rect* space, char* name, type lo, type hi, float scale, type* var,
               void(*update)(PnP_SliderOp op, Rect* where, type val, int data), int data, ulong flags, char* format); 
   ~pnpSlider();
};

////////////////////////////////////////

SLIDER_TEMPLATE bool pnpSlider<type,DESC,SLIDER,METHODS>::cycle_cb(CycleGadg* gadg, ulong action, eCyclePart part,
 void* var, CycleGadgDesc* desc)
{ 
   BOOL retval = TRUE;
   BOOL potent;

   CycleData<type>* cyc = (CycleData<type>*)desc->user_data; 

   if (CYCLE_ACTION_KIND(action) == kCycleActionUpdate)
   {
      if (cyc->send_updates)
      {
         potent = TRUE;
         retval = FALSE;
      }
      else return FALSE;
   }
   else
      potent = part != kCycleCenterPart || CYCLE_ACTION_KIND(action) == kCycleActionKey;
   PnP_SliderOp op = (potent) ? PnP_SliderUpdateOp : PnP_SliderClickOp; 

   if (cyc->update) 
      cyc->update(op,BOX_RECT(VB(gadg)),*(type *)var,cyc->data); 
   return retval; 
}


////////////////////////////////////////

SLIDER_TEMPLATE
 void pnpSlider<type,DESC,SLIDER,METHODS>::Update(void* g, void* arg)
{
   pnpSlider<type,DESC,SLIDER,METHODS>* slide = (pnpSlider<type,DESC,SLIDER,METHODS>*)g;
   CycleGadg *gadg = &slide->_gadg; 
   UpdateCycleGadg(gadg,TRUE); 
   if (arg != NULL)
   {
      TriggerCycleGadg(gadg,CYCLE_MAKE_ACTION(kCycleActionKey,KB_FLAG_DOWN|KEY_ENTER),kCycleCenterPart);
   }
}

#define BuildCycleUpdate(type) \
EXTERN void PnP_##type##SliderUpdate(void *g, void *arg) \
{ \
   SLIDER_INSTANCE(type)::Update(g,arg); \
}

////////////////////////////////////////

SLIDER_TEMPLATE
 pnp_vslider_data* pnpSlider<type,DESC,SLIDER,METHODS>
::build_vslider(void* gadg, type* var, type lo, type hi, float scale)
{
   pnp_vslider_data* vdata = (pnp_vslider_data*)Malloc(sizeof(*vdata)); 
   SLIDER* slider  = (SLIDER*)Malloc(sizeof(*slider));   
   vdata->slider = (anonSlider*)METHODS::Build(slider);
   slider->val = var;                                    
   slider->lo = lo;                                      
   slider->hi = hi;                                      
   slider->scale = scale;                                
   vdata->update_gadg = gadg;                            
   vdata->update_func = Update;
   vdata->update_data = (void*)1;          
   return vdata;                                         
}


////////////////////////////////////////////////////////////

SLIDER_TEMPLATE pnpSlider<type,DESC,SLIDER,METHODS>:: 
pnpSlider(Rect* space, char* name, type lo, type hi, float scale, type* var,
       void(*update)(PnP_SliderOp op, Rect* where, type val, int data), 
       int data, ulong flags, char* format)
{
   CycleGadgDesc cdesc = { {0,}, NULL, stupid_arrows, cycle_cb, format};
   DESC fdesc;
   CycleData<type>* cyc = &_data;
   vdata = NULL; 
   int w;   
   CycleGadg* gadg = &_gadg;

   memset(gadg,0,sizeof(*gadg));

   if (flags & PNP_SLIDER_VSLIDE)
   {
      vdata = build_vslider(gadg,var,lo,hi,1.0);
   }
   w=_slider_build_name(space,name,4,vdata);

   // now build the cyclegadg
   cdesc.bounds = *space;
   cdesc.bounds.ul.x += w;
   cdesc.var = var;
   cdesc.user_data = cyc;
   cdesc.flags = PNP_CYCLE_FLAGS;

   if (flags & PNP_SLIDER_CLICKS)
      cdesc.flags |= CYCLE_NONPOTENT_FLAG;
      
   cyc->update = update;
   cyc->data = data;
   cyc->send_updates = FALSE;

   memset(&fdesc,0,sizeof(fdesc));
   _signed_set_min_max(&fdesc,lo,hi,scale,FLT_MAX);
   if (flags & PNP_SLIDER_WRAP)
      fdesc.wrap = TRUE;
   

   gadg = METHODS::GadgCreate(gadg,curPnP->_root,&cdesc,&fdesc);
}


SLIDER_TEMPLATE int pnpSlider<type,DESC,SLIDER,METHODS>::Register(int num)
{ 
   if (num < 0) num = METHODS::registry_num();
   _PnP_Register(&_gadg,num);
   return curPnP->GadgOwner++;
}

#define BuildCycle(type,Type,format) \
EXTERN int PnP_Slider##Type(Rect* space, char* name, type lo, type hi, type scale, type *var, \
                     void (*update)(PnP_SliderOp op, Rect* where, type val, int data), int data, ulong flags) \
{ \
   SLIDER_INSTANCE(type)* slider; \
   slider = new SLIDER_INSTANCE(type)(space,name,lo,hi,scale,var,update,data,flags,format); \
   return slider->Register();\
}

////////////////////////////////////////

SLIDER_TEMPLATE pnpSlider<type,DESC,SLIDER,METHODS>::~pnpSlider()
{  // Um, this is somewhat of an abstraction violation
   // but theres no current api for ripping the userdata back out of cyclegadgs
   METHODS::GadgDestroy(&_gadg);
   if (vdata) Free(vdata); 

}

#define BuildCycleDestroy(type) \
EXTERN void PnP_Slider##type##Destroy(void* p) \
{ \
     delete (SLIDER_INSTANCE(type)*)p; \
}

//////////////////////////////////
// Instantiate

BuildMethods(float)
BuildCycle(float,Float,"%3.2f")
BuildCycleUpdate(float)
BuildCycleDestroy(float)

BuildMethods(short)
BuildCycle(short,Short,"%5hd")
BuildCycleUpdate(short)
BuildCycleDestroy(short)



BuildMethods(int)
BuildCycle(int,Int,"%d")
BuildCycleUpdate(int)
BuildCycleDestroy(int)

////////////////////////////////////////////////////////////
// String slider
// 

static bool string_cycle_cb(CycleGadg* gadg, ulong action, eCyclePart part,
 void* var, CycleGadgDesc* desc)
{ 
   if (CYCLE_ACTION_KIND(action) == kCycleActionUpdate)
      return FALSE;
   PnP_SliderOp op = PnP_SliderUpdateOp;
   CycleData<int>* cyc = (CycleData<int>*)desc->user_data; 
   if (part == kCycleCenterPart 
       && CYCLE_ACTION_KIND(action) == kCycleActionMouse)
       op = PnP_SliderClickOp;
   if (cyc->update) 
   {
      cyc->update(op,BOX_RECT(VB(gadg)),*(int *)var,cyc->data); 
   }
   return TRUE; 
}

EXTERN int PnP_SliderString(Rect *space, char *name, int num, char** vals, int *var,
                   void (*update)(PnP_SliderOp op, Rect *where, int val, int data), int data, ulong flags)
{
   CycleGadgDesc cdesc = { {0,}, NULL, stupid_arrows, string_cycle_cb, };
   StringCycleGadgDesc sdesc;
   CycleData<int>* cyc = (CycleData<int>*)Malloc(sizeof(*cyc));
   
   CycleGadg* gadg;
   int w=_slider_build_name(space,name,4,NULL);

   // now build the cyclegadg
   cdesc.bounds = *space;
   cdesc.bounds.ul.x += w;
   cdesc.var = var;
   cdesc.user_data = cyc;
   cdesc.flags = PNP_CYCLE_FLAGS; 
   if (flags & (PNP_SLIDER_CLICKS|PNP_SLIDER_MENU))
      cdesc.flags |= CYCLE_NONPOTENT_FLAG;
   
   memset(&sdesc,0,sizeof(sdesc));
   sdesc.strings = vals;
   sdesc.num = num;
   if (flags & PNP_SLIDER_WRAP)
      sdesc.flags |= STRING_CYCLE_WRAP;
   if (flags & PNP_SLIDER_MENU)
      sdesc.flags |= STRING_CYCLE_MENU;

   cyc->update = update;
   cyc->data = data;

   gadg = CreateStringCycleGadg(NULL,curPnP->_root,&cdesc,&sdesc);
   _PnP_Register(gadg,PnP_REGSLIDERString);
   return curPnP->GadgOwner++;
}

EXTERN void PnP_SliderStringDestroy(void* p)
{
   CycleGadg* gadg = (CycleGadg*)p;
   void* data = StringCycleGadgData(gadg);
   DestroyStringCycleGadg(gadg);
   Free(data);
}

EXTERN void PnP_StringSliderUpdate(void *g, void *data) 
{ 
   CycleGadg *gadg = (CycleGadg *)g;
   UpdateCycleGadg(gadg,TRUE);
}

EXTERN void PnP_StringSliderSetStrings(void* g, char** strings, int num)
{
   CycleGadg* gadg = (CycleGadg *)g;
   RedescribeStringCycleGadg(gadg,strings,num);
}



////////////////////////////////////////////////////////////
// SPECIAL FIXANG GADGET
// 

#define TOFIXANG(x)  (fixang)((x)*FIXANG_PI/180.0)
#define TOFLOAT(x)   ((float)(x)*180.0/FIXANG_PI)

//
// What we want is a float slider that secretly converts to fixang on the way out. 
//

typedef SLIDER_INSTANCE(float) fSlider;

struct DegreeSlider : public fSlider
{
   float fakevar;
   void (*real_update)(PnP_SliderOp op, Rect* where, fixang val, int data); 
   fixang* realvar;
   int realdata;
      
   DegreeSlider(Rect* space, char* name, fixang lo, fixang hi, float scale, fixang* var,
       void(*update)(PnP_SliderOp op, Rect* where, fixang val, int data), 
       int data, ulong flags);
   static void fake_update(PnP_SliderOp op, Rect* where, float val, int data); 
};

DegreeSlider::DegreeSlider(Rect* space, char* name, fixang lo, fixang hi, float scale, fixang* var,
       void(*update)(PnP_SliderOp op, Rect* where, fixang val, int data), 
       int data, ulong flags) 
: fakevar(TOFLOAT(*var)),
  realvar(var),
  real_update(update),
  realdata(data),
  fSlider(space,name,TOFLOAT(lo),TOFLOAT(hi),TOFLOAT(scale),&fakevar,fake_update,(int)this,flags,"%3.2f")
{
   // send update messages even when others wouldn't want them.
   //   _data.send_updates = TRUE;
   Update(this,NULL);
}

void DegreeSlider::fake_update(PnP_SliderOp op, Rect* where, float val, int data)
{
   DegreeSlider* s = (DegreeSlider*)data;


   *s->realvar = TOFIXANG(val);

   if (s->real_update != NULL)
      s->real_update(op,where,TOFIXANG(val),s->realdata);
}

EXTERN int PnP_SliderFixang(Rect* space, char* name, fixang lo, fixang hi, fixang scale, fixang *var, \
                     void (*update)(PnP_SliderOp op, Rect* where, fixang val, int data), int data, ulong flags) 
{ 
   DegreeSlider* slider; 
   slider = new DegreeSlider(space,name,lo,hi,scale,var,update,data,flags); 
   return slider->Register(PnP_REGSLIDERfixang);
}

EXTERN void PnP_SliderfixangDestroy(void* p) 
{  
   delete (DegreeSlider*)p; 
}

EXTERN void PnP_fixangSliderUpdate(void *g, void *arg) 
{ 
   DegreeSlider* s = (DegreeSlider*)g;
   s->fakevar = TOFLOAT(*s->realvar);
   DegreeSlider::Update(g,arg); 
}



// $Header: r:/t2repos/thief2/src/editor/pnptools.c,v 1.26 2000/02/19 13:11:12 toml Exp $
// tools for PnP maintenance

#include <float.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include <rect.h>
#include <config.h>
#include <gadblist.h>
#include <lgsprntf.h>
#include <cyclegad.h>
#include <command.h>
#include <guistyle.h>
#include <uiedit.h>

#include <brushGFH.h>
#include <PnPtools.h>
#include <pnptool_.h>
#include <pnpvslid.h>
#include <vslider.h>
#include <viewmgr.h>

#include <mprintf.h>
#include <editor.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// this is the easy one, for rectangle building
// note that bx is really on both sides, where by is only on the top
void buildYLineRect(Rect *fill, Rect *src, int vline, float hsplit, int side, int bx, int by)
{
   // use vline for Y
   fill->ul.y=src->ul.y+(RectHeight(src)*vline/NUM_LINES)+by;
   fill->lr.y=src->ul.y+(RectHeight(src)*(vline+1)/NUM_LINES)-1;
   if (side)
   {
      fill->ul.x=src->ul.x+(int)(RectWidth(src)*hsplit);
      fill->lr.x=src->lr.x;
   }
   else
   {
      fill->ul.x=src->ul.x;
      fill->lr.x=src->ul.x+(int)(RectWidth(src)*hsplit);
   }
   fill->ul.x+=bx;
   fill->lr.x-=bx;
}

void PnP_ExecCommandInt(char *cmd, int val)
{
   char pbuf[16];
   itoa(val,pbuf,10);
   if (!CommandExecuteParam(cmd,pbuf))
      Warning(("Couldnt find command <%s> to execute (w/%d)",cmd,val));
}

void PnP_ExecCommandFloat(char *cmd, float val)
{
   char pbuf[24];
   gcvt(val,10,pbuf);
   if (!CommandExecuteParam(cmd,pbuf))
      Warning(("Couldnt find command <%s> to execute (w/%s)",cmd,pbuf));
}

////////////////////////////////////////////////
// from here on down are the hideous shell layer
// on top of the real gadget stuff

_PnP_GadgData *curPnP;

// redraw functions are down at the bottom of the file

// void PnP_GadgFree(void) is down at the bottom of the file

void PnP_SetCurrent(_PnP_GadgData *thePnP)
{
   curPnP=thePnP;
}

void PnP_GadgStart(_PnP_GadgData *thePnP, LGadRoot *root)
{
   if (thePnP==NULL)
   {
      Warning(("Hey, start called with no curPnP!"));
      return;
   }
   if (thePnP->GadgIdx>0)      
   {
      Warning(("Hey, start called while active PnP gadgs are around!"));
      PnP_GadgFree(thePnP);
   }
   thePnP->GadgIdx=thePnP->GadgOwner=0;
   thePnP->_root=root;
   PnP_SetCurrent(thePnP);
}

// for now, we ignore type, since we only do boxes
void _PnP_Register(void *gadg, int type)
{
   if (curPnP->GadgIdx==MAX_PNP_GADG)
      Warning(("Out of PnP Gadget Space"));
   curPnP->GadgType[curPnP->GadgIdx] = type;
   curPnP->GadgSrc[curPnP->GadgIdx]=curPnP->GadgOwner;
   curPnP->GadgPtr[curPnP->GadgIdx++]=gadg;
}

////////////////////////
// picture box

typedef struct {
   void (*draw_me)(int data);
   int data;
} pictureInfo;

static void _pnp_picture_box_draw(void *data, LGadBox *box)
{
   pictureInfo *our_pi=LGadBoxGetUserData(VB(box));
   if (our_pi->draw_me!=NULL)
      (*our_pi->draw_me)(our_pi->data);
}

// installs a picture frame at space, with an update/render callback of draw
int PnP_PictureBox(Rect *space, void (*draw)(int data), int data)
{
   pictureInfo *our_pi=(pictureInfo *)Malloc(sizeof(pictureInfo));
   LGadBox *gadg;
   
   gadg=LGadCreateBox(NULL,curPnP->_root,
      space->ul.x,space->ul.y,(short)RectWidth(space),(short)RectHeight(space),
      NULL,NULL,_pnp_picture_box_draw,0);
   our_pi->draw_me=draw;
   our_pi->data=data;
   LGadBoxSetUserData(gadg,our_pi);
   _PnP_Register(gadg,PnP_REGPICTURE);
   return curPnP->GadgOwner++;
}

static void _PnP_PictureDestroy(void *g)
{
   void *ptr = LGadBoxGetUserData(VB(g));
   LGadDestroyBox(VB(g),TRUE);
   Free(ptr);
}

static void _PnP_PictureUpdate(void *g, void *data)
{
   pictureInfo *our_pi=LGadBoxGetUserData(VB(g));
   if (data!=NULL)
   {
      our_pi->data=(int)data;
      LGadBoxSetUserData(VB(g),our_pi);
   }
   LGadDrawBox(VB(g),NULL);
}

/////////////////////////////////////////////
// text boxes

void _pnp_textbox(Rect *space, char *text)
{
   LGadButton *gadg;
   DrawElement draw; 
   ElementClear(&draw); 
   draw.draw_type = DRAWTYPE_TEXT; 
   draw.draw_data = text;
   // attempt to make textboxes clearly non-interactive
   //   draw.draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);
   draw.bcolor = guiStyleGetColor(NULL,StyleColorBG2);
   
   gadg=LGadCreateButtonArgs(NULL,curPnP->_root,
      space->ul.x,space->ul.y,(short)RectWidth(space),(short)RectHeight(space),&draw,NULL,0);
   // watch while we turn this ordinary button into an inert, listless textbox...
   LGadButtonSetFlags(gadg,LGADBUTT_FLAG_STATELESS); 

   _PnP_Register(gadg,PnP_REGTEXTBOX);
}

int PnP_TextBox(Rect *space, char *text)
{
   _pnp_textbox(space,text);
   return curPnP->GadgOwner++;
}

void PnP_TextBoxDestroy(void *g)
{
   LGadDestroyBox(VB(g),TRUE);
}

void PnP_TextBoxUpdate(void *g, void *data)
{
   if (data!=NULL)
      LGadButtonDrawElem(VB(g)).draw_data=data;
   LGadDrawBox(VB(g),NULL);
}

////////////////////////////////////////////////////////////
// TOGGLE TOOL

typedef struct _toggle_data
{
   char* strings[2];
   bool* var;
   int realvar;
   void (*update)(Rect* , bool, int);
   int data;
} toggle_data;

static void toggle_update_elem(LGadToggle* gadg)
{
   toggle_data* tog = (toggle_data*)LGadBoxGetUserData(VB(gadg));
   DrawElement* elem = &BUTTON_DRAWELEM(gadg);
   char* newstring = tog->strings[tog->realvar];
   if (newstring != NULL)
   {
      elem->draw_data = newstring;
      elem->fcolor = 0;
   }
   else 
   {
      elem->fcolor = guiStyleGetColor(NULL,StyleColorHilite);
   }
}

static bool toggle_call(short action, void* data, LGadBox* vb)
{
   toggle_data* tog = (toggle_data*)LGadBoxGetUserData(vb);
   if (action & (MOUSE_LUP|MOUSE_RUP))
   {
      LGadToggle* gadg = (LGadToggle*)vb;
      toggle_update_elem(gadg);

      LGadDrawBox(vb,NULL);
      *tog->var = tog->realvar;
      if (tog->update)
         tog->update(BOX_RECT(vb),*tog->var,tog->data);
      return TRUE;
   }
   return FALSE;
}

// a 0-1 toggle which is a bool, at space, calls update if non null w/data

int PnP_ButtonToggle(Rect *space, char *off, char *on, bool *var,
                  void (*update)(Rect *where, bool val, int data), int data)
{
   toggle_data* tog = Malloc(sizeof(toggle_data));
   LGadToggle* gadg;
   DrawElement draw;
   
                                           
   tog->strings[0] = off;
   tog->strings[1] = on;
   if (*var != 0) *var = TRUE;  // lets range check
   tog->var = var;
   tog->realvar = *var;
   tog->update = update;
   tog->data = data;
   ElementClear(&draw);
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = tog->strings[*var];
   if (draw.draw_data == NULL)
   {
      draw.draw_data = tog->strings[!*var];
      draw.fcolor = guiStyleGetColor(NULL,StyleColorHilite);
   }
   draw.draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);
   
   gadg = LGadCreateToggleArgs(NULL,curPnP->_root,space->ul.x,space->ul.y,
                               (short)RectWidth(space),(short)RectHeight(space),
                               &draw,toggle_call,&tog->realvar,2,1,0);
   LGadBoxSetUserData(VB(gadg),tog);
   _PnP_Register(gadg,PnP_REGTOGGLE);
   return curPnP->GadgOwner++;
}

void PnP_ButtonToggleDestroy(void* g)
{
   void *ptr = LGadBoxGetUserData(VB(g));
   LGadDestroyBox(VB(g),TRUE);
   Free(ptr);
}

void PnP_ButtonToggleUpdate(void* g, void *data)
{
   toggle_data *tog=LGadBoxGetUserData(VB(g));
   LGadToggle* gadg = (LGadToggle*)VB(g);
   if (data!=NULL)
      tog->var=(bool *)data;
   tog->realvar=*tog->var;
   toggle_update_elem(gadg);
   LGadDrawBox(VB(g),NULL);
}

////////////////////////////////////////////////////////////
// ONE SHOT TOOL 

typedef struct _oneshotdata
{
   void (*shoot)(int);
   int data;
} oneshotdata;

bool pnp_oneshot_cb(short action, void* data, LGadBox* vb)
{
   oneshotdata *shooter = (oneshotdata*)LGadBoxGetUserData(vb);
   
   if (action & (MOUSE_LUP|MOUSE_RUP))
   {
      shooter->shoot(shooter->data);
      return TRUE;
   }
   return FALSE;
}

void _PnP_ButtonOneShot(Rect *space, char *name, void (*shoot)(int data), int data)
{
   oneshotdata* shooter = Malloc(sizeof(oneshotdata));
   DrawElement draw; 
   LGadButton* gadg;
   
   shooter->shoot = shoot;
   shooter->data = data;
   
   ElementClear(&draw);
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = name;
   draw.draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);

   gadg = LGadCreateButtonArgs(NULL,curPnP->_root,space->ul.x,space->ul.y,
                               (short)RectWidth(space),(short)RectHeight(space),
                               &draw,pnp_oneshot_cb,0);
   LGadBoxSetUserData(VB(gadg),shooter);
   _PnP_Register(gadg,PnP_REGONESHOT);
}


int PnP_ButtonOneShot(Rect *space, char *name, void (*shoot)(int data), int data)
{
   _PnP_ButtonOneShot(space,name,shoot,data);
   return curPnP->GadgOwner++;
}

void PnP_ButtonOneShotDestroy(void* g)
{
   void *ptr = LGadBoxGetUserData(VB(g));
   LGadDestroyBox(VB(g),TRUE);
   Free(ptr);
}

void PnP_ButtonOneShotUpdate(void* g, void *data)
{
   // not sure what to do here with data
   LGadDrawBox(VB(g),NULL);
}

////////////////////////////////////////////////////////////
// virtual slider sub-gadget
//



// I'd like to apologize in advance to anyone who has to port this code.

static pnp_vslider_data* the_slider_data;

static void pnp_vslider_func(void)
{
   pnp_vslider_data* data = the_slider_data;
   vm_render_cameras(); 
   if (data->update_func != NULL)
      data->update_func(data->update_gadg,data->update_data);
}

static bool vslider_cb(short action, void* arg, LGadBox* vb)
{
   pnp_vslider_data* data = (pnp_vslider_data*)LGadBoxGetUserData(vb);
   if (data != NULL && action & (MOUSE_LDOWN|MOUSE_RDOWN|MOUSE_CDOWN))
   {
      the_slider_data = data;
      virtual_slider(1,&data->slider,pnp_vslider_func);
      return TRUE;
   }
   return FALSE;
}

void _pnp_vslider(Rect* area, char* title, pnp_vslider_data* _data)
{
   pnp_vslider_data* data = _data;
   DrawElement draw;
   void* gadg;
   
   if (_data != NULL)
   {
      data = Malloc(sizeof(*data)); 
      *data = *_data;
   }

   ElementClear(&draw);
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = title;
   draw.draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);

   gadg=LGadCreateButtonArgs(NULL,curPnP->_root,
        area->ul.x,area->ul.y,(short)RectWidth(area),(short)RectHeight(area),&draw,
        vslider_cb,0);                     
   if (data != NULL)
      LGadButtonSetFlags(gadg,LGADBUTT_FLAG_GETDOWNS);
   else
      LGadButtonSetFlags(gadg,LGADBUTT_FLAG_STATELESS);
   LGadBoxSetUserData(VB(gadg),data);

   _PnP_Register(gadg,PnP_REGVSLIDER);
}

void _pnp_vslider_update(void* g, void* arg)
{
   pnp_vslider_data* data = (pnp_vslider_data*)LGadBoxGetUserData(VB(g));
   if (data != NULL)
   {
      data->slider->parse(0,data->slider,SLIDER_UPDATE);
   }
}

void _pnp_vslider_destroy(void* g)
{
   pnp_vslider_data* data = (pnp_vslider_data*)LGadBoxGetUserData(VB(g));
   if (data != NULL)
   {
      Free(data->slider);
      Free(data);
   }
   LGadDestroyBox(VB(g),TRUE);
}

////////////////////////////////////////////////////////////
// Slider generics
////////////////////////////////////////////////////////////

#define DeclareCycleUpdate(type) \
EXTERN void PnP_##type##SliderUpdate(void *g, void *arg) 

#define DeclareCycleDestroy(type) \
EXTERN void PnP_Slider##type##Destroy(void* p)




//////////////////////////////////
// float Sliders

DeclareCycleUpdate(float);
DeclareCycleDestroy(float);


////////////////////////////////////////////////////////////
// int sliders

DeclareCycleUpdate(int); 
DeclareCycleDestroy(int);


//////////////////////////////////
// short Sliders

DeclareCycleUpdate(short); 
DeclareCycleDestroy(short);

//////////////////////////////////
// fixang??? Sliders

DeclareCycleUpdate(fixang); 
DeclareCycleDestroy(fixang);


////////////////////////////////////////////////////////////
// String Slider
//


DeclareCycleUpdate(String);
DeclareCycleDestroy(String);

//
// Destroy funcs
//


void (*PnP_GadgDestroy[])(void *g)=
{
   PnP_TextBoxDestroy,
   PnP_ButtonToggleDestroy,
   PnP_ButtonOneShotDestroy,
   PnP_SliderfloatDestroy,
   PnP_SliderintDestroy,   
   PnP_SlidershortDestroy,
   PnP_SliderfixangDestroy,
   _PnP_PictureDestroy,
   PnP_SliderStringDestroy,
   _pnp_vslider_destroy,
};


#define NUM_GADGDESTROYS (sizeof(PnP_GadgDestroy)/sizeof(PnP_GadgDestroy[0]))

///////////////////////////////////
// Free all current gadgets
void PnP_GadgFree(_PnP_GadgData *thePnP)
{
   int cur;
   while (--thePnP->GadgIdx>=0)
   {
      cur=thePnP->GadgType[thePnP->GadgIdx];
      if ((cur>=0)&&(cur<NUM_GADGDESTROYS))
         (*PnP_GadgDestroy[cur])(thePnP->GadgPtr[thePnP->GadgIdx]);
      else
         Free(thePnP->GadgPtr[thePnP->GadgIdx]);
   }
}

void (*PnP_GadgUpdate[])(void *g, void *data)=
{
   PnP_TextBoxUpdate,
   PnP_ButtonToggleUpdate,
   PnP_ButtonOneShotUpdate,
   PnP_floatSliderUpdate,
   PnP_intSliderUpdate,
   PnP_shortSliderUpdate,
   PnP_fixangSliderUpdate,
   _PnP_PictureUpdate,
   PnP_StringSliderUpdate,
   _pnp_vslider_update,
};

#define NUM_GADGUPDATES (sizeof(PnP_GadgUpdate)/sizeof(PnP_GadgUpdate[0]))

static void _pnp_updateidx(_PnP_GadgData *thePnP, int idx, void *data)
{
   int cur=thePnP->GadgType[idx];
   if ((cur>=0)&&(cur<NUM_GADGUPDATES))
      (*PnP_GadgUpdate[cur])(thePnP->GadgPtr[idx],data);
   else
      Warning(("Hey, trying to update invalid Gadget type %d at %d\n",cur,idx));
}

void PnP_Redraw(int Owner, void *data)
{
   int i;
   if (Owner>=curPnP->GadgOwner) return;
   for (i=0; i<curPnP->GadgIdx; i++)
      if (curPnP->GadgSrc[i]==Owner)
         _pnp_updateidx(curPnP,i,data);
      else if (curPnP->GadgSrc[i]>Owner)
         break; // they are sorted, so we are done
   return;
}

void PnP_FullRedraw(_PnP_GadgData *thePnP)
{
   int i;
   for (i=0; i<thePnP->GadgIdx; i++)
      _pnp_updateidx(thePnP,i,NULL);
}

void PnP_Hide(int Owner, bool which)
{
   int i;
   if (Owner>=curPnP->GadgOwner) return;
   for (i=0; i<curPnP->GadgIdx; i++)
      if (curPnP->GadgSrc[i]==Owner)
         LGadHideBox(VB(curPnP->GadgPtr[i]),which);
      else if (curPnP->GadgSrc[i]>Owner)
         break; // they are sorted, so we are done
   return;
}

void *PnP_GetStringSubGadget(int Owner)
{
   int i;
   if (Owner>=curPnP->GadgOwner) return NULL;
   for (i=0; i<curPnP->GadgIdx; i++)
   {
      if (curPnP->GadgSrc[i]==Owner)
         if (curPnP->GadgType[i]==PnP_REGSLIDERString)
            return (void *)curPnP->GadgPtr[i];
      if (curPnP->GadgSrc[i]>Owner)
         break;
   }
   return NULL;
}
// $Header: r:/t2repos/thief2/src/editor/pnptools.h,v 1.15 2000/01/29 13:12:52 adurant Exp $
// header for PnP maintenance tools
#pragma once

// the PnP has 7 virtual lines

#define NUM_LINES 7

////////////////////////////////////////
// misc usefulness
// note that bx is really on both sides, where by is only on the top
EXTERN void buildYLineRect(Rect *fill, Rect *src, int vline, float hsplit, int side, int bx, int by);

// these are sort of randomly here, but convienient
EXTERN void PnP_ExecCommandInt(char *cmd, int val);
EXTERN void PnP_ExecCommandFloat(char *cmd, float val);

////////////////////////////////////////
// here come all the actual PnP tools

// what a PnP looks like, really
// this is only so you can Malloc them outside
// i suppose i could have a getPnPSize call.
// anyway, dont screw with these yourself, sheesh
// hmmmmm

#define MAX_PNP_GADG 48

typedef struct {
   void     *GadgPtr[MAX_PNP_GADG];
   int       GadgType[MAX_PNP_GADG];
   int       GadgSrc[MAX_PNP_GADG];
   int       GadgIdx;
   int       GadgOwner;
   LGadRoot *_root;
   void     *userData;
} _PnP_GadgData;

EXTERN void PnP_SetCurrent(_PnP_GadgData *thePnP);

// redraw tools for updating the gadgets
EXTERN void PnP_FullRedraw(_PnP_GadgData *thePnP);
EXTERN void PnP_Redraw(int Owner, void *data);
EXTERN void PnP_Hide(int Owner, bool hide_or_show); // true is hide
   
// call when starting or freeing a gadget list
// note start implicitly calls SetCurrent, ie it SetCurrent(thePnP)'s at end
EXTERN void PnP_GadgStart(_PnP_GadgData *thePnP, LGadRoot *root);
EXTERN void PnP_GadgFree(_PnP_GadgData *thePnP);

// installs a picture frame at space, with an update/render callback of draw
EXTERN int PnP_PictureBox(Rect *space, void (*draw)(int data), int data);
EXTERN int PnP_TextBox(Rect *space, char *text);

// a 0-1 toggle which is a bool, at space, calls update if non null w/data
EXTERN int PnP_ButtonToggle(Rect *space, char *off, char *on, bool *var,
                  void (*update)(Rect *where, bool val, int data), int data);
EXTERN int PnP_ButtonOneShot(Rect *space, char *name, void (*shoot)(int data), int data);

// ranged slider, calls update w/data, scale is set, 
typedef enum _PnP_SliderOp
{
   PnP_SliderUpdateOp, // value has been updated
   PnP_SliderClickOp,  // we've been clicked.
} PnP_SliderOp;

#define PNP_SLIDER_WRAP   0x1
#define PNP_SLIDER_VSLIDE 0x2 
#define PNP_SLIDER_MENU   0x4 // strings only
#define PNP_SLIDER_CLICKS 0x8 // get click events


EXTERN int PnP_SliderFloat(Rect *space, char *name, float lo, float hi, float scale, float *var,
                     void (*update)(PnP_SliderOp op, Rect *where, float val, int data), int data, ulong flags);
EXTERN int PnP_SliderInt(Rect *space, char *name, int lo, int hi, int scale, int *var,
                   void (*update)(PnP_SliderOp op, Rect *where, int val, int data), int data, ulong flags);
EXTERN int PnP_SliderFixang(Rect *space, char *name, ushort lo, ushort hi, ushort scale,
                            ushort *var, void (*update)(PnP_SliderOp op, Rect *where, ushort val, int data), 
                            int data, ulong flags);
EXTERN int PnP_SliderShort(Rect *space, char *name, short lo, short hi, short scale, 
                           short *var, void (*update)(PnP_SliderOp op, Rect *where, short val, int data), 
                           int data, ulong flags);

EXTERN int PnP_SliderString(Rect *space, char *name,  int num, char** vals, int *var, 
                     void (*update)(PnP_SliderOp op, Rect *where, int val, int data), int data, ulong flags);

// dynamic string length resetting code
EXTERN void PnP_StringSliderSetStrings(void* g, char** strings, int num);
EXTERN void *PnP_GetStringSubGadget(int owner);

// this hateful macro is a utility for synching variables

// this should be a function, but its a macro since it wants to work for all types
// note it changes changed, and glob and loc and such
#define _varforPnP_synch(Glob,Loc,update,owner,changed) \
   if (Glob!=Loc)                                    \
   {                                                 \
      if (update)                                    \
         Glob=Loc;                                   \
      else                                           \
         Loc=Glob;                                   \
      PnP_Redraw(owner,NULL);                        \
      changed=TRUE;                                  \
   }

// these are to use in watcom, so you dont get always false warnings
#define _varforPnP_synch_FALSE(Glob,Loc,owner,changed) \
   if (Glob!=Loc)                                    \
   {                                                 \
      Loc=Glob;                                      \
      PnP_Redraw(owner,NULL);                        \
      changed=TRUE;                                  \
   }

#define _varforPnP_synch_TRUE(Glob,Loc,owner,changed) \
   if (Glob!=Loc)                                    \
   {                                                 \
      Glob=Loc;                                      \
      PnP_Redraw(owner,NULL);                        \
      changed=TRUE;                                  \
   }
// $Header: r:/t2repos/thief2/src/editor/pnptool_.h,v 1.4 2000/01/29 13:12:53 adurant Exp $
#pragma once

#ifndef __PNPTOOL__H
#define __PNPTOOL__H

extern _PnP_GadgData *curPnP;

// register codes, for freeing
#define PnP_REGTEXTBOX          0
#define PnP_REGTOGGLE           1
#define PnP_REGONESHOT          2
#define PnP_REGSLIDERfloat      3
#define PnP_REGSLIDERint        4
#define PnP_REGSLIDERshort      5
#define PnP_REGSLIDERfixang     6
#define PnP_REGPICTURE          7
#define PnP_REGSLIDERString     8
#define PnP_REGVSLIDER          9 

EXTERN void _PnP_Register(void* gadg, int type);

#endif // __PNPTOOL__H
// $Header: r:/t2repos/thief2/src/editor/pnpvslid.h,v 1.3 2000/01/29 13:12:54 adurant Exp $
#pragma once

#ifndef __PNPVSLID_H
#define __PNPVSLID_H

#include <vslider.h>

typedef struct _pnp_vslider_data
{
   anonSlider* slider;
   void* update_gadg; 
   void (*update_func)(void* g, void* data);
   void* update_data;
} pnp_vslider_data;

EXTERN void _pnp_vslider(Rect* area, char* title, pnp_vslider_data* _data);
EXTERN void _pnp_vslider_destroy(void* g);



#endif // __PNPVSLID_H
// $Header: r:/t2repos/thief2/src/editor/preload.c,v 1.9 2000/02/19 13:11:13 toml Exp $
// stupid preloading system
//
// @TBD (justin 6-26-98): This can probably go away entirely once the
// resource system is fully functional. As of this writing, AsyncPreload()
// fails on two counts -- the ARQ is currently non-funct in the resource
// system, and the shared cache (essential to preloading) isn't there.
// However, both should be in before Dark ships, so AsyncPreload() and/or
// plain Preload() should be able to deal with this functionality better.
//

#include <string.h>

#include <lg.h>
#include <mprintf.h>
#include <appagg.h>

#include <preload.h>

#include <resapi.h>
#include <binrstyp.h>
#include <sndrstyp.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static int  hand_cnt=0, hand_sz=0;
static IRes **hand_pre=NULL;

static int  preload_size=0;
static BOOL preload_unknown=FALSE;

BOOL preload_data(int type_code, char *name, char *aux)
{
   char *lr_type;
   char pre_path[256];
   IRes *pRes;
   IResMan *pResMan = AppGetObj(IResMan);

   pre_path[0] = '\0';

   switch (type_code)
   {
      case PRELOAD_SOUND: 
         lr_type=RESTYPE_SOUND; 
         strcpy(pre_path,"snd/"); 
         break;

      case PRELOAD_BIN:
         lr_type=RESTYPE_BINARY;
         strcpy(pre_path,aux);
         break;

      default: 
         return FALSE;
   }
   pRes = IResMan_Bind(pResMan, name, lr_type, NULL, pre_path, 0);
   if (!pRes)
   {
      Warning(("preload failed for %s (type %d - auxpath %s)\n",name,type_code,aux?aux:"NULL"));
      return FALSE;
   }
   if (hand_cnt==hand_sz)
   {
      hand_sz+=128;
      if (hand_cnt==0)
         hand_pre=(IRes **)Malloc(sizeof(IRes *)*hand_sz);
      else
         hand_pre=(IRes **)Realloc(hand_pre,sizeof(IRes *)*hand_sz);
   }
   if (hand_pre==NULL)
   {
      SafeRelease(pRes);
      return FALSE;
   }
   IRes_Lock(pRes);
   hand_pre[hand_cnt++]=pRes;
   if (IRes_GetSize(pRes)!=0)
      preload_size+=IRes_GetSize(pRes);
   else
      preload_unknown=TRUE;
   return TRUE;
}

void preload_free_all(void)
{
   if (hand_pre)
   {
      int i;
      for (i=0; i<hand_cnt; i++) {
         IRes_Unlock(hand_pre[i]);
         SafeRelease(hand_pre[i]);
      }
      Free(hand_pre);
   }
   hand_cnt=hand_sz=0;
   hand_pre=NULL;
   preload_size=0;
   preload_unknown=FALSE;
}

void preload_dump_stats(void)
{
   mprintf("Cur count %d, table size %d - using %s %d bytes of mem\n",
      hand_cnt,hand_sz,preload_unknown?"At least":"Exactly",preload_size);
}
// $Header: r:/t2repos/thief2/src/editor/preload.h,v 1.2 2000/01/29 13:12:56 adurant Exp $
// stupid preloading system
#pragma once

#ifndef __PRELOAD_H
#define __PRELOAD_H

EXTERN BOOL preload_data(int type_code, char *name, char *aux);
EXTERN void preload_free_all(void);

// type codes
#define PRELOAD_SOUND 0x01
#define PRELOAD_BIN   0x02

#endif  // __PRELOAD_H
// $Header: r:/t2repos/thief2/src/editor/primal.c,v 1.11 2000/02/19 13:11:14 toml Exp $
// primal brush systems

#include <malloc.h>
#include <string.h>
#include <math.h>

#include <lg.h>
#include <r3d.h>
#include <matrix.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>

#include <primal.h>
#include <primals.h>
#include <primshap.h>
#include <primfast.h>

// exposed in primal.h for defines and such - look up an ID here
primalInfo *primals_list[2*(USED_PRIMAL_TYPES)][USED_PRIMAL_SIDES-2];

// for setting up default
static primalInfo default_primal={0,0,0,0,NULL,NULL,NULL,NULL};

////////////////////
// fast and unsafe system for editbr rendering use

// rest of this is in primfast.h macros
int *primalBrs_FU_faceedgebase=NULL;
primalInfo *primalBrs_FastUnsafe=NULL;
void primalBr_SetFastUnsafePrimal(int primal_id)
{
   primalBrs_FastUnsafe=getPrimInfo(primal_id);
}

/////////////////////
// internal utility stuff

// given a primalInfo with points edges and faces set up, allocate us the 3 arrays
BOOL _primalBr_GetMem(primalInfo *us)
{
   us->pt_array=(mxs_vector *)Malloc(sizeof(mxs_vector)*us->points);
   us->edge_list=(int *)Malloc(sizeof(int)*us->edges*2);  // each edge is 2 points
   us->face_pts_list=(int *)Malloc(sizeof(int)*us->faces*us->face_stride);
   us->face_edge_list=(int *)Malloc(sizeof(int)*us->faces*us->face_stride);
   return us->pt_array && us->edge_list && us->face_pts_list && us->face_edge_list;
}

// free the memory of the pointers in
void _primalBr_FreeMem(primalInfo *us)
{
   if (us->pt_array)  Free(us->pt_array);
   if (us->edge_list) Free(us->edge_list);
   if (us->face_pts_list) Free(us->face_pts_list);
   if (us->face_edge_list) Free(us->face_edge_list);
}

BOOL _primalBr_SzCheck(primalInfo *us)
{
   if (us->edges>MAX_PRIMAL_EDGES) return FALSE;
   if (us->faces>MAX_PRIMAL_FACES) return FALSE;
   if (us->points>MAX_PRIMAL_PTS) return FALSE;
   return TRUE;
}

//////////////////////
// startup and shutdown

// @TODO: add a save and load for primals to send them to disk and all

static BOOL cur_setup=FALSE;
static primalInfo cube, line, light,wedge,dodec;

#define PRIMAL_CNT_PER (USED_PRIMAL_SIDES-2)
static primalInfo vcyl[PRIMAL_CNT_PER], fcyl[PRIMAL_CNT_PER];
static primalInfo vpyr[PRIMAL_CNT_PER], fpyr[PRIMAL_CNT_PER];
static primalInfo vcpyr[PRIMAL_CNT_PER], fcpyr[PRIMAL_CNT_PER];

// NEED TO SET UP WHEN THIS IS CALLED/CLEARED
// setup the primal brush system
void primalBr_Init(void)
{
   int i;
   BOOL worked=TRUE;
   if (cur_setup) { Warning(("Yo - PrimalInit Again")); return; }
   worked&=PrimShape_CreateCube(&cube);    // setup the master cube of destruction
   worked&=PrimShape_CreateLine(&line);   
   worked&=PrimShape_CreateLight(&light);  // build the custom light shape
   worked&=PrimShape_CreateWedge(&wedge);
   worked&=PrimShape_CreateDodecahedron(&dodec);
   for (i=0; i<USED_PRIMAL_SIDES-3; i++)   // all the basics default to cube
      primals_list[0][i]=primals_list[1][i]=&cube;
   getPrimInfo(PRIMAL_LIGHT_IDX)=getPrimInfo(PRIMAL_LIGHT_IDX|PRIMAL_ALIGN_FACE)=&light;
   getPrimInfo(PRIMAL_LINE_IDX)=getPrimInfo(PRIMAL_LINE_IDX|PRIMAL_ALIGN_FACE)=&line;   
   // hm, are these actually the same when face aligned?
   getPrimInfo(PRIMAL_WEDGE_IDX)=getPrimInfo(PRIMAL_WEDGE_IDX|PRIMAL_ALIGN_FACE)=&wedge;
   getPrimInfo(PRIMAL_DODEC_IDX)=getPrimInfo(PRIMAL_DODEC_IDX|PRIMAL_ALIGN_FACE)=&dodec;
   for (i=0; i<PRIMAL_CNT_PER; i++)
   {
      worked&=PrimShape_CreateNGonCyl(&vcyl[i],i+3,FALSE);
      primals_list[PRIMAL_TYPE_CYLINDER*2+0][i]=&vcyl[i];
      worked&=PrimShape_CreateNGonCyl(&fcyl[i],i+3,TRUE);
      primals_list[PRIMAL_TYPE_CYLINDER*2+1][i]=&fcyl[i];

      worked&=PrimShape_CreateNGonPyr(&vpyr[i],i+3,FALSE,FALSE);
      primals_list[PRIMAL_TYPE_PYRAMID*2+0][i]=&vpyr[i];
      worked&=PrimShape_CreateNGonPyr(&fpyr[i],i+3,TRUE,FALSE);
      primals_list[PRIMAL_TYPE_PYRAMID*2+1][i]=&fpyr[i];

      worked&=PrimShape_CreateNGonPyr(&vcpyr[i],i+3,FALSE,TRUE);
      primals_list[PRIMAL_TYPE_CORNERPYR*2+0][i]=&vcpyr[i];
      worked&=PrimShape_CreateNGonPyr(&fcpyr[i],i+3,TRUE,TRUE);
      primals_list[PRIMAL_TYPE_CORNERPYR*2+1][i]=&fcpyr[i];
   }
   default_primal=cube;            // for now, to be safe
   cur_setup=TRUE;
   if (!worked)
      Warning(("Failed to correctly initialize all primal shapes\n"));
}

void primalBr_Term(void)
{
   int i;
   if (!cur_setup) { Warning(("Yo - PrimalTerm Again")); return; }   
   _primalBr_FreeMem(&cube);
   _primalBr_FreeMem(&line);
   _primalBr_FreeMem(&light);
   _primalBr_FreeMem(&wedge);
   _primalBr_FreeMem(&dodec);
   for (i=0; i<PRIMAL_CNT_PER; i++)
   {
      _primalBr_FreeMem(&vcyl[i]);
      _primalBr_FreeMem(&fcyl[i]);
      _primalBr_FreeMem(&vpyr[i]);
      _primalBr_FreeMem(&fpyr[i]);
      _primalBr_FreeMem(&vcpyr[i]);
      _primalBr_FreeMem(&fcpyr[i]);
      // ick - this is all super icky, argh
      primals_list[0][i]=primals_list[1][i]=
         primals_list[2][i]=primals_list[3][i]=
         primals_list[4][i]=primals_list[5][i]=
         primals_list[6][i]=primals_list[7][i]=NULL;
   }
   cur_setup=FALSE;   
}

/////////////////////
// actual accessors

// return the two brush points to use for this edge
int *primalBr_EdgePts(int primal, int edge_id)
{
   primalInfo *prim=getPrimInfo(primal);
   if (prim->edges>edge_id)
      return &prim->edge_list[edge_id*2];
   return NULL;
}

static int *primalBr_FaceData(primalInfo *prim, int *base_pt, int face_id, int *cnt)
{
   *cnt=0;
   if (prim->faces>face_id)
   {
      int i=0, *next_pt;
      base_pt+=face_id*prim->face_stride;
      next_pt=base_pt;
      while (((*cnt)<prim->face_stride)&&(*next_pt!=-1))
       {  next_pt++; (*cnt)++; }
      return base_pt;
   }
   return NULL;
}

// return the _cnt_ face points to use for this edge
int *primalBr_FacePts(int primal, int face_id, int *cnt)
{
   primalInfo *prim=getPrimInfo(primal);
   return primalBr_FaceData(prim,prim->face_pts_list,face_id,cnt);
}

int *primalBr_FaceEdges(int primal, int face_id, int *cnt)
{
   primalInfo *prim=getPrimInfo(primal);
   return primalBr_FaceData(prim,prim->face_edge_list,face_id,cnt);
}

// get the raw initial untransed point data for this primal brush point
mxs_vector *primalBr_GetRawPt(int primal, int pt_id)
{
   primalInfo *prim=getPrimInfo(primal);
   if (prim->points>pt_id)
      return &prim->pt_array[pt_id];
   return FALSE;
}

#ifdef DBG_ON
#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 
void primalBr_mprint(int primal_id)
{
   primalInfo *prim=getPrimInfo(primal_id);
   int i, j, next_val;
   
   mprintf("primal %d> pts %d edges %d faces %d stride %d\n",primal_id,prim->points,prim->edges,prim->faces,prim->face_stride);
   for (i=0; i<prim->points; i++)
      mprintf("     point %d> %g %g %g\n",i,prim->pt_array[i].x,prim->pt_array[i].y,prim->pt_array[i].z);
   for (i=0; i<prim->edges; i++)
      mprintf("      edge %d> %d %d\n",i,prim->edge_list[i*2],prim->edge_list[i*2+1]);
   for (i=0; i<prim->faces; i++)
   {
      mprintf(" face edge %d> ",i);
      j=0;
      while ((next_val=prim->face_edge_list[prim->face_stride*i+(j++)])!=-1)
         mprintf("%d ",next_val);
      mprintf("\n");
   }

   for (i=0; i<prim->faces; i++)
   {
      mprintf("   face pt %d> ",i);
      j=0;
      while ((next_val=prim->face_pts_list[prim->face_stride*i+(j++)])!=-1)
         mprintf("%d ",next_val);
      mprintf("\n");
   }
}
#endif

///////////////////////
// wacky get sets of points in world or local space stuff

// this whole in/out two arrays thing is super ugly
// but on the other hand dont want secret statics in here which you have to remember to expire
// or mallocs you have to free, so, for now, oh well, this is it

//#define DO_POS_QUANTIZE
#ifdef DO_POS_QUANTIZE
#define QUANTIZE 32
static mxs_vector *size_quantize(mxs_vector *in, mxs_vector *out)
{
   out->x = ((float) (int) (in->x*QUANTIZE)) / QUANTIZE;
   out->y = ((float) (int) (in->y*QUANTIZE)) / QUANTIZE;
   out->z = ((float) (int) (in->z*QUANTIZE)) / QUANTIZE;
   return out;
}
#else
static mxs_vector *size_quantize(mxs_vector *in, mxs_vector *out)
{
   *out=*in;
   return out;
}
#endif

void primalRawPart(int primal_id, mxs_vector *scale, mxs_vector *pts, int *pt_list, int cnt)
{
   primalInfo *prim=getPrimInfo(primal_id);
#ifdef DO_POS_QUANTIZE
   mxs_vector sz_mem;  // this is ifdefed to avoid unrefed var warnings if you make size_quantize deal
   mxs_vector *sz=size_quantize(scale,&sz_mem);
#else
   mxs_vector *sz=scale;
#endif
   int i;

   for (i=0; i<cnt; i++)
      mx_elmul_vec(&pts[i],sz,&prim->pt_array[pt_list[i]]);
}

// build the entire brushes point list, basically
int primalRawFull(int primal_id, mxs_vector *scale, mxs_vector *pts)
{
   primalInfo *prim=getPrimInfo(primal_id);
#ifdef DO_POS_QUANTIZE
   mxs_vector sz_mem;
   mxs_vector *sz=size_quantize(scale,&sz_mem);
#else
   mxs_vector *sz=scale;
#endif
   int i;

   for (i=0; i<prim->points; i++)
      mx_elmul_vec(&pts[i],sz,&prim->pt_array[i]);
   return i;
}
  
// world position build
void primalQuantizePos(editBrush *br, mxs_vector *pos)
{
   size_quantize(&br->pos,pos);
}

#define DO_ANG_QUANTIZE

#ifdef DO_ANG_QUANTIZE
// ok, legal angles for creation are 15/64ths of a degree (ANG_QUANTIZE_VAL)
// thus, we solve n(15/64)=360*(x/65536), or n=3x/128
// so, the angle we want is ang = floor(3x/128)*(15/64)
mxds_vector *ang_quantize(mxs_angvec *ang_in, mxds_vector *ang_out)
{
   ang_out->x=floor(((3.0*(double)ang_in->tx)/128.0)+0.5)*(15.0/64.0)*(MX_REAL_PI/180.0);
   ang_out->y=floor(((3.0*(double)ang_in->ty)/128.0)+0.5)*(15.0/64.0)*(MX_REAL_PI/180.0);
   ang_out->z=floor(((3.0*(double)ang_in->tz)/128.0)+0.5)*(15.0/64.0)*(MX_REAL_PI/180.0);
   return ang_out;
}
#else  // DO_ANG_QUANTIZE
mxds_vector *ang_quantize(mxs_angvec *ang_in, mxds_vector *ang_out)
{
   ang_out->x=((double)ang_in->tx/65536.0)*MX_REAL_2PI;
   ang_out->y=((double)ang_in->ty/65536.0)*MX_REAL_2PI;
   ang_out->z=((double)ang_in->tz/65536.0)*MX_REAL_2PI;
   return ang_out;
}
#endif // DO_ANG_QUANTIZE

void primalQuantizeAng(mxs_angvec *ang_in, mxds_vector *ang_out)
{
   ang_quantize(ang_in,ang_out);
}

///////////////////////////////////////////
///////////////////////////////////////////

void primalStartTransGroup(void)
 { r3_start_frame(); }

void primalFinishTransGroup(void)
 { r3_end_frame(); }

// setup a transform for this brush
static void _primalSetupTrans(editBrush *br, mxs_vector *pos)
{
   r3_start_object_angles(pos,&br->ang,R3_DEFANG);
}

// transform the cnt pts_in vectors to pts_out, grid snap on brush has been disabled for now
static void _primalDoTrans(editBrush *br, int cnt, mxs_vector *pts_in, mxs_vector *pts_out)
{
   int i;
   for (i=0; i<cnt; i++)
   {
      r3_transform_o2w(&pts_out[i],&pts_in[i]);
      if (br->grid.grid_enabled)                // who knows what is the point of this
         gedit_vertex_snap(&br->grid,&pts_out[i],&pts_out[i]);
   }
   r3_end_object();
}

// do primal build of world coordinates for a brush list
static void _primalBuildWorldPos(editBrush *br, int cnt, mxs_vector *pts_in, mxs_vector *pts_out)
{
   mxs_vector pos;

   primalQuantizePos(br,&pos);
   _primalSetupTrans(br,&pos);
   _primalDoTrans(br,cnt,pts_in,pts_out);
}

void primalTransBrush(editBrush *br, mxs_vector *world_pts)
{

}

// call these for standalone build of a given face or point
//
// These 2 Worlds get all points for the brush or part in world coordinates
// ie. one calls and pts is filled with the correct world space points
//
// a single element edge list is built and transformed
void primalWorldPart(editBrush *br, mxs_vector *pts, int *pt_list, int cnt)
{
   mxs_vector *wrld_pts;

   wrld_pts=(mxs_vector *)Malloc(cnt*sizeof(mxs_vector));
   primalRawPart(br->primal_id,&br->sz,wrld_pts,pt_list,cnt);
   _primalBuildWorldPos(br,cnt,wrld_pts,pts);
   Free(wrld_pts);
}

void primalWorldFull(editBrush *br, mxs_vector *pts)
{
   primalInfo *prim=getPrimInfo(br->primal_id);
   mxs_vector *wrld_pts;
   int pt_cnt=prim->points;

   wrld_pts=(mxs_vector *)Malloc(pt_cnt*sizeof(mxs_vector));
   primalRawFull(br->primal_id,&br->sz,wrld_pts);
   _primalBuildWorldPos(br,pt_cnt,wrld_pts,pts);
   Free(wrld_pts);      
}
// $Header: r:/t2repos/thief2/src/editor/primal.h,v 1.11 2000/01/29 13:12:57 adurant Exp $
// primal brush systems
#pragma once

// @TODO: these should look at current primal brushes
// not be brutally hardcoded to a cube

#ifndef __PRIMAL_H
#define __PRIMAL_H

#include <matrixs.h>
#include <matrixds.h>
#include <primals.h>
#include <editbrs.h>

///////////////////
// simple silly initializer
EXTERN void primalBr_Init(void);
EXTERN void primalBr_Term(void);

//////////// new hipper type/side info
#define primalID_Make(type,sides)          (((type)<<9)+(sides-3))
#define primalID_FullMake(type,face,sides) (primalID_Make(type,sides)|face)
#define primalID_GetType(id_val)           ((id_val)>>9)
#define primalID_GetSides(id_val)          (((id_val)&0xff)+3)
#define primalID_GetFaceAlign(id_val)      (((id_val)&PRIMAL_ALIGN_FACE)!=0)

#define primalID_GetSideCode(id_val)       ((id_val)&0xff)
#define primalID_InternalTypeCode(id_val)  (id_val>>8) /// cheat and know Type/Align are one big thing, eh?

#define PRIMAL_ALIGN_FACE     (0x100)

#define PRIMAL_CUBE_IDX       primalID_Make(PRIMAL_TYPE_SPECIAL,4)
#define PRIMAL_LIGHT_IDX      primalID_Make(PRIMAL_TYPE_SPECIAL,USED_PRIMAL_SIDES)     //12
#define PRIMAL_LINE_IDX       primalID_Make(PRIMAL_TYPE_SPECIAL,USED_PRIMAL_SIDES-1)   //11
#define PRIMAL_WEDGE_IDX      primalID_Make(PRIMAL_TYPE_SPECIAL,USED_PRIMAL_SIDES-2)   //10
#define PRIMAL_DODEC_IDX      primalID_Make(PRIMAL_TYPE_SPECIAL,USED_PRIMAL_SIDES-3)   //9


#define PRIMAL_TYPE_SPECIAL   (0)
#define PRIMAL_TYPE_CYLINDER  (1)
#define PRIMAL_TYPE_PYRAMID   (2)
#define PRIMAL_TYPE_CORNERPYR (3)
#define PRIMAL_TYPE_MAX       (4)

#define USED_PRIMAL_TYPES     (PRIMAL_TYPE_MAX)
#define USED_PRIMAL_SIDES     (12)          // for now, since we are keeping to editbr_ limit, eh

// the actual array of primals, should you need it
EXTERN primalInfo *primals_list[2*(USED_PRIMAL_TYPES)][USED_PRIMAL_SIDES-2];

#define getPrimInfo(prim_id) primals_list[primalID_InternalTypeCode(prim_id)][primalID_GetSideCode(prim_id)]

// various defines which might be useful
// really "unused", except to check in create stuff
#define MAX_PRIMAL_PTS        (64)
#define MAX_PRIMAL_EDGES     (128)
#define MAX_PRIMAL_FACES      (96)

//////////////////
// basic max counts and sizes
#define primalBr_PointCnt(i) (getPrimInfo(i)->points)
#define primalBr_EdgeCnt(i)  (getPrimInfo(i)->edges)
#define primalBr_FaceCnt(i)  (getPrimInfo(i)->faces)

/////////////////
// get at the shape data

// return the two brush points to use for this edge
EXTERN int *primalBr_EdgePts(int primal, int edge_id);

// return the _cnt_ points to use for this face
EXTERN int *primalBr_FacePts(int primal, int face_id, int *cnt);

// return the _cnt_ edges to use for this face
EXTERN int *primalBr_FaceEdges(int primal, int face_id, int *cnt);

////////////////
// get at point data, build world raw and full data

// get the raw initial untransed point data for this primal brush point
EXTERN mxs_vector *primalBr_GetRawPt(int primal, int pt_id);

// build all the points in brush br into array pts, returns the cnt used
EXTERN int primalRawFull(int primal, mxs_vector *scale, mxs_vector *pts);
EXTERN void primalRawPart(int primal, mxs_vector *scale, mxs_vector *pts, int *pt_list, int cnt);

// convert (via quantization) a brush pos to a usable world pos
EXTERN void primalQuantizePos(editBrush *br, mxs_vector *pos);
EXTERN void primalQuantizeAng(mxs_angvec *ang_in, mxds_vector *ang_out);

// tools for standalone transformation of primal (as brush) into world space
EXTERN void primalWorldPart(editBrush *br, mxs_vector *pts, int *pt_list, int cnt);
EXTERN void primalWorldFull(editBrush *br, mxs_vector *pts);

///////////////
// internal for use by other primal systems

// sanity checks a nascent primal brush for sizes of the face/pts/edges being cool
EXTERN BOOL _primalBr_SzCheck(primalInfo *us);

// get/free memory for a priminfo whose faces,pts,edges,and facestride are set
EXTERN BOOL _primalBr_GetMem(primalInfo *us);
EXTERN void _primalBr_FreeMem(primalInfo *us);

#ifdef DBG_ON
EXTERN void primalBr_mprint(int primal_id);
#endif
                            
#endif
// $Header: r:/t2repos/thief2/src/editor/primals.h,v 1.2 2000/01/29 13:12:58 adurant Exp $
// structures for primal brush system/setup
#pragma once

#ifndef __PRIMALS_H
#define __PRIMALS_H

#include <matrixs.h>

typedef struct {
   int points, edges, faces;
   int face_stride;      // number of edge or face entries per face, counting bonus -1 at end
   mxs_vector *pt_array; 
   int *edge_list;
   int *face_pts_list;
   int *face_edge_list;
} primalInfo;

#endif  // __PRIMALS_H
// $Header: r:/t2repos/thief2/src/editor/primfast.h,v 1.3 2000/01/29 13:12:59 adurant Exp $
// fast unsafe non checking primal brush use
// really just for editbr, which "knows what it is doing"
#pragma once

#ifndef __PRIMFAST_H
#define __PRIMFAST_H

#include <primals.h>

// setup for fast
EXTERN int *primalBrs_FU_faceedgebase;
EXTERN primalInfo *primalBrs_FastUnsafe;

EXTERN void primalBr_SetFastUnsafePrimal(int primal_id);

// get edge pt 0 or 1 (n) from edge (edge) of current unsafe prim
#define primFastUnsafe_EdgePt(edge,n)      primalBrs_FastUnsafe->edge_list[((edge)*2)+(n)]

// you first faceedgesetup the face... then you can reference FaceEdge(edge), -1 means we are out..
#define primFastUnsafe_FaceEdgeSetup(face) \
   primalBrs_FU_faceedgebase=&primalBrs_FastUnsafe->face_edge_list[(face)*primalBrs_FastUnsafe->face_stride]
#define primFastUnsafe_FaceEdge(edge)      primalBrs_FU_faceedgebase[edge]

#define primFastUnsafe_EdgeCnt()           primalBrs_FastUnsafe->edges
#define primFastUnsafe_PointCnt()          primalBrs_FastUnsafe->points
#define primFastUnsafe_FaceCnt()           primalBrs_FastUnsafe->faces  

#endif  // __PRIMFAST_H
// $Header: r:/t2repos/thief2/src/editor/primshap.c,v 1.12 2000/02/19 13:11:15 toml Exp $
// primshap(e)... code and data for generating the primal shapes

#include <string.h>
#include <stdlib.h>
#include <math.h>

#include <matrix.h>
#include <primal.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

///////////////////
// setup template silliness

// declare the base static setup, ie. the primalInfo inlined struct
#define _static_declare_base(NAME) \
  static primalInfo NAME##_base= \
    {##NAME##_PT_CNT,##NAME##_EDGE_CNT,##NAME##_FACE_CNT,##NAME##_FACE_PTS,NULL,NULL,NULL,NULL}

// various array declarations, here to be consistently named, and have array sizes hardcoded
#define _static_declare_edges(NAME) \
  static int NAME##_edge_list[##NAME##_EDGE_CNT*2]
#define _static_declare_face_pts(NAME) \
  static int NAME##_face_pts_list[##NAME##_FACE_CNT * ##NAME##_FACE_PTS]
#define _static_declare_face_edge(NAME) \
  static int NAME##_face_edge_list[##NAME##_FACE_CNT * ##NAME##_FACE_PTS]
#define _static_declare_pt_list(NAME) \
  static mxs_vector NAME##_pts_list[##NAME##_PT_CNT]

// memory setup ops
#define _build_named_primal(NAME,newprim) \
  do { \
     memcpy(newprim,&##NAME##_base,sizeof(primalInfo)); \
     if (!_primalBr_GetMem(newprim)) return FALSE; \
     memcpy(newprim->edge_list,##NAME##_edge_list,sizeof(##NAME##_edge_list)); \
     memcpy(newprim->face_pts_list,##NAME##_face_pts_list,sizeof(##NAME##_face_pts_list)); \
     memcpy(newprim->face_edge_list,##NAME##_face_edge_list,sizeof(##NAME##_face_edge_list)); \
     memcpy(newprim->pt_array,##NAME##_pts_list,sizeof(##NAME##_pts_list)); \
  } while (0)
  
///////////////////
// basic cube!

#define cube_PT_CNT     (8)
#define cube_EDGE_CNT  (12)
#define cube_FACE_CNT   (6)
#define cube_FACE_PTS (4+1)

// here is our primalInfo intself
_static_declare_base(cube);

_static_declare_edges(cube)=
 { 0,1, 1,2, 2,3, 3,0,
   0,4, 4,7, 7,3, 2,6,
   6,5, 5,1, 4,5, 6,7};
_static_declare_face_pts(cube)=
 { 0,1,2,3,-1,
   3,2,6,7,-1,
   7,6,5,4,-1,
   4,5,1,0,-1,
   1,5,6,2,-1,
   4,0,3,7,-1 };
_static_declare_face_edge(cube)=
 { 0,1,2,3,-1,
   2,7,11,6,-1,
   11,8,10,5,-1,
   10,9,0,4,-1,
   9,8,7,1,-1,
   4,3,6,5,-1 };
_static_declare_pt_list(cube)=
 { {-1,1,-1},{-1,1,1},{-1,-1,1},{-1,-1,-1},
   { 1,1,-1},{ 1,1,1},{ 1,-1,1},{ 1,-1,-1}};

BOOL PrimShape_CreateCube(primalInfo *new_cube)
{
   _build_named_primal(cube,new_cube);  // can return FALSE internally
   return TRUE;
}

/////////////////////
// look, a line - really just here to simplify some other code

#define line_PT_CNT     (2)
#define line_EDGE_CNT   (1)
#define line_FACE_CNT   (1)
#define line_FACE_PTS (2+1)

// here is our primalInfo intself
_static_declare_base(line);

_static_declare_edges(line)=
 { 0,1 };
_static_declare_face_pts(line)=
 { 0,1,-1 };
_static_declare_face_edge(line)=
 { 0,1,-1 };
_static_declare_pt_list(line)=
 { {-1,0,0},{1,0,0} };

BOOL PrimShape_CreateLine(primalInfo *new_line)
{
   _build_named_primal(line,new_line);  // can return FALSE internally
   return TRUE;
}

//////////////////////
// tri pyramid hack for test

#define tri_PT_CNT     (4)
#define tri_EDGE_CNT   (6)
#define tri_FACE_CNT   (4)
#define tri_FACE_PTS (3+1)

#define Root3Over2 (0.866025)
#define EdgeLn     (1.0)

// here is our primalInfo intself
_static_declare_base(tri);

_static_declare_edges(tri)=
 { 0,1, 1,2, 2,0, 3,2, 3,1, 0,3 };
_static_declare_face_pts(tri)=
 { 0,1,2,-1,
   2,1,3,-1,
   3,1,0,-1,
   0,2,3,-1 };
_static_declare_face_edge(tri)=
 { 0,1,2,-1,
   1,4,3,-1,
   4,0,5,-1,
   2,3,5,-1 };
_static_declare_pt_list(tri)=
 { {          0,   EdgeLn, -EdgeLn/2 },
   {-Root3Over2,-EdgeLn/2, -EdgeLn/2 },
   { Root3Over2,-EdgeLn/2, -EdgeLn/2 },
   {          0,        0,    EdgeLn } };

BOOL PrimShape_CreateTri(primalInfo *new_tri)
{
   _build_named_primal(tri,new_tri);
   return TRUE;
}

//////////////////////
// light

#define light_PT_CNT     (6)
#define light_EDGE_CNT   (3)
#define light_FACE_CNT   (1)
#define light_FACE_PTS   (1)

// here is our primalInfo intself
_static_declare_base(light);

_static_declare_edges(light)=
 { 0,1, 2,3, 4,5 };
_static_declare_face_pts(light)=
 { -1 };
_static_declare_face_edge(light)=
 { -1 };
_static_declare_pt_list(light)=
 { { 0, 1, 0}, { 0,-1, 0},
   { 1, 0, 0}, {-1, 0, 0},
   { 0, 0, 1}, { 0, 0,-1} };

BOOL PrimShape_CreateLight(primalInfo *new_light)
{
   _build_named_primal(light,new_light);
   return TRUE;
}

/////////////////////
// generic ngon basis stuff

// fill pts with an n-gon in xy with z coodinate z
static void build_ngon_base(int n, mxs_vector *pts, float z, BOOL face_align)
{
   double face_mod=face_align?1.0:0.0, scale_f=1.0;
   int i;

   for (i=0; i<n; i++)
   {
      double ang=MX_REAL_2PI*(i*2.0+face_mod)/(n*2.0);  // currently vertex aligned, add 1.0 to numerator for face
      if (face_align&&(i==0))
         scale_f=(double)1.0/cos(ang);
      pts[i].y= cos(ang)*scale_f;
      pts[i].x=-sin(ang)*scale_f;
      pts[i].z= z;
   }
}

static void build_ngon_edge_list(int n, int *base_pt, int base_idx)
{
   int i;
   for (i=0; i<n-1; i++)
   {
      base_pt[i*2]=base_idx+i;
      base_pt[i*2+1]=base_idx+i+1;
   }
   base_pt[i*2]=base_idx+i;
   base_pt[i*2+1]=base_idx;
}

////////////////////
// ngon pyramids

BOOL PrimShape_CreateNGonPyr(primalInfo *new_pyr, int n, BOOL face_align, BOOL corner_p)
{
   int i;
   
   new_pyr->faces=n+1;
   new_pyr->points=n+1;
   new_pyr->edges=2*n;
   new_pyr->face_stride=n+1;
   if (!_primalBr_SzCheck(new_pyr)) return FALSE;
   if (!_primalBr_GetMem(new_pyr)) return FALSE;

   //////// PTLIST
   build_ngon_base(n,new_pyr->pt_array,-1,face_align);
   if (corner_p)
   {
      new_pyr->pt_array[n].x=new_pyr->pt_array[0].x;
      new_pyr->pt_array[n].y=new_pyr->pt_array[0].y;
      new_pyr->pt_array[n].z=1.0;
   }
   else
   {
      new_pyr->pt_array[n].x=new_pyr->pt_array[n].y=0;
      new_pyr->pt_array[n].z=1.0;
   }

   //////// EDGELIST
   build_ngon_edge_list(n,new_pyr->edge_list,0);   // ring around the base
   for (i=0; i<n; i++)
   {                                               // and here are edges up to the top
      new_pyr->edge_list[(n+i)*2]=i;
      new_pyr->edge_list[(n+i)*2+1]=n;
   }

   //////// FACEPTS   
   for (i=0; i<n; i++)                             // faces up to the top 
   {
      new_pyr->face_pts_list[new_pyr->face_stride*i+0]=i;
      new_pyr->face_pts_list[new_pyr->face_stride*i+1]=n+1;
      new_pyr->face_pts_list[new_pyr->face_stride*i+2]=(i+1)%n;
      new_pyr->face_pts_list[new_pyr->face_stride*i+3]=-1;
   }
   for (i=0; i<n; i++)                             // right around the base
      new_pyr->face_pts_list[new_pyr->face_stride*n+i]=i;
   new_pyr->face_pts_list[new_pyr->face_stride*n+i]=-1;

   //////// FACEEDGES   
   for (i=0; i<n; i++)                             // faces up to the top 
   {
      new_pyr->face_edge_list[new_pyr->face_stride*i+0]=i;
      new_pyr->face_edge_list[new_pyr->face_stride*i+1]=n+i;
      new_pyr->face_edge_list[new_pyr->face_stride*i+2]=n+((i+1)%n);
      new_pyr->face_edge_list[new_pyr->face_stride*i+3]=-1;
   }
   for (i=0; i<n; i++)                             // right around the base
      new_pyr->face_edge_list[new_pyr->face_stride*n+i]=i;
   new_pyr->face_edge_list[new_pyr->face_stride*n+i]=-1;

   return TRUE;
}

////////////////////
// ngon cylinders

BOOL PrimShape_CreateNGonCyl(primalInfo *new_cyl, int n, BOOL face_align)
{
   int i;   
   new_cyl->faces=n+2;
   new_cyl->points=2*n;
   new_cyl->edges=3*n;
   new_cyl->face_stride=max(n+1,4+1);  // in case you have a 3 sided base on a cyl - rect sides have more edges
   if (!_primalBr_SzCheck(new_cyl)) return FALSE;
   if (!_primalBr_GetMem(new_cyl)) return FALSE;

   //////// PTLIST
   build_ngon_base(n,new_cyl->pt_array  ,-1, face_align); // bottom of cylinder
   build_ngon_base(n,new_cyl->pt_array+n, 1, face_align); // top of cylinder

   //////// EDGELIST
   build_ngon_edge_list(n,new_cyl->edge_list  ,0);   // ring around the base
   build_ngon_edge_list(n,new_cyl->edge_list+2*n,n); // ring around the top
   for (i=0; i<n; i++)
   {                                                 // and here are sides
      new_cyl->edge_list[(2*n+i)*2]  =i;
      new_cyl->edge_list[(2*n+i)*2+1]=n+i;
   }

   //////// FACEPTS
   for (i=0; i<n; i++)                               // faces up to the top 
   {
      new_cyl->face_pts_list[new_cyl->face_stride*i+0]=i;
      new_cyl->face_pts_list[new_cyl->face_stride*i+1]=n+i;
      new_cyl->face_pts_list[new_cyl->face_stride*i+2]=n+((i+1)%n);
      new_cyl->face_pts_list[new_cyl->face_stride*i+3]=(i+1)%n;      
      new_cyl->face_pts_list[new_cyl->face_stride*i+4]=-1;
   }
   new_cyl->face_pts_list[new_cyl->face_stride*n+0]=n;
   for (i=1; i<n; i++)                               // around the top
      new_cyl->face_pts_list[new_cyl->face_stride*n+i]=2*n-i;
   new_cyl->face_pts_list[new_cyl->face_stride*n+i]=-1;   
   for (i=0; i<n; i++)                               // around the top
      new_cyl->face_pts_list[new_cyl->face_stride*(n+1)+i]=i;
   new_cyl->face_pts_list[new_cyl->face_stride*(n+1)+i]=-1;

   //////// FACEEDGES
   for (i=0; i<n; i++)                               // faces up to the top 
   {
      new_cyl->face_edge_list[new_cyl->face_stride*i+0]=i;
      new_cyl->face_edge_list[new_cyl->face_stride*i+1]=2*n+i;
      new_cyl->face_edge_list[new_cyl->face_stride*i+2]=n+i;
      new_cyl->face_edge_list[new_cyl->face_stride*i+3]=2*n+((i+1)%n);
      new_cyl->face_edge_list[new_cyl->face_stride*i+4]=-1;
   }
   for (i=0; i<n; i++)                               // around the top
      new_cyl->face_edge_list[new_cyl->face_stride*n+i]=2*n-i-1;
   new_cyl->face_edge_list[new_cyl->face_stride*n+i]=-1;
   for (i=0; i<n; i++)                               // around the top
      new_cyl->face_edge_list[new_cyl->face_stride*(n+1)+i]=i;
   new_cyl->face_edge_list[new_cyl->face_stride*(n+1)+i]=-1;

   return TRUE;
}

///////////////////
// Wedge Antilles

#define wedge_PT_CNT     (6)
#define wedge_EDGE_CNT   (9)
#define wedge_FACE_CNT   (5)
#define wedge_FACE_PTS (4+1)

// here is our primalInfo intself
_static_declare_base(wedge);

_static_declare_edges(wedge)=
 { 0,1, 1,2, 2,0,
   3,4, 4,5, 5,3,
   0,3, 2,5, 1,4,
};

_static_declare_face_pts(wedge)=
{  
   0,3,4,1,-1,
   2,1,4,5,-1,
   0,2,5,3,-1,
   0,1,2,-1,-1,
   3,5,4,-1,-1,
};
_static_declare_face_edge(wedge)=
{  
   0,6,3,8,-1,
   1,8,4,7,-1,
   6,2,7,5,-1,
   0,1,2,-1,-1,
   3,5,4,-1,-1,
};

_static_declare_pt_list(wedge)=
{  {1,-1,1},{1,1,-1},{1,-1,-1},
   {-1,-1,1},{-1,1,-1},{-1,-1,-1},
};

/*
_static_declare_pt_list(wedge)=
{  {-1,1,1},{1,-1,1},{-1,-1,1},
   {-1,1,-1},{1,-1,-1},{-1,-1,-1},
};
*/
BOOL PrimShape_CreateWedge(primalInfo *new_wedge)
{
   _build_named_primal(wedge,new_wedge);  // can return FALSE internally
   return TRUE;
}

/////////////////////////////////////////////
// Dodecahedron, or a d12 for you philistines

#define dodec_PT_CNT    (20)
#define dodec_EDGE_CNT  (30)
#define dodec_FACE_CNT  (12)
#define dodec_FACE_PTS (5+1)

// here is our primalInfo intself
_static_declare_base(dodec);

_static_declare_edges(dodec)=
 { 0,1, 1,2, 2,3, 3,4, 4,0,
   4,9, 9,15, 15,5, 5,0, 5,19,
   19,6, 6,1, 6,18, 18,7, 7,2,
   7,17, 17,8, 8,3, 8,16, 16,9,
   10,11, 11,12, 12,13, 13,14, 14,10,
   14,19, 10,15, 11,16, 17,12, 13,18,
   /*
   1,2, 2,3, 3,4, 4,5, 5,1,
   5,10, 10,16, 16,6, 6,1, 6,20,
   20,7, 7,2, 7,19, 19,8, 8,3,
   8,18, 18,9, 9,4, 9,17, 17,10,
   11,12, 12,13, 13,14, 14,15, 15,11,
   15,20, 11,16, 12,17, 18,13, 14,19,
   */
};
   

_static_declare_face_pts(dodec)=
{  0,1,2,3,4,-1,
   0,4,9,15,5,-1,
   1,0,5,19,6,-1,
   2,1,6,18,7,-1,
   3,2,7,17,8,-1,

   4,3,8,16,9,-1,
   10,11,12,13,14,-1,
   10,14,19,5,15,-1,
   11,10,15,9,16,-1,
   12,11,16,8,17,-1,

   13,12,17,7,18,-1,
   14,13,18,6,19,-1,
};
   
_static_declare_face_edge(dodec)=
{  0,1,2,3,4,-1,
   4,5,6,7,8,-1,
   0,8,9,10,11,-1,
   1,11,12,13,14,-1,
   2,14,15,16,17,-1,

   3,17,18,19,5,-1,
   20,21,22,23,24,-1,
   24,25,9,7,26,-1,
   20,26,6,19,27,-1,
   21,27,18,16,28,-1,

   22,28,15,13,29,-1,
   23,29,12,10,25,-1,
};

#define DOD_SCALE 1.0F
#define DODA   (0.0F * DOD_SCALE)
#define DODB   (0.5773502692F * DOD_SCALE)
#define DODC   (0.7946544723F * DOD_SCALE)
#define DODD   (0.1875924741F * DOD_SCALE)
#define DODE   (0.9822469464F * DOD_SCALE)
#define DODF   (0.6070619982F * DOD_SCALE)
#define DODG   (0.9341723590F * DOD_SCALE)
#define DODH   (0.3568220898F * DOD_SCALE)
#define DODI   (0.4911234732F * DOD_SCALE)
#define DODJ   (0.3035309991F * DOD_SCALE)

_static_declare_pt_list(dodec)=
{  
   {DODB,DODD,-DODC},{DODA,DODF,-DODC},{-DODB,DODD,-DODC},{-DODH,-DODI,-DODC},{DODH,-DODI,-DODC},
   {DODG,DODJ,-DODD},{DODA,DODE,-DODD},{-DODG,DODJ,-DODD},{-DODB,-DODC,-DODD},{DODB,-DODC,-DODD},
   {DODB,-DODD,DODC},{DODA,-DODF,DODC},{-DODB,-DODD,DODC},{-DODH,DODI,DODC},{DODH,DODI,DODC},
   {DODG,-DODJ,DODD},{DODA,-DODE,DODD},{-DODG,-DODJ,DODD},{-DODB,DODC,DODD},{DODB,DODC,DODD},
};

BOOL PrimShape_CreateDodecahedron(primalInfo *new_dodec)
{
   _build_named_primal(dodec,new_dodec);  // can return FALSE internally
   return TRUE;
}
// $Header: r:/t2repos/thief2/src/editor/primshap.h,v 1.6 2000/01/29 13:13:00 adurant Exp $
// primshap(e)... code and data for generating the primal shapes
#pragma once

#ifndef __PRIMSHAP_H
#define __PRIMSHAP_H

EXTERN BOOL PrimShape_CreateCube(primalInfo *new_cube);
EXTERN BOOL PrimShape_CreateLight(primalInfo *new_light);

EXTERN BOOL PrimShape_CreateLine(primalInfo *new_line);
EXTERN BOOL PrimShape_CreateTri(primalInfo *new_tri);

EXTERN BOOL PrimShape_CreateNGonPyr(primalInfo *new_pyr, int n, BOOL face_align, BOOL corner);
EXTERN BOOL PrimShape_CreateNGonCyl(primalInfo *new_cyl, int n, BOOL face_align);

EXTERN BOOL PrimShape_CreateWedge(primalInfo *new_wedge);
EXTERN BOOL PrimShape_CreateDodecahedron(primalInfo *new_dodec);

#endif  // __PRIMSHAP_H
// $Header: r:/t2repos/thief2/src/editor/prompts.c,v 1.3 2000/02/19 13:11:16 toml Exp $
// basic prompts for asking for data from the user

#include <string.h>
#include <stdlib.h>

#include <lg.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>

#include <prompts.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

///////////////////
// auto-prompters for menu use

static BOOL do_prompt_editor(void *data, sStructDesc *sd, char *title)
{
   IStructEditor *sed;
   sStructEditorDesc editdesc;
   BOOL result;

   strncpy(editdesc.title, title, sizeof(editdesc.title));
   editdesc.flags = kStructEditNoApplyButton; 
   sed = CreateStructEditor(&editdesc, sd, data);
   if (!sed) return FALSE;   // got me, it didnt work

   result = IStructEditor_Go(sed,kStructEdModal); 
   SafeRelease(sed);
   return result;
}

typedef struct { BOOL data; } sBoolPrompt;
static sFieldDesc bool_fields[]={{"Bool Arg",kFieldTypeBool,FieldLocation(sBoolPrompt,data) } };
static sStructDesc bool_struct = StructDescBuild(sBoolPrompt,kStructFlagNone,bool_fields);

BOOL prompt_bool(char *def)
{
   sBoolPrompt bdata;
   bdata.data=TRUE;
   if (def)
      if ((def[0]=='f')||(def[0]=='F')||(def[0]=='0'))
         bdata.data=FALSE;
   do_prompt_editor(&bdata,&bool_struct,"Bool Argument");
   return bdata.data;
}

typedef struct { int data; } sIntPrompt;
static sFieldDesc int_fields[]={{"Int Arg",kFieldTypeInt,FieldLocation(sIntPrompt,data) } };
static sStructDesc int_struct = StructDescBuild(sIntPrompt,kStructFlagNone,int_fields);

int prompt_int(char *def)
{
   sIntPrompt idata;
   if (def)
      idata.data=atoi(def);
   else
      idata.data=0;
   do_prompt_editor(&idata,&int_struct,"Int Argument");
   return idata.data;
}

typedef struct { double data; } sDoublePrompt;
static sFieldDesc double_fields[]={{"Double Arg",kFieldTypeFloat,FieldLocation(sDoublePrompt,data) } };
static sStructDesc double_struct = StructDescBuild(sDoublePrompt,kStructFlagNone,double_fields);

double prompt_double(char *def)
{
   sDoublePrompt ddata;
   if (def)
      ddata.data=atof(def);
   else
      ddata.data=0.0;
   do_prompt_editor(&ddata,&double_struct,"Double Argument");
   return ddata.data;
}

// major memory tracking issue here!!! - not going to work
typedef struct { char data[PROMPT_STR_LEN]; } sStringPrompt;
static sFieldDesc string_fields[]={{"String Arg",kFieldTypeString,FieldLocation(sStringPrompt,data) } };
static sStructDesc string_struct = StructDescBuild(sStringPrompt,kStructFlagNone,string_fields);

// ok, this one is funky, since it needs a valid tmp buffer
// it uses the "data" field
// then, if the editor was real, moves it into buf and returns it, else returns def
char *prompt_string(char *def, char *buf)
{
   sStringPrompt sdata;
   if (def)
      strncpy(sdata.data,def,PROMPT_STR_LEN);
   else
      strcpy(sdata.data,"");
   sdata.data[PROMPT_STR_LEN-1]='\0';
   if (do_prompt_editor(&sdata,&string_struct,"String Argument"))
   {
      strcpy(buf,sdata.data);
      return buf;
   }
   else
      return def;
}
// $Header: r:/t2repos/thief2/src/editor/prompts.h,v 1.2 2000/01/29 13:13:01 adurant Exp $
// basic prompts for asking for data from the user
#pragma once

#ifndef __PROMPTS_H
#define __PROMPTS_H

// basic "get this value for me" prompts - all modal
EXTERN BOOL   prompt_bool(char *def);
EXTERN int    prompt_int(char *def);
EXTERN double prompt_double(char *def);
EXTERN char  *prompt_string(char *def, char *buf);

// for prompt strings
#define PROMPT_STR_LEN 128

#endif  // __PROMPTS_H
// $Header: r:/t2repos/thief2/src/editor/proped.cpp,v 1.16 1999/11/22 17:55:20 henrys Exp $

#include <proped.h>
#include <property.h>
#include <propbase.h>
#include <string.h>
#include <dataops.h>
#include <propstor.h>

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>

#include <config.h>

// must be last header
#include <dbmem.h>

IStructEditor* NewAlertResponseDialog (void* data);
IStructEditor* NewBodyResponseDialog (void* data);
IStructEditor* NewCombatResponseDialog (void* data);
IStructEditor* NewSignalResponseDialog (void* data);
IStructEditor* NewThreatResponseDialog (void* data);
IStructEditor* NewVisionDescDialog (void* data);

typedef IStructEditor* (*psDialogFuncType)(void*);

////////////////////////////////////////////////////////////
// cBasePropEditTrait implementation 
//

static sEditTraitCaps default_caps = 
{
   kTraitCanAdd|kTraitCanRemove, 
}; 

cBasePropEditTrait::cBasePropEditTrait(IProperty* prop)
   : Prop(prop),
     Caps(default_caps)
{
   Prop->AddRef(); 

   const sPropertyDesc* pdesc = Prop->Describe(); 


   // Build the descriptor
   memset(&Desc,0,sizeof(Desc));
   Desc.kind = kPropertyTrait;
   strncpy(Desc.strings.name,pdesc->name,sizeof(Desc.strings.name));
   // check to see if we have a friendly name
   if (pdesc->ui.friendly_name != NULL)
      strncpy(Desc.strings.friendly_name,pdesc->ui.friendly_name,sizeof(Desc.strings.friendly_name)); 
   else // default to name
      strcpy(Desc.strings.friendly_name,Desc.strings.name); 
   // copy category
   if (pdesc->ui.category != NULL)
      strncpy(Desc.strings.category,pdesc->ui.category,sizeof(Desc.strings.category));

   if (pdesc->flags & kPropertyNoEdit)
      Desc.flags |= kTraitInvisible;
}


cBasePropEditTrait::~cBasePropEditTrait()
{
   // @HACK: we know the prop is going to get blasted anyway, so don't bother
   Prop = NULL; 
   //   SafeRelease(Prop); 
}


//------------------------------------------------------------

STDMETHODIMP_(const sEditTraitDesc*) cBasePropEditTrait::Describe()
{
   return &Desc;
}

STDMETHODIMP_(const sEditTraitCaps*) cBasePropEditTrait::Capabilities()
{
   return &Caps;
}

//------------------------------------------------------------

STDMETHODIMP_(BOOL) cBasePropEditTrait::IntrinsicTo(ObjID obj)
{
   return Prop->IsSimplyRelevant(obj); 
}

STDMETHODIMP cBasePropEditTrait::Add(ObjID obj)
{
   Prop->Create(obj);
   return S_OK;
}

STDMETHODIMP cBasePropEditTrait::Remove(ObjID obj)
{
   Prop->Delete(obj);
   return S_OK;
}


////////////////////////////////////////////////////////////
// cSdescPropEditTrait implementation 
//

cSdescPropEditTrait::cSdescPropEditTrait(IProperty* property)
   : cBasePropEditTrait(property), Sdesc(NULL)
{


}



cSdescPropEditTrait::~cSdescPropEditTrait()
{
}

STDMETHODIMP_(const sEditTraitCaps*) cSdescPropEditTrait::Capabilities()
{
   if (Sdesc == NULL)
   {
      const sPropertyTypeDesc* tdesc = Prop->DescribeType(); 
      AutoAppIPtr_(StructDescTools,pTools); // @TODO: hold on to this
      Sdesc = pTools->Lookup(tdesc->type);
      if (Sdesc)
      {
         Caps.flags |= kTraitCanEdit|kTraitCanUnparse; 
         if (pTools->IsSimple(Sdesc))
            Caps.flags |= kTraitCanParse; 
      }   
   }
   return &Caps;
}


STDMETHODIMP cSdescPropEditTrait::Edit(ObjID obj)
{
   if (Sdesc != NULL)
   {
      HRESULT retval = S_FALSE; 
      IPropertyStore* store;
      Verify(SUCCEEDED(Prop->QueryInterface(IID_IPropertyStore,(void**)&store)));

      // copy property data
      sDatum dat;
      store->GetCopy(obj,&dat);
      sStructEditorDesc eddesc = { "" , kStructEditAllButtons };
      strncpy(eddesc.title,Desc.strings.friendly_name,sizeof(eddesc.title)); 

      
      IDataOps* ops = store->GetOps(); 
      // decide whether dat is used as a pointer or a value...
      void* struc = (ops && ops->BlockSize(dat) > 0) ? dat.value : &dat; 

      // Check for the new pseudo-script dialog
      //
      psDialogFuncType AlternateDialogFunction = NULL;
      if (config_is_defined("hens_changes"))
      {
         char* candidates [] =
         {
            "Alert response",
            "Body response",
            "Sense combat response",
            "Signal response",
            "Threat response",
            "Vision description"
         };

         psDialogFuncType funcs [] =
         {
            &NewAlertResponseDialog,
            &NewBodyResponseDialog,
            &NewCombatResponseDialog,
            &NewSignalResponseDialog,
            &NewThreatResponseDialog,
            &NewVisionDescDialog,
         };

         for (short i = 0; i < (sizeof(candidates) / sizeof(char*)); i++)
         {
            if (strcmp(Desc.strings.friendly_name, candidates[i]) == 0)
            {
               AlternateDialogFunction = funcs[i];
               break;
            }
         }
      }

      IStructEditor* sed;
      if (AlternateDialogFunction != NULL)
      {
          while (true)
          {
              sed = AlternateDialogFunction (struc);
              if (sed == NULL)  break;
                  
              if (sed->Go(kStructEdModal))
              {
                 store->Set(obj,dat); 
                 Prop->Touch(obj); 
                 retval = S_OK; 
              }
              SafeRelease(sed);
          }
      }
      else
      {
          sed = CreateStructEditor(&eddesc,Sdesc,struc);
          
          if (sed->Go(kStructEdModal))
          {
             store->Set(obj,dat); 
             Prop->Touch(obj); 
             retval = S_OK; 
          }
          SafeRelease(sed);
      }
      SafeRelease(ops); 

      store->ReleaseCopy(obj,dat);
      SafeRelease(store); 

      return retval;
   }

   return E_FAIL; 
}


STDMETHODIMP cSdescPropEditTrait::Parse(ObjID obj, const char* val) 
{
   if (Sdesc != NULL)
   {
      IPropertyStore* store;
      Verify(SUCCEEDED(Prop->QueryInterface(IID_IPropertyStore,(void**)&store)));

      BOOL already_present = store->Relevant(obj); 
      sDatum dat = store->Create(obj); 
      IDataOps* ops = store->GetOps(); 
      // Use BlockSize to determine the whether we're a pointer or a scalar
      void* struc = (ops && ops->BlockSize(dat) >= 0) ? dat.value : &dat; 

      SafeRelease(ops); 
      
      AutoAppIPtr_(StructDescTools,pTools); 

      if (pTools->ParseSimple(Sdesc,val,struc))
      {
         store->Set(obj,dat);
         Prop->Touch(obj); 
      }
      else if (!already_present)
         Prop->Delete(obj);

      SafeRelease(store); 

      return S_OK;
   }

   return E_FAIL;    
}

#define BUF_SIZE(x) ((x) < 1024 ? 1024 : (x))
 
STDMETHODIMP cSdescPropEditTrait::Unparse(ObjID obj, char* buf, int buflen)
{
   if (Sdesc != NULL)
   {
      IPropertyStore* store;
      Verify(SUCCEEDED(Prop->QueryInterface(IID_IPropertyStore,(void**)&store)));

      sDatum dat;
      store->Get(obj,&dat); 

      IDataOps* ops = store->GetOps(); 

      // Determine whether dat is a pointer 
      BOOL isPtr = (ops && ops->BlockSize(dat) >= 0);

      if (dat || !isPtr)
      {
         void* struc = isPtr ? dat.value : &dat; 
         AutoAppIPtr_(StructDescTools,pTools); 
         pTools->UnparseFull(Sdesc,struc,buf,buflen); 
      
         buf[buflen-1] = '\0';

         SafeRelease(store); 

         return S_OK;
      }

      buf[0] = '\0';
   }

   return E_FAIL;
}




// $Header: r:/t2repos/thief2/src/editor/proped.h,v 1.2 1997/12/05 19:23:37 mahk Exp $
#pragma once  
#ifndef __PROPED_H
#define __PROPED_H

#include <edtrait.h>
#include <edtraist.h>

#include <isdescty.h>

F_DECLARE_INTERFACE(IProperty); 

//
// Default Property EditTrait Implementation
//

//
// Base Property editor.  It is suggested that all property editors, custom or otherwise,
// derive from this. 
//

class cBasePropEditTrait : public cCTUnaggregated<IEditTrait,&IID_IEditTrait,kCTU_Default>
{
public:
   cBasePropEditTrait(IProperty* prop); 

   virtual ~cBasePropEditTrait(); 

   STDMETHOD_(const sEditTraitDesc*,Describe)();
   STDMETHOD_(const sEditTraitCaps*,Capabilities)();
   STDMETHOD_(BOOL,IntrinsicTo)(ObjID obj);
   STDMETHOD(Add)(ObjID obj); 
   STDMETHOD(Remove)(ObjID obj); 

protected:
   IProperty* Prop;
   sEditTraitDesc Desc;
   sEditTraitCaps Caps; 

}; 

//
// Sdesc-based property editor
//


class cSdescPropEditTrait : public cBasePropEditTrait
{
public:
   cSdescPropEditTrait(IProperty* property); 
   ~cSdescPropEditTrait(); 

   STDMETHOD_(const sEditTraitCaps*,Capabilities)();
   STDMETHOD(Edit)(ObjID obj); 
   STDMETHOD(Parse)(ObjID obj, const char* val) ; 
   STDMETHOD(Unparse)(ObjID obj, char* buf, int buflen);  

protected:
   const struct sStructDesc* Sdesc; 

}; 



#endif // __PROPED_H
// $Header: r:/t2repos/thief2/src/editor/proptest.cpp,v 1.38 2000/01/18 12:35:24 PATMAC Exp $

#include <comtools.h>
#include <io.h>

#include <str.h>
#include <dynarray.h>

extern "C"
{
#include <editbr.h>
#include <brlist.h>
#include <status.h>
}
#include <ctype.h>
#include <appagg.h>
#include <propbase.h>
#include <propman.h>
#include <proptest.h>
#include <propguid.h>
#include <propface.h>
#include <propraw.h>
#include <proparry.h>
#include <command.h>
#include <mprintf.h>
#include <traitprp.h>
#include <iobjsys.h>
#include <objedit.h>
#include <traitman.h>
#include <traitbas.h>
#include <osysbase.h>
#include <objlpars.h>
#include <objquery.h>
#include <editobj.h>
#include <editbr_.h>
#include <vbrush.h>
#include <brinfo.h>
#include <trcachui.h>
#include <trcache.h>
#include <linkint.h>
#include <lnkquery.h>
#include <autolink.h>
#include <report.h>

#include <objnotif.h>
#include <dbfile.h>

// for texture search and destroy
#include <config.h>
#include <cfgtool.h>

// For tree edit
#include <otreeed.h>

// For obj EDIT
#include <iobjed.h>
#include <objedbas.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////
static ObjID parse_obj_arg(char* arg)
{
   // Remove trailing whitespace;
   int len = strlen(arg); 
   for (char* s = arg + len - 1; s > arg && isspace(*s); s--)
      *s = '\0';
   ObjID focus = EditGetObjNamed(arg);
   if (focus == OBJ_NULL)
   {
      editBrush* cur = vBrush_GetSel(); 
      if (brushGetType(cur) == brType_OBJECT)
         return brObj_ID(cur); 
   }

   return focus; 
}


////////////////////////////////////////

static void lookup_obj(char* symname)
{
   char buf[256];
   char* s = symname;

   while (!isspace(*s) && *s != '\0') s++;
   *s = '\0';
   
   ObjID obj = EditGetObjNamed(symname);

   AutoAppIPtr_(ObjectSystem,pObjSys); 

   if (obj != OBJ_NULL && pObjSys->Exists(obj))
   {
      sprintf(buf,"Found: %s",ObjEditName(obj));

      if (OBJ_IS_ABSTRACT(obj))
      {
         EditObjHierarchy(obj); 
      }
      else
      {
         editBrush* br = editObjGetBrushFromObj(obj);
         if (br != NULL)
            vBrush_SelectBrush(br);
      }
         
   }
   else
      sprintf(buf,"There is no obj named %s",symname);
   Status(buf);
}


////////////////////////////////////////

static void edit_obj_tree(char* arg)
{
   ObjID focus = parse_obj_arg(arg); 
   if (OBJ_IS_CONCRETE(focus))
   {
      AutoAppIPtr_(TraitManager,pTraitMan);
      focus = pTraitMan->GetArchetype(focus); 
   }

   EditObjHierarchy(focus); 
}


////////////////////////////////////////

static sObjEditorDesc objeddesc = 
{
   "",
   kObjEdShowAll
};

static void obj_edit(char* arg)
{
   ObjID obj = parse_obj_arg(arg); 

   AutoAppIPtr_(ObjEditors,pEditors);
   IObjEditor* ed = pEditors->Create(&objeddesc,obj); 
   ed->Go(kObjEdModal);
   SafeRelease(ed); 

}


////////////////////////////////////////

static void clear_trait_cache()
{
   AutoAppIPtr_(DonorCache,pCache);
   pCache->Clear();
}



////////////////////////////////////////

static void link_lock_count(void)
{
   AutoAppIPtr_(LinkManagerInternal,LinkMan);
   long count = LinkMan->GetLockCount(); 
   mprintf("Link lock count is %d\n",count);
}

////////////////////////////////////////

#define STRINGARG(x) ((x) == NULL ? "" : (x))

static void list_props(void)
{
   AutoAppIPtr_(PropertyManager,pMan); 
   sPropertyIter iter; 
   pMan->BeginIter(&iter); 
   IProperty* prop; 
   for (prop = pMan->NextIter(&iter); prop != NULL; prop = pMan->NextIter(&iter))
   {
      const sPropertyDesc* desc = prop->Describe(); 
      if (desc->ui.friendly_name != NULL)
         mprintf("%s\\%s = %s\n",STRINGARG(desc->ui.category),desc->ui.friendly_name,desc->name); 
      else
         mprintf("%s\n",desc->name);
      SafeRelease(prop); 
   } 
}

int count_links(ILinkQuery* query)
{

   for (int count = 0; !query->Done(); query->Next(), count++)
      ;
   return count;
}

static void link_dump_stats(void)
{
   AutoAppIPtr_(LinkManager,pLinkMan);
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   IObjectQuery* objects = pObjSys->Iter(kObjectAll); 
   for (; !objects->Done(); objects->Next())
   {
      ObjID obj = objects->Object(); 
      mprintf("Obj %s: ",ObjEditName(obj)); 
      ILinkQuery* from = pLinkMan->Query(obj,LINKOBJ_WILDCARD,RELID_WILDCARD);
      mprintf("links from: %d ",count_links(from));
      SafeRelease(from); 
      ILinkQuery* to = pLinkMan->Query(LINKOBJ_WILDCARD,obj,RELID_WILDCARD);
      mprintf("links to: %d\n",count_links(to)); 
      SafeRelease(to); 
   }
   SafeRelease(objects);

   mprintf("Total links: "); 
   ILinkQuery* query = pLinkMan->Query(LINKOBJ_WILDCARD,LINKOBJ_WILDCARD,RELID_WILDCARD); 

   mprintf("%d\n",count_links(query));
   SafeRelease(query); 
}


////////////////////////////////////////

static void destroy_obj(char* symname)
{
   ObjID obj = parse_obj_arg(symname); 
   if (obj != OBJ_NULL)
   {
      AutoAppIPtr_(ObjectSystem,pObjSys); 
      pObjSys->Destroy(obj); 
      Status ("Object Destroyed"); 
   }
   Status("No such object"); 
}

////////////////////////////////////////

// @HACK: here we have secret gnosis of the set of object hierarchy trees 

static const char* obj_roots [] = 
{
   "Object",
   "Metaproperty", 
   "Stimulus",
   "Texture",
   "Flow Group", 
   "Base Room",
   "This Source",
   "This Sensor", 
}; 

#define NUM_ROOTS (sizeof(obj_roots)/sizeof(obj_roots[0]))

static void find_lost_objects(void)
{
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   AutoAppIPtr_(TraitManager,pTraitMan);
   
   IObjectQuery* query = pObjSys->Iter(kObjectAll); 
   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();

      BOOL found = FALSE; 
      for (int i = 0; i < NUM_ROOTS; i++)
      {
         ObjID root = pObjSys->GetObjectNamed(obj_roots[i]);
         if (obj == root || pTraitMan->ObjHasDonor(obj,root))
         {
            found = TRUE; 
            break; 
         }
      }

      if (found)
         continue; 

      // Named objects can be lost 
      //      if (pObjSys->GetName(obj) != NULL) 
      //         continue; 

      ObjID missing;
      pTraitMan->CreateBaseArchetype("Missing",&missing); 
      //      pObjSys->SetObjTransience(missing,TRUE); 

      pTraitMan->SetArchetype(obj,missing); 
      //      pObjSys->SetObjTransience(obj,TRUE); 
   }
   SafeRelease(query); 
}


static void report_lost_objects(int WarnLevel, void *data, char *buffer)
{
   char *p=buffer;
   int numLost = 0;
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   AutoAppIPtr_(TraitManager,pTraitMan);

   rsprintf(&p,"\nChecking for Lost Objects\n");

   IObjectQuery* query = pObjSys->Iter(kObjectAll); 
   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();

      BOOL found = FALSE; 
      for (int i = 0; i < NUM_ROOTS; i++)
      {
         ObjID root = pObjSys->GetObjectNamed(obj_roots[i]);
         if (obj == root || pTraitMan->ObjHasDonor(obj,root))
         {
            found = TRUE; 
            break; 
         }
      }

      if (found)
         continue; 

      numLost++;
      rsprintf(&p, "ERROR: Object %s is lost!\n", ObjWarnName(obj) );

   }
   if ( numLost ) {
      rsprintf(&p,"\n%d Lost Objects\n", numLost );
   }
   SafeRelease(query); 
}


static void purge_missing_objs(void)
{
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   AutoAppIPtr_(TraitManager,pTraitMan); 
   ObjID missing = pObjSys->GetObjectNamed("Missing"); 
   ObjID metaprop = pTraitMan->RootMetaProperty(); 
   if (missing == OBJ_NULL)
   {
      Status("No 'Missing' Archetype"); 
      return; 
   }

   // remove "missing" from the tree 
   pTraitMan->SetArchetype(missing,OBJ_NULL); 

   pObjSys->Lock(); 
   cAutoIPtr<IObjectQuery> query (pTraitMan->Query(missing,kTraitQueryAllDescendents));
   for (;!query->Done(); query->Next())
   {
      ObjID obj = query->Object(); 
      if (!pTraitMan->ObjHasDonor(obj,ROOT_ARCHETYPE) 
          && !pTraitMan->ObjHasDonor(obj,metaprop))
         pObjSys->Destroy(query->Object()); 
   }
   pObjSys->Unlock(); 

   pObjSys->Destroy(missing); 
}

static void lookup_gamesys_textures(void)
{
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   AutoAppIPtr_(TraitManager,pTraitMan);
   
   //query just the abstract objects.
   IObjectQuery* query = pObjSys->Iter(kObjectAbstract); 
   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();

      BOOL found = FALSE; 
//hack, here I know that the root Texture archetype is called "Texture"
      ObjID root = pObjSys->GetObjectNamed("Texture");
      if ((obj != root) && (pTraitMan->ObjHasDonor(obj,root)) )
	found = TRUE;

      if (!found)
	continue;

      //DANGER! hack ahead.  Assume textures start with t_fam if they
      //are from files, and assume all are pcx files.
      char texname[256];
      strcpy(texname,pObjSys->GetName(obj));
      char texsubpath[256];
      char texpath[256];
      if (sscanf(texname,"t_fam%s",texsubpath))
	{
	  sprintf(texpath,"fam%s.pcx",texsubpath);
	  mprintf("%s",texpath);
	  char filename[256];
	  if (find_file_in_config_path(filename,texpath,"resname_base"))
	    mprintf("  Found\n");
	  else
	    mprintf(" NOT FOUND\n");
	}
      else
	mprintf("%s\n",texname);
   }
   SafeRelease(query); 
}

static void kill_old_gamesys_textures(void)
{
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   AutoAppIPtr_(TraitManager,pTraitMan);
   
   //query just the abstract objects.
   IObjectQuery* query = pObjSys->Iter(kObjectAbstract); 
   for (; !query->Done(); query->Next())
   {
      ObjID obj = query->Object();

      BOOL found = FALSE; 
//hack, here I know that the root Texture archetype is called "Texture"
      ObjID root = pObjSys->GetObjectNamed("Texture");
      if ((obj != root) && (pTraitMan->ObjHasDonor(obj,root)) )
	found = TRUE;

      if (!found)
	continue;

      //DANGER! hack ahead.  Assume textures start with t_fam if they
      //are from files, and assume all are pcx files.
      char texname[256];
      strcpy(texname,pObjSys->GetName(obj));
      char texsubpath[256];
      char texpath[256];
      if (sscanf(texname,"t_fam%s",texsubpath))
	{
	  sprintf(texpath,"fam%s.pcx",texsubpath);
 	  char filename[256];
	  if (!find_file_in_config_path(filename,texpath,"resname_base"))
	    {
	      mprintf("KILLING %s\n",texpath);
	      pObjSys->Destroy(obj);
	    }
	}
   }
   SafeRelease(query); 
}


////////////////////////////////////////

static void link_many(char* arg)
{
   cStr argStr(arg);
   cStr args[3];
   cStr fromStr;
   cStr toStr;
   int  len;
   
   for (int i = 0; i < 3; i++)
   {
      len = argStr.SpanExcluding(",");
      if (!len)
         return;
      argStr.Mid(args[i], 0, len);
      if (argStr[len])
         argStr.Remove(0, len + 1);
      else
         argStr.Remove(0, len);
      args[i].Trim();
   }

   cDynArray<ObjID> sources, destinations;
   cObjListParser   objListParser;

   if (args[1] == "*")
      destinations.Append(LINKOBJ_WILDCARD);
   else
      objListParser.Parse(args[1], &sources);

   if (args[2] == "*")
      destinations.Append(LINKOBJ_WILDCARD);
   else
      objListParser.Parse(args[2], &destinations);

   if (!sources.Size() || !destinations.Size())
      return;

   AutoAppIPtr(LinkManager);
   IRelation * pRelation = pLinkManager->GetRelationNamed(args[0]);
   
   if (!pRelation)
      return;
      
   for (i = 0; i < sources.Size(); i++)
   {
      if (sources[i] != LINKOBJ_WILDCARD)
      {
         for (int j = 0; j < destinations.Size(); j++)
         {
            if (destinations[j] != LINKOBJ_WILDCARD && sources[i] != destinations[j])
               pRelation->Add(sources[i], destinations[j]);
         }
      }
   }

   pRelation->Release();
}

static void unlink_many(char* arg)
{
   cStr argStr(arg);
   cStr args[3];
   cStr fromStr;
   cStr toStr;
   int  len;
   
   for (int i = 0; i < 3; i++)
   {
      len = argStr.SpanExcluding(",");
      if (!len)
         return;
      argStr.Mid(args[i], 0, len);
      if (argStr[len])
         argStr.Remove(0, len + 1);
      else
         argStr.Remove(0, len);
      args[i].Trim();
   }

   cDynArray<ObjID> sources, destinations;
   cObjListParser   objListParser;

   if (args[1] == "*")
      destinations.Append(LINKOBJ_WILDCARD);
   else
      objListParser.Parse(args[1], &sources);

   if (args[2] == "*")
      destinations.Append(LINKOBJ_WILDCARD);
   else
      objListParser.Parse(args[2], &destinations);

   if (!sources.Size() || !destinations.Size())
      return;

   AutoAppIPtr(LinkManager);
   IRelation * pRelation = pLinkManager->GetRelationNamed(args[0]);
   
   if (!pRelation)
      return;
      
   for (i = 0; i < sources.Size(); i++)
   {
      for (int j = 0; j < destinations.Size(); j++)
      {
         if (sources[i] != destinations[j])
         {
            ILinkQuery * pQuery;
            pQuery = pRelation->Query(sources[i], destinations[j]);
            for (; !pQuery->Done(); pQuery->Next())
               pRelation->Remove(pQuery->ID());
               
            pQuery->Release();
         }
      }
   }

   pRelation->Release();
}

void make_archetype(char* arg)
{
   ObjID objID = parse_obj_arg(arg); 

   AutoAppIPtr_(TraitManager, pTraitMan);
   AutoAppIPtr_(ObjectSystem, pObjSys);

   if (objID == OBJ_NULL)
   {
      Status("No object specified"); 
      return; 
   }

   char name[256];
   sprintf(name,"Archetype copy of %s", ObjEditName(objID)); 
   ObjID old_arch = pTraitMan->GetArchetype(objID); 
   if (old_arch == OBJ_NULL)
      old_arch = ROOT_ARCHETYPE; 

   ObjID new_arch = pTraitMan->CreateArchetype(name, old_arch);
  
   pObjSys->CloneObject(new_arch, objID);
   Status("Archetype Created"); 
}

////////////////////////////////////////

static BOOL LGAPI test_partition_func(ObjID obj, const sObjPartitionFilter* )
{
   // even numbered objects go in the briefcase :)
   return (obj % 2) == 0; 
}


static void test_briefcase_save(void)
{
   AutoAppIPtr_(ObjectSystem,pObjSys);

   // register the filter that describes the "briefcase" sub-partition 
   sObjPartitionFilter filter = { test_partition_func}; 
   pObjSys->SetSubPartitionFilter(kObjPartBriefcase,&filter); 

   // save the "briefcase" sub-partition 
   dbSave("briefcase.tmp",kObjPartConcrete|kObjPartBriefcase); 
}

static void test_briefcase_load(void)
{
   // merge load the "briefcase" subpartition 
   dbMergeLoad("briefcase.tmp",kObjPartConcrete|kObjPartBriefcase); 
}

////////////////////////////////////////

static void copy_props_to(char* arg)
{
   // Remove trailing whitespace;
   int len = strlen(arg); 
   for (char* s = arg + len - 1; s > arg && isspace(*s); s--)
      *s = '\0';
 
   ObjID targ = EditGetObjNamed(arg);
   if (targ == NULL)
   {
      Status("No such object");
      return ; 
   }

   editBrush* cur = vBrush_GetSel(); 
   if (brushGetType(cur) != brType_OBJECT)
   {
      Status("Selection is not an object");
      return ; 
   }

   ObjID src = brObj_ID(cur); 
      
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   pObjSys->CloneObject(targ,src); 
}

////////////////////////////////////////

static Command commands[] = 
{

   { "find_obj", FUNC_STRING, lookup_obj, "Look up an object by name or number",HK_EDITOR},
   { "destroy_obj", FUNC_STRING, destroy_obj, "Destroy an object by name or number",HK_EDITOR},
   { "trait_cache_params", FUNC_VOID, EditDonorCacheParams, "Edit trait cache parameters", HK_EDITOR },
   { "trait_cache_clear", FUNC_VOID, clear_trait_cache, "Empty the trait cache", HK_ALL },
   { "link_lock_count", FUNC_VOID, link_lock_count, "Report the number active link queries", HK_ALL },
   { "obj_tree", FUNC_STRING, edit_obj_tree, "Object Hierarchy editor", HK_EDITOR },
   { "edit_obj", FUNC_STRING, obj_edit, "edit an object", HK_EDITOR },
   { "copy_props_to", FUNC_STRING, copy_props_to, "Copy all props from selection to arg", HK_EDITOR },

   { "list_props", FUNC_VOID, list_props, "List properties on mono", HK_ALL },
   { "link_dump_stats", FUNC_VOID, link_dump_stats, "Dump tons of stats on links", HK_ALL },
   { "find_lost_objs", FUNC_VOID, find_lost_objects, "Find lost objects and set their archetypes to 'missing' ", HK_ALL },
   { "purge_missing_objs", FUNC_VOID, purge_missing_objs, "Delete all objects that inherit from 'Missing'", HK_ALL },

   { "briefcase_save", FUNC_VOID, test_briefcase_save, "Try to save the briefcase", HK_ALL },
   { "briefcase_load", FUNC_VOID, test_briefcase_load, "Try to load the briefcase", HK_ALL },

   { "link_many", FUNC_STRING, link_many, "Link many concrete objects", HK_EDITOR },
   { "unlink_many", FUNC_STRING, unlink_many, "Unlink many concrete objects", HK_EDITOR },

   { "make_archetype", FUNC_STRING, make_archetype, "Clone a concrete into an archetype", HK_EDITOR },
   { "print_gamesys_textures", FUNC_STRING, lookup_gamesys_textures, "Print to monolog all textures in the gamesys, and whether they are in path or not",HK_EDITOR},
   { "X99_kill_old_gamesys_textures", FUNC_STRING, kill_old_gamesys_textures, "Delete all textures in gamesys associated with files which aren't in the resource path.  DANGEROUS.",HK_EDITOR},
};


////////////////////////////////////////

void proptest_init_real(void)
{
   COMMANDS(commands,HK_EDITOR);
   ReportRegisterGenCallback( report_lost_objects, kReportAllObj, "Lost Objects", NULL );
}

////////////////////////////////////////

void proptest_term_real(void)
{
   ReportUnRegisterGenCallback( report_lost_objects, kReportAllObj, NULL );
}
 

// $Header: r:/t2repos/thief2/src/editor/proptest.h,v 1.3 2000/01/29 13:13:02 adurant Exp $
#pragma once

#ifndef __PROPTEST_H
#define __PROPTEST_H

EXTERN void proptest_init_real(void);
EXTERN void proptest_term_real(void);

#ifdef EDITOR
#define proptest_init() proptest_init_real()
#define proptest_term() proptest_term_real()
#else
#define proptest_init() 
#define proptest_term() 
#endif




#endif // __PROPTEST_H
//
//  The new list-based pseudo-script dialog
//  Presents data as a series of sub-dialogs accesible from a simple list:
//  eg.  Header
//       Step 01
//       Step 02
//       Step 03
//       ...
//

#include <lg.h>
#include <psdialog.h>
#include <simpwrap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


// The default pseudo-script field format
// This is what will appear in the sub-dialogs that open when you choose to edit a step
//
static sFieldDesc gStepFieldDesc[] =
{
   { "Response Step", kFieldTypeEnum,   FieldLocation(sAIPsdScrAct, type), kFieldFlagNone, 0, FieldNames(g_ppszAIPsdScrActions) }, \
   { "   Argument 1", kFieldTypeString, FieldLocation(sAIPsdScrAct, args[0])                                                    }, \
   { "   Argument 2", kFieldTypeString, FieldLocation(sAIPsdScrAct, args[1])                                                    }, \
   { "   Argument 3", kFieldTypeString, FieldLocation(sAIPsdScrAct, args[2])                                                    }
};

static sStructDesc gStepStructDesc = StructDescBuild(sAIPsdScrAct, kStructFlagNone, gStepFieldDesc);

// Arguments:
//   title        - The dialog's caption 
//   maxSteps     - The number of steps to display
//   headerStruct - Format of the header, created with StructDescBuild()
//   data         - Pointer to the entire data structure
//   steps        - Pointer to the pseudo-script array within the data structure
//
IStructEditor* NewPseudoScriptDialog (char* title, int maxSteps, sStructDesc* headerStruct, void* data, sAIPsdScrAct* steps)
{
    int i;
    int numMenuSlots = maxSteps + 2;
    char **responseMenu = (char **) malloc(sizeof(char*) * numMenuSlots);
    sStructEditorDesc headerDesc = { "Header", kStructEditAllButtons };
    sStructEditorDesc stepDesc = { "Step", kStructEditAllButtons };
    BOOL result = FALSE;

    //  Add the "done" choice at the beginning
    //
    responseMenu[0] = (char*) malloc(sizeof(char) * 16);
    sprintf(responseMenu[0], "-- DONE --");
    
    //  Put the header in as an option
    //
    responseMenu[1] = (char*) malloc(sizeof(char) * 16);
    sprintf(responseMenu[1], "Header");
    
    //  Build the list of response steps
    //
    for (i = 2; i < numMenuSlots; i++)
    {
        responseMenu[i] = (char*) malloc(sizeof(char) * 64);
        if (i-1 < 10)
            sprintf(responseMenu[i], "Step 0%d: %.54s", i-1, g_ppszAIPsdScrActions[steps[i-2].type]);
        else
            sprintf(responseMenu[i], "Step %d: %.54s", i-1, g_ppszAIPsdScrActions[steps[i-2].type]);
    }
    
    //  Display the list, and let the user choose
    //
    int choice = PickFromStringList(title, (const char* const*)responseMenu, numMenuSlots);
    for (i = 0; i < numMenuSlots; i++)
       free (responseMenu[i]);
    free (responseMenu);

    //  Done
    //
    if (choice == 0)
        return NULL;
    
    //  Bring up the header dialog
    //
    else if (choice == 1)
        return CreateStructEditor(&headerDesc, headerStruct, data);
    
    //  Bring up the specific dialog for step chosen
    //
    else if (choice >= 2 && choice < numMenuSlots)
        return CreateStructEditor(&stepDesc, &gStepStructDesc, &steps[choice - 2]);

    return NULL;
}

#pragma once

#include <aipsdscr.h>
#include <isdescty.h>
#include <isdescst.h>
#include <isdesced.h>
#include <sdesbase.h>

IStructEditor* NewPseudoScriptDialog (char* title, int maxSteps, sStructDesc* headerStruct, void* data, sAIPsdScrAct* steps);

// $Header: r:/t2repos/thief2/src/editor/quesedit.cpp,v 1.2 2000/02/19 13:11:19 toml Exp $

#include <appagg.h>
#include <questapi.h>
#include <str.h>
#include <mprintf.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <command.h>
#include <simpwrap.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>

#include <questapi.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

#define IS_DELIM(x) ((x) == ',')

void QuestSet(char* pArg, eQuestDataType type)
{
   char *pName;
   int value = 0;
   char* pDelim;
   char save;
   
   while (*pArg && isspace(*pArg)) 
      pArg++;
   
   // get first delimeter
   pDelim = pArg; 
   while (*pDelim && !IS_DELIM(*pDelim))
      pDelim++;
   if (*pDelim)
   {
      save = *pDelim;
      *pDelim = '\0';
      pName = pArg;
      pArg = pDelim+1;
      if (*pArg)
         value = atoi(pArg);
      AutoAppIPtr(QuestData);
      pQuestData->Create(pName, value, type);
      *pDelim = save;
   }
   else
      mprintf("Usage: quest_set <name>, <value>\n");
}

void QuestSetCampCmd(char *pArg)
{
   QuestSet(pArg, kQuestDataCampaign);
}

void QuestSetMisCmd(char *pArg)
{
   QuestSet(pArg, kQuestDataMission);
}

void QuestGetCmd(char* pArg)
{
   while (*pArg && isspace(*pArg)) 
      pArg++;

   AutoAppIPtr(QuestData);
   int val = pQuestData->Get(pArg);
   mprintf("%s = %d\n", pArg, val);
}

void QuestDeleteCmd(char* pArg)
{
   while (*pArg && isspace(*pArg)) 
      pArg++;

   AutoAppIPtr(QuestData);
   pQuestData->Delete(pArg);
}

void QuestSpewListenCmd(int objID)
{
#ifdef DEBUG
   AutoAppIPtr(QuestData);
   pQuestData->ObjSpewListen(objID);
   mprintf("\n");
#endif
}

void QuestSubscribeCmd(char* pArg)
{
   char *pName;
   char* pDelim;
   char save;
   ObjID objID;
   
   while (*pArg && isspace(*pArg)) 
      pArg++;
   
   // get first delimeter
   pDelim = pArg; 
   while (*pDelim && !IS_DELIM(*pDelim))
      pDelim++;
   if (*pDelim)
   {
      save = *pDelim;
      *pDelim = '\0';
      objID = atoi(pArg);
      *pDelim = save;
      pName = pDelim+1;
      AutoAppIPtr(QuestData);
      pQuestData->SubscribeMsg(objID, pName);
   }
}

void QuestUnsubscribeCmd(char* pArg)
{
   char *pName;
   char* pDelim;
   char save;
   ObjID objID;
   
   while (*pArg && isspace(*pArg)) 
      pArg++;
   
   // get first delimeter
   pDelim = pArg; 
   while (*pDelim && !IS_DELIM(*pDelim))
      pDelim++;
   if (*pDelim)
   {
      save = *pDelim;
      *pDelim = '\0';
      objID = atoi(pArg);
      *pDelim = save;
      pName = pDelim+1;
      AutoAppIPtr(QuestData);
      pQuestData->UnsubscribeMsg(objID, pName);
   }
}

struct sQueryTron 
{
   char name[32];
   int value;
}; 

static sFieldDesc query_tron_fields[] = 
{
   { "Name", kFieldTypeString, FieldLocation(sQueryTron,name), },
   { "Value", kFieldTypeInt, FieldLocation(sQueryTron,value), },
};

static sStructDesc query_tron_desc = StructDescBuild(sQueryTron,kStructFlagNone,query_tron_fields); 

void QuestEdit(eQuestDataType type)
{
   AutoAppIPtr(QuestData);
   char **ppszMenu = (char **)Malloc(1);
   int iNumMenuSlots = 0;
   IQuestDataIter *pIter;

   for (pIter = pQuestData->Iter(type); !pIter->Done(); pIter->Next())
   {
      ppszMenu = (char **) Realloc(ppszMenu, (iNumMenuSlots+1)*sizeof(char*));
      ppszMenu[iNumMenuSlots] = (char*) Malloc(sizeof(char)*(strlen(pIter->Name())+12));
      sprintf(ppszMenu[iNumMenuSlots], "%s %10d", pIter->Name(), pIter->Value());
      ++iNumMenuSlots;
   }
   pIter->Release();
   if (iNumMenuSlots>0)
   {
      int iChoice = PickFromStringList("Quest Data", (const char* const*)ppszMenu, iNumMenuSlots);
      if (iChoice>=0)
      {
         char *pChar = ppszMenu[iChoice];
         while (*pChar != ' ')
            ++pChar;
         *pChar = '\0';
         int value = atoi(pChar+1);

         // Set up initial values
         sQueryTron tron;
         strncpy(tron.name, ppszMenu[iChoice], 31);
         tron.value = value;
         sStructEditorDesc editdesc = 
         {  
            "Quest Data", 
         };

         IStructEditor* ed = CreateStructEditor(&editdesc,&query_tron_desc,&tron);

         if (ed->Go(kStructEdModal))
            pQuestData->Create(tron.name, tron.value, type);
      }
   }
   for (int i = 0; i < iNumMenuSlots; ++i)
      Free(ppszMenu[i]);
   Free(ppszMenu);
}

void QuestEditCampCmd(void)
{
   QuestEdit(kQuestDataCampaign);
}

void QuestEditMisCmd(void)
{
   QuestEdit(kQuestDataMission);
}

static Command g_QuestCommands[] = 
{
   {"quest_create", FUNC_STRING, QuestSetCampCmd, "quest_set <name>,<value>", HK_EDITOR},
   {"quest_create_mis", FUNC_STRING, QuestSetMisCmd, "quest_set_mis <name>,<value>", HK_EDITOR},
   {"quest_get", FUNC_STRING, QuestGetCmd, "quest_get <name>", HK_EDITOR},
   {"quest_delete", FUNC_STRING, QuestDeleteCmd, "quest_delete <name>", HK_EDITOR},
   {"quest_spew_sub", FUNC_INT, QuestSpewListenCmd, "quest_spew_sub <objID>", HK_EDITOR},
   {"quest_sub", FUNC_STRING, QuestSubscribeCmd, "quest_sub <objID>,<name>", HK_EDITOR},
   {"quest_unsub", FUNC_STRING, QuestUnsubscribeCmd, "quest_unsub <objID>,<name>", HK_EDITOR},
   {"quest_edit", FUNC_VOID, QuestEditCampCmd, "quest_edit", HK_EDITOR},
   {"quest_edit_mis", FUNC_VOID, QuestEditMisCmd, "quest_edit_mis", HK_EDITOR},
};

void QuestEditInit(void)
{ 
   COMMANDS(g_QuestCommands, HK_ALL);
}
// $Header: r:/t2repos/thief2/src/editor/quesedit.h,v 1.2 2000/01/29 13:13:05 adurant Exp $
#pragma once
#ifndef __QUESEDIT_H
#define __QUESEDIT_H
 
void QuestEditInit(void);

#endif // __QUESEDIT_H
// $Header: r:/t2repos/thief2/src/editor/rendtest.c,v 1.6 2000/02/19 13:11:20 toml Exp $
// tests the renderer by doing lots of renderings from various places

#ifndef SHIP

#include <stdlib.h>
#include <stdio.h>
#include <io.h>

#include <timer.h>
#include <mprintf.h>
#include <kbcook.h>
#include <dump.h>

#include <csg.h>
#include <csgbrush.h>
#include <portal.h>
#include <editbr_.h>
#include <modalui.h>  // for ui for rendtest
#include <brinfo.h>
#include <brquery.h>
#include <gedit.h>
#include <ged_csg.h>
#include <rendtest.h>

#include <command.h>
#include <status.h>

#include <sdesc.h>
#include <sdesbase.h>
#include <isdesced.h>
#include <isdescst.h>

////////////////////////
// sdesc/setup for the config

typedef struct {
   // public fields for user   
   int  tests_per_source;
   int  total_count;
   int  view_width;
   int  view_height;
   int  rand_seed;
   float step_size;
   BOOL flat_only;
   BOOL inc_angle;
   BOOL move_straight;
   BOOL brush_centers;
   // internal fields for state
   int  tests_run;
   int  tests_left_at_this_source;
   Position pos;
   BOOL rand_time;
   // probably need more fields here for level validity checking?
} sRendTestParms;

// add a filename?

static sFieldDesc rendtest_fields [] =
{
   {"Total Count",         kFieldTypeInt,   FieldLocation(sRendTestParms,total_count) },
   {"Tests Per Source",    kFieldTypeInt,   FieldLocation(sRendTestParms,tests_per_source) },
   {"View Width (0 full)", kFieldTypeInt,   FieldLocation(sRendTestParms,view_width) },
   {"View Height(0 full)", kFieldTypeInt,   FieldLocation(sRendTestParms,view_height) },
   {"Rand Seed (0=time)",  kFieldTypeInt,   FieldLocation(sRendTestParms,rand_seed) },
   {"Step Size",           kFieldTypeFloat, FieldLocation(sRendTestParms,step_size) },
   {"Flat Only",           kFieldTypeBool,  FieldLocation(sRendTestParms,flat_only) },
   {"Increment Angle",     kFieldTypeBool,  FieldLocation(sRendTestParms,inc_angle) },
   {"Move Straight",       kFieldTypeBool,  FieldLocation(sRendTestParms,move_straight) },
   {"Brush Centers",       kFieldTypeBool,  FieldLocation(sRendTestParms,brush_centers) },
};

static sStructDesc rendtest_struct = StructDescBuild(sRendTestParms,kStructFlagNone,rendtest_fields);

static sRendTestParms rtP={250,0,0,0,0,1.0,FALSE,FALSE,FALSE,FALSE,0,-1};
static BOOL          _rtP_inuse=FALSE;

#define DEFAULT_FNAME "rtest000.try"
static char           cur_write_fname[255];

///////////////////////////
// dialog controllers

// this is really later in the file
void rendtest_run(BOOL new_run);

static void LGAPI rendtest_prop_cb(sStructEditEvent *event, StructEditCBData data)
{
   switch (event->kind)
   {
      case kStructEdOK:
         rendtest_run(TRUE);  // this sets the inuse off, eh?
         break;
      case kStructEdCancel:
         _rtP_inuse=FALSE;
         break;
   }
}

static BOOL rendtest_dialog(void)
{
   IStructEditor *sed;
   sStructEditorDesc editdesc;

   strncpy(editdesc.title, "RendTest Parameters", sizeof(editdesc.title));
   editdesc.flags = kStructEditNoApplyButton;
   sed = CreateStructEditor(&editdesc, &rendtest_struct, &rtP);
   if (!sed)
    { _rtP_inuse=FALSE; return FALSE; }
   IStructEditor_SetCallback(sed,rendtest_prop_cb,&rtP);
   IStructEditor_Go(sed,kStructEdModeless);
   SafeRelease(sed);
   return TRUE;
}

/////////////////////////
// ultra-dorky file api

#include <stdio.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static BOOL write_rtP(char *fname)
{
   FILE *fp;
   if ((fp=fopen(fname,"wb"))==NULL)
      return FALSE;
   fwrite(&rtP,sizeof(sRendTestParms),1,fp);
   fclose(fp);
   return TRUE;   
}

static BOOL read_rtP(char *fname)
{
   FILE *fp;
   if ((fp=fopen(fname,"rb"))==NULL)
      return FALSE;
   fread(&rtP,sizeof(sRendTestParms),1,fp);
   fclose(fp);
   return TRUE;
}

/////////////////////////
// actual tester

static float frand_hack(void)
{
   float tmp=(float)((rand()&0x7fff)-16384);
   tmp/=16384;
   return tmp;
}

static void get_rand_vec(mxs_vector *dst, float scale)
{
   dst->x=frand_hack()*scale;
   dst->y=frand_hack()*scale;
   dst->z=frand_hack()*scale;
}

// sit around picking locations making sure they are valid
static BOOL rendtest_pick_source_pos(Position *p)
{
   int br_id=rand()%csg_num_brushes, attempts=0;
   editBrush *br;
   
   do {          // lovely do construction, eh?
      do {
         br=brFind(br_id);
         br_id=(br_id+1)%csg_num_brushes;
      } while (((br==NULL)||(brushGetType(br)==brType_HOTREGION))&&(++attempts<csg_num_brushes));
      if (rtP.brush_centers)
         MakeLocationFromVector(&p->loc,&br->pos);
      else
      {
         mxs_vector tmp_pos=br->pos, tmp_sz=br->sz, rnd;
         get_rand_vec(&rnd,1.0);
         mx_elmuleq_vec(&tmp_sz,&rnd);
         mx_addeq_vec(&tmp_pos,&tmp_sz);
         MakeLocationFromVector(&p->loc,&tmp_pos);
      }
      MakeOrientationFromAngVec(&p->fac,&br->ang);
   } while ((ComputeCellForLocation(&p->loc)==CELL_INVALID)&&(attempts<csg_num_brushes));
   if (rtP.flat_only) p->fac.tx=p->fac.ty=0;
   return attempts<csg_num_brushes;
}

// cnt -1 means new setup
static void rendtest_init_new(void)
{
   int fd;
   
   rtP.rand_time=(rtP.rand_seed==0);
   if (rtP.rand_time)
      rtP.rand_seed=tm_get_millisec_unrecorded();
   srand(rtP.rand_seed);

   rtP.tests_left_at_this_source=-1;
   rtP.tests_run=0;

   if ((fd=dmp_find_free_file(cur_write_fname,"rtest","try"))!=-1)
      close(fd);
}

static grs_canvas *rendtest_maybe_build_subcanvas(void)
{
   int x_off=0, y_off=0;     // subcanvas offsets

   if ((rtP.view_width!=0)&&(rtP.view_width<grd_canvas->bm.w))
      x_off=(grd_canvas->bm.w-rtP.view_width)/2;
   if ((rtP.view_height!=0)&&(rtP.view_height<grd_canvas->bm.h))
      y_off=(grd_canvas->bm.h-rtP.view_height)/2;
   if ( (x_off>0) || (y_off>0) )
      return gr_alloc_sub_canvas(grd_canvas,x_off,y_off,
                               min(grd_canvas->bm.w,rtP.view_width),
                               min(grd_canvas->bm.h,rtP.view_height));
   return NULL;
}

static void do_angle_updates(void)
{
   if (rtP.inc_angle)
   {
      if (!rtP.flat_only)
      { rtP.pos.fac.ty+=rand()&0x7ff; rtP.pos.fac.tx+=rand()&0x7ff; }
      rtP.pos.fac.tz+=rand()&0x7ff;
   }
   else
   {
      if (!rtP.flat_only)
      { rtP.pos.fac.ty=rand()*2; rtP.pos.fac.tx=rand()*2; }
      rtP.pos.fac.tz=rand()*2;
   }
}

// actually update our position
static BOOL rtP_update_position(void)
{
   if (rtP.tests_left_at_this_source--<0)
   {  // get a new source
      Status("Find new location");
      if (!rendtest_pick_source_pos(&rtP.pos))
      {
         Status("Cant find source pos");
         return FALSE;
      }
      rtP.tests_left_at_this_source=rtP.tests_per_source;
   }
   else
   {  // raycast to a new position
      Location ray_dest, ray_hit;
      mxs_vector ray_end, delta;
      int tries=10;
      
      do {
         if (rtP.move_straight)
         {
            mxs_matrix move_mat;
            mxs_vector move_vec={1,0,0};
            if (tries<10) do_angle_updates(); // if moving straight isnt working, try angle change
            mx_ang2mat(&move_mat,&rtP.pos.fac);
            move_vec.el[0]=frand_hack();
            mx_mat_mul_vec(&delta,&move_mat,&move_vec);
         }
         else
            get_rand_vec(&delta,rtP.step_size);
         mx_add_vec(&ray_end,&rtP.pos.loc.vec,&delta);
         MakeHintedLocationFromVector(&ray_dest,&ray_end,&rtP.pos.loc);
         if (PortalRaycast(&rtP.pos.loc,&ray_dest,&ray_hit,0))
            break;                  // we did hit
      } while (--tries>0);
      if (tries<=0)                 // we failed, backup from hit
      {
         float mag=mx_mag_vec(&delta);
         mx_scaleeq_vec(&delta,mag/2.0);
         mx_addeq_vec(&delta,&ray_hit.vec);
         MakeHintedLocationFromVector(&ray_dest,&delta,&ray_hit);
      }
      do_angle_updates();
      rtP.pos.loc=ray_dest;
   }
   return TRUE;
}

// is it time to quit
static BOOL check_modal_quit(void)
{
   uiEvent ev;
   uiCookedKeyEvent *kev;
   uiMouseEvent *mev;
   if (modal_ui_get_event(&ev))
   {
      BOOL quit=FALSE;
      switch (ev.type)
      {
         case UI_EVENT_KBD_COOKED:
            kev=(uiCookedKeyEvent *)&ev;
            quit=(kev->code&KB_FLAG_DOWN); // quit if we see a down event
            break;
         case UI_EVENT_MOUSE:
            mev=(uiMouseEvent *)&ev;
            quit=(mev->action&(MOUSE_LDOWN|MOUSE_RDOWN));
            break;
      }
      return quit;
   }
   return FALSE;
}

void rendtest_run(BOOL new_run)
{
   grs_canvas *subc=NULL, *initial_canvas=grd_canvas;  // in case user doesnt want full screen
   char buf[100];            // for status messages
   BOOL first_frame=TRUE;

   if (new_run)
      rendtest_init_new();

   modal_ui_start(FALSE);  // sadly

   if ((subc=rendtest_maybe_build_subcanvas())!=NULL)
      gr_push_canvas(subc);

   while ((rtP.total_count<=0) || (rtP.tests_run<rtP.total_count))
   {
      if (new_run)
      {
         if (!rtP_update_position())
            break;
         write_rtP(cur_write_fname);
         portal_render_scene(&rtP.pos,1.0);      // now do the test
         sprintf(buf,"Frame %d of %d",++rtP.tests_run,rtP.total_count);
      }
      else if (first_frame)
      {
         portal_render_scene(&rtP.pos,1.0);      // now do the test
         sprintf(buf,"Rerun of Frame %d of %d",rtP.tests_run,rtP.total_count);
         first_frame=FALSE;
      }

      if (subc)
         gr_push_canvas(initial_canvas);
      Status(buf);
      if (subc)
         gr_pop_canvas();
      modal_ui_update();
      if (check_modal_quit())
         break;
   }
   modal_ui_end();
   if (subc)
   {
      gr_pop_canvas();
      gr_free_sub_canvas(subc);
   }
   if (rtP.rand_time) rtP.rand_seed=0;
   if (new_run)  // didnt crash, lose the record
      remove(cur_write_fname);
   gr_clear(0);
   sprintf(buf,"Rendered %d frames",rtP.tests_run);
   CommandExecute("redraw_all");
   _rtP_inuse=FALSE;
}

// the real command
void do_rendtest_cmd(int cnt)
{
   if (_rtP_inuse)
      Status("I think you have a dialog up");
   else if (gedit_editted)
      Status("Need portalized level to rendtest");
   else if (cnt==0)  // no arguments
      rendtest_dialog();
   else
   {
      rtP.total_count=cnt;
      _rtP_inuse=TRUE;
      rendtest_run(TRUE);
   }
}

static char last_rerun[255]=DEFAULT_FNAME;

void do_rendtest_rerun_cmd(char *fname)
{
   if ((fname!=NULL)&&(fname[0]!='\0'))
      strcpy(last_rerun,fname);
   if (read_rtP(last_rerun))
   {
      _rtP_inuse=TRUE;
      rendtest_run(FALSE);
   }
   else
   {
      char buf[300];
      sprintf(buf,"Cant open rendtest <%s>",last_rerun);
      Status(buf);
   }
}
#endif // SHIP
// $Header: r:/t2repos/thief2/src/editor/rendtest.h,v 1.2 2000/01/29 13:13:07 adurant Exp $
#pragma once

#ifndef __RENDTEST_H
#define __RENDTEST_H

#ifndef SHIP
// the rendtest command itself
EXTERN void do_rendtest_cmd(int cnt);
EXTERN void do_rendtest_rerun_cmd(char *fname);
#endif  // SHIP

#endif  // __RENDTEST_H
// $Header: r:/t2repos/thief2/src/editor/roompnp.c,v 1.15 2000/02/19 13:11:21 toml Exp $
// skeletal room PnP stuff

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <editobj.h>
#include <brinfo.h>
#include <gedit.h>
#include <comtools.h>

#include <gadblist.h>
#include <brushGFH.h>
#include <PnPtools.h>
#include <iobjsys.h>
#include <objsys.h>
#include <osysbase.h>
#include <objedit.h>
#include <linkedit.h>
#include <linkedst.h>
#include <linktype.h>

#include <otreeed.h>
#include <editinh.h>
#include <edinhst.h>

#include <modalui.h>

#include <iobjed.h>
#include <objedbas.h>
#include <edittool.h>

#include <ged_room.h>
#include <roomeax.h>
#include <roomprop.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 * 
 * 0 Our Name (id)
 * 1 RoomID
 * 2 Type
 * 3 xxxx
 * 4{create}  7{show}   
 * 5{edit}    8{show sel}
 * 6{links}   9{compile}
 */

#define NUM_BUTTONS (0xA)
static Rect roomPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (roomPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 4
#define BTN_BELOW 3
#define VERT_DIV  4
#define HORIZ_DIV (0.5)

void roomPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   for (i=0; i<BTN_ABOVE; i++)
      buildYLineRect(curRect++,whole,i,0,1,2,2);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,0,2,2);   
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,HORIZ_DIV,1,2,2);
}

#define EDIT_CREATE  1
#define EDIT_EDIT    2
#define EDIT_LINKS   3
#define EDIT_COMPILE 4
#define EDIT_SHOWSEL 5
#define EDIT_SHOWALL 6

// statics for the PnP itself
static ObjID roomObjId=0;
static editBrush *roomPnP_br;
static char roomPnP_myName[64];
static char roomPnP_myNum[64];
static char roomPnP_myType[64];

static _PnP_GadgData roomPnP;

void Update_roomPnP(GFHUpdateOp op, editBrush *br);

void roomPnP_setvars(editBrush *br, bool update)
{
   IObjectSystem *pObjSys = AppGetObj(IObjectSystem);
   int room_id;
   int room_type;

   if (update) br=roomPnP_br;
   else        roomPnP_br=br;

   if (br==NULL) return;  // no data, go home

   if (update)
   {
      brRoom_ObjID(br)=roomObjId;
      // do whatever i have to do to make it so, invalidate, so on
      // perhaps this means an i_changed_the_brush, eh?
   }
   else
      roomObjId=brRoom_ObjID(br);

   // Set name
   strncpy(roomPnP_myName,ObjEditName(brRoom_ObjID(br)),sizeof(roomPnP_myName));
   roomPnP_myName[sizeof(roomPnP_myName)-1] = '\0';

   room_id = brRoom_InternalRoomID(br);
   room_type = GetRoomAcoustics(room_id);

   sprintf(roomPnP_myNum, "%d", room_id);

   if (room_type < 0)
      sprintf(roomPnP_myType, "-unset-");
   else
      strncpy(roomPnP_myType, g_RoomTypes[room_type], sizeof(roomPnP_myType));

   SafeRelease(pObjSys);
}

static int  last_draw_sel = -1;
static BOOL draw_all = FALSE;

static void roomPnP_PopUp(int data)
{
   ObjID root_room;
   ObjID default_room;
   ObjID room_id;

   if (roomPnP_br == NULL) 
      return;

   room_id = brRoom_ObjID(roomPnP_br);

   // Get the root and default room ids
   root_room    = ged_room_get_root();
   default_room = ged_room_get_default();

   // Verify that our default archtype is concrete
   // @TODO: should make sure that its a valid room too
   if (OBJ_IS_ABSTRACT(ged_room_get_default_arch()))
      ged_room_set_default_arch(default_room);

   switch (data)
   {
      case EDIT_CREATE:
      {
         EditObjHierarchyRoom(room_id);

         // Slam it to room brush
         gedit_set_default_brush_type(brType_ROOM);

         // If they selected the root archetype, change to the default room
         if (ged_room_get_default_arch() == root_room)
            ged_room_set_default_arch(default_room);
            
         // Set the current brush to the selected room
         brRoom_ObjID(roomPnP_br) = ged_room_get_default_arch();

         // And update the PnP
         Update_roomPnP(GFH_FORCE, roomPnP_br);
      }
      break;

      case EDIT_EDIT:
      {
         sObjEditorDesc eddesc = { "" };
         IObjEditors* eds = AppGetObj(IObjEditors); 

         IObjEditor* ed = IObjEditors_Create(eds,&eddesc,room_id); 
         IObjEditor_Go(ed,kObjEdModal);
         SafeRelease(ed);
         SafeRelease(eds);

         break;
      }

      case EDIT_LINKS:
      {
         sLinkEditorDesc desc = { "", kLinkEditAllButtons };
         EditLinks(&desc, room_id, LINKOBJ_WILDCARD, RELID_WILDCARD);

         break;
      }
         
      case EDIT_SHOWALL:
      {
         last_draw_sel = -1;
         draw_all = !draw_all;
         ged_room_draw_all_connections(draw_all);

         break;
      }

      case EDIT_SHOWSEL:
      {
         if (brushGetType(roomPnP_br) == brType_ROOM)
         {
            if (brRoom_InternalRoomID(roomPnP_br) != last_draw_sel)
            {
               last_draw_sel = brRoom_InternalRoomID(roomPnP_br);
               ged_room_draw_connections(last_draw_sel, TRUE);
            }
            else
            {
               ged_room_draw_connections(-1, TRUE);
               last_draw_sel = -1;
            }
         }

         break;
      }

      case EDIT_COMPILE:
         ged_compile_rooms();
         break;
   }

}

void Create_roomPnP(LGadRoot* root, Rect* bounds, editBrush *br)
{
   GFHSetCoordMask(0);
   roomPnP_buildRects(bounds);
   PnP_GadgStart(&roomPnP,root);
   roomPnP_setvars(br,FALSE);

   PnP_TextBox(getRect(0),roomPnP_myName);
   PnP_TextBox(getRect(1),roomPnP_myNum);
   PnP_TextBox(getRect(2),roomPnP_myType);

   PnP_ButtonOneShot(getRect(4),"Create",roomPnP_PopUp,EDIT_CREATE);
   PnP_ButtonOneShot(getRect(5),"Edit",roomPnP_PopUp,EDIT_EDIT);
   PnP_ButtonOneShot(getRect(6),"Links",roomPnP_PopUp,EDIT_LINKS);
   PnP_ButtonOneShot(getRect(7),"Show All",roomPnP_PopUp,EDIT_SHOWALL);
   PnP_ButtonOneShot(getRect(8),"Show Sel",roomPnP_PopUp,EDIT_SHOWSEL);
   PnP_ButtonOneShot(getRect(9),"Compile",roomPnP_PopUp,EDIT_COMPILE);
}

void Destroy_roomPnP(void)
{
   PnP_GadgFree(&roomPnP);
   roomPnP_br=NULL;
}

void Update_roomPnP(GFHUpdateOp op, editBrush *br)
{
   roomPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      PnP_FullRedraw(&roomPnP);
}
// $Header: r:/t2repos/thief2/src/editor/saveload.c,v 1.22 2000/02/19 13:13:50 toml Exp $
// abstracted save/load for our burgeoning area of save/load formats

// for now, so we can make sure we dont have old broken data in vbrush saveoffs
#define PROTECT_DELETE

#include <stdlib.h>     // getenv

#include <lg.h>
#include <config.h>

#include <editbr.h>
#include <editbr_.h>
#include <brlist.h>
#include <brinfo.h>
#include <editobj.h>
#include <objmodel.h>
#include <vbrush.h>
#include <primal.h>
#include <mprintf.h>
#include <objremap.h>

#include <saveload.h>
#include <ged_rmap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// global which gets set and looked at for knowing name/user of current level
levelNameInfo saveloadLevelInfo;

// NOTE: this assume brush field update (for obj's) does
//  1) if obj exists, attach brush and sync brush to obj. 
//  2) if no obj, create it from the brush

// read in the brushes with the readfunc, insert into brush list
// if num_brush is != SAVELOAD_NO_COUNT, it will read that many
// returns TRUE if SAVELOAD_NO_COUNT, else returns whether it read num_brush brushes
bool saveloadReadBrushes(bool (*readnext)(editBrush *newbr), int num_brush, BOOL preserve_id)
{
   editBrush us, *tmp, *old_curs=blistGet();

   while ((*readnext)(&us))
   {
      // ignore object brushes - MAHK
      if (brushGetType(&us) == brType_OBJECT)
         continue;

      tmp=brushCopy(&us);
#ifdef PROTECT_DELETE
      if ((tmp->flags&kEBF_BeingDeleted)!=0)
      {
         Warning(("Hey! Brush %d is mid delete, it thinks\n",us.br_id));
         tmp->flags&=~kEBF_BeingDeleted;
      }
#endif
      if (preserve_id)
         tmp->br_id=us.br_id;   // here we copy the brush ids across for csg_brush
      blistInsert(tmp);         //   remapping compatibility
      blistSetPostoBrush(tmp);  // hack to try and fix the reversal of time on insert in middle
      //      brush_field_update(tmp,NULL,brField_Old);      // see NOTE above about brush_field_update
      if (num_brush!=SAVELOAD_NO_COUNT)  // if we have been given a count
         if (--num_brush==0)    // see if we have reached it
            break;              // done with real thing
   }
   if (preserve_id)
      ged_remap_brushes();
   blistSetPostoBrush(old_curs);
   return !(num_brush>0);     // if >0, we thought we had count, but failed somehow
}

BOOL saveloadPostLoadBrushes(void)
{
   int hIter;
   editBrush* us=blistIterStart(&hIter);
   while (us!=NULL)
   {
     //to fix room brush number remapping.
     if (brushGetType(us) == brType_ROOM)
       {
	 us->primal_id = ObjRemapOnLoad(us->primal_id);
       }
      brush_field_update(us,NULL,brField_Old);      // see NOTE above about brush_field_update
      us=blistIterNext(hIter);
   }
   return TRUE;
}

// writes out the brushes, by computing the correct size and passing it and
// the brush to the write function, which is supposed to store it out
bool saveloadWriteBrushes(bool (*writebr)(editBrush *br, int size), int groupFilter)
{
   int base_sz = sizeof(editBrush) - EDITBR_MAX_FACES * sizeof(TexInfo);
   editBrush *us;
   int hIter;
   
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      int xtra_sz=0;
      if ((groupFilter==0)||(brSelect_Group(us)==groupFilter))
      {
         int type = brushGetType(us);
#ifdef PROTECT_DELETE
         if ((us->flags&kEBF_BeingDeleted)!=0)
         {
            Warning(("Hey! Brush %d is mid delete, it thinks\n",us->br_id));
            us->flags&=~kEBF_BeingDeleted;
         }
#endif
         if (type==brType_TERRAIN)
            xtra_sz+=us->num_faces * sizeof(TexInfo);
         if (!(*writebr)(us,base_sz+xtra_sz))
            return FALSE;
      }
      us=blistIterNext(hIter);
   }
   return TRUE;
}

// reads contiguous model strings in from the file,
// md_cnt is number to read, name_len is strlen of each name
// readnext should return FALSE if it cant read the model
bool saveloadReadModels(bool (*readnext)(char *model, int len), int md_cnt, int name_len)
{
   int i;
   char *name=(char *)Malloc(name_len+1);

   for (i=0; i<md_cnt; i++)
   {
      if (!(*readnext)(name,name_len))
         break;
      if (name[0]!='\0')
         objmodelLoadModelIntoHandle(name,i);
   }
   Free(name);
   return i==md_cnt;
}

// same as ReadModel, basically
bool saveloadWriteModels(bool (*writenxt)(char *model, int len), int md_cnt, int name_len)
{
   char noname[]="";
   int i;
   
   for (i=0; i<md_cnt; i++)
   {
      char *name=objmodelGetName(i);
      if (name==NULL) name=noname;
      if (!(*writenxt)(name,name_len))
         break;
   }
   return i==md_cnt;
}

// get the current username from the environment
char *saveloadGetUser(void)
{
   static char buf[32];
   if (config_get_raw("user",buf,sizeof(buf)))
   {
      buf[sizeof(buf)-1]='\0';
      return buf;
   }
   else
   {
      char* val = getenv("USER");
      if (val != NULL) return val;
   }
   return "UNKNOWN";
}

///////////////
// various format fixup code

// to deal with levels from before group fields
static void _zeroGroup(editBrush *us)
 { brSelect_Group(us)=0; }

void saveloadZeroAllGroups(void)
{
   vBrush_GroupOp(TRUE,_zeroGroup);
}

// for old 0xDD filled fields
static void _clearOldFields(editBrush *us)
 { brSelect_Flag(us)=0; us->edge=us->point=0; us->group_id=0; }

void saveloadCleanVer1File(void)
{
   vBrush_GroupOp(TRUE,_clearOldFields);
}

// to fix texture alignment fields
static void _fixAlign(editBrush *us)
{
   int i;
   if (brushGetType(us)==brType_TERRAIN)
      for (i=0; i<us->num_faces; i++)
      {
         us->txs[i].tx_x/=4;
         us->txs[i].tx_y/=4;
      }
}

void saveloadFixAlignmentFields(void)
{
   vBrush_GroupOp(TRUE,_fixAlign);
}

// to fix old idiotic primal id space stuff
// in case you need to just go do something in code with a particular primal
#define OLD_PRIMAL_CUBE_IDX  (0)
#define OLD_PRIMAL_NUM_NGONS (16-3)
#define OLD_PRIMAL_CYL_BASE  (3)
#define OLD_PRIMAL_PYR_BASE  (3+OLD_PRIMAL_NUM_NGONS)
static void _fixPrimFields(editBrush *us)
{
   if ((brushGetType(us)==brType_TERRAIN)&&(us->primal_id!=OLD_PRIMAL_CUBE_IDX))
   {  // fix the old primal data
      BOOL odd=FALSE;
      if (us->primal_id<OLD_PRIMAL_CYL_BASE)
         odd=TRUE;
      if ((us->primal_id>=OLD_PRIMAL_CYL_BASE)&&(us->primal_id<OLD_PRIMAL_PYR_BASE))
         us->primal_id=primalID_Make(PRIMAL_TYPE_CYLINDER,us->primal_id-OLD_PRIMAL_CYL_BASE+3);
      else if (us->primal_id<OLD_PRIMAL_PYR_BASE+OLD_PRIMAL_NUM_NGONS)
         us->primal_id=primalID_Make(PRIMAL_TYPE_PYRAMID,us->primal_id-OLD_PRIMAL_PYR_BASE+3);
      else
         odd=TRUE;
      if (odd)
      {
         Warning(("Odd old level primal_id %d (on br %d)\n",us->primal_id,us->br_id));
         us->primal_id=PRIMAL_CUBE_IDX;
      }
   }
}

void saveloadFixIntPrimalIDs(void)
{
   vBrush_GroupOp(TRUE,_fixPrimFields);
}

////////////////
// for old misbuilt bad primals on non-terr brushes
static void _fixNonTerrPrimFields(editBrush *us)
{
   if ((brushGetType(us)!=brType_TERRAIN)&&(us->primal_id!=0))
      if (brushGetType(us)!=brType_ROOM)
      {
         us->num_faces=6;
         us->primal_id=0;
      }  // should we play with txs? probably not...
}

void saveloadFixNonTerrPrimalIDs(void)
{
   vBrush_GroupOp(TRUE,_fixNonTerrPrimFields);
}

////////////////
// for clearing the flags field

BOOL loud_flag_clear=FALSE;

static void _fixFlagFields(editBrush *us)
{
   if (loud_flag_clear)
      if (us->flags)
         mprintf("Brush %d had flags %x\n",(int)us->br_id,(int)us->flags);
   us->flags = 0;
}

void saveloadFixFlagField(void)
{
   vBrush_GroupOp(TRUE,_fixFlagFields);
}
// $Header: r:/t2repos/thief2/src/editor/roomtowr.cpp,v 1.4 1999/12/09 18:16:26 MAT Exp $

/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\
   roomtowr.cpp

   modifying our freshly-generated world rep according to properties
   on room brushes

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */


#include <mprintf.h>

#include <wrtype.h>
#include <wrfunc.h>
#include <bspsphr.h>
#include <room.h>
#include <rooms.h>

#include <roomtowr.h>

#include <dbmem.h>


/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\

   data types

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

struct sCallbackEntry
{
   sCallbackEntry(tRoomToWRCallback pfnCallback, void *pData)
      : m_pfnCallback(pfnCallback),
        m_pData(pData)
   {
   }

   tRoomToWRCallback m_pfnCallback;
   void *m_pData;
};


/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\

   constants

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

#define kToRightOfEdgeEpsilon .01


/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\

   internal globals--these only mean anything while we're in RoomToWR

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

static cDynArray<sCallbackEntry> g_Callbacks;
static cDynArray<tRoomToWRStartCallback> g_StartCallbacks;
static cDynArray<tRoomToWREndCallback> g_EndCallbacks;
static cDynArray<int> g_CellList;
static uchar g_aaVertexOffset[6][4]
= {
   {0, 4, 6, 2},        // x
   {1, 3, 7, 5},
   {0, 1, 5, 4},        // y
   {2, 6, 7, 3},
   {0, 2, 3, 1},        // z
   {4, 5, 7, 6},
};
static cRoom *g_pRoom;
static mxs_vector g_RoomCenter;
static mxs_vector g_RoomDims;
static float g_fRoomRadius;
static Location g_RoomLocation;
static mxs_plane g_aRoomPlane[6];
static mxs_vector g_aRoomVertexPool[8];


/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\

   weird little helper functions

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

// Does edge p1p2 cross the plane?  If so, stuff pIntersection with
// the point and return TRUE.
static inline BOOL EdgePolyIntersection(mxs_vector *p1, mxs_vector *p2,
                                        mxs_vector *pPlaneNorm,
                                        float fPlaneConstant,
                                        mxs_vector *pIntersection)
{
   float fDist1 = mx_dot_vec(p1, pPlaneNorm) + fPlaneConstant;
   float fDist2 = mx_dot_vec(p2, pPlaneNorm) + fPlaneConstant;

   // Are both endpoints on the same side of the plane?
   if ((fDist1 > 0 && fDist2 > 0) || (fDist1 < 0 && fDist2 < 0))
      return FALSE;

   float fTime = fDist1 / (fDist1 - fDist2);
   mx_interpolate_vec(pIntersection, p1, p2, fTime);
   return TRUE;
}


// Is this point to the right of this edge, in a plane with this norm?
static inline BOOL ToRightOfEdge(mxs_vector *pPoint, mxs_vector *pE1,
                                mxs_vector *pE2, mxs_vector *pPlaneNorm)
{
   mxs_vector EdgeToPoint;
   mx_sub_vec(&EdgeToPoint, pPoint, pE1);
   mx_normeq_vec(&EdgeToPoint);

   mxs_vector Edge, Perp;
   mx_sub_vec(&Edge, pE2, pE1);
   mx_cross_vec(&Perp, &Edge, pPlaneNorm);
   mx_normeq_vec(&Perp);

   // Now we have two unit vectors, one perpendicular to the edge and
   // the other pointing from the first vertex of the edge to our
   // point.  How close a match are they?
   if (mx_dot_vec(&EdgeToPoint, &Perp) > -kToRightOfEdgeEpsilon)
      return TRUE;
   else
      return FALSE;
}


// Given polygon A and polygon B, does any edge of polygon A pass
// through polygon B?  We don't catch cases where they are coplanar.
static BOOL PolyEdgeTest(uchar *pAVert, mxs_vector *pAPool, int iANumEdges,
                         mxs_vector *pAPlaneNorm, float fAPlaneConstant,
                         uchar *pBVert, mxs_vector *pBPool, int iBNumEdges,
                         mxs_vector *pBPlaneNorm, float fBPlaneConstant)
{
   // iterate over all edges in polygon A
   for (int i = 0; i < iANumEdges; ++i) {
      mxs_vector Intersection;

      // Does this edge intersect the plane of polygon B?
      if (EdgePolyIntersection(&pAPool[pAVert[i]],
                               &pAPool[pAVert[(i + 1) & iANumEdges]],
                               pBPlaneNorm, fBPlaneConstant, &Intersection)) {

         // If all of the edges of polygon B are to the right of our
         // intersection point, or all are to the left (because the
         // polygon is wound the other way), then the intersection is
         // inside polygon B and our polygons intersect.

         // The first edge goes from the last point in the poly to the
         // first.
         BOOL bToRight = ToRightOfEdge(&Intersection,
                                       &pBPool[pBVert[iBNumEdges - 1]],
                                       &pBPool[pBVert[0]], pBPlaneNorm);

         // Here's all the other edges.
         for (int j = 0; j < (iBNumEdges - 1); ++j) {
            if (bToRight != ToRightOfEdge(&Intersection, &pBPool[pBVert[j]],
                                        &pBPool[pBVert[j + 1]], pBPlaneNorm)) {
               break;
            }
         }

         if (j == (iBNumEdges - 1))
            return TRUE;
      }
   }

   return FALSE;
}


static BOOL PolygonsIntersect(uchar *pAVert, mxs_vector *pAPool,int iANumEdges,
                              mxs_vector *pAPlaneNorm, float fAPlaneConstant,
                              uchar *pBVert, mxs_vector *pBPool,int iBNumEdges,
                              mxs_vector *pBPlaneNorm, float fBPlaneConstant)
{
   if (PolyEdgeTest(pAVert, pAPool, iANumEdges, pAPlaneNorm, fAPlaneConstant,
                    pBVert, pBPool, iBNumEdges, pBPlaneNorm, fBPlaneConstant))
      return TRUE;

   if (PolyEdgeTest(pBVert, pBPool, iBNumEdges, pBPlaneNorm, fBPlaneConstant,
                    pAVert, pAPool, iANumEdges, pAPlaneNorm, fAPlaneConstant))
      return TRUE;

   return FALSE;
}


// set up info about room: center, planes, vertices
static void SetGlobalsForRoom(cRoom *pRoom)
{
   g_pRoom = pRoom;
   g_RoomCenter = pRoom->GetCenterPt();
   MakeLocationFromVector(&g_RoomLocation, &g_RoomCenter);
   g_RoomDims = pRoom->GetSize();
   g_fRoomRadius = mx_mag_vec(&g_RoomDims);

   int i;
   for (i = 0; i < 6; ++i) {
      tPlane P = pRoom->GetPlane(i);

      g_aRoomPlane[i].v = P.normal;
      g_aRoomPlane[i].d = P.d;
   }

   mxs_vector aAxis[3];
   for (i = 0; i < 3; ++i)
      mx_scale_vec(&aAxis[i], &g_aRoomPlane[i].v, g_RoomDims.el[i]);

   for (i = 0; i < 8; ++i) {
      mx_copy_vec(&g_aRoomVertexPool[i], &g_RoomCenter);
      mx_scale_addeq_vec(&g_aRoomVertexPool[i], &aAxis[0], (i&1)? -1 : 1);
      mx_scale_addeq_vec(&g_aRoomVertexPool[i], &aAxis[1], (i&2)? -1 : 1);
      mx_scale_addeq_vec(&g_aRoomVertexPool[i], &aAxis[2], (i&4)? -1 : 1);
   }
}


// Does the current room intersect this world rep cell?
static BOOL RoomIntersectsCell(int iCellIndex)
{
   PortalCell *pCell = WR_CELL(iCellIndex);

   // If either of these guys contains a point inside the other, they
   // intersect and we're done.  This is a little goofy since the room
   // system and Portal have different epsilons for their tests.
   if (g_pRoom->PointInside(pCell->sphere_center))
      return TRUE;
   if (PortalTestInCell(iCellIndex, &g_RoomLocation))
      return TRUE;

   // Quick rejection?
   float fDist = mx_dist_vec(&pCell->sphere_center, &g_RoomCenter);
   if (fDist > (g_fRoomRadius + pCell->sphere_radius))
      return FALSE;

   // iterate over polygons of cell and faces of room and compare
   // everything to everything exhaustingly
   PortalPolygonCore *pPoly = pCell->poly_list;
   int iCellVertexIndex = 0;

   int i, j;
   for (i = 0; i < pCell->num_polys; ++i) {
      for (j = 0; j < 6; ++j) {
         if (PolygonsIntersect(
                // poly from cell
                pCell->vertex_list + iCellVertexIndex, pCell->vpool,
                pPoly->num_vertices, &pCell->plane_list[pPoly->planeid].normal,
                pCell->plane_list[pPoly->planeid].plane_constant,

                // poly from room
                g_aaVertexOffset[j], g_aRoomVertexPool,
                4, &g_aRoomPlane[j].v,
                g_aRoomPlane[j].d))
            return TRUE;
      }
      iCellVertexIndex += pPoly->num_vertices;
      ++pPoly;
   }

   return FALSE;
}


// There are two steps to finding which world rep cells intersect a
// given room.  First, we use the BSP-sphere intersector for a rough
// cut.  Then we check each cell against the room individually.
static void SetCellsIntersectingRoom(cRoom *pRoom)
{
   int i;

   // find all cells intersecting the bounding sphere of our room
   g_CellList.SetSize(BSPSPHR_OUTPUT_LIMIT);

   SetGlobalsForRoom(pRoom);
   g_CellList.SetSize(portal_cells_intersecting_sphere(&g_RoomLocation,
                             g_fRoomRadius, g_CellList.AsPointer()));

   if (!g_CellList.Size() || g_CellList.Size() == (BSPSPHR_OUTPUT_LIMIT - 1)) {
      // use all cells
      g_CellList.SetSize(wr_num_cells);
      for (i = 0; i < wr_num_cells; ++i)
         g_CellList[i] = i;
   }

   // There may be cells which intersect the sphere, but not the
   // room.  For that matter, we may have cells which don't even
   // intersect the sphere, since the intersection is done
   // quick-and-dirty style.  So we iterate over the list and knock
   // out any cells which aren't really intersecting our room.
   for (i = 0; i < g_CellList.Size(); ++i) {
      if (!RoomIntersectsCell(g_CellList[i])) {
         g_CellList.FastDeleteItem(i);
         --i;
      }
   }
}


/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\

   weird little exposed functions

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

void RoomToWRAddCallback(tRoomToWRCallback pfnCallback, void *pData)
{
   for (int i = 0; i < g_Callbacks.Size(); ++i)
      if (g_Callbacks[i].m_pfnCallback == pfnCallback
       && g_Callbacks[i].m_pData == pData) {
         Warning(("RoomToWR: Callback already added.  Leave me alone.\n"));
         return;
      }

   g_Callbacks.Append(sCallbackEntry(pfnCallback, pData));
}


void RoomToWRAddStartCallback(tRoomToWRStartCallback pfnCallback)
{
   for (int i = 0; i < g_StartCallbacks.Size(); ++i)
      if (g_StartCallbacks[i] == pfnCallback) {
         Warning(("RoomToWR: Start callback already added.\n"));
         return;
      }

   g_StartCallbacks.Append(pfnCallback);
}


void RoomToWRAddEndCallback(tRoomToWREndCallback pfnCallback)
{
   for (int i = 0; i < g_EndCallbacks.Size(); ++i)
      if (g_EndCallbacks[i] == pfnCallback) {
         Warning(("RoomToWR: End callback already added.\n"));
         return;
      }

   g_EndCallbacks.Append(pfnCallback);
}


// For every room, we find out what WR cells intersect it and call out
// to whatever clients are interested.
void RoomToWRProcess()
{
   int i, iCell, iCB;

   for (iCB = 0; iCB < g_StartCallbacks.Size(); ++iCB)
      g_StartCallbacks[iCB]();

   int iNumRooms = g_pRooms->GetNumRooms();
   for (i = 0; i < iNumRooms; ++i) {
      cRoom *pRoom = g_pRooms->GetRoom(i);
      if (pRoom->GetObjID() == OBJ_NULL)
         continue;

      SetCellsIntersectingRoom(pRoom);

      for (iCell = 0; iCell < g_CellList.Size(); ++iCell)
         for (iCB = 0; iCB < g_Callbacks.Size(); ++iCB)
            g_Callbacks[iCB].m_pfnCallback(g_CellList[iCell], pRoom,
                                           g_Callbacks[iCB].m_pData);
   }

   g_CellList.SetSize(0);

   for (iCB = 0; iCB < g_EndCallbacks.Size(); ++iCB)
      g_EndCallbacks[iCB]();
}
// $Header: r:/t2repos/thief2/src/editor/roomtowr.h,v 1.1 1999/12/01 09:26:03 MAT Exp $

/* --=<= --/-/-/-/-/-/-/ <(< (( ((( /^^\ ))) )) >)> \-\-\-\-\-\-\-- =>=-- *\
   roomtowr.h

   There are a few cases where we want to use room brushes to flag, at
   least in a rough way, cells in the world rep.  This works something
   like flow brushes, finding which geometry intersects which.
   Clients should install their callbacks once on app init.

   RoomToWRProcess, the main function, should be called right after
   the world rep has been generated.

   This stuff should only exist in editor builds.

\* --=<= --\-\-\-\-\-\-\ <(< (( ((( \vv/ ))) )) >)> /-/-/-/-/-/-/-- =>=-- */

#ifndef _ROOMTOWR_H_
#pragma once
#define _ROOMTOWR_H_

#include <wrdb.h>

class cRoom;

// We call these on every cell/room combination which intersect.
typedef void (* tRoomToWRCallback)(int iCell, cRoom *pRoom, void *pData);

// We call these as the first step in RoomToWRProcess.
typedef void (* tRoomToWRStartCallback)();

// We call these as the final step in RoomToWRProcess.
typedef void (* tRoomToWREndCallback)();

extern void RoomToWRAddCallback(tRoomToWRCallback pfnCallback, void *pData);
extern void RoomToWRAddStartCallback(tRoomToWRStartCallback pfnCallback);
extern void RoomToWRAddEndCallback(tRoomToWREndCallback pfnCallback);
extern void RoomToWRProcess();

#endif // ~_ROOMTOWR_H_
// $Header: r:/t2repos/thief2/src/editor/saveload.h,v 1.8 2000/01/29 13:13:08 adurant Exp $
// a few simple saveload system functions
// in particular, too minimize code duplication/bit rot across our saveload in cow and bl and stuff
#pragma once

#ifndef __SAVELOAD_H
#define __SAVELOAD_H

typedef struct {
   char  user[16];     // last user to save this level
   char  creator[16];  // first user to save the level
   char  fullname[64]; // fancy level name from the "fancy name" dialog
} levelNameInfo;

EXTERN levelNameInfo saveloadLevelInfo;

// actually load or read brushes, use read/write callback as appropriate
//   num_brush can be set to SAVELOAD_NO_COUNT if you want to read as many as you can find
//   size is the size of the currently to be written brush, based on brType of br
EXTERN bool saveloadReadBrushes(bool (*readnext)(editBrush *newbr), int num_brush, BOOL preserve_id);
EXTERN bool saveloadWriteBrushes(bool (*writebr)(editBrush *br, int size), int groupFilter);
EXTERN BOOL saveloadPostLoadBrushes(void);

// reads contiguous model strings in from the file,
//   md_cnt is number to read, name_len is strlen of each name
//   callback should return FALSE if it cant read/write the model
EXTERN bool saveloadReadModels(bool (*readnext)(char *name, int len), int md_cnt, int str_len);
EXTERN bool saveloadWriteModels(bool (*writenxt)(char *name, int len), int md_cnt, int str_len);

// get the current username from the environment, either config file or getenv
EXTERN char *saveloadGetUser(void);

#define SAVELOAD_NO_COUNT (-1)

EXTERN void saveloadZeroAllGroups(void);        // zero all groups
EXTERN void saveloadCleanVer1File(void);        // zap all fields of a ver1 file from 0xDD
EXTERN void saveloadFixAlignmentFields(void);   // fix all texture alignment fields in terrain brushes
EXTERN void saveloadFixIntPrimalIDs(void);      // fix old primal ids from old headers
EXTERN void saveloadFixNonTerrPrimalIDs(void);  // deal with non-terrain brushes with zany primal ids
EXTERN void saveloadFixFlagField(void);         // zero all flag fields

#endif // __SAVELOAD_H
// $Header: r:/t2repos/thief2/src/editor/scrnedit.cpp,v 1.2 2000/02/19 13:11:22 toml Exp $
#include <scrnedit.h>
#include <scrnmode.h>
#include <sdesbase.h>
#include <sdestool.h>
#include <isdesced.h>
#include <isdescst.h>
#include <string.h>

#include <gamescrn.h>
#include <command.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


//------------------------------------------------------------
// Screen mode sdesc 
//

static const char* valid_names[] = 
{
   "Dimensions",
   "Depth",
   "Flags", 
};

static const char* flag_names[] = 
{
   "Fullscreen",
   "Windowed",
   "Hardware",
   "DirectX",
};

static sFieldDesc mode_fields[] = 
{
   { "Valid Parameters", kFieldTypeBits, FieldLocation(sScrnMode,valid_fields), 0, 0, FieldNames(valid_names) }, 
   { "Width", kFieldTypeInt, FieldLocation(sScrnMode,w), kFieldFlagUnsigned }, 
   { "Height", kFieldTypeInt, FieldLocation(sScrnMode,h), kFieldFlagUnsigned }, 
   { "Bit Depth", kFieldTypeInt, FieldLocation(sScrnMode,bitdepth), kFieldFlagUnsigned }, 
   { "Flags", kFieldTypeBits, FieldLocation(sScrnMode,flags), 0, 0, FieldNames(flag_names) }, 
}; 

static sStructDesc mode_sdesc = StructDescBuild(sScrnMode,0,mode_fields); 

//------------------------------------------------------------

BOOL EditScreenMode(const char* title, struct sScrnMode* mode)
{
   sStructEditorDesc eddesc = { "", kStructEditNoApplyButton};
   strncpy(eddesc.title,title,sizeof(eddesc.title));
   eddesc.title[sizeof(eddesc.title)-1] = '\0'; 

   IStructEditor* ed = CreateStructEditor(&eddesc,(sStructDesc*)&mode_sdesc,mode);

   BOOL result = ed->Go(kStructEdModal);
   SafeRelease(ed);
   return result;
}

//------------------------------------------------------------
// Commands
//

static void game_mode_edit(void)
{
   sScrnMode mode = *GetGameScreenMode(); 
   if (EditScreenMode("Default Game Screen Mode",&mode))
      SetGameScreenMode(&mode); 
}

//----------------------------------------

static Command commands[] = 
{
   { "game_mode_edit", FUNC_VOID, game_mode_edit, "Edit screen mode params for game mode.", HK_EDITOR },
}; 

void ScrnEditInit(void)
{
   COMMANDS(commands,HK_ALL); 
}

void ScrnEditTerm(void)
{
}
// $Header: r:/t2repos/thief2/src/editor/scrnedit.h,v 1.1 1998/10/07 14:30:12 mahk Exp $
#pragma once  
#ifndef __SCRNEDIT_H
#define __SCRNEDIT_H

//------------------------------------------------------------
// Editing tools for sScrnMode
//
EXTERN BOOL EditScreenMode(const char* title, struct sScrnMode* mode); 

EXTERN void ScrnEditInit(void); 
EXTERN void ScrnEditTerm(void); 


#endif // __SCRNEDIT_H
// $Header: r:/t2repos/thief2/src/editor/scrpted.cpp,v 1.2 2000/02/19 13:11:24 toml Exp $
#include <simpwrap.h>
#include <scrptpr_.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern "C" 
BOOL PickAndDropScript(void)
{
   BOOL retval = FALSE; 
   char **ppszMenu = (char **) Malloc(1);
   int iNumMenuSlots = 0;

   cScriptProp::cModuleSet::cIter iter;
   for (iter = cScriptProp::TheProp->Modules(); !iter.Done(); iter.Next())
   {
      ppszMenu = (char **) Realloc(ppszMenu, 
                                   (iNumMenuSlots + 1) * sizeof(char *));
      ppszMenu[iNumMenuSlots]
         = (char *) Malloc(sizeof (char) * (strlen(iter.Value().name) + 1));
      sprintf(ppszMenu[iNumMenuSlots], "%s", iter.Value().name);
      ++iNumMenuSlots;
   }

   // pop up our menu
   if (iNumMenuSlots) {
      int iChoice = PickFromStringList("Pick a module to drop",
                                       (const char **) ppszMenu, 
                                       iNumMenuSlots);
      if (iChoice != -1) {
         cScriptProp::TheProp->DropModule(ppszMenu[iChoice]);
         retval = TRUE;
      }
    }

   // get rid of all this stuff
   for (int i = 0; i < iNumMenuSlots; ++i)
      Free(ppszMenu[i]);
   Free(ppszMenu);
   return retval; 

}
// $Header: r:/t2repos/thief2/src/editor/scrpted.h,v 1.1 1998/04/12 17:04:17 mahk Exp $
#pragma once  
#ifndef __SCRPTED_H
#define __SCRPTED_H

#ifdef EDITOR
EXTERN BOOL PickAndDropScript(void);
#else
#define PickAndDropScript() FALSE 
#endif 

#endif // __SCRPTED_H
// $Header: r:/t2repos/thief2/src/editor/sdesedit.h,v 1.6 2000/01/29 13:13:09 adurant Exp $
#pragma once

#ifndef __SDESEDIT_H
#define __SDESEDIT_H

#include <sdestype.h>

typedef struct StructEditor StructEditor;
typedef struct StructEditorDesc StructEditorDesc;

typedef ulong eStructEditorFlags;
typedef ulong eStructEditEventType;

//
// Attach a callback to a struct editor.  Each struct editor can have only
// one callback
//

typedef struct StructEditEvent StructEditEvent;
typedef void* StructEditCBData;

typedef void (*StructEditCB)(StructEditEvent* event, StructEditCBData data);

EXTERN void StructEditorInstallCallback(StructEditor* ed, StructEditCB cb, StructEditCBData data);

//
// Create a structure editor for a data block
// IF root is NULL, creates it in the LGadCurrentRoot();
// 

EXTERN StructEditor* StructEditorCreate(StructEditorDesc* editdesc, sStructDesc* sdesc, void* editme);

// if you want to have a struct editor BLOCK on its done/cancel 
// returns true if done, false if cancel
EXTERN BOOL StructEditorGoModal(StructEditor* ed);

//
// Accessors
//

EXTERN StructEditorDesc*   StructEditorGetDesc(StructEditor* ed);
EXTERN sStructDesc*        StructEditorGetStructDesc(StructEditor* ed);
EXTERN void*               StructEditorGetStruct(StructEditor* ed);

//
// Destroy a struct editor
//

EXTERN void StructEditorDestroy(StructEditor* ed);

#endif // __SDESEDIT_H
// $Header: r:/t2repos/thief2/src/editor/sdesedst.h,v 1.7 2000/01/29 13:13:11 adurant Exp $
#pragma once

#ifndef __SDESEDST_H
#define __SDESEDST_H

#include <rect.h>
#include <sdestype.h>
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

//
// Struct Editor Flags (part of the editor descriptor)
//

enum _eStructEditorFlags 
{
   kStructEditNoFieldNames  = (1 << 0),  // don't show field names
   kStructEditShowTypes     = (1 << 1),  // DO show types (defaults OFF!)
   kStructEditFriendlyTypes = (1 << 2),  // user-friendly type names (String instead of char*)
   kStructEditDoneButton    = (1 << 3),  // Add a "Done" button
   kStructEditCancelButton  = (1 << 4),  // Add a "Cancel" button
   kStructEditApplyButton   = (1 << 5),  // Add an "Apply" button
};

#define kStructEditAllButtons (kStructEditDoneButton | kStructEditCancelButton | kStructEditApplyButton)

// 
// Struct Editor Descriptor
//

struct StructEditorDesc 
{
   char title[32]; // Title string appearing at top of gadget;
   eStructEditorFlags flags;
};

////////////////////

//
// Edit event types
//

enum _eStructEditEventType
{
   kStrEdEventApply,    // Apply button was hit
   kStrEdEventFieldChange,   // A field was changed
   kStrEdEventDone,        // We're done
   kStrEdEventCancel,      // We've been cancelled.
};

//
// The event structure
//

struct StructEditEvent
{
   eStructEditEventType type; // what happened?
   StructEditor* editor;      // to whom?
   void* eventdata;           // event-type-specific info
};

//
// Struct Editor
//

#define MAX_FIELDS 32
#define MAX_STRLEN 32

enum eStructEditorStatusFlags
{
   kSdescInProgress = 1 << 0,
   kSdescOK         = 1 << 1,
};


struct StructEditor
{
   StructEditorDesc     editdesc;
   void*                cur_struc;
   const sStructDesc*   sdesc;
   int                  numbutts;
   StructEditCB         cb;
   StructEditCBData     cbdata;
   Rect*                rects;
   ulong*               p_flags;    // pointer to flag word
   ulong                def_flags;  // flag word if not modal

   HWND                 hWnd;
   HINSTANCE            hInst;
   HWND                 textbox[MAX_FIELDS];
   HFONT                hWndFont;
};

#endif // __SDESEDST_H



// $Header: r:/t2repos/thief2/src/editor/sdesparm.cpp,v 1.6 1998/10/05 17:27:53 mahk Exp $

#include <comtools.h>
#include <appagg.h>

#include <scrptbas.h>
#include <sdesparm.h>

#include <sdesbase.h>
#include <sdestool.h>

// Must be last header 
#include <dbmem.h>


static IStructDescTools* SdescTools()
{
   static IStructDescTools* tools = NULL;
   if (tools == NULL)
   {
      tools = AppGetObj(IStructDescTools);
   }
   return tools;
} 

cMultiParm GetParmFromField(const sFieldDesc* field, void *buf)
{
   cMultiParm retval = 0; 

   switch (field->type)
   {
      case kFieldTypeInt:
      case kFieldTypeShort:
      case kFieldTypeBits:
      case kFieldTypeEnum:
      case kFieldTypeFix:
      {
         long val;
         SdescTools()->GetIntegral(field,buf,&val);
         retval = (int)val;
      }
      break;

      case kFieldTypeBool:
      {
         long val;
         SdescTools()->GetIntegral(field,buf,&val);
         retval = (boolean)val;
      }
      break;

      case kFieldTypeFloat:
         retval =  *(float*)((char*)buf + field->offset);
         break;

      case kFieldTypeVector:
         retval = *(mxs_vector*)((char*)buf + field->offset); 
         break;

      default:
      {
         int len = field->size < 64 ? 64 : field->size;
         char* str = new char[len];
         SdescTools()->UnparseField(field,buf,str,len);
         retval = (string)str;
         delete [] str;
      }
      break;
   }
   return retval; 
}

void SetFieldFromParm(const sFieldDesc* field, void *buf, const cMultiParm& val)
{
   switch (field->type)
   {
      case kFieldTypeInt:
      case kFieldTypeShort:
      case kFieldTypeBits:
      case kFieldTypeEnum:
      case kFieldTypeBool:
      case kFieldTypeFix:
         SdescTools()->SetIntegral(field,(int)val,buf);
         break;

      case kFieldTypeFloat:
         *(float*)((char*)buf + field->offset) = (float)val;
         break;

      case kFieldTypeVector:
         *(mxs_vector*)((char*)buf + field->offset) = (mxs_vector)val;
         break;


      default:
         SdescTools()->ParseField(field,(const char*)val,buf);
         break;
   }
}   


void FillStructFromParams(const sStructDesc* sdesc, void* struc, cMultiParm** parms, int nparms)
{
   int n = sdesc->nfields;
   if (n > nparms) n = nparms; 
   for (int i = 0; i < n; i++)
   {
      const sFieldDesc* field  = &sdesc->fields[i]; 
      const cMultiParm& val = *parms[i]; 

      SetFieldFromParm(field,struc,val); 
   }
}

// $Header: r:/t2repos/thief2/src/editor/sdesparm.h,v 1.2 1997/12/30 17:50:13 mahk Exp $
#pragma once  
#ifndef __SDESPARM_H
#define __SDESPARM_H

////////////////////////////////////////////////////////////
// SDESC MULTIPARM TOOLS
//

class cMultiParm; 

extern void SetFieldFromParm(const struct sFieldDesc* field, void *struc, const cMultiParm& parm);
extern cMultiParm GetParmFromField(const struct sFieldDesc* field, void *struc); 

extern void FillStructFromParams(const struct sStructDesc* sdesc, void* struc, cMultiParm** params, int nparams); 



#endif // __SDESPARM_H



// $Header: r:/t2repos/thief2/src/editor/simpwrap.cpp,v 1.2 2000/02/19 13:11:25 toml Exp $
// wrappers around darkdlgs dll "simple" menus and other ui tools

#include <wtypes.h>
#include <dynfunc.h>

#include <simpwrap.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// here we go, copied in dll hookup zaniness

//////////////
// simplemenu

static int simpmenu_woe(const char*, const menustring*, int )
{
//   CriticalMsg("Could not load dialog!");
   return -1; 
}

DeclDynFunc_(int, LGAPI, DoSimpleMenu, (const char*, const menustring*, int));
ImplDynFunc(DoSimpleMenu, "darkdlgs.dll", "_DoSimpleMenu@12", simpmenu_woe);

#define SimpleMenu (DynFunc(DoSimpleMenu).GetProcAddress())

int PickFromStringList(char *title, const menustring* list, int cnt)
{
   return SimpleMenu(title,list,cnt);
}
// $Header: r:/t2repos/thief2/src/editor/simpwrap.h,v 1.2 2000/01/29 13:13:12 adurant Exp $
// wrappers around darkdlgs dll "simple" menus and other ui tools
#pragma once

#ifndef __SIMPWRAP_H
#define __SIMPWRAP_H

typedef const char* menustring;

// bring up menu of the strings in list, of which there are cnt, titled Title
// return -1 if no pick, else the picked item
EXTERN int PickFromStringList(char *title, const menustring* list, int cnt);

#endif  // __SIMPWRAP_H
// $Header: r:/t2repos/thief2/src/editor/status.c,v 1.12 2000/02/19 13:11:27 toml Exp $

// Status line system

#include <string.h>

#include <lg.h>
#include <2d.h>
#include <res.h>
#include <rect.h>
#include <guistyle.h>

#include <status.h>

#include <editor.h>
#include <scrnman.h>

#include <config.h>
#include <cfgdbg.h>
#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////  If I were Mahk, this would be
////  data driven and determined by layout
////  But I'm not, so I won't.

////  Start points are expressed as
////  locations from 0..100

  // foreground/background colors
#define STATUS_BG  (guiStyleGetColor(NULL,StyleColorWhite))
#define STATUS_FG  (guiStyleGetColor(NULL,StyleColorBlack))

#define MAX_FIELDS  SF_NUM_FIELDS
#define MAX_FIELD_SIZE  128

static int default_size[MAX_FIELDS] =
{
    0,
    1, 
   20,
   40,
   42,
   75,
   77,
   79,
};

static int default_x[MAX_FIELDS+1];
static int current_x[MAX_FIELDS+1];
static int current_size[MAX_FIELDS];
char status_string[MAX_FIELDS][MAX_FIELD_SIZE];

static Rect rect;
static int chr;        // typical character width
#if 0
static bool overflow;  // do we have any strings that have gone qwazy?
#endif

static int status;         // is the status line enabled, to what nesting?
static bool redraw=TRUE;  // do we have pending stuff to show?

void StatusEnable(void)
{
   if (++status > 2)
      ConfigSpew("status_spew",("StatusEnable called %d times not StatusDisabled\n", status));
}

void StatusDisable(void)
{
   if (--status < 0)
      ConfigSpew("status_spew",("StatusDisable: Called too many times.\n"));
   redraw = TRUE;
}

void StatusSetRect(Rect *r)
{
   int i;
   rect = *r;
   guiStyleSetupFont(NULL,StyleFontNormal); 
   chr = gr_font_char_width(gr_get_font(), 'a');
   guiStyleCleanupFont(NULL,StyleFontNormal); 
   current_x[MAX_FIELDS] = grd_bm.w;
   for (i=0; i < MAX_FIELDS; ++i) {
      default_x[i] = grd_bm.w * default_size[i] / 100;
      current_x[i] = default_x[i];
   }
}

static grs_canvas canv;

void StatusStartDrawing(void)
{
   short w = RectWidth(&rect);
   short h = RectHeight(&rect);
   
   gr_init_sub_canvas(grd_canvas, &canv, rect.ul.x, rect.ul.y,w,h);
   gr_push_canvas(&canv);

}

void StatusStopDrawing(void)
{
   gr_pop_canvas();
   ScrnForceUpdateRect(&rect);
   gr_close_canvas(&canv);
}

void StatusDrawString(int f)
{
   int x0 = current_x[f];
   int x1 = current_x[f+1];
   grs_clip clip = grd_gc.clip;

   gr_set_fcolor(STATUS_BG);
   gr_rect(x0,0,x1,grd_bm.h);
   gr_safe_set_cliprect(x0,0,x1-1,grd_bm.h-1);
   gr_set_fcolor(STATUS_FG);
   guiStyleSetupFont(NULL,StyleFontNormal); 
   gr_string(status_string[f], x0, 0);
   guiStyleCleanupFont(NULL,StyleFontNormal); 

   grd_gc.clip = clip;
}

void StatusDrawStringAll(void)
{
   int i;
   StatusStartDrawing();
   for (i=0; i < MAX_FIELDS; ++i)
       StatusDrawString(i);
   StatusStopDrawing();
}


int str_wid(char* s)
{
   guiStyleSetupFont(NULL,StyleFontNormal); 
   gr_font_string_width(gr_get_font(),s); 
   guiStyleCleanupFont(NULL,StyleFontNormal); 
}

void StatusField(int x, char *s)
{
   int cur_sz;

   if (x < 0 || x > MAX_FIELDS)
      Error(1, "Invalid status field parameter %d\n", x);
   if (!strcmp(status_string[x], s))
      return;

   strncpy(status_string[x], s, MAX_FIELD_SIZE);

   if (!status) {
      redraw = TRUE;
      return;
   }

   cur_sz = current_size[x];
   current_size[x] = str_wid(s);

     // if we're not in a wacky overflow state, and
     // this string fits in the default size, then
     // just draw it
#if 0
   if (current_size < cur_sz && !overflow) {
#endif
      StatusStartDrawing();
      StatusDrawString(x);
      StatusStopDrawing();
#if 0
   }
#endif
}

void Status(char *s)
{
   StatusField(SF_STATUS, s);
#ifndef SHIP   
   if (*s != '\0' && config_is_defined("status"))
      mprintf("STATUS: %s\n",s);
#endif 
}

void StatusRecomputeAll(void)
{
   int i;
   for (i=0; i < MAX_FIELDS; ++i)
      current_size[i] = str_wid(status_string[i]);
   StatusDrawStringAll();
}

void StatusUpdate(void)
{
   if (redraw) {
      StatusRecomputeAll();
      redraw = FALSE;
   }
}
// $Header: r:/t2repos/thief2/src/editor/status.h,v 1.7 2000/01/29 13:13:13 adurant Exp $
#pragma once

#ifndef __STATUS_H
#define __STATUS_H

#define SF_FILESTATE   0
#define SF_FILENAME    1
#define SF_GAMESYSNAME 2
#define SF_CUR_ITEM    3
#define SF_STATUS      4
#define SF_UNUSED1     5
#define SF_UNUSED2     6
#define SF_TIME        7

#define SF_NUM_FIELDS (SF_TIME+1)

EXTERN void StatusField(int x, char *s);
EXTERN void Status(char *s);

EXTERN void StatusEnable(void);
EXTERN void StatusDisable(void);
EXTERN void StatusUpdate(void);

EXTERN void StatusDrawStringAll(void);

#endif

// $Header: r:/t2repos/thief2/src/editor/strprped.cpp,v 1.2 2000/02/19 13:11:28 toml Exp $
#include <string.h>
#include <strprop_.h>
#include <proped.h>
#include <iobjed.h>

#include <sdesc.h>
#include <isdesced.h>
#include <isdescst.h>
#include <sdesbase.h>
#include <sdestool.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////////////////////////////////////////////////////////////
// STRING PROPERTY EDITING 

//
// For now, we'll just use a really big sdesc
//
struct sBuf
{
   char buf[2048]; 

   sBuf(const char* s = NULL) 
   { 
      if (s)
      {
         strncpy(buf,s,sizeof(buf)); 
         buf[sizeof(buf)-1] = '\0'; 
      }
      else
         memset(buf,0,sizeof(buf)); 
   };

   operator const char*() { return buf; }; 
}; 

StructDescDefineSingleton(string_sdesc,sBuf,kFieldTypeString,0); 

// mostly for other things to use
static void register_sdesc()
{
   AutoAppIPtr_(StructDescTools,pTools);
   pTools->Register(&string_sdesc); 
}



class cStringEditTrait: public cBasePropEditTrait
{
public:
   cStringEditTrait(IStringProperty* prop)
      : cBasePropEditTrait((IProperty*)prop)
   {
      Caps.flags |= kTraitCanParse|kTraitCanUnparse|kTraitCanEdit; 
   }

   STDMETHOD(Edit)(ObjID obj)
   {
      const char* str; 
      IStringProperty* prop = (IStringProperty*)Prop; 
      if (!prop->Get(obj,&str))
         return E_FAIL; 
      sBuf buf(str); 

      sStructEditorDesc eddesc = { "" , kStructEditAllButtons };
      strncpy(eddesc.title,Desc.strings.friendly_name,sizeof(eddesc.title)); 
      IStructEditor* sed = CreateStructEditor(&eddesc,&string_sdesc,&buf); 

      HRESULT retval = S_FALSE; 
      if (sed->Go(kStructEdModal))
      {
         prop->Set(obj,buf); 
         retval = S_OK; 
      }
      SafeRelease(sed);
      return retval; 
   }


   STDMETHOD(Parse)(ObjID obj, const char* val)
   {
      IStringProperty* prop = (IStringProperty*)Prop; 
      return prop->Set(obj,val); 
   }


   STDMETHOD(Unparse)(ObjID obj, char* buf, int buflen)
   {
      IStringProperty* prop = (IStringProperty*)Prop; 
      const char* str; 
      if (prop->Get(obj,&str))
      {
         strncpy(buf,str,buflen);
         buf[buflen-1] = '\0'; 
         return S_OK; 
      }
      return S_FALSE; 
   }

};

void CreateStringPropEditor(IStringProperty* prop)
{
   register_sdesc();

   IObjEditors* pEditors = AppGetObj(IObjEditors);
   if (pEditors)
   {
      IEditTrait* trait = new cStringEditTrait(prop); 
      pEditors->AddTrait(trait);
      SafeRelease(trait); 
      SafeRelease(pEditors); 
   }
}
// $Header: r:/t2repos/thief2/src/editor/stupidui.c,v 1.5 2000/02/19 13:11:31 toml Exp $

//////////////////////////////////////////////////////////////
// Don't try this at home kids!
//
// This is a stupid alternate interface for the ui that allows you to 
// grab the events one at a time.
//

#include <event.h>
#include <region.h>
#include <reg.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static uiEvent event_queue[41];  // THIS ABSOLUTELY MUST BE FORTY-ONE! 
static int qin = 0;
static int qout = 0;
static Region stupid_region; // placeholder for our handler
 

#define QUEUE_SIZE (sizeof(event_queue)/sizeof(event_queue[0]))

// 
// stupid event hander that just queues
//

#pragma off(unreferenced)
bool stupid_event_handler(uiEvent* ev, Region* reg, void* data)
{
   if (ev->type == UI_EVENT_KBD_RAW)
      return FALSE;

   if (qin < QUEUE_SIZE)
   {
      event_queue[qin++] = *ev;
   }
   else
      Warning(("Stupid event queue is too small!\n"));
   return TRUE;
}

//
// Get the next event
//



bool get_stupid_ui_event(uiEvent* ev)
{
   static fail_once_per_frame = TRUE;
   if (qout >= qin)
   {
      if (fail_once_per_frame) {
         fail_once_per_frame = FALSE;
         return FALSE;
      } else
         fail_once_per_frame = TRUE;
      qout = qin = 0;
      uiGrabFocus(&stupid_region,ALL_EVENTS);
      region_flush_sequence(TRUE);
      uiPoll();
      uiReleaseFocus(&stupid_region,ALL_EVENTS);
   }
   if (qout < qin)
   {
      *ev = event_queue[qout++];
      return TRUE;
   }
   return FALSE;
}


//
// start queuing going 
//

void stupid_ui_start(void)
{
   Rect stupid_rect = { { 0, 0}, {1,1}};
   int cookie;

   // the root region of sphincter-space!
   make_region(NULL,&stupid_region,&stupid_rect,0,NULL);
   
   uiInstallRegionHandler(&stupid_region,ALL_EVENTS, stupid_event_handler, NULL, &cookie);

   qin = qout = 0;
}

void stupid_ui_end(void)
{
   for (; qout < qin ; qout++)
   {
      uiQueueEvent(&event_queue[qout]);
   }
   region_destroy(&stupid_region,FALSE);

}


// $Header: r:/t2repos/thief2/src/editor/stupidui.h,v 1.3 2000/01/29 13:13:15 adurant Exp $
#pragma once

#ifndef __STUPIDUI_H
#define __STUPIDUI_H

#include <lg.h>
#include <event.h>

//
// This is an editor-only stupid polling interface to the ui.
//

EXTERN void stupid_ui_start(void);
EXTERN void stupid_ui_end(void);

//
// get the next ui event.  returns false iff there are none yet.
//

EXTERN bool get_stupid_ui_event(uiEvent* ev);


#endif // __STUPIDUI_H
// $Header: r:/t2repos/thief2/src/editor/swappnp.c,v 1.16 2000/02/19 13:11:33 toml Exp $
#include <gcompose.h>

#include <swappnp.h>
#include <userpnp.h>

#include <editbr.h>
#include <brinfo.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////////////////////////////////////////////////////////////
// gadget creation/destruction/update methods
////////////////////////////////////////////////////////////

typedef struct methods 
{
   void (*open)(LGadRoot* root, Rect* bounds, editBrush* brush);
   void (*update)(GFHUpdateOp op, editBrush* brush);
   void (*close)(void);
} Methods;

typedef struct methodizer
{
   char* name;
   int max;
   Methods* methods;
   LGadRoot root;
   int which;
} Methodizer;

////////////////////////////////////////////////////////////
// Generic methodizer stuff
////////////////////////////////////////////////////////////

void MethodOpen(Methodizer* m, int  kind, LGadRoot* root, Rect* bounds, editBrush* brush)
{
   if (m->which > 0)
   {
      Warning(("opening %s %d when %d is already open!\n",m->name,kind,m->which));
   }
   
   if (kind >= m->max)
   {
      Warning(("There is no %s #%d\n",m->name,kind));
      return;
   }

   if (m->methods[kind].open != NULL)
   {
      Rect r = { { 0,0},}; 
      
      r.lr = MakePoint(RectWidth(bounds),RectHeight(bounds));
      LGadSetupSubRoot(&m->root,root,bounds->ul.x,bounds->ul.y,
                       (short)RectWidth(bounds),(short)RectHeight(bounds));
      m->methods[kind].open(&m->root,&r,brush);
   }
   m->which = kind;
}

////////////////////////////////////////

void MethodUpdate(Methodizer* m, GFHUpdateOp op,editBrush* brush)
{
   if (m->which < 0)
   {
      Warning(("Updating the null %s\n",m->name));
      return;
   }
   Assrt(m->which < m->max);
   if (m->methods[m->which].update != NULL)
      m->methods[m->which].update(op,brush);
}

////////////////////////////////////////

void MethodClose(Methodizer* m)
{
   if (m->which < 0)
   {
      Warning(("Closing the null %s\n",m->name));
      return;
   }
   Assrt(m->which < m->max);
   if (m->methods[m->which].close != NULL)
   {
      Rect r;
      GUIcompose c;
      m->methods[m->which].close();
      region_abs_rect(&VB(&m->root)->r,BOX_RECT(VB(&m->root)),&r);
      GUIsetup(&c,&r,ComposeFlagClear,GUI_CANV_ANY);
      GUIdone(&c);
      LGadDestroyRoot(&m->root);
   }
   m->which = -1;
}


////////////////////////////////////////////////////////////
// PNP methods
//////////////////////////////////////////////////////////////

#define PnPFunctionList(x) Create_##x##PnP, Update_##x##PnP, Destroy_##x##PnP, 
#define PnPProto(x) \
   EXTERN void Create_##x##PnP(LGadRoot *root, Rect *bounds, editBrush *br); \
   EXTERN void Destroy_##x##PnP(void); \
   EXTERN void Update_##x##PnP(GFHUpdateOp op, editBrush *br)

PnPProto(txt);
PnPProto(grid);
PnPProto(align);
PnPProto(light);
PnPProto(area);
PnPProto(obj);
PnPProto(flow);
PnPProto(room);

Methods pnp_methods[] = 
{
   { PnPFunctionList(txt) },
   { PnPFunctionList(grid) },
   { PnPFunctionList(align) },
   { PnPFunctionList(light) },
   { PnPFunctionList(area) },
   { PnPFunctionList(obj) },
   { PnPFunctionList(flow) },
   { PnPFunctionList(room) },
   { CreateUserPNP, UpdateUserPNP, DestroyUserPNP,}, // user
   { NULL, NULL, NULL }
};

#define NUM_PNPS (sizeof(pnp_methods)/sizeof(pnp_methods[0]))

static Methodizer PNPizer[2] =
{ { "PNP 1", NUM_PNPS, pnp_methods, NULL, -1}, { "PNP 2", NUM_PNPS, pnp_methods, NULL, -1} };

int PnP_ForBrush(editBrush *brush)
{
   if (brush!=NULL)
      switch (brushGetType(brush))
      {
         case brType_TERRAIN:      return PNP_TEXTURE;
         case brType_LIGHT:        return PNP_LIGHT;
         case brType_HOTREGION:    return PNP_AREA;
         case brType_OBJECT:       return PNP_OBJ;
         case brType_FLOW:         return PNP_FLOW;
         case brType_ROOM:         return PNP_ROOM;
      }
   return PNP_NULL;
}

////////////////////////////////////////

void GFHOpen_a_PNP(int which, PNPkind kind, LGadRoot* root, Rect* bounds, editBrush* brush)
{
   MethodOpen(&PNPizer[which],kind,root,bounds,brush);
}

////////////////////////////////////////

void GFHUpdate_a_PNP(int which, GFHUpdateOp op,editBrush* brush)
{
   MethodUpdate(&PNPizer[which],op,brush);
}

////////////////////////////////////////

void GFHClose_a_PNP(int which)
{
   MethodClose(&PNPizer[which]);
}

/// check for am i one of two up
int GFH_PNP_Control_2Up(int me)
{
   int v1=PNPizer[0].which, v2=PNPizer[1].which;
   if ((v1<0)||(v2<0)) return -1;
   if (v1==me) return v2;
   else        return v1;
}

////////////////////////////////////////////////////////////
// SWAPPABLE methods
//////////////////////////////////////////////////////////////

// since swaps are really just PnPs in a different place, for all practical purposes
#define SwapFunctionList(x) Create_##x##Swap, Update_##x##Swap, Destroy_##x##Swap, 
#define SwapProto(x) \
   extern void Create_##x##Swap(LGadRoot *root, Rect *bounds, editBrush *br); \
   extern void Destroy_##x##Swap(void); \
   extern void Update_##x##Swap(GFHUpdateOp op, editBrush *br)

SwapProto(cr);
SwapProto(layout);
SwapProto(scroll);
SwapProto(filter);
SwapProto(test);

Methods swappable_methods[] = 
{
   { SwapFunctionList(cr) },     // cr eate
   { SwapFunctionList(layout) }, // layout
   { SwapFunctionList(scroll) }, // scroll
   { SwapFunctionList(filter) }, // filter
   { SwapFunctionList(test) },   // test
   { NULL, NULL, NULL,},         // user
};

#define NUM_SWAPPABLES (sizeof(swappable_methods)/sizeof(swappable_methods[0]))

static Methodizer Swapizer = { "Swappable", NUM_SWAPPABLES, swappable_methods,};

void GFHOpenSwappable(GFHSwapKind kind, LGadRoot* root, Rect* bounds, editBrush *brush)
{
   MethodOpen(&Swapizer, kind,root,bounds,brush);
}

////////////////////////////////////////

void GFHUpdateSwappable(GFHUpdateOp op, editBrush* brush)
{
   MethodUpdate(&Swapizer,op,brush);
}

////////////////////////////////////////

void GFHCloseSwappable(void)
{
   MethodClose(&Swapizer);
}

////////////////////////////////////////

GFHSwapKind GFHCurrentSwappable(void)
{
   return Swapizer.which;
}
// $Header: r:/t2repos/thief2/src/editor/swappnp.h,v 1.10 2000/01/29 13:13:16 adurant Exp $
#pragma once

#ifndef __SWAPPNP_H
#define __SWAPPNP_H

#include <gadget.h>
#include <brushgfh.h>
#include <editbr.h>

//
// API for connecting to the "plug and play" region of the GFH
//

typedef enum PNPkind
{
   PNP_TEXTURE,
   PNP_GRID,
   PNP_ALIGN,
   PNP_LIGHT,
   PNP_AREA,
   PNP_OBJ,
   PNP_FLOW,
   PNP_ROOM,
   PNP_USER,
   PNP_NULL
} PNPkind;

// go figure what sort of PnP to use for this brush
int PnP_ForBrush(editBrush *brush);

// Create the PNP of the specified kind and make it the current PNP
EXTERN void GFHOpen_a_PNP(int which, PNPkind kind, LGadRoot* root, Rect* bounds, editBrush* brush);
#define GFHOpenPNP(kind,root,bounds,brush) GFHOpen_a_PNP(0,kind,root,bounds,brush)

//
//  Update the current pnp
//

EXTERN void GFHUpdate_a_PNP(int which, GFHUpdateOp op, editBrush* brush);
#define GFHUpdatePnP(op,brush) GFHUpdate_a_PNP(0,op,brush)

//
// Destroy the current pnp
//

EXTERN void GFHClose_a_PNP(int which);
#define GFHClosePnP() GFHClose_a_PNP(0)

/// check for am i one of the PnPs up
// returns -1 if not, else returns the PnP idx of the other one
int GFH_PNP_Control_2Up(int me);

////////////////////////////////////////////////////////////
// The swappable button region is much like the PNP, but its 
// gadgets tend to be simpler.
////////////////////////////////////////////////////////////

typedef enum GFHSwapKind
{
   GFH_SWAP_CREATE,
   GFH_SWAP_LAYOUT,
   GFH_SWAP_SCROLL,
   GFH_SWAP_FILTER,
   GFH_SWAP_TEST,
} GFHSwapKind;

// Create the swappable of the specified kind and make it the current swappable
EXTERN void GFHOpenSwappable(GFHSwapKind kind, LGadRoot* root, Rect* bounds, editBrush* brush);

//  Update the current swappable
EXTERN void GFHUpdateSwappable(GFHUpdateOp op, editBrush* brush);

// Destroy the current swappable
EXTERN void GFHCloseSwappable(void);

// Get current swappable.
EXTERN GFHSwapKind GFHCurrentSwappable(void);

#endif // __SWAPPNP_H
// $Header: r:/t2repos/thief2/src/editor/swapregs.c,v 1.11 2000/02/19 13:11:35 toml Exp $
// swap button list for the create tool

#include <string.h>

#include <lg.h>
#include <mprintf.h>

#include <swaptool.h>
#include <brushgfh.h>
#include <pnptools.h>

#include <status.h>

#include <command.h>
#include <editbr.h>
#include <viewmgr.h>
#include <vmwincfg.h>
#include <brrend.h>
#include <gedit.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

///////////////////////////////
// Generically useful swap stuff

#define strlist_len(x) (sizeof(x)/sizeof(x[0]))

static void *curSwap=NULL;

void _generic_swap_destroy(void)
{
   if (curSwap==NULL)
      Warning(("Hey! dont have a swap"));
   SwapDestroyList(curSwap);
   curSwap=NULL;
}

///////////////////////////////
// Create Swap Region

static char *createNames[]={"Brush", "Light", "Area", "Object", "Flow", "Room"};

static void _crCallBack(int idx)
{
   if (idx==-1)
      CommandExecute("insert_brush");
   else
   {
      char buf[80];
      PnP_ExecCommandInt("set_brush_type",idx);
      sprintf(buf,"Create type now %s",createNames[idx]);
      Status(buf);
   }
}

void Create_crSwap(LGadRoot *root, Rect *bounds, editBrush *br)
{
   if (curSwap!=NULL)
      Warning(("Hey! already have a swap"));
   curSwap=SwapBuildList(root,bounds,"Create",strlist_len(createNames),createNames,_crCallBack,BUTTONLIST_RADIO_FLAG);
}

void Destroy_crSwap(void)
{
   _generic_swap_destroy();
}

void Update_crSwap(GFHUpdateOp op, editBrush *br)
{
   int type = gedit_default_brush_type();
   if (curSwap == NULL) return;
   if (SwapListSelection(curSwap) != type)
   {
      SwapListSelect(curSwap,type);
      SwapRedrawList(curSwap);
   }
}

//////////////////////////////
// Scroll subregion
static char *scrollNames[]={"Next", "Prev", "Up", "Left", "Right", "Down"};

static void _scrollCallBack(int idx)
{
   float scale_f=1.0;
   //   mprintf("CrCallBack %d\n",idx);
   switch (idx)
   {
      case 0: vm_cycle_camera(TRUE);  break;
      case 1: vm_cycle_camera(FALSE); break;
      case 2: vm_cur_scroll( 0*scale_f,-1*scale_f); break;
      case 3: vm_cur_scroll(-1*scale_f, 0*scale_f); break;
      case 4: vm_cur_scroll( 1*scale_f, 0*scale_f); break;
      case 5: vm_cur_scroll( 0*scale_f, 1*scale_f); break;
   }
}

void Create_scrollSwap(LGadRoot *root, Rect *bounds, editBrush *br)
{
   if (curSwap!=NULL)
      Warning(("Hey! already have a swap"));
   curSwap=SwapBuildList(root,bounds,"Scroll",strlist_len(scrollNames),scrollNames,_scrollCallBack,0);
}

void Destroy_scrollSwap(void)
{
   _generic_swap_destroy();
}

void Update_scrollSwap(GFHUpdateOp op, editBrush *br)
{

}

//////////////////////////////
// Layout subregion
static char *layoutNames[]={"2by2", "3x1 Vert", "3x1 Horz", "Center", "Solo"};

static void _layoutCallBack(int idx)
{
   idx++;   // -1 (off top) maps to 0 (cycle), which is fine
   if ((idx>=vmWINCFG_CYCLE)||(idx<=vmWINCFG_SOLO))
      vmWinCfgCycleLayout(idx);
}

void Create_layoutSwap(LGadRoot *root, Rect *bounds, editBrush *br)
{
   if (curSwap!=NULL)
      Warning(("Hey! already have a swap"));
   curSwap=SwapBuildList(root,bounds,"Layout",strlist_len(layoutNames),layoutNames,_layoutCallBack,0);
}

void Destroy_layoutSwap(void)
{
   _generic_swap_destroy();
}

void Update_layoutSwap(GFHUpdateOp op, editBrush *br)
{
// i tried this with radio buttons but was mocked, so, ah, who knows, i guess
#ifdef THIS_TOTALLY_FAILED
   int cur_ly=vmWinCfgGetLayout();
   if (curSwap == NULL) return;
   if (SwapListSelection(curSwap) != cur_ly-1)
   {
      SwapListSelect(curSwap,cur_ly-1);
      SwapRedrawList(curSwap);
   }
#endif   
}

//////////////////////////////
// Filters subregion
static char *filterNames[]={"Terr","Light","Area","Object","Flow","Room"};

// this is a dorky hideous hack
static void _filterSetSelections(void)
{
   int i;

   for (i=0; i<sizeof(filterNames)/sizeof(char *); i++)
   {
      if (editbr_filter&brFlag_GetFilterType(i))
         SwapListSelect(curSwap,i);
      else
         SwapListDeSelect(curSwap,i);
   }
   SwapRedrawList(curSwap);
}

static void _filterCallBack(int idx)
{
   int bit=1<<(idx+brFlag_FILTERSHIFT);
   if (idx==-1)              // secret behavior for clicking on menu title
      if (editbr_filter)
         editbr_filter=0;
      else               
         editbr_filter=brFlag_FILTERMASK;
   else
      if (editbr_filter&bit) // already on
         editbr_filter&=~bit;
      else
         editbr_filter|=bit;
   _filterSetSelections();
   gedit_full_redraw();      // hey, who are we kidding
}

void Create_filterSwap(LGadRoot *root, Rect *bounds, editBrush *br)
{
   if (curSwap!=NULL)
      Warning(("Hey! already have a swap"));
   curSwap=SwapBuildList(root,bounds,"Filter",strlist_len(filterNames),filterNames,_filterCallBack,0);
   _filterSetSelections();
}

void Destroy_filterSwap(void)
{
   _generic_swap_destroy();
}

void Update_filterSwap(GFHUpdateOp op, editBrush *br)
{
   //   if (SwapListSelection(curSwap) != cur_ly-1)
   //      SwapListSelect(curSwap,cur_ly-1);
   //   SwapRedrawList(curSwap);
}

//////////////////////////////
// Test subregion
static char *testNames[]={"Scroll"};

static void _testCallBack(int idx)
{
   switch (idx)
   {
   case 0: vmWinCfgSetMode(vmWINCFG_MODE_SCROLL); break;
   }
}

void Create_testSwap(LGadRoot *root, Rect *bounds, editBrush *br)
{
   if (curSwap!=NULL)
      Warning(("Hey! already have a swap"));
   curSwap=SwapBuildList(root,bounds,"Test",strlist_len(testNames),testNames,_testCallBack,0);
}

void Destroy_testSwap(void)
{
   _generic_swap_destroy();
}

void Update_testSwap(GFHUpdateOp op, editBrush *br)
{
}
// $Header: r:/t2repos/thief2/src/editor/swaptool.c,v 1.11 2000/02/19 13:11:36 toml Exp $
// utilities for PnP swap area

#include <string.h>

#include <lg.h>
#include <mprintf.h>
#include <guistyle.h>

#include <swaptool.h>
#include <cmdbutts.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////////////////////////////////////////
typedef struct {
   LGadButtonListDesc desc;
   LGadButtonList     list;
   LGadButton title;
   LGadRoot* root;
} SwapButtonList;

static void (*listShoot)(int idx);

static bool swap_list_callback(ushort action, int button, void *data, LGadBox *vb)
{
   if (!(action&BUTTONGADG_LCLICK))
      return FALSE;
   // int blah=*(int *)data;
   // blah seems to never have any relevance to anything?
   //   mprintf("Yo here for %d, data %x\n",button,blah);
   if (listShoot!=NULL)
      (*listShoot)(button);
   return TRUE;
}

static void SwapBuildElement(DrawElement *elem, int i, char *text)
{
   ElementClear(elem);
   elem->draw_type=DRAWTYPE_TEXT;
   elem->draw_data=text;
   elem->draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);
}

static void SwapBuildTitle(Rect* area, LGadRoot* root,  LGadButton* butt, char* title)
{
   DrawElement draw;
   short h;

   // figure out the string height
   guiStyleSetupFont(NULL,StyleFontNormal);
   h = gr_string_height(title);
   guiStyleCleanupFont(NULL,StyleFontNormal);

   ElementClear(&draw);
   draw.draw_type = DRAWTYPE_TEXT;
   draw.draw_data = title;

   LGadCreateButtonArgs(butt,root,area->ul.x,area->ul.y,
      (short)RectWidth(area),(short)(h+2),&draw,NULL,0);
   LGadButtonSetFlags(butt,LGADBUTT_FLAG_STATELESS);
}


void *SwapBuildList(LGadRoot *root, Rect *area, char* title, int n, char *strings[], void (*shoot)(int idx), ulong flags)
{
   SwapButtonList *SwapList=(SwapButtonList *)Malloc(sizeof(SwapButtonList));
   LGadButtonListDesc *SwapPtr;
   int i;
   Rect bounds = *area;
   
   if (SwapList==NULL) return NULL;      // didnt work, sad day for us

   memset(SwapList,0,sizeof(*SwapList));

   SwapList->root = root;

   // build the title 
   SwapBuildTitle(area,root,&SwapList->title,title);
   // exclude the title area from our buttonlist. 
   bounds.ul.y = LGadBoxRect(&SwapList->title)->lr.y;

   
   SwapPtr=&SwapList->desc;
   SwapPtr->num_buttons=n;
   SwapPtr->button_rects=(Rect *)Malloc(n*sizeof(Rect));

   // hey doug, I took out swaprect fill, because I already have LayoutRectangles
   //   SwapRectFill(SwapPtr->button_rects,area,n);
   LayoutRectangles(&bounds,SwapPtr->button_rects,n,MakePoint(1,n),MakePoint(2,2));
   
   // build the buttonlist proper
   SwapPtr->button_elems=(DrawElement *)Malloc(n*sizeof(DrawElement));
   for (i=0; i<n; i++)
      SwapBuildElement(&SwapPtr->button_elems[i],i,strings[i]);
   SwapPtr->cb=swap_list_callback;
   SwapPtr->paltype=0;
   SwapPtr->flags = flags;
   LGadCreateButtonListDesc(&SwapList->list,root,SwapPtr);
   listShoot=shoot;
   return SwapPtr;
}

// call this will the void * returned to you by BuildList
void SwapDestroyList(void *data)
{
   SwapButtonList *SwapList=(SwapButtonList *)data;
   LGadDestroyButtonList(&SwapList->list);
   LGadDestroyBox((LGadBox*)&SwapList->title,FALSE);
   Free(SwapList->desc.button_rects);
   Free(SwapList->desc.button_elems);
   Free(SwapList);
}


void SwapRedrawList(void* data)
{
   SwapButtonList* list = (SwapButtonList*)data;
   LGadDrawBox(VB(list->root),NULL);
}

// well, these are great, if you only have radio buttons
// so, perhaps they should get smarter

int SwapListSelection(void* data)
{
   SwapButtonList* swaplist = (SwapButtonList*)data;
   if (swaplist->desc.flags&BLIST_RADIO_FLAG)
      return LGadRadioButtonSelection(&swaplist->list);
   else
      Warning(("Not really relevant for non-button list\n"));
   return -1; // ?? some way to say "no button, maybe ?? - not sure
}

void SwapListSelect(void* data,int sel)
{
   SwapButtonList* swaplist = (SwapButtonList*)data;
   if (swaplist->desc.flags&BLIST_RADIO_FLAG)
      LGadRadioButtonSelect(&swaplist->list,sel);
   else
      swaplist->desc.button_elems[sel].fcolor=guiStyleGetColor(NULL,StyleColorBright);
}

void SwapListDeSelect(void* data,int sel)
{
   SwapButtonList* swaplist = (SwapButtonList*)data;
   if (swaplist->desc.flags&BLIST_RADIO_FLAG)
      Warning(("Cant deselect a Radio button\n"));
   else
      swaplist->desc.button_elems[sel].fcolor=guiStyleGetColor(NULL,StyleColorDim);
}
// $Header: r:/t2repos/thief2/src/editor/swaptool.h,v 1.5 2000/01/29 13:13:17 adurant Exp $
// tools for swap region buttons
#pragma once

#ifndef __SWAPTOOL_H
#define __SWAPTOOL_H

#include <rect.h>
#include <gadblist.h>

// build a button list for the Swappable region, use flags in gadblist.h
void *SwapBuildList(LGadRoot *root, Rect *area, char* title, int n, char *strings[], void (*shoot)(int idx),ulong flags);

// call this will the void * returned to you by BuildList
void SwapDestroyList(void *data);

// call this to redraw your list
void SwapRedrawList(void *list);

// void call this to set and get the "current button" if any
int SwapListSelection(void* list);

// for radio buttons, select sets selection
// for normal lists. select/deselect colors/uncolors that button (according to guiStyle)
void SwapListSelect(void* list, int selection);
void SwapListDeSelect(void* list, int selection);

#endif // __SWAPTOOL_H
// $Header: r:/t2repos/thief2/src/editor/txtpnp.c,v 1.48 2000/02/19 13:11:37 toml Exp $
// Brush Texture PnP gadget

#include <string.h>

#include <gadblist.h>
#include <lgsprntf.h>
#include <guistyle.h>
#include <config.h>
#include <winui.h>

#include <resapi.h>
#include <storeapi.h>

#include <command.h>
#include <status.h>

#include <editor.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <ged_csg.h>
#include <brinfo.h>

#include <brushGFH.h>
#include <PnPtools.h>
#include <swappnp.h>
#include <txtrpal.h>
#include <texmem.h>
#include <family.h>
#include <txtpnp.h>
#include <primal.h>

#include <mprintf.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

/* artists conception
 *            ___________
 * 1<align>   |0 pict of  |  (grid flips to the brush grid pnp)
 * 2<grid>    |   brush   |  (show causes main 3d view to try to look at this wall)
 * 3<show>    |           |  (reset resets all fields to defaults)
 * 4<reset>   |___________|
 *        5<-media->
 *        6<-face->          (face is 0-n int)
 *       7<- texture ->      (texture is 0-n (string list))
 */

#define NUM_BUTTONS (0x8)
static Rect txtPnP_rects[NUM_BUTTONS];
#define OUR_RECTS (txtPnP_rects)
#define getRect(n) (&OUR_RECTS[n])

#define BTN_ABOVE 4
#define BTN_BELOW 3
#define VERT_DIV  4
#define HORIZ_DIV (0.45)

void txtPnP_buildRects(Rect *whole)
{
   Rect *curRect=OUR_RECTS;
   int i;

   buildYLineRect(curRect++,whole,0,HORIZ_DIV,1,2,1);
   for (i=0; i<BTN_ABOVE; i++)
      buildYLineRect(curRect++,whole,i,HORIZ_DIV,0,2,1);
   for (i=0; i<BTN_BELOW; i++)
      buildYLineRect(curRect++,whole,VERT_DIV+i,0,1,2,2);
   // fixup the big box (these are brutal hacks, sorry)
   OUR_RECTS[0].lr.y=OUR_RECTS[4].lr.y;
}

#define BUTTON_ALIGN   1
#define BUTTON_GRID    2
#define BUTTON_SHOW    3
#define BUTTON_RESET   4

#define FROBS_PICTURE  5

#define FROBS_FACE     6
#define FROBS_MEDIA    7
#define FROBS_TEXTURE  8

#define NUM_OWNED (FROBS_TEXTURE+1)

// statics for the PnP itself
static int pnpOwners[NUM_OWNED];
static editBrush *txtPnP_br;
static int face, media, texture;
static BOOL im_detached=FALSE;

static _PnP_GadgData txtPnP;

// to get texture id stuff
extern short *_geditGetTxPtr(editBrush *br);

// media data
extern char *mediaop_names[];
extern int num_media_ops;

// face data
static char *cube_faces[] =  // for a natural cube
  {"default", "north", "west", "south", "east", "top", "bottom"};
static char *side_names[] =  // for various sides of a multibrush
  {"side 1","side 2","side 3","side 4","side 5","side 6","side 7","side 8","side 9","side 10",
   "side 11","side 12","side 13","side 14","side 15","side 16","side 17","side 18","side 19", "side 20"};
char *faces[] =       // the actual use me in the PnP thing
  {"", "", "", "", "", "", "", "", "", "", "", "", ""};

int cur_max_face=0, cur_primal=-1;

static void txtPnP_rebuild_face_info(int primal_id)
{
   void *str_gadg=PnP_GetStringSubGadget(pnpOwners[FROBS_FACE]);
   int i=0, j;
   if (primal_id==PRIMAL_CUBE_IDX)
      for (i=0; i<sizeof(cube_faces)/sizeof(char *); i++)
         faces[i]=cube_faces[i];
   else
   {
      BOOL is_pyr=(primalID_GetType(primal_id)==PRIMAL_TYPE_PYRAMID)||(primalID_GetType(primal_id)==PRIMAL_TYPE_CORNERPYR);
      int eff_face_cnt=primalBr_FaceCnt(primal_id)-(is_pyr?1:2);
      faces[i++]=cube_faces[0];
      for (j=0; j<eff_face_cnt; j++)
         faces[i++]=side_names[j];
      if (!is_pyr)
         faces[i++]=cube_faces[5];
      faces[i++]=cube_faces[6];
   }
   cur_primal=primal_id;
   cur_max_face=primalBr_FaceCnt(primal_id);
   if (face>cur_max_face) face=-1; // ?? or max?
   if (str_gadg)
      PnP_StringSliderSetStrings(str_gadg,faces,cur_max_face); // or +1?
}

// this is sort of a mess
// basically, this is here to sync the globals and the brush
// update is TRUE if we know the globals just changed
// and false if we know the brush just changed, so we want to reload the globals
// the messy part is the interdependance, esp. the update=FALSE in the face change
//  since if the globals changed the face, we want to update it (ie. reload the brush
//  from the face varaible) but then disable update so that we reload the appropriate
//  new texture from the brush into the global for the new face
static void txtPnP_setvars(editBrush *br, bool update)
{
   bool change=FALSE;

   if (im_detached) return;
   if (br==NULL) { txtPnP_br=NULL; return; }

   if (br->primal_id!=cur_primal)
   {
      txtPnP_rebuild_face_info(br->primal_id);
      PnP_Redraw(pnpOwners[FROBS_FACE],NULL);
   }

   PnP_SetCurrent(&txtPnP);
   if (face!=br->cur_face+1)    // since face is 0-n+1 whereas in brush is -1,0-n
   {
      if (update)
      {
         br->cur_face=face-1;
         gedit_redraw_selection();
         update=FALSE;          // since face drives the other, set update to false
      }                         // so that texture reloads from the newly set face
      else
         face=br->cur_face+1;
      PnP_Redraw(pnpOwners[FROBS_FACE],NULL);
      change=TRUE;
   }
   if (media!=br->media)
   {
      if (update)
         br->media=media;
      else
         media=br->media;
      PnP_Redraw(pnpOwners[FROBS_MEDIA],NULL);
      change=TRUE;
   }
   if (texture!=(int)(*_geditGetTxPtr(br)))
   {
      if (update)
         gedit_texture_brush(br,texture);
      else
         texture=(int)(*_geditGetTxPtr(br));
      PnP_Redraw(pnpOwners[FROBS_TEXTURE],NULL);
      PnP_Redraw(pnpOwners[FROBS_PICTURE],NULL); // make sure we do the picture too
      change=TRUE;
   }
   txtPnP_br=br;
   if (change&&update)
      gedit_redraw_3d();
}

// just do these one of command sort of things
static void txtPnP_OneShots(int lid)
{
   switch (lid)
   {
      case BUTTON_GRID:  PnP_ExecCommandInt("start_pnp", PNP_GRID); break;
      case BUTTON_ALIGN: PnP_ExecCommandInt("start_pnp", PNP_ALIGN); break;
      case BUTTON_SHOW:  CommandExecute("cam_to_brush"); break;
      case BUTTON_RESET:
         PnP_ExecCommandInt("reset_brush_tx",texture);
         txtPnP_setvars(txtPnP_br,FALSE);
         break;
   }
}

// the idea here is that this just makes sure the globals are right
// then calls setvars, which deals with making the brush consistent with the globals
// or, if say a face changes, the globals consistent with the brush
static void txtPnP_IntFrob(PnP_SliderOp op,Rect *where, int val, int data)
{
   if (op != PnP_SliderUpdateOp)
      return;
   switch (data)
   {
      case FROBS_FACE:  // deal with 
         if (face>cur_max_face)
            face=0;
         break;
      case FROBS_MEDIA:     break;
   }
   txtPnP_setvars(txtPnP_br,TRUE);
}

void texture_pal_cmd(void);

static void txtPnP_TxtFrob(PnP_SliderOp op,Rect *where, int val, int data)
{
   if (op == PnP_SliderUpdateOp)
   {
      if ((val==-1)&&(face==0))
         texture=0;          // cant set to default if you are whole brush
      if (val>=texmemGetMax())
      {
         int mid=texmemGetMax()+((BACKHACK_IDX-texmemGetMax())/2);
         if ((texture<mid)||(texture>=BACKHACK_IDX)) texture=BACKHACK_IDX;
         else texture=texmemGetMax()-1;
      }
      txtPnP_setvars(txtPnP_br,TRUE);
   }
   else
      texture_pal_cmd();
}

static void stringToCanvasBottom(char *str, BOOL shadow, BOOL hilite)
{
   short w, h;
   int x,y;
   
   guiStyleSetupFont(NULL,StyleFontNormal);
   gr_string_size(str,&w,&h);
   x=(grd_canvas->bm.w-w)/2;
   y=grd_canvas->bm.h-h-2;
   if (shadow)
   {
      gr_set_fcolor(guiStyleGetColor(NULL,StyleColorBG));
      gr_string(str,x+2,y+2);
   }
   if (hilite)
      gr_set_fcolor(guiStyleGetColor(NULL,StyleColorHilite));
   else
      gr_set_fcolor(guiStyleGetColor(NULL,StyleColorFG));
   gr_string(str,x,y);
   guiStyleCleanupFont(NULL,StyleFontNormal);
}

static BOOL FillInName(char *buf, BOOL full, int handle)
{
   IRes *pRes = texmemGetHandle(handle);
   if (pRes)
   {
      if (full)
      {
         char *p;
         IRes_GetCanonPathName(pRes, &p);
         strcpy(buf, p);
         Free(p);
      }
      else
         strcpy(buf,IRes_GetName(pRes));
      strlwr(buf);
      return TRUE;
   }
   return FALSE;
}

// if which is -1, uses the current texture of the current brush
BOOL drawTexturetoCanvas(int mt, editBrush *br, BOOL active)
{
   char buf[128];
   
   if ((mt==-1)&&(br!=NULL))
      mt=(int)(*_geditGetTxPtr(br));
   
   if (texmemValidIdx(mt))
      gr_scale_bitmap(texmemGetTexture(mt),0,0,grd_canvas->bm.w,grd_canvas->bm.h);
   else
   {
      gr_clear(0);
      return FALSE;
   }

   if (FillInName(buf,FALSE,mt))
      stringToCanvasBottom(buf,TRUE,active);
   else
      stringToCanvasBottom("Jorge",TRUE,active);

   return TRUE;
}

static void draw_string_hack(int color, char *str)
{
   gr_clear(color);
   stringToCanvasBottom(str,TRUE,TRUE);
}

#pragma off(unreferenced)
// this really should probably just load from the brush
// since we really hope it is consistent and right when we get here
static void txtPnP_Picture(int data)
{
   int mt=texture;

   if (im_detached||(txtPnP_br==NULL))
      draw_string_hack(0,"Detached");
   else if (brSelect_Flag(txtPnP_br)&brSelect_VIRTUAL)
      draw_string_hack(0,"MULTI\nBRUSH");
   else if (mt==BACKHACK_IDX)
      draw_string_hack(0,"SKY HACK");      
   else
   {
      if (mt==-1)
         if (txtPnP_br->cur_face!=-1)
            mt=txtPnP_br->tx_id;
      drawTexturetoCanvas(mt,NULL,FALSE);
   }
}
#pragma on(unreferenced)

BOOL txtPnP_allow_attach=FALSE;

void Create_txtPnP(LGadRoot *root, Rect *bounds, editBrush *br)
{
   txtPnP_allow_attach=config_is_defined("allow_attach");
//   im_detached=FALSE;
   GFHSetCoordMask(GFH_ALL_COORDS);
   txtPnP_buildRects(bounds);
   PnP_GadgStart(&txtPnP,root);
   txtPnP_setvars(br,FALSE);
   pnpOwners[FROBS_PICTURE]=PnP_PictureBox(getRect(0),txtPnP_Picture,0);
   if (!brushGFH_AlignNTextureUp())
   {  // not a lot of point in these if both PnP's are up, eh?
      PnP_ButtonOneShot(getRect(1),"Align",txtPnP_OneShots,BUTTON_ALIGN);
      PnP_ButtonOneShot(getRect(2),"Grid",txtPnP_OneShots,BUTTON_GRID);
   }
   PnP_ButtonOneShot(getRect(3),"Show",txtPnP_OneShots,BUTTON_SHOW);
   PnP_ButtonOneShot(getRect(4),"Reset",txtPnP_OneShots,BUTTON_RESET);
   pnpOwners[FROBS_MEDIA]=
      PnP_SliderString(getRect(5),"Op",num_media_ops,mediaop_names,&media,txtPnP_IntFrob,FROBS_MEDIA,PNP_SLIDER_MENU);
   pnpOwners[FROBS_FACE]=
      PnP_SliderString(getRect(6),"Face",br->num_faces+1,faces,&face,txtPnP_IntFrob,FROBS_FACE,PNP_SLIDER_MENU|PNP_SLIDER_WRAP);
   if (!config_is_defined("txt_click"))
   {
      pnpOwners[FROBS_TEXTURE]=
         PnP_SliderInt(getRect(7),"Texture",-1,BACKHACK_IDX,1,&texture,txtPnP_TxtFrob,
                       FROBS_TEXTURE,PNP_SLIDER_VSLIDE); // |PNP_SLIDER_CLICKS);
   }
   else
   {
      pnpOwners[FROBS_TEXTURE]=
         PnP_SliderInt(getRect(7),"Texture",-1,BACKHACK_IDX,1,&texture,txtPnP_TxtFrob,
                       FROBS_TEXTURE,PNP_SLIDER_VSLIDE|PNP_SLIDER_CLICKS);
   }
}

void Destroy_txtPnP(void)
{
   PnP_GadgFree(&txtPnP);
   txtPnP_br=NULL;
}

void Update_txtPnP(GFHUpdateOp op, editBrush *br)
{
   if (!im_detached)
      txtPnP_setvars(br,FALSE);
   if (op==GFH_FORCE)
      PnP_FullRedraw(&txtPnP);
   TexturePaletteUpdate(GFH_MINIMAL);
}

BOOL txtPnP_attached(void)
{
   return (txtPnP_br!=NULL) && (!im_detached);
}

void txtPnP_detach(void)
{
   if (!im_detached)
   {
      im_detached=TRUE;
      PnP_SetCurrent(&txtPnP);
      PnP_Redraw(pnpOwners[FROBS_PICTURE],NULL); // make sure we do the picture too
   }
}

void txtPnP_attach(void)
{
   im_detached=FALSE;
   if (TexturePaletteVisible())  // hey, we be on screen
      txtPnP_setvars(txtPnP_br,FALSE);
   GFHRedrawPnPnSuch();
}

static bool txtpal_update(int txt)
{
   if (TpalIsExtraButton(txt))
      if (TpalGetExtraCode(txt)==TPAL_XTRA_SKY)
         txt=BACKHACK_IDX;
      else
      {
         switch (TpalGetExtraCode(txt))
         {
         case TPAL_XTRA_DETACH:
            if (txtPnP_allow_attach)
            {
               if (im_detached)
                  txtPnP_attach();
               else
                  txtPnP_detach();
            }
            else // if (assign_button) - if !allow_attach treat detach/attach as paint into current
               if (txtPnP_br)
               {
                  im_detached=FALSE;              // do we need these?
                  txtPnP_setvars(txtPnP_br,TRUE);
                  im_detached=TRUE;
               }
            break;
         case TPAL_XTRA_REMOVE:
            if (texture!=BACKHACK_IDX)
            {  // ask if they really want to remove it
               char buf[200];
               strcpy(buf,"Do you really want to Remove\n");
               if (FillInName(buf+strlen(buf),TRUE,texture))
                  if (winui_GetYorN(buf))
                  {
                     family_free_single(texture);
                     texture=0;
                  }
            }
            break;
         default:
            Warning(("Txtpal_Update in default case\n"));
            break;
         }
         TexturePaletteSelect(texture);
         return FALSE;
      }
   texture = txt;
   {
      char buf[200];
      if (FillInName(buf,TRUE,texture))
         Status(buf);
   }
   if (txtPnP_allow_attach)
      if ((txtPnP_br)&&(!im_detached))
         txtPnP_setvars(txtPnP_br,TRUE);
   return FALSE;
}

void texture_pal_cmd(void)
{
   ToggleTexturePalette(txtpal_update);
   if (TexturePaletteVisible())  // hey, we be on screen
   {
      if (!txtPnP_allow_attach)
         txtPnP_detach();
      TexturePaletteSelect(texture);
   }
}

// returns -2 (NO_TXT_PAL) if not, else current texture selection
int txtPnP_pal_query(void)
{
   if (TexturePaletteVisible())  // hey, we be on screen
      return texture;
   else
      return TXTPNP_NO_PAL_UP;
}
// $Header: r:/t2repos/thief2/src/editor/txtpnp.h,v 1.4 2000/01/29 13:13:18 adurant Exp $
#pragma once

#ifndef __TXTPNP_H
#define __TXTPNP_H

// returns TXTPNP_NO_PAL_UP if no palette up, else returns currently chosen texture
EXTERN int txtPnP_pal_query(void);
#define TXTPNP_NO_PAL_UP (-2)

// is it allowed to do attaches?  used by txtrpal and such
EXTERN BOOL txtPnP_allow_attach;

// actually query and control attach/detach state
EXTERN BOOL txtPnP_attached(void);
EXTERN void txtPnP_detach(void);
EXTERN void txtPnP_attach(void);

#endif  // __TXTPNP_H
// $Header: r:/t2repos/thief2/src/editor/txtrpal.c,v 1.16 2000/02/19 13:13:39 toml Exp $

#include <string.h>
#include <stdlib.h>

#include <mprintf.h>
#include <dev2d.h>
#include <gadbox.h>
#include <gadblist.h>

#include <vumanui.h>
#include <editbr.h>
#include <editbr_.h>
#include <gedit.h>
#include <cmdbutts.h>
#include <txtrpal.h>
#include <txtpnp.h>
#include <texmem.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static struct _TextPal
{
   LGadRoot* root;  // grabbed from view manager
   LGadButtonList list;
   DrawElement* elems;
   int *xtra;       // to hold callback data, for now
   Rect* rects;
   TexturePalCall update;
   int numbutts;
} TextPal;

static BOOL phoenix_rising=FALSE;

#define TP_EXTRA_BUTTONS 4 
#define TP_DONE_BUILD_INDEX(palptr)   ((palptr)->numbutts-5+TPAL_XTRA_DONE)
#define TP_DETACH_BUILD_INDEX(palptr) ((palptr)->numbutts-5+TPAL_XTRA_DETACH)
#define TP_REMOVE_BUILD_INDEX(palptr) ((palptr)->numbutts-5+TPAL_XTRA_REMOVE)
#define TP_SKY_BUILD_INDEX(palptr)    ((palptr)->numbutts-5+TPAL_XTRA_SKY)

static void textpal_draw_cb(DrawElement* elem, DrawElemState state)
{
   extern BOOL drawTexturetoCanvas(int mt, editBrush *br, BOOL active);
   int n=(int)elem->draw_data2;

   if ((n >= 0)&&(n<TextPal.numbutts-TP_EXTRA_BUTTONS))
      drawTexturetoCanvas(n,NULL,state==dsDEPRESSED);
   else
      gr_clear(0);
}

////////////////////////////////////////

#pragma off(unreferenced)
static void destroy_me(void* arg)
{
   DestroyTexturePalette();
}

static bool textpal_button_cb(ushort action, int button, void* data, LGadBox* vb)
{
   bool destroy = (action & LGADBUTT_LDOUBLE) != 0;
   int cb_val=TextPal.xtra[button];

   if (TpalGetExtraCode(cb_val)==TPAL_XTRA_DONE)
      destroy = TRUE;
   else
      if (action & (LGADBUTT_LCLICK|LGADBUTT_LDOUBLE))
         if (TextPal.update != NULL)
            destroy = TextPal.update(cb_val) || destroy;
   if (destroy)
      uiDefer(destroy_me,NULL);
   return TRUE;
}
#pragma on(unreferenced)

////////////////////////////////////////

#define DIMS_RATIO_X 3
#define DIMS_RATIO_Y 1

void CreateTexturePalette(TexturePalCall update)
{
   struct _TextPal* pal = &TextPal;
   int n = texmemGetMax()+TP_EXTRA_BUTTONS;
   int i; 

   pal->update = update;

   pal->root = vmGrabViews(vmGrabTwoWide);
   if (pal->root == NULL)
   {
      Warning(("Failed to grab texture palette views\n"));
      return;
   }
   
   pal->rects = Malloc(n*sizeof(*pal->rects));
   pal->elems = Malloc(n*sizeof(*pal->elems));
   pal->xtra  = Malloc(n*sizeof(*pal->xtra));
   pal->numbutts = n;

   for (i = 0; i < n; i++)
   {
      DrawElement* elem = &pal->elems[i];
      ElementClear(elem);
      if (i < n-TP_EXTRA_BUTTONS)
      {
         elem->draw_type  = DRAWTYPE_CALLBACK;
         elem->draw_data  = textpal_draw_cb;
         elem->draw_data2 = (void*)i;
         pal->xtra[i]=i;
      }
      else
      {
         elem->draw_type  = DRAWTYPE_TEXT;
         pal->xtra[i]=(-(1+i-(n-TP_EXTRA_BUTTONS)));
         
         if (i==TP_DONE_BUILD_INDEX(pal))
            elem->draw_data = "Done";
         else if (i==TP_SKY_BUILD_INDEX(pal))
            elem->draw_data = "Sky";
         else if (i==TP_REMOVE_BUILD_INDEX(pal))
            elem->draw_data = "Remove\nfrom\nLevel";
         else if (i==TP_DETACH_BUILD_INDEX(pal))
         {
            if (txtPnP_allow_attach)
               elem->draw_data = "detach\nattach";
            else
               elem->draw_data = "put on\nbrush";
         }
         else
            elem->draw_data = "Bug!\nReport\nMe";
         elem->draw_flags = BORDER(DRAWFLAG_BORDER_OUTLINE);
      }
   }
   
   // compute rectangles
   {
      Rect* box = LGadBoxRect(pal->root);
      Rect bounds = { {0,0},};
      Point ratio; 
      Point dims; 
      int xr = 0 ,yr = 0;
      bounds.lr = MakePoint(RectWidth(box),RectHeight(box));

      // compute ratio. -- dc: used to go <n, now <n-EXTRA
      for (i = 0; i < n - TP_EXTRA_BUTTONS; i++)
      {
         grs_bitmap *bm=texmemGetTexture(i);
         xr += bm->w;
         yr += bm->h;
      }
      for (i = 0; i < TP_EXTRA_BUTTONS; i++)
       { xr += 32; yr += 32; }   // hack to try and get rid of tiny tiny palette??
      ratio.x = (short)max(RectWidth(box)*n/xr,1);
      ratio.y = (short)max(RectHeight(box)*n/yr,1);
      dims = ratio;
      
      // scale dimensions until we have enough
      while(dims.x * dims.y < n)
      {
         dims.x++;
         dims.y = dims.x*ratio.y/ratio.x;
      }
      LayoutRectangles(&bounds,pal->rects,n,dims,MakePoint(0,0));
   }

   // build the button list finally
   {
      LGadButtonListDesc desc;
      memset(&desc,0,sizeof(desc));
      desc.num_buttons = n;
      desc.button_rects = pal->rects;
      desc.button_elems = pal->elems;
      desc.cb = textpal_button_cb;
      desc.flags=BUTTONLIST_RADIO_FLAG;

      LGadCreateButtonListDesc(&pal->list,pal->root,&desc);
   }
   pal->numbutts = n;
   LGadDrawBox(VB(pal->root),NULL);
}

////////////////////////////////////////

void DestroyTexturePalette(void)
{
   if (TextPal.root == NULL)
      return;
   LGadHideBox(VB(TextPal.root),TRUE);
   LGadDestroyButtonList(&TextPal.list);
   Free(TextPal.elems);
   Free(TextPal.rects);
   Free(TextPal.xtra);

   vmReleaseViews(TextPal.root);
   TextPal.root = NULL;
   if (!phoenix_rising)
      txtPnP_attach();     // if we got detached, reattach to brush
}

////////////////////////////////////////

void ToggleTexturePalette(TexturePalCall update)
{
   if (TextPal.root == NULL)
      CreateTexturePalette(update);
   else
      DestroyTexturePalette();
}

////////////////////////////////////////

bool TexturePaletteVisible(void)
{
   return TextPal.root != NULL;
}

////////////////////////////////////////

void TexturePaletteSelect(int texture)
{
   LGadRadioButtonSelect(&TextPal.list,texture);
   LGadDrawBox(VB(TextPal.root),NULL);
}

////////////////////////////////////////

static void rise_like_phoenix(void* update)
{
   phoenix_rising=TRUE;
   DestroyTexturePalette();
   CreateTexturePalette((TexturePalCall)update);
   phoenix_rising=FALSE;
}

void TexturePaletteUpdate(GFHUpdateOp op)
{
   if (TextPal.root != NULL)
   {
      if (op == GFH_FORCE || TextPal.numbutts != texmemGetMax()+TP_EXTRA_BUTTONS)
      {
         TexturePalCall update = TextPal.update;
         uiDefer(rise_like_phoenix,update);
      }
   }
}

/////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/editor/txtrpal.h,v 1.5 2000/01/29 13:13:19 adurant Exp $
#pragma once

#ifndef __TEXTRPAL_H
#define __TEXTRPAL_H
#include <brushgfh.h>

#define TPAL_XTRA_DONE   (4)
#define TPAL_XTRA_DETACH (3)
#define TPAL_XTRA_REMOVE (2)
#define TPAL_XTRA_SKY    (1)

#define TpalIsExtraButton(x) (x<0)
#define TpalGetExtraCode(x)  (-(x))

// called when a texture is clicked on.  returns whether to destroy texture pal.
typedef bool (*TexturePalCall)(int texture);

EXTERN void CreateTexturePalette(TexturePalCall update);
EXTERN void DestroyTexturePalette(void);

EXTERN void ToggleTexturePalette(TexturePalCall update);

EXTERN bool TexturePaletteVisible(void);
EXTERN void TexturePaletteUpdate(GFHUpdateOp op);

EXTERN void TexturePaletteSelect(int texture);

#endif // __TEXTRPAL_H
// $Header: r:/t2repos/thief2/src/editor/uiedit.c,v 1.33 2000/02/19 13:13:40 toml Exp $
#include <lg.h>
#include <stdlib.h>
#include <comtools.h>
#include <res.h>
#include <gadget.h>
#include <guistyle.h>
#include <gcompose.h>
#include <2d.h>
#include <config.h>

#include <uiedit.h>
#include <viewmgr.h>
#include <vumanui.h>
#include <scrnman.h>
#include <uiapp.h>
#include <hotkey.h>
#include <brushgfh.h>
#include <cmdterm.h>
#include <txtrpal.h>
#include <status.h>

#include <mprintf.h>

// for windows common controls
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <commctrl.h>

#include <comtools.h>
#include <wappapi.h>
#include <appagg.h>
// END for windows common controls

// res files
#include <editor.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern guiStyle editStyle;   // at the bottom

//------------------------------------------------------------
// Screen layout stuff 
//

// table mapping modes to layouts

typedef struct Layout Layout;

static struct Layout
{
   Point dims;
   Id id;
}
Layouts[] =
{
   { { 640, 480 }, RES_EditorLayout640x480},
   { {1024, 768 }, RES_EditorLayout1024x768},
   { { 800, 600 }, RES_EditorLayout800x600},
   { {1280,1024 }, RES_EditorLayout1280x1024}, 
};


#define NUM_LAYOUTS (sizeof(Layouts)/sizeof(Layouts[0]))

//
// Find the layout for our screenmode
//

static Layout* screen_layout(void)
{
   Region* root = GetRootRegion();
   Point rootdims = MakePoint(RectWidth(root->r),RectHeight(root->r));
   int i;
   ulong besterror = 0xFFFFFFFF;
   int besti = 0;

   for (i = 0; i < NUM_LAYOUTS; i++)
   {
      Layout* l = &Layouts[i];
      ulong error = abs(rootdims.x - l->dims.x) * abs(rootdims.y - l->dims.y);
      if (error < besterror)
      {
         besterror = error;
         besti = i;
      } 
   }
   return &Layouts[besti];
}

static Rect* get_layout_rect(Layout* lay, int idx)
{
   static Rect outrect;

   Region* root = GetRootRegion();
   Point rootdims = MakePoint(RectWidth(root->r),RectHeight(root->r));   
   Rect* r = &outrect;

   // load rect from resource
   *r = *(Rect*)RefGet(MKREF(lay->id,idx));
   // scale
   r->ul.x = r->ul.x * rootdims.x / lay->dims.x;
   r->lr.x = r->lr.x * rootdims.x / lay->dims.x;
   r->ul.y = r->ul.y * rootdims.y / lay->dims.y;
   r->lr.y = r->lr.y * rootdims.y / lay->dims.y;   

   return r;
}

////////////////////////////////////////////////////////////


void EditorCreateGUI(void)
{
   extern void StatusSetRect(Rect *);

   Region* root = GetRootRegion();
   Layout* lay = screen_layout();

   GUIErase(root->r);

   uieditStyleSetup();
   SetCurrentStyle(&editStyle);

   vmCreateGUI(root,get_layout_rect(lay,REFINDEX(REF_RECT_layViewMan)));
   StatusSetRect(get_layout_rect(lay,REFINDEX(REF_RECT_layStatus)));
   CreateBrushGFH(get_layout_rect(lay,REFINDEX(REF_RECT_layGFH)));
   CreateCommandTerminal(LGadCurrentRoot(), get_layout_rect(lay,REFINDEX(REF_RECT_layCommand)),kCmdTermNoFlags);


   // make sure the windows common controls are loaded
   InitCommonControls();
}

void EditorDestroyGUI(void)
{
   IWinApp* pWA = AppGetObj(IWinApp);
   HWND hWnd, hPrevWnd, hMainWnd = IWinApp_GetMainWnd(pWA);
   SafeRelease(pWA);

   // close all child and owned windows - let's go both ways (next and prev) to make sure
   // we get them all
   hWnd = hPrevWnd = hMainWnd;
   while ((hWnd = GetNextWindow(hWnd, GW_HWNDPREV)) != NULL)
   {
      if (GetWindow(hWnd, GW_OWNER) == hMainWnd)
      {
         DestroyWindow(hWnd);
         hWnd = hPrevWnd;
      }
      else
         hPrevWnd = hWnd;
   }

   hWnd = hPrevWnd = hMainWnd;
   while ((hWnd = GetNextWindow(hWnd, GW_HWNDNEXT)) != NULL)
   {
      if (GetWindow(hWnd, GW_OWNER) == hMainWnd)
      {
         DestroyWindow(hWnd);
         hWnd = hPrevWnd;
      }
      else
         hPrevWnd = hWnd;
   }

   if (TexturePaletteVisible())
      DestroyTexturePalette();
   DestroyCommandTerminal();
   DestroyBrushGFH();
   vmDestroyGUI();
   uieditStyleCleanup(); 
}

////////////////////////////////////////

guiStyle editStyle;     // this is the current usable style

guiStyle masterEditStyle = 
{
   0, // palette
   {  // colors
      uiRGB(255,255,255), // fg
      uiRGB( 10, 10, 10), // bg
      uiRGB( 40,200,200), // text
      uiRGB(255,  0,255), // hilite
      uiRGB(255,255,255), // bright
      uiRGB( 96, 96, 96), // dim
      uiRGB(255,255,255), // fg2
      uiRGB( 64, 64, 64), // bg2
      uiRGB( 40,200,200), // border
      uiRGB(255,255,255), // white
      uiRGB(  5,  5,  5), // black
      1, // xor
      1, // light bevel
      0, // dark bevel
   },

}; 

   
void uieditStyleSetup(void)
{
   guiStyle style = masterEditStyle;
   uieditStyleCleanup(); 

   uiGameLoadStyle("edit_",&style,NULL); 
   guiCompileStyleColors(&editStyle,&style); 
   SetCurrentStyle(&editStyle); 
}

void uieditStyleCleanup()
{
   uiGameUnloadStyle(&editStyle); 
}

void uieditRedrawAll(void)
{
   LGadDrawBox(VB(LGadCurrentRoot()),NULL);
}

void redraw_all_cmd(void)
{
   uieditRedrawAll();
   vm_redraw();
   StatusDrawStringAll();
}  

// $Header: r:/t2repos/thief2/src/editor/uiedit.h,v 1.8 2000/01/29 13:13:20 adurant Exp $
#pragma once

#ifndef __UIEDIT_H
#define __UIEDIT_H
#include <guistyle.h>
#include <uigame.h>

EXTERN void EditorCreateGUI(void);
EXTERN void EditorDestroyGUI(void);

EXTERN void uieditStyleSetup(void);
EXTERN void uieditStyleCleanup(void); 
EXTERN void uieditRedrawAll(void);

#define uieditFixupColor guiScreenColor
EXTERN void redraw_all_cmd(void);

   
#endif // __UIEDIT_H





// $Header: r:/t2repos/thief2/src/editor/undoredo.c,v 1.5 1998/08/08 16:52:11 dc Exp $
// undo system for brush/motion elements

#include <mprintf.h>
#include <lg.h>

#include <editbr.h>
#include <undoredo.h>

#include <dbmem.h>

#define UNDO_STACK_BLOCK_SIZE 1024

static void **undoStack=NULL;
static void **undoPtr, **undoMax;
static int    undoCurSize=0;

void undoStackInit(void)
{
   undoCurSize=UNDO_STACK_BLOCK_SIZE;
   undoStack=(void **)Malloc(undoCurSize*sizeof(void *));
   undoMax=undoPtr=undoStack;
}

void undoStackFree(void)
{
   if (undoStack!=NULL)
   {
      undoClearUndoStack();
      Free(undoStack);
      undoStack=NULL;
   }
}

void  _undoFreeStack(void **low, void **hi)
{
   while (low<hi)
      Free(*low++);
}

BOOL  _undoStoreStack(void *ptr)
{
   if (undoPtr-undoStack>=undoCurSize)
   {
      int new_size=undoCurSize+UNDO_STACK_BLOCK_SIZE;
      void **newStack=(void **)Realloc(undoStack,new_size*sizeof(void *));
      if (newStack==NULL)
         return FALSE;
      undoMax=(undoMax-undoStack)+newStack;
      undoPtr=(undoPtr-undoStack)+newStack;
      undoStack=newStack;
      undoCurSize=new_size;
   }
   _undoFreeStack(undoPtr,undoMax); // this free stack is here so that if you
   *undoPtr++=ptr;                  // start storing after an undo, it goes and
   undoMax=undoPtr;                 // frees the actions you are discarding
   return TRUE;
}

BOOL _undoStackReplace(void **loc, void *ptr)
{
   if (loc==undoMax)          // if you are already at end of stack
      return FALSE;           // you cant do a replace to the stack
   _undoFreeStack(loc,loc+1); // else just free this exact elem
   *loc=ptr;                  // and load over it 
   return TRUE;         
}

void  undoKillStackTop(void)
{
   if (undoPtr>undoStack)
   {
      --undoPtr;
      _undoFreeStack(undoPtr,undoMax);
      undoMax=undoPtr;
   }
}

void *_undoFetchStack(void)
{
   if (undoPtr==undoStack)
      return NULL;
   return *--undoPtr;
}

void *_undoWalkStack(void)
{
   if (undoPtr==undoMax)   // cant walk the stack, nothing to say
      return NULL;
   return *undoPtr++;      // walk to the next element
}

BOOL undoStoreAction(void *action)
{
   if (!_undoStoreStack(action))
   {
      Warning(("Hey, undo stack full - couldnt Realloc size %d block %d",undoCurSize,UNDO_STACK_BLOCK_SIZE));
      return FALSE;
   }
   return TRUE;
}

BOOL undoUndoReplace(void *ptr)
{
   return _undoStackReplace(undoPtr,ptr);
}

BOOL undoRedoReplace(void *ptr)
{
   return _undoStackReplace(undoPtr-1,ptr);
}

void *undoPeek(void)
{
   if (undoPtr>undoStack)
      return *(undoPtr-1);
   else
      return NULL;
}

void *undoDoUndo(void)
{
   return _undoFetchStack();
}

void *undoDoRedo(void)
{
   return _undoWalkStack();
}

void undoClearUndoStack(void)
{
   _undoFreeStack(undoStack,undoMax);
   undoPtr=undoMax=undoStack;    // set us back at the beginning
}

// rain is wonderful

#ifdef DBG_ON
void undoDumpStack(void (*cback)(void *action,bool next))
{
   void **ptr=undoStack;
   mprintf("undoStack @ %dof%d..",undoPtr-undoStack,undoMax-undoStack);
   while (ptr<undoMax)
   {
      (*cback)(*ptr,ptr==undoPtr-1);
      ptr++;
   }
   mprintf("\n");
}
#endif
// $Header: r:/t2repos/thief2/src/editor/undoredo.h,v 1.3 1998/08/08 16:52:27 dc Exp $

#pragma once

#ifndef __UNDOREDO_H
#define __UNDOREDO_H

EXTERN void  undoStackInit(void);
EXTERN void  undoStackFree(void);
EXTERN BOOL  undoStoreAction(void *action);
EXTERN BOOL  undoUndoReplace(void *ptr);
EXTERN BOOL  undoRedoReplace(void *ptr);
EXTERN void *undoPeek(void);
EXTERN void *undoDoUndo(void);
EXTERN void *undoDoRedo(void);
EXTERN void  undoClearUndoStack(void);
EXTERN void  undoKillStackTop(void);

#ifdef DBG_ON
EXTERN void undoDumpStack(void (*cback)(void *action,bool next));
#endif

#endif  // __UNDOREDO_H
// $Header: r:/t2repos/thief2/src/editor/userpnp.c,v 1.2 2000/02/19 13:13:41 toml Exp $
#include <config.h>

#include <userpnp.h>
#include <cmdbutts.h>
#include <gadblist.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

////////////////////////////////////////////////////////////
// USER-DEFINED PNP
// fills the area with a config-driven menu
////////////////////////////////////////////////////////////

#define USER_PNP_PREFIX "user_menu"

static CmdButtonListDesc user_desc;
static LGadButtonList user_list;
static int menu_size = 0;

#define MAX_MENU_LINES 7
#define USER_MENU_SPACING MakePoint(1,1)

#pragma off(unreferenced)
void CreateUserPNP(LGadRoot* root, Rect* bounds, editBrush* brush)
{
   menu_size = 0;
   config_get_int(USER_PNP_PREFIX"_size",&menu_size);
   if (menu_size > 0)
   {
      Point dims = MakePoint(1,MAX_MENU_LINES); 
      dims.x = (menu_size+MAX_MENU_LINES-1)/MAX_MENU_LINES;
      CreateConfigButtonDesc(&user_desc,menu_size,bounds,USER_PNP_PREFIX,dims,USER_MENU_SPACING);
      CreateCmdButtonList(&user_list,root,&user_desc);
   }
}


void UpdateUserPNP(GFHUpdateOp op, editBrush* brush)
{
   if (menu_size > 0 && op == GFH_FORCE)
      LGadDrawBox(VB(&user_list),NULL);
}

void DestroyUserPNP(void)
{
   if (menu_size > 0)
   {
      LGadDestroyButtonList(&user_list);
      DestroyConfigButtonDesc(&user_desc);
   }
   menu_size = 0;
}



#pragma on(unreferenced)
// $Header: r:/t2repos/thief2/src/editor/vbrush.c,v 1.52 2000/03/16 19:17:52 patmac Exp $
// virtual brush/multi brush concentrator abstractions

#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include <lg.h>
#include <matrix.h>
#include <matrixd.h>
#include <mprintf.h>
#include <config.h>

#include <command.h>
#include <status.h>

#include <tagfile.h>
#include <editsave.h>
#include <filetool.h>
#include <filemenu.h>

#include <gridsnap.h>

#include <editbr.h>
#include <editbr_.h>
#include <editobj.h>
#include <brinfo.h>
#include <brlist.h>
#include <brundo.h>
#include <brrend.h>
#include <primal.h>
#include <gedit.h>
#include <brquery.h>
#include <hilight.h>

#include <vbrush.h>
#include <vbr_math.h>

#include <namenum.h>
#include <prompts.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

//#define WATCH_LAST_LAST

extern BOOL brushIsLocked (editBrush* brush);

void br_update_obj(editBrush *us);

#ifdef WATCH_LAST_LAST
#define invalidNotify(msg) mprintf(msg)
#else
#define invalidNotify(msg)
#endif

// simple safe get accessor for now
editBrush *vBrush_GetSel(void)
{
   static editBrush safety_brush;
   editBrush *p=blistGet();
   return p ? p : &safety_brush;
}

/////////////
// misc simple "operators"

static void br_degroup(editBrush *us)
{
   brSelect_Group(us)=0;
}

static BOOL delete_shuffle=FALSE;
static void br_delete(editBrush *toast)
{
   editBrush *us=blistGet(), *modBr;
   BOOL shuffle=((toast!=NULL)&&(us!=toast));
   if (shuffle)   // @TODO: get rid of dorky requirement that you delete at cursor
      if (blistSetPostoBrush(toast)==-1)
         return;
   editUndoStoreStart(toast);
   editUndoStoreDelete(toast);
   modBr=blistDelete();
   if (modBr!=NULL)
   {
      if (!delete_shuffle)
      {
         modBr->flags |=  kEBF_BeingDeleted;
         brush_field_delete(modBr);
         modBr->flags &= ~kEBF_BeingDeleted;
      }
      brushDelete(modBr);
   }
   if (shuffle)
      if (blistSetPostoBrush(us)==-1)
         return;
}

// @TODO: get primal type from old brush
static int        clone_type=-1;
static editBrush *clone_cursor=NULL;
static void br_clone(editBrush *us)
{
   editBrush *modBrush;
   int type=(brushGetType(us)==brType_TERRAIN)?us->primal_id:0;
   modBrush=brushInstantiate(type);
   mx_copy_vec(&modBrush->pos,&us->pos);
   if (clone_type==-1)
      mx_copy_vec(&modBrush->sz,&us->sz);
   else
      modBrush->sz.el[0]=modBrush->sz.el[1]=modBrush->sz.el[2]=1.0;
   modBrush->ang=us->ang;
   gedit_full_create_brush(modBrush,us,GEDIT_CREATE_AT_END|GEDIT_CREATE_CLONE,clone_type);
   brSelect_Group(modBrush)=brSelect_Group(us);    // new group is us
   brSelect_Group(us)=0;    // our old brush goes back to group 0
   if (us==clone_cursor) clone_cursor=modBrush;
}

// actually move this brush to the end of time
static void br_eot(editBrush *move_me)
{
   if (move_me!=blistGet())
      blistSetPostoBrush(move_me);
   blistDelete();
   blistSeek(0,SEEK_END);
   blistInsert(move_me);
}

/////////////
// "loop clients" - ie. things which actually do operations... currently somewhat icky

// the frame callback snoops on the focused brush every frame
//   all editor brush modifiers should vBrush_editBrush_Get, not blistGet()
//   if the current focus is a real brush, the modifiers just do so, and it changes
//     (though now it saves last frame, so it can auto do the undos from here)
//   if the current focus is a virtual brush, it snoops the changes
//     it goes through all fields whose changes it can react to
//     it then calls the operation for all brushes in the vBrush

// delete and clone are specials, basically, since they need to be called out to here
// as is cycle_brush (which now has a within vBrush parameter, basically)

// group id invariant is
//  cur_Group is the "Active group selection"
//  0 means no selection active
//  1 is reserved for the "in progress" selection
//  2-> are saved (real) selections
static int        cur_Group=0;

static editBrush  _virtual_Br;           // static for holding a multiBrush virtual object
static editBrush  _last_Br;              // static for holding copy of last brush, v or not
static BOOL       last_br_valid=FALSE;   // does _last_Br have valid data
static int        last_Group=0;          // what's the last group we had

static sNameNum  *pNN_MultiBrush=NULL;

#define abandon_Group() last_Group=cur_Group=0

// singular callback for vBrush Focus Changes
void (*vBrush_Change_Callback)(editBrush *brush) = NULL;

static void create_virtual_Br(void)
{
   editBrush *p=&_virtual_Br;
   brushZero(p,0);
   brSelect_Group(p)=cur_Group;
   brSelect_Flag(p)=brSelect_VIRTUAL;
   memcpy(&_last_Br,p,sizeof(editBrush));
   p->br_id=VIRTUAL_BRUSH_ID;
   invalidNotify("create invalidation\n");
   last_br_valid=FALSE;  // so we know not to try and "do" anything in the frame callback
}

// get the current vBrush
editBrush *vBrush_editBrush_Get(void)
{
   editBrush *p=vBrush_GetSel();
   if (cur_Group==0) return p;
   // otherwise, we better have a virtual brush around for the gfh
   if (brSelect_Group(&_virtual_Br)!=cur_Group)
      create_virtual_Br();  // this test is bad, since we want to reset it more often
   return &_virtual_Br;
}

// is this brush in the current group?
BOOL vBrush_inCurGroup(editBrush *us)
{
   if (cur_Group==0) return FALSE;
   return brSelect_Group(us)==cur_Group;
}

// ok.. things get ugly
//   if we changed the last brush (i_changed_the_brush) we have to redraw everything
//     (to get correct new brush as part of back and store)
//   else we just change, so we just need to do a select update
// still broken, we really want i_changed to somehow update the old picture for the old brush loc
void we_switched_brush_focus(void)
{
   editBrush *cur=vBrush_GetSel();
   if (cur_Group)
      if (brSelect_Group(cur)!=cur_Group)
      {
         last_Group=cur_Group;
         cur_Group=0; // we changed groups on this focus change, so "deactivate" old
         editUndoStoreGroup(last_Group,cur_Group);
      }
   invalidNotify("switch focus invalidation\n");
   last_br_valid=FALSE;
   // set up GFH Stuff? anyone?
   if (vBrush_Change_Callback)
      (*vBrush_Change_Callback)(vBrush_editBrush_Get());
   gedit_change_selection();
}

// run a callback on all brushes in the group, or on all brushes if run_all is TRUE
void vBrush_GroupOp(BOOL run_all, void (*br_op)(editBrush *us))
{
   bool grid_state=cur_global_grid.grid_enabled;
   editBrush *us, *tmp;
   int hIter;

   if (!run_all && cur_Group==0) return; // well, no group, so we just dont care
   cur_global_grid.grid_enabled=0;
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      tmp=us;                     // save us off
      us=blistIterNext(hIter);   // get to next now, then do the callback
      if (run_all || (brSelect_Group(tmp)==cur_Group))
         (*br_op)(tmp);           // look, go run the op
   }
   cur_global_grid.grid_enabled=grid_state;   
}

// run a callback on all brushes in the group, or on all brushes if run_all is TRUE
static void run_simple_bounded_group_br_op(void (*br_op)(editBrush *us))
{
   bool grid_state=cur_global_grid.grid_enabled;
   editBrush *us, *tmp, *end;
   int hIter;

   if (cur_Group==0) return; // well, no group, so we just dont care
   cur_global_grid.grid_enabled=0;
   blistSeek(0,SEEK_END);
   end=blistGet();
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      tmp=us;                    // save us off
      us=blistIterNext(hIter);  // get to next now, then do the callback
      if (brSelect_Group(tmp)==cur_Group)
         (*br_op)(tmp);          // look, go run the op
      if (tmp==end)              // should be tmp, not us, since we want to run the original end of list too
      {
         blistIterDone(hIter);  // tell next system we are done
         break;                  // at original end of list, lets go home
      }
   }
   cur_global_grid.grid_enabled=grid_state;   
}

static BOOL group_ok(editBrush *br)
{
   return (cur_Group==0) || (brSelect_Group(br)==cur_Group);
}

BOOL vBrush_cycle(int dir)
{
   BOOL rv=brCycle(dir,group_ok);
   if (!rv) abandon_Group();       // since we cant find any of it
   return rv;
}


// @TODO: for now just cycle randomly (should have a look for closest call back, eh?)
static BOOL getToCurGroup(void)
{
   return vBrush_cycle(1);
}

///// backdoors for things like undo and such
BOOL vBrush_GoToGroup(int group_id)
{
   editBrush *cur=vBrush_GetSel();
   BOOL rv=TRUE;
   
   if ((cur_Group==group_id)&&(brSelect_Group(cur)==cur_Group))
      return rv;
   cur_Group=group_id;
   if (brSelect_Group(cur)!=cur_Group)
      rv=vBrush_cycle(1);
   if (!rv)
      vBrush_SelectBrush(cur);
   return rv;
}

BOOL vBrush_DontUpdateFocus=FALSE;

// this is used for mouse or other direct brush selection
void vBrush_SelectBrush(editBrush *sel)
{
    if (brushIsLocked(sel))
    {
        Status ("* LOCKED *");
        return;
    }

   if (sel==NULL) return;
   blistSetPostoBrush(sel);
   if (!vBrush_DontUpdateFocus)
      we_switched_brush_focus();
}

// @SOLVE: do we want to do things with parm for real or fake, or 2 calls
// ie. there is user does delete, and internal system does delete
void vBrush_DeletePtr(editBrush *what)
{
   BOOL need_db_update=TRUE; // cause on multibrush we are gonna wuss out and always update

   if (what->flags & kEBF_BeingDeleted)
      return;

   if (what==&_virtual_Br)   // we are the virtual brush
   {  // @TODO: put an undo package around this
      editUndoStoreBlock(TRUE);
      vBrush_GroupOp(FALSE,br_delete);
      editUndoStoreBlock(FALSE);
      abandon_Group();   // as we know we just got rid of the last of it
   }
   else
   {
      delete_shuffle=(what!=blistGet());
      //need_db_update=(brushGetType(what)==brType_LIGHT)||(brushGetType(what)==brType_TERRAIN);
      need_db_update = (brushGetType(what)==brType_TERRAIN);
      br_delete(what);
      delete_shuffle=FALSE;   // make this less of a @HACK
   }
   if (need_db_update)
      gedit_db_update(TRUE);  // and redraw, as well
   else
      gedit_full_redraw();    // just redraw, since the db was not changed (in a portal/WR way)
   we_switched_brush_focus();
}

static BOOL vBrush_singlecopy(editBrush *br, BOOL clone)
{
   if (!clone) clone_type=gedit_default_brush_type();
   br_clone(br);
   if (!clone) clone_type=-1;
   return (brushGetType(br)==brType_TERRAIN);
}

static void vBrush_clonefinish(BOOL update_p)
{
   vBrush_SelectBrush(clone_cursor);
   if (update_p)
      gedit_db_update(TRUE);  // know about new brushes in one place
   else
      gedit_full_redraw();
}

// clone this brush, in a group status, clone punts group id
void vBrush_ClonePtr(editBrush *what)
{
   BOOL need_update=FALSE;
   clone_cursor=vBrush_GetSel();
   if (what==&_virtual_Br)   // we are the virtual brush
   {
      editUndoStoreBlock(TRUE);      
      run_simple_bounded_group_br_op(br_clone);
      editUndoStoreBlock(FALSE);
      need_update=TRUE;
   }
   else
      need_update=vBrush_singlecopy(what,TRUE);
   vBrush_clonefinish(need_update);
}

void vBrush_CreateSingle(void)
{
   clone_cursor=vBrush_GetSel();
   vBrush_clonefinish(vBrush_singlecopy(clone_cursor,FALSE));
}

// a new Brush (singleton) has been created in the editor
void vBrush_NewBrush(editBrush *new_br)
{
   if (cur_Group)
      brSelect_Group(new_br)=cur_Group;
   we_switched_brush_focus();
}

editBrush *vBrush_UndoVBrush(editBrush *old_br)
{
   if (cur_Group==brSelect_Group(old_br))
   {
      _last_Br=_virtual_Br;
      invalidNotify("undo invalidation\n");
      last_br_valid=TRUE;
      return &_virtual_Br;
   }
   Warning(("vbrush undo fail: curG %d, brush is %d\n",cur_Group,brSelect_Group(old_br)));
   return NULL;
}

// first see what sort of context we are in
// ie. if our vBrush is just a real brush, great, nothing to really do

//   @TODO: should undoredo really be through here even for single brush???

extern BOOL gedit_is_drag_in_prog(void);

static int       last_vec_type=brVec_NONE;
static editBrush last_vec_vb;

#define brVec_RESET (brVec_NONE-1)
static void switch_vb_base_p(int type, editBrush *base_br)
{
   if (type!=last_vec_type)
   {
      last_vec_vb=*base_br;
      store_BrushVecs();
      if (type==brVec_RESET)
         last_vec_type=brVec_NONE;
      else
         last_vec_type=type;
#ifdef WATCH_LAST_LAST      
      mprintf("new vBase %x type %d\n",base_br->ang.el[2],type);
#endif
   }
}

// per frame setup
void vBrush_FrameCallback(void)
{
   static BOOL      last_last_valid=FALSE;
   editBrush *curB=vBrush_editBrush_Get();
   
   if (last_br_valid) // then just record it off, no changes
   {
      if (!last_last_valid)
         invalidNotify("Trigger In\n");
      if (cur_Group==0) // nothing to do
         ;
      else if (brSelect_Group(curB)!=cur_Group)
      {  // @TODO: do undo stuff with last brush?
         invalidNotify("Local invalidation\n");
         last_br_valid=FALSE;
         return;
      }
      else
      {  // if here, curB is part of the current active Group
         // if trigger in, save off all vectors and initial multibrush
         if (!last_last_valid)
            switch_vb_base_p(brVec_RESET,&_last_Br);  // always reset since < Vec_NONE
         if (memcmp(curB,&_last_Br,sizeof(editBrush))!=0)
         {
            mxs_vector vec_change;
            mxds_vector ang_diff;
            BOOL deal=FALSE;

            if (memcmp(&curB->pos,&_last_Br.pos,sizeof(mxs_vector)))
            {
               switch_vb_base_p(brVec_POS,&_last_Br);
               mx_sub_vec(&vec_change,&curB->pos,&_last_Br.pos);
               br_translate_setup(&vec_change);
               vBrush_GroupOp(FALSE,br_translate);
               vBrush_GroupOp(FALSE,br_update_obj);    
               deal=TRUE;
            }
            if (memcmp(&curB->sz,&_last_Br.sz,sizeof(mxs_vector)))
            {
               mxs_vector scale_change;
               //               mx_sub_vec(&vec_change,&curB->sz,&_last_Br.sz);
               if (compute_scale_fac(&scale_change,&_last_Br.sz,&curB->sz))
               {
                  switch_vb_base_p(brVec_SZ,&_last_Br);
                  compute_scale_fac(&scale_change,&last_vec_vb.sz,&curB->sz);
                  // mprintf("scale d %g from %g %g %g\n",scale_change.x,last_vec_vb.sz.x,_last_Br.sz.x,curB->sz.x);
                  restore_BrushVecs(brVec_SZ|brVec_POS);
                  br_scale_setup(&scale_change);
                  vBrush_GroupOp(FALSE,br_scale);
               }
               else
               {
                  extern void label_vs_update(void); // only do this if it isnt the last one, or something
                  memcpy(&curB->sz,&_last_Br.sz,sizeof(mxs_vector));   // save back
                  label_vs_update();
               }
               deal=TRUE;
            }
            if (ang_quantize_and_sub(&ang_diff,&curB->ang,&_last_Br.ang))
            {
               mxs_angvec ang_change;
               switch_vb_base_p(brVec_ANG,&_last_Br);
               sub_angvecs(&ang_change,&curB->ang,&last_vec_vb.ang);
               //               ang_quantize_and_sub(&ang_diff,&curB->ang,&last_vec_vb.ang);
               restore_BrushVecs(brVec_ANG|brVec_POS);
               br_rotate_setup(&ang_change);
               vBrush_GroupOp(FALSE,br_rotate);
               deal=TRUE;
            }
            else if (memcmp(&curB->ang,&_last_Br.ang,sizeof(mxs_angvec)))
               deal=TRUE;
            if (!deal)
               Warning(("cant multibrush that, batman\n"));
            else if (!gedit_is_drag_in_prog())  // else drag is dealing with it?
               gedit_raw_change_brush(curB,FALSE,FALSE,TRUE);
         }
      }
      last_last_valid=last_br_valid;      
   }
   else
   {
      if (last_last_valid)
         invalidNotify("Trigger Out\n");
      // if deselected, reset scale to normal
      _virtual_Br.sz.el[0]=_virtual_Br.sz.el[1]=_virtual_Br.sz.el[2]=2.0;
   }
   last_last_valid=last_br_valid;
   memcpy(&_last_Br,curB,sizeof(editBrush));
   last_br_valid=TRUE;
}

/////////////
// the group public vBrush operations

// when we add to group we check cur_Group
// if >=1, we can just add to it, woo-woo
// if 0, we then assume we are starting a new group
//   which means we first go clear group 1
//   then set curGroup to 1, and do the add
static BOOL new_group;
static void add_to_group(editBrush *us)
{
   new_group=FALSE;
   if (cur_Group==0)
   {
      if (brSelect_Group(us))
         cur_Group=brSelect_Group(us);
      else
      {  // @TODO: i dont think this is working
         cur_Group=1;
         vBrush_editBrush_Op(NULL,vBrush_OP_RESET);
         new_group=TRUE;
      }
   }
   brSelect_Group(us)=cur_Group;
}

// this little section is the save system
static char used_IDs[256];
static int  new_ID=0;

static void make_used_id_map(editBrush *us)
{
   used_IDs[brSelect_Group(us)]=1;
}

static void switch_to_new_group(editBrush *us)
{
   brSelect_Group(us)=new_ID;
}

int vBrush_GetFreeGroup(void)
{
   int i;
   memset(used_IDs,0,sizeof(char)*256);
   vBrush_GroupOp(TRUE,make_used_id_map);
   for (i=2; i<256; i++)
      if (used_IDs[i]==0)
         return i;
   return 0;
}

static int vBrush_NextUsedGroup(int cur, int dir)
{
   int idx=cur;
   memset(used_IDs,0,sizeof(char)*256);
   vBrush_GroupOp(TRUE,make_used_id_map);
   do {
      cur=(cur+dir)&0xff;  // move to next candidate
   } while ((cur!=idx)&&(used_IDs[cur]==0));
   return cur;
}

// editBrush statechanges with respect to the current vBrush
BOOL vBrush_editBrush_Op(editBrush *us, int op)
{
   BOOL rv=TRUE;
   switch (op)
   {
      case vBrush_OP_ADD:
         new_group=FALSE;
         if (brSelect_Group(us)!=0)
          { Warning(("cant add from an existing group\n")); rv=FALSE; }
         else
            add_to_group(us);
         break;
      case vBrush_OP_REM:
         if (brSelect_Group(us)==0)
          { Warning(("Trying to remove an ungrouped brush\n")); rv=FALSE; }
         else if (brSelect_Group(us)!=cur_Group)
          { Warning(("removing from a non-current group?\n")); rv=FALSE; }
         brSelect_Group(us)=0;
         break;         
      case vBrush_OP_TOG:
         new_group=FALSE;
         if (brSelect_Group(us)==0)     
            add_to_group(us);           // we have no group, so put us in the group
         else if (cur_Group==0)
            cur_Group=brSelect_Group(us);
         else if (brSelect_Group(us)==cur_Group)
            brSelect_Group(us)=0;
         else
          { Warning(("Togging a brush in another group?\n")); rv=FALSE; }
         break;
      case vBrush_OP_SAVE:
         rv=FALSE;
         if (cur_Group==1)
         {
            new_ID=vBrush_GetFreeGroup();
            if (new_ID)
            {
               editUndoStoreBlock(TRUE);               
               vBrush_GroupOp(FALSE,switch_to_new_group);
               editUndoStoreBlock(FALSE);               
               cur_Group=new_ID;  // @TODO: Status here?
               rv=TRUE;
            }
         }
         break;
      case vBrush_OP_RESET:
         editUndoStoreBlock(TRUE);
         vBrush_GroupOp(FALSE,br_degroup);
         editUndoStoreBlock(FALSE);
         break;
   }
   return rv;
}

/////////////////////
// debug stuff

#ifdef DBG_ON
static void show_vbrush_info(editBrush *us)
{
   mprintf("%d> group %d\n",us->br_id,brSelect_Group(us));
}

void vBrush_DebugInfo(int dbg_level)
{  // for now, if dbg_level, do a full dump, else just the current group
   vBrush_GroupOp(dbg_level>0,show_vbrush_info);
   mprintf(" cur %d, last %d, get %x, blist %x, virt %x group %d\n",
           cur_Group,last_Group,vBrush_editBrush_Get(),blistGet(),
           &_virtual_Br,brSelect_Group(&_virtual_Br));
}
#endif   

///////////////////
// command system stuff

static int cycle_type_target=brType_TERRAIN;
static BOOL type_ok(editBrush *br)
{
   return brushGetType(br)==cycle_type_target;
}

static BOOL highlight_ok(editBrush *br)
{
   return isActiveHighlight(br->br_id);
}

static BOOL filter_ok(editBrush *br)
{
   return (brrendCheckTypeFilter(br) && !brushIsLocked(br));
}

static editBrush *near_brush = NULL;
static BOOL near_ok(editBrush *br)
{
    float posDiff[3];
    float szDiff[3];
    
    posDiff[0] = abs(br->pos.x - near_brush->pos.x) + abs(br->pos.y - near_brush->pos.y);
    posDiff[1] = abs(br->pos.y - near_brush->pos.y) + abs(br->pos.z - near_brush->pos.z);
    posDiff[2] = abs(br->pos.z - near_brush->pos.z) + abs(br->pos.x - near_brush->pos.x);

    szDiff[0] = abs(br->sz.x - near_brush->sz.x) + abs(br->sz.y - near_brush->sz.y);
    szDiff[1] = abs(br->sz.x - near_brush->sz.x) + abs(br->sz.y - near_brush->sz.y);
    szDiff[2] = abs(br->sz.x - near_brush->sz.x) + abs(br->sz.y - near_brush->sz.y);

    return ((posDiff[0] <= 1.0 && szDiff[0] <= 1.0) ||
            (posDiff[1] <= 1.0 && szDiff[1] <= 1.0) ||
            (posDiff[2] <= 1.0 && szDiff[2] <= 1.0));
}

// find next highlighted brush
// useful when you can't find the first highlighted brush in a set
static void vbrui_cycle_highlight(int dir)
{
   brCycle(dir, highlight_ok);
}

// cycle through brushes that overlap the current brush
static void vbrui_cycle_near(int dir)
{
   near_brush = blistGet();
   brCycle(dir, near_ok);
}

// cycle based on current "context", ie. brush type
static void vbrui_cycle_context(int dir)
{
   editBrush *cur=vBrush_editBrush_Get();
   if (isActiveHighlight(cur->br_id))
      vbrui_cycle_highlight(dir);
   else if (brSelect_Flag(cur)&brSelect_VIRTUAL) // currently a multibrush
      vBrush_cycle(dir);
   else
   {
      cycle_type_target=brushGetType(cur);
      brCycle(dir,type_ok);
   }
}

void vbrui_select_obj(int obj_id)
{
   editBrush *br=editObjGetBrushFromObj(obj_id);
   if (br!=NULL)
      vBrush_SelectBrush(br);
   else
      Status("No brush for objID");
}

void vbrui_select_brid(int br_id)
{
   editBrush *br=brFind(br_id);
   if (br!=NULL)
      vBrush_SelectBrush(br);
   else
      Status("No brush with that ID");
}

// should cycle within current type filter
static void vbrui_cycle_brush(int dir)
{
   if (brrendTypeFilterActive() || config_is_defined ("hens_changes"))
      brCycle(dir,filter_ok);
   else
      brCycle(dir,NULL);
}

static void vbrui_save_vbrush(void)
{
   if (cur_Group==1)
   {  // @TODO: make sure there are elements in our group?
      char buf[PROMPT_STR_LEN], def[PROMPT_STR_LEN], *val;
      vBrush_editBrush_Op(NULL,vBrush_OP_SAVE);
      strcpy(def,"Group_");
      itoa(cur_Group,def+strlen(def),10);
      val=prompt_string(def,buf);
      NamenumStore(pNN_MultiBrush,val,cur_Group);
      Status("Saved Group");
   }
   else if (cur_Group)
      Status("Group already saved");
   else
      Status("No group to save");
}

static void vbrui_select_by_name(char *name)
{
   int picked_tag;
   if (name && *name)
      picked_tag=NamenumFetchTagForString(pNN_MultiBrush,name);
   else
      picked_tag=NamenumSimpleMenuChooseTag(pNN_MultiBrush);
   if (picked_tag!=NAMENUM_NO_TAG)
   {
      cur_Group=picked_tag;
      getToCurGroup();
   }
}

static void vbrui_breakup_vbrush(void)
{
   if (cur_Group)
   {
      NamenumClearByTag(pNN_MultiBrush,cur_Group);
      vBrush_editBrush_Op(NULL,vBrush_OP_RESET);
      gedit_full_redraw();
      Status("Group dissolved");
   }
   else
      Status("No group");
}

static void change_brushes_by_id(char *args, int op)
{
   char *s=args, *p, tmp;
   BOOL any_new_groups=FALSE;
   int val, max;

   if (s==NULL) return;
   do {
      while ((*s)!='\0'&&!isdigit(*s))
         ++s;
      if ((*s)=='\0') break;
      p=s;
      while ((*p)!='\0'&&isdigit(*p))
         p++;  // go over the digits
      tmp=*p; *p='\0'; val=atoi(s); *p=tmp;
      vBrush_editBrush_Op(brFind(val),op);
      any_new_groups|=new_group;
      s=p;
      if ((*s)=='-')
      {
         s++;
         p=s;
         while ((*p)!='\0'&&isdigit(*p))
            p++;  // go over the digits
         tmp=*p; *p='\0'; max=atoi(s); *p=tmp;
         for (++val;val<=max;++val)
         {
            vBrush_editBrush_Op(brFind(val),op);
            any_new_groups|=new_group;
         }
         s=p;
      }
   } while (*s!='\0');
   if (any_new_groups)
      getToCurGroup();
   gedit_full_redraw();
}

static void vbrui_add_brush_by_id(char *args)
 { change_brushes_by_id(args,vBrush_OP_ADD); }

static void vbrui_rem_brush_by_id(char *args)
 { change_brushes_by_id(args,vBrush_OP_REM); }

static void vbrui_tog_brush_by_id(char *args)
 { change_brushes_by_id(args,vBrush_OP_TOG); }

// @TODO: code this right
static void vbrui_group_cycle(int arg)
{
   int targ_Group;
   if (arg==0) targ_Group=last_Group;
   else targ_Group=(cur_Group+arg)&0xff;  // really should have a max vBrush or something
   if (targ_Group!=0)
   {  // correctly validate/invalidate virtual brush here
      int tmp=cur_Group;
      BOOL fixup=(brSelect_Group(vBrush_editBrush_Get())!=targ_Group);
      cur_Group=targ_Group;
      last_Group=tmp;
      if (fixup)
         if (!vBrush_getToCurGroup())
            if (arg==0)
               abandon_Group();
            else  // should really go look for a used group
               cur_Group=vBrush_NextUsedGroup(cur_Group,arg);
   }
}

static void vbrui_delete_brush(void)
{
   vBrush_DeletePtr(vBrush_editBrush_Get());
}

static void vbrui_clone_brush(void)
{
   vBrush_ClonePtr(vBrush_editBrush_Get());
}

static void vbrui_build_brush(void)
{
   vBrush_CreateSingle();
}


// if a 2 brush object group, sets src and dst to start and end of brush


static char path_buf[256];
static char *make_brush_fname(char *str)
{
   char dir_name[256];
   if (!config_get_raw("vBrush_dir",dir_name,256))
      strcpy(dir_name,".");
   diskPathMunge(path_buf,dir_name,NULL,str);
   return path_buf;
}

// filter for save load fun
static sFileMenuFilter db_file_filters[] = 
{
   { "MultiBrush Files (*.vbr)", "*.vbr"},
   { "All Files (*.*)", "*.*"},
   { NULL }
};

static char _fname_buf[256]="";

static char *get_real_fname(char *str, eFileMenuMode fMode)
{
   if (str != NULL)
      while (isspace(*str)) str++;
   if (str == NULL || *str == '\0')
   {
      str=FileDialog(fMode, db_file_filters, "VBR", _fname_buf, sizeof(_fname_buf));
      if (str == NULL || *str == '\0')
         return NULL;
   }
   else
      str=make_brush_fname(str);
   return str;
}

void br_update_obj(editBrush *us)
{
   if (brushGetType(us) == brType_OBJECT)
      editobjUpdateObjfromBrush(us);
}

// @NEEDUNDO
// load a new group from disk
static void vbrui_load_group(char *str)
{
   int newGroup=vBrush_GetFreeGroup();
   mxs_vector loc_origin;

   if ((str=get_real_fname(str,kFileMenuLoad))==NULL)
      return;
   find_brush_origin(vBrush_GetSel(),&loc_origin,NULL);
   if (editor_LoadMiniBrush(str,newGroup))
   {  // now go translate into local frame of reference, ie. where we are
      br_trans_vec=&loc_origin;
      cur_Group=newGroup;
      vBrush_GroupOp(FALSE,br_translate);    // zero relative them all
      vBrush_GroupOp(FALSE,br_update_obj);    
      vBrush_getToCurGroup();
      Status("Loaded Group");
   }
   else
      Status("Couldn't load Group");
}

// save of cur_Group to file 
static void vbrui_save_group(char *str)
{
   if (cur_Group)
   {
      mxs_vector loc_origin;

      if ((str=get_real_fname(str,kFileMenuSave))==NULL)
         return;
      br_trans_vec=&loc_origin;
      find_brush_origin(vBrush_GetSel(),br_trans_vec,NULL);
      mx_negeq_vec(br_trans_vec);
      vBrush_GroupOp(FALSE,br_translate);    // zero relative them all
      vBrush_GroupOp(FALSE,br_update_obj);    
      editor_SaveMiniBrush(str,cur_Group);
      mx_negeq_vec(br_trans_vec);
      vBrush_GroupOp(FALSE,br_translate);    // and now put them back
      vBrush_GroupOp(FALSE,br_update_obj);    

      Status("Saved group");
   }
   else
      Status("No current group");
}

// should go somewhere better, eh?
void brFlag_Toggle(editBrush *us, int flag)
{
   if (brSelect_Flag(us)&flag)
      brSelect_Flag(us)&=~flag;
   else
      brSelect_Flag(us)|= flag;
}

// 
void vBrush_click(editBrush *us, int flags, int x, int y)
{
   editBrush *last=vBrush_GetSel();
//   mprintf("vbClick: us %x last %x... flags %x - grp us %d last %d cur %d\n",
//            us,last,flags,brSelect_Group(us),last_Group,cur_Group);
   if (flags&GEDIT_CLICK_FANCY) // well, still in a valid brushSetupDraw
      brushSelectFancy(us,x,y);
   if ((last==us)&&((flags&GEDIT_CLICK_NOTOGGLE)==0)&&
       ((flags&(GEDIT_CLICK_FANCY|GEDIT_CLICK_VBRUSH))==0))
   {  // if we are not multi and our brushType has complex type (terrain), toggle complex flag
      if ((brSelect_Flag(us)&brSelect_VIRTUAL)==0)
         if ((brushGetType(us)==brType_HOTREGION)||
             (brushGetType(us)==brType_TERRAIN))
            brFlag_Toggle(us,brSelect_COMPLEX);       // if !click_fancy or Vbrush, you just reclicked
   }
   if (flags&GEDIT_CLICK_VBRUSH)
   {
      vBrush_editBrush_Op(us,vBrush_OP_TOG);
      if (brSelect_Group(us)==0)  // this is a "did Tog remove us from the group" hack
         if (brSelect_Group(last)==cur_Group)
            us=last;              // @HACK: so the select will just go back to us
         else
         {
            vBrush_getToCurGroup();  // if so, get back to our groups  (was a minor_update here?)
            return;               // since we dont want to do the select
         }
      else if (new_group) // we want to, if this is a new group, make last in our group tooo!!
         if ((last!=us)&&(brSelect_Group(last)==0)) // last not in another group
            brSelect_Group(last)=brSelect_Group(us);
   }
   vBrush_SelectBrush(us);        // if not a vbrush op, then just select us
}

// @TODO: real focusing Code!!! - modularize this crap, jesus
static void vbrui_click(void)
{
   vBrush_click(vBrush_GetSel(),GEDIT_CLICK_VBRUSH,0,0);
}

void vBrush_go_EOT(void)
{  
   editBrush *cursor=vBrush_GetSel();

   if (cur_Group==0)   // just do us
      br_eot(cursor);
   else
      run_simple_bounded_group_br_op(br_eot);
   vBrush_SelectBrush(cursor);
   gedit_db_update(FALSE);
}

// raw cycling code
int cycle_us(int val, int dir, int max, int min)
{
   val+=dir;
   if (val==max)     val=min;
   else if (val<min) val=max-1;
   return val;
}

// @TODO: figure out if this should use GetSel or editBrush_Get????
static void vbrui_cycle_face(int dir)
{
   editBrush *us=vBrush_GetSel();
   brSelect_Flag(us)&=~brSelect_COMPLEX;
   us->cur_face=cycle_us(us->cur_face,dir,us->num_faces,-1);   // should just use our internal sense of it
   gedit_redraw_selection();
}

static void vbrui_cycle_edge(int dir)
{
   editBrush *us=vBrush_GetSel();
   brSelect_Flag(us)|=brSelect_COMPLEX|brSelect_EDGE;
   us->edge=(char)cycle_us(us->edge,dir,primalBr_EdgeCnt(us->primal_id),0);
   gedit_redraw_selection();
}

static void vbrui_cycle_point(int dir)
{
   editBrush *us=vBrush_GetSel();   
   brSelect_Flag(us)|=brSelect_COMPLEX;
   brSelect_Flag(us)&=~brSelect_EDGE;
   us->point=(char)cycle_us(us->point,dir,primalBr_PointCnt(us->primal_id),0);
   gedit_redraw_selection();
}

// virtual brush command stuff
Command vbrush_keys[] =
{
   { "delete_brush", FUNC_VOID, vbrui_delete_brush },
   { "insert_brush", FUNC_VOID, vbrui_clone_brush },
   { "new_brush", FUNC_VOID, vbrui_build_brush },
   { "add_brush_num", FUNC_STRING, vbrui_add_brush_by_id },
   { "rem_brush_num", FUNC_STRING, vbrui_rem_brush_by_id },
   { "tog_brush_num", FUNC_STRING, vbrui_tog_brush_by_id },
   { "cycle_brush", FUNC_INT, vbrui_cycle_brush },
   { "cycle_context", FUNC_INT, vbrui_cycle_context, "cycle to next like brush (vBrush or type)" },
   { "cycle_highlight", FUNC_INT, vbrui_cycle_highlight, "cycle to next highlighted brush" },
   { "cycle_near", FUNC_INT, vbrui_cycle_near, "cycle to brushes near to current brush" },
   { "store_group", FUNC_VOID, vbrui_save_vbrush, "save cur vBrush to new ID" },
   { "dissolve_group", FUNC_VOID, vbrui_breakup_vbrush, "remove group ID of vBrush" },
   { "pick_group_name", FUNC_STRING, vbrui_select_by_name, "pick group by name" },
   { "cycle_group", FUNC_INT, vbrui_group_cycle, "move group by arg (0 is last)" },
   { "brush_relative", TOGGLE_BOOL, &vBrush_relative_motion },
   { "axial_scale", TOGGLE_BOOL, &vBrush_axial_scale },
   { "cycle_face", FUNC_INT, vbrui_cycle_face },
   { "cycle_edge", FUNC_INT, vbrui_cycle_edge },
   { "cycle_point", FUNC_INT, vbrui_cycle_point },
   { "brush_select", FUNC_INT, vbrui_select_brid },
   { "obj_brush_select", FUNC_INT, vbrui_select_obj, "set current brush to objID" },
   { "vBrush_click", FUNC_VOID, vbrui_click, "alt-click cur brush" },  // , auto last_Group if no multi" },
   { "vBrush_EOT", FUNC_VOID, vBrush_go_EOT, "send to end of time" },
   { "load_group", FUNC_STRING, vbrui_load_group },
   { "save_group", FUNC_STRING, vbrui_save_group },
#ifdef DBG_ON
   { "vBrush_dump", FUNC_INT, vBrush_DebugInfo },
#endif
};

void vBrush_UI_register(void)
{
   COMMANDS(vbrush_keys, HK_BRUSH_EDIT);
}

/////////////
// setup/so on

#define VB_NN_NAME "MultiBrush"
#define VB_NN_SIZE 256

// initialize virtual brush tracking system
void vBrushInit(void)
{
   vBrush_UI_register();
   pNN_MultiBrush=NamenumInit(VB_NN_NAME,VB_NN_SIZE);
}

void vBrushReset(void)
{
   if (pNN_MultiBrush)
      NamenumFree(pNN_MultiBrush);      
   pNN_MultiBrush=NamenumInit(VB_NN_NAME,VB_NN_SIZE);
}

void vBrushFree(void)
{
   if (pNN_MultiBrush)
      NamenumFree(pNN_MultiBrush);
   clear_BrushVecs();
}

///////////
// save/load setup

BOOL vBrush_NameSave(ITagFile *file)
{
   if (pNN_MultiBrush)
      return NamenumSave(pNN_MultiBrush,file);
   return FALSE;
}

BOOL vBrush_NameLoad(ITagFile *file)
{
   if (pNN_MultiBrush)
      NamenumFree(pNN_MultiBrush);      
   pNN_MultiBrush=NamenumLoad(VB_NN_NAME,file);
   if (pNN_MultiBrush)
      return TRUE;
   pNN_MultiBrush=NamenumInit(VB_NN_NAME,VB_NN_SIZE);   
   return FALSE;
}

// call this when about to save
int vBrushGetSaveData(void)
{
   return cur_Group;
}

// call this after load, with value from the save
// assumes you will vBrush_SetPos soon
int vBrushParseLoadData(int saved)
{
   cur_Group=saved;
   last_Group=0;
   return cur_Group;
}
// $Header: r:/t2repos/thief2/src/editor/userpnp.h,v 1.2 2000/01/29 13:13:21 adurant Exp $
#pragma once
#ifndef __USERPNP_H
#define __USERPNP_H

#include <swappnp.h>

EXTERN void CreateUserPNP(LGadRoot* root, Rect* bounds, editBrush* brush);
EXTERN void UpdateUserPNP(GFHUpdateOp op, editBrush* brush);
EXTERN void DestroyUserPNP(void);

#endif // __USERPNP_H
// $Header: r:/t2repos/thief2/src/editor/vbrush.h,v 1.9 2000/01/29 13:13:22 adurant Exp $
// virtual brush/multi brush concentrator abstractions
#pragma once

#ifndef __VBRUSH_H
#define __VBRUSH_H

#include <tagfile.h>

///////// major systems
// init and free the vBrush system
EXTERN void vBrushInit(void);
EXTERN void vBrushReset(void);
EXTERN void vBrushFree(void);

// for save/load of files
EXTERN BOOL vBrush_NameSave(ITagFile *file);
EXTERN BOOL vBrush_NameLoad(ITagFile *file);
// pass res from save to load (group id, really)
EXTERN int  vBrushGetSaveData(void);
EXTERN int  vBrushParseLoadData(int saved);
EXTERN int  vBrush_GetFreeGroup(void);   // for loading subgroup sort of things

//////// playing with vBrushes
// the actual vBrush_Op's
#define vBrush_OP_ADD    1
#define vBrush_OP_REM    2
#define vBrush_OP_TOG    3
#define vBrush_OP_SAVE   4
#define vBrush_OP_RESET  5

// ways of manipulating the current vBrush
EXTERN BOOL vBrush_editBrush_Op(editBrush *us, int op);

//////// finding the "current brush"
// tells you if the given brush is in the current group
EXTERN BOOL vBrush_inCurGroup(editBrush *us);
// editBrush get gets you the virtual or normal editBrush for real ops
EXTERN editBrush *vBrush_editBrush_Get(void);
// GetSel gets you the current singular selection, for things like face selection?
EXTERN editBrush *vBrush_GetSel(void);

#define VIRTUAL_BRUSH_ID (-1)
// used by UndoRedo when the changed brush is really the vbrush
// you give it old_br, it makes old last_Br, returns vbrush current to stuff
EXTERN editBrush *vBrush_UndoVBrush(editBrush *old_br);

///////// doing things with the "current brush"
// delete or clone cur brush, vBrush aware
EXTERN void vBrush_DeletePtr(editBrush *toast);
EXTERN void vBrush_CloneCur(void);
EXTERN void vBrush_NewBrush(editBrush *new_br);
// selection/cycle
EXTERN void vBrush_SelectBrush(editBrush *sel);
EXTERN BOOL vBrush_cycle(int dir);
#define vBrush_getToCurGroup() vBrush_cycle(1)
// fancy setup for clicks
EXTERN void vBrush_click(editBrush *us, int flags, int x, int y);

// should be called whenever you initiate a brush focus switch behind the scenes
EXTERN void we_switched_brush_focus(void);

// time hacking craziness?
EXTERN void vBrush_go_EOT(void);

// go to the group of this groupid
EXTERN BOOL vBrush_GoToGroup(int group_id);

///////// actual thing to call a lot, as it were
// frame callback - complete means we are "done", false is for modalui/drag sort of stuff
EXTERN void vBrush_FrameCallback(void/*BOOL Complete*/);

// you can set this if you want changes, but there is only one of them for now
// of course, it should really be an array of callback or something
EXTERN void (*vBrush_Change_Callback)(editBrush *brush);

// this runs the op on the current vBrush group, or all brushes if run_all is TRUE
EXTERN void vBrush_GroupOp(BOOL run_all, void (*br_op)(editBrush *us));

// silly global meaning "dont update things with focus callbacks"
// mostly (only, as of now) used to disable GFH update during level load
EXTERN BOOL vBrush_DontUpdateFocus;
#endif  // __VBRUSH_H
// $Header: r:/t2repos/thief2/src/editor/vbr_math.c,v 1.9 2000/02/19 13:13:43 toml Exp $
// math ops for virtual brush manipulation fun (tm)

#include <lg.h>
#include <matrix.h>
#include <matrixd.h>
#include <mxcvrt.h>
#include <mprintf.h>
#include <math.h>

#include <editbr.h>
#include <editbr_.h>
#include <brinfo.h>
#include <brrend.h>
#include <brquery.h>
#include <primal.h>

#include <vbrush.h>
#include <vbr_math.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// control parameters for brush motion
bool vBrush_relative_motion=FALSE;
bool vBrush_axial_scale=FALSE;

/////////////
// utility/setup stuff

#ifdef VEC_MPRINT
// print a matrix for debugging for now
static void br_prn_mat(mxs_matrix *m)
{
   char buf[128];
   int i;
   for (i=0; i<3; i++)
   {
      sprintf(buf," %4.6f %4.6f %4.6f\n",m->el[i],m->el[i+3],m->el[i+6]);
      mprintf(buf);
   }
}

static void br_prn_vec(mxs_vector *v)
{
   char buf[128];   
   sprintf(buf," %4.6f %4.6f %4.6f",v->el[0],v->el[1],v->el[2]);
   mprintf(buf);
}

// print a matrix for debugging for now
static void br_prn_mat_d(mxds_matrix *m)
{
   char buf[128];
   int i;
   for (i=0; i<3; i++)
   {
      sprintf(buf," %4.12lf %4.12lf %4.12lf\n",m->el[i],m->el[i+3],m->el[i+6]);
      mprintf(buf);
   }
}

static void br_prn_vec_d(mxds_vector *v)
{
   char buf[128];   
   sprintf(buf," %4.12lf %4.12lf %4.12lf",v->el[0],v->el[1],v->el[2]);
   mprintf(buf);
}
#endif

// would be cool if FacePts could get pulled out of here
// finds an origin for (us),
//   someday may filter ang_in if necessary (ie. an edge) (ang can be NULL)
//   returns TRUE if a complex edge thing, else FALSE if only focused on brush as whole
BOOL find_brush_origin(editBrush *us, mxs_vector *origin, mxs_angvec *ang_in)
{
   mxs_vector *pvec, sum_vec;
   int i, *pt_list, pt_val, pt_cnt=0;
   
   if ((brSelect_Flag(us)&brSelect_COMPLEX)||(us->cur_face!=-1))
   {
      pvec=brushBuildSolo(us);
      if (brSelect_Flag(us)&brSelect_COMPLEX)
         if (brSelect_Flag(us)&brSelect_EDGE)
         {
            pt_list=primalBr_EdgePts(us->primal_id,brSelect_Edge(us));
            pt_cnt=2;
         }
         else
         {
            pt_val=brSelect_Point(us);
            pt_list=&pt_val;
            pt_cnt=1;
         }
      else // since we know cur_face!=-1, we can just use the face
         pt_list=primalBr_FacePts(us->primal_id,us->cur_face,&pt_cnt);
      if (pt_cnt&&pt_list)
      {  // now go through and find the median point of all the points in the list
         mx_zero_vec(&sum_vec);
         for (i=0; i<pt_cnt; i++)
            mx_addeq_vec(&sum_vec,&pvec[pt_list[i]]);
         mx_scale_vec(origin,&sum_vec,(float)(1.0/pt_cnt));
         return TRUE;  // we have done it, long live us, so on
      }
   }
   mx_copy_vec(origin,&us->pos);
   return FALSE;
}

// we have no ways of doing stuff with angvecs, so here are some things
BOOL sub_angvecs(mxs_angvec *targ, mxs_angvec *v1, mxs_angvec *v2)
{
   targ->el[0]=v1->el[0]-v2->el[0];
   targ->el[1]=v1->el[1]-v2->el[1];
   targ->el[2]=v1->el[2]-v2->el[2];
   return targ->el[0]|targ->el[1]|targ->el[2];
}

#ifdef NEEDED
static void invert_angvec(mxs_angvec *vec, mxs_angvec *invvec)
{
   invvec->el[0]=-vec->el[0];
   invvec->el[1]=-vec->el[1];
   invvec->el[2]=-vec->el[2];
}
#endif

#define ANG_EPSILON (0.00001)
static BOOL sub_double_ang_vectors(mxds_vector *targ, mxds_vector *a1, mxds_vector *a2)
{
   mxd_sub_vec(targ,a1,a2);
   return (fabs(targ->el[0])>ANG_EPSILON)||(fabs(targ->el[1])>ANG_EPSILON)||(fabs(targ->el[2])>ANG_EPSILON);
}

/////// TRANSLATION
mxs_vector *br_trans_vec;
void br_translate_setup(mxs_vector *raw_vec)
{
   mxs_vector tmp;
   if (vBrush_relative_motion)
   {
      mxs_matrix rot;
      mx_ang2mat(&rot,&vBrush_GetSel()->ang);
      mx_mat_mul_vec(&tmp,&rot,raw_vec);
      mx_copy_vec(raw_vec,&tmp);
   }
   br_trans_vec=raw_vec;
}

void br_translate(editBrush *us)
{
   mx_addeq_vec(&us->pos,br_trans_vec);
}

/////// SCALING
#define MIN_SCALE (0.1)
#define MIN_DENOM (0.01)
BOOL compute_scale_fac(mxs_vector *scale, mxs_vector *old_v, mxs_vector *new_v)
{
   if ((old_v->el[0]<MIN_DENOM)||(old_v->el[1]<MIN_DENOM)||(old_v->el[2]<MIN_DENOM))
      return FALSE;
   scale->el[0]=new_v->el[0]/old_v->el[0];
   scale->el[1]=new_v->el[1]/old_v->el[1];
   scale->el[2]=new_v->el[2]/old_v->el[2];
   if ((scale->el[0]<MIN_SCALE)||(scale->el[1]<MIN_SCALE)||(scale->el[2]<MIN_SCALE))
      return FALSE;
   return TRUE;
}

static mxs_vector   scale_origin;    // where in worldspace do we start from?
static mxds_vector  source_ang;      // this is just used for comparing if we match?

static mxs_vector  *scale_local;
static mxds_matrix  scale_xform_mat;
void br_scale_setup(mxs_vector *raw_vec)
{
   editBrush *master=vBrush_GetSel();
   mxds_matrix rot_in;
   mxds_vector scale_d;

   mx_vec_d_from_s(&scale_d,raw_vec);
   primalQuantizeAng(&master->ang,&source_ang);
   mxd_rad2mat(&scale_xform_mat,&source_ang);  // this is L-1, from brush to world, really
   mxd_trans_mat(&rot_in,&scale_xform_mat);    // so this is L, from world offset to brush offset
   mxd_mat_eltmuleq_vec(&rot_in,&scale_d);     // this is ISL, scaled world offset in brush space
   mxd_muleq_mat(&scale_xform_mat,&rot_in);    // and now back to world space, L(-1)ISL
   scale_local=raw_vec;                        // in brush space scale facs, for sz if we can
   find_brush_origin(master,&scale_origin,&master->ang); // hey, we need the origin, eh?
}

// actually go do the scale
void br_scale(editBrush *us)
{
   mxs_vector  offset_s,xform_offset_s;
   mxds_vector offset,xform_offset;
   BOOL        do_scale=vBrush_axial_scale;

   // we take the offset vector, multiply it by L(-1)ISL, add new offset back to origin
   mx_sub_vec(&offset_s,&us->pos,&scale_origin); // get offset of brush from source of scale_d
   mx_vec_d_from_s(&offset,&offset_s);
   mxd_mat_mul_vec(&xform_offset,&scale_xform_mat,&offset); // compute new offset
   mx_vec_s_from_d(&xform_offset_s,&xform_offset);
   mx_add_vec(&us->pos,&scale_origin,&xform_offset_s); // move the brush to there

   if (!do_scale)     
   {  // not scaling for sure, so check if we are same angle as source brush
      mxds_vector br_ang, diff_ang;
      primalQuantizeAng(&us->ang,&br_ang);    // are we at the same angle?
      do_scale=!sub_double_ang_vectors(&diff_ang,&source_ang,&br_ang);
   }
   if (do_scale)       //   we take the size of brush times brush space scale vec (per-element)   
      mx_elmuleq_vec(&us->sz,scale_local);
}

/////// ROTATION

static mxds_matrix rot_base;     // out is from brush to axial, back is back
static mxs_vector  rot_origin;

BOOL ang_quantize_and_sub(mxds_vector *diff, mxs_angvec *v1, mxs_angvec *v2)
{
   mxds_vector a1, a2;
   primalQuantizeAng(v1,&a1);
   primalQuantizeAng(v2,&a2);
   return sub_double_ang_vectors(diff,&a1,&a2);
}

void br_rotate_setup(mxs_angvec *rot)
{
   editBrush *master=vBrush_GetSel();
   mxds_matrix lmat, rmat;
   
   primalQuantizeAng(&master->ang,&source_ang);
   find_brush_origin(master,&rot_origin,&master->ang);
   if (vBrush_relative_motion)
   {
      mxd_rad2mat(&lmat,&source_ang);   // L is axial to master brush
      mxd_ang2mat(&rmat,rot);           // R is the rotation of the object
      mxd_muleq_mat(&rmat,&lmat);       // so this is RL
      mxd_trans_mat(&rot_base,&lmat);   // this is L(-1), since L is orthonormal
      mxd_muleq_mat(&rot_base,&rmat);   // and here is L(-1)RL
   }
   else
      mxd_ang2mat(&rot_base,rot);       // if non relative, just build axial rot matrix
}

void br_rotate_rad_setup(mxds_vector *real_rot)
{
   editBrush *master=vBrush_GetSel();
   mxds_matrix lmat, rmat;

   primalQuantizeAng(&master->ang,&source_ang);
   find_brush_origin(master,&rot_origin,&master->ang);
   if (vBrush_relative_motion)
   {
      mxd_rad2mat(&lmat,&source_ang);   // L is axial to master brush
      mxd_rad2mat(&rmat,real_rot);      // R is the rotation of the object
      mxd_muleq_mat(&rmat,&lmat);       // so this is RL
      mxd_trans_mat(&rot_base,&lmat);   // this is L(-1), since L is orthonormal
      mxd_muleq_mat(&rot_base,&rmat);   // and here is L(-1)RL
   }
   else
      mxd_rad2mat(&rot_base,real_rot);  // if non relative, just build axial rot matrix
}

void br_rotate(editBrush *us)
{
   mxs_vector  offset_s, xform_offset_s;
   mxds_vector offset, xform_offset;   
   mxds_vector br_ang, br_inv_ang;
   mxds_matrix tmp, tmp2;

   primalQuantizeAng(&us->ang,&br_ang);
   mxd_neg_vec(&br_inv_ang,&br_ang);
   mxd_rad2mat(&tmp2,&br_ang);         // U: this goes from brush to axial space
   mxd_mul_mat(&tmp,&rot_base,&tmp2);   // now we are L(-1)RLU
   mxd_mat2ang(&us->ang,&tmp);
   mxd_mat2rad(&br_ang,&tmp);   

   // we take the offset vector, multiply it by L(-1)RL, add new offset back to origin
   mx_sub_vec(&offset_s,&us->pos,&rot_origin);         // offset of brush from origin
   mx_vec_d_from_s(&offset,&offset_s);   
   mxd_mat_mul_vec(&xform_offset,&rot_base,&offset);  // compute new offset
   mx_vec_s_from_d(&xform_offset_s,&xform_offset);   
   mx_add_vec(&us->pos,&rot_origin,&xform_offset_s);   // move the brush to there
}

////////////////////
// horrible "back and store" of vector fields

typedef struct {
   short      br_id;  // 2
   mxs_angvec ang;    // +6=8
   mxs_vector pos;    // +12=20
   mxs_vector sz;     // +12=32
} brushVecs;

static brushVecs *curVecData    = NULL;
static int        curVecCnt     = 0;
static int        curVecAlloced = 0;

#define ALLOC_CHUNK 64

static BOOL store_vec(editBrush *us)
{
   if (curVecCnt>=curVecAlloced)
   {  // get more memory
      curVecAlloced+=ALLOC_CHUNK;
      if (curVecAlloced==ALLOC_CHUNK)  // first one
         curVecData=(brushVecs *)Malloc(curVecAlloced*sizeof(brushVecs));
      else
         curVecData=(brushVecs *)Realloc(curVecData,curVecAlloced*sizeof(brushVecs));
   }
   curVecData[curVecCnt].br_id = us->br_id;
   curVecData[curVecCnt].ang   = us->ang;
   curVecData[curVecCnt].pos   = us->pos;
   curVecData[curVecCnt].sz    = us->sz;
   curVecCnt++;
   return TRUE;
}

BOOL store_BrushVecs(void)
{
   curVecCnt=0;
   if (brFilter(vBrush_inCurGroup,store_vec)!=curVecCnt)
      Warning(("Huh?!? odd vec store craziness\n"));
   return curVecCnt>0;
}

void clear_BrushVecs(void)
{
   if (curVecAlloced)
      Free(curVecData);
   curVecAlloced=0;
   curVecData=NULL;
}

void restore_BrushVecs(int which)
{
   int i;
   
   for (i=0; i<curVecCnt; i++)
   {
      brushVecs *vec_data=&curVecData[i];
      editBrush *us=brFind(vec_data->br_id);
      if (us==NULL)
         Warning(("Missing brush in restore_BrushVecs\n"));
      else
      {
         if (which&brVec_ANG) us->ang=vec_data->ang;
         if (which&brVec_POS) us->pos=vec_data->pos;
         if (which&brVec_SZ)  us->sz =vec_data->sz;
      }
   }
}
// $Header: r:/t2repos/thief2/src/editor/viewmgr.c,v 1.62 2000/02/19 13:13:51 toml Exp $

// View management system

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <lg.h>
#include <2d.h>
#include <r3d.h>
#include <mprintf.h>

#include <portal.h>
#include <pt.h>

#include <command.h>
#include <editbr.h>
#include <ged_csg.h>   // level valid extern
#include <ged_rend.h>
#include <viewmgr_.h>
#include <viewmgr.h>
#include <vumanui.h>
#include <vmwincfg.h>
#include <brinfo.h>
#include <brrend.h>
#include <linkdraw.h>
#include <uiedit.h>

#include <gridsnap.h>
#include <rand.h>
#include <wrlimit.h>

#include <status.h>

#include <config.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


EXTERN void AIPathFindDrawDB(); // from aipthdbg

void vm_set_synch(int r, bool flag);

//////////////////////////////
//
// partial update
//

static BOOL redraw, new_select, new_camera, new_render;
static bool vmRenderAlways=FALSE;  // needs to be bool for TOGGLE_BOOL in command

#define REDRAW_ALL()   redraw
#define REDRAW(c)      REDRAW_ALL()

#define UPDATE_CAMERA(c) (redraw = TRUE)
#define NEW_CAMERA(c)    (new_camera = TRUE)

void vm_redraw(void)
{
   redraw=TRUE;
}

// this is ugly, but we need the speed, sorry
void vm_redraw_from_select(void)
{
   new_select=TRUE;
}

void vm_redraw_from_camera(void)
{
   new_camera=TRUE;
}

void vm_redraw_from_new3d(void)
{
   new_render=TRUE;
}

////////////////////////////////////////////////////////////
//
//  screen area management (independent of UI)
//
//  Ok, Mahk and I haggled about this a bit, so we're
//  saving it until I have some more context to work in.

uchar camera_to_region_mapping[MAX_CAMERAS]=
{
   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
};

uchar region_to_camera_mapping[MAX_CAMERAS]=
{
   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
};

int vm_avail_regions = 0xf; // bitmask of allowed regions
int vm_cur_region, vm_cur_camera;
bool vm_xmouse;

void vm_set_cur_region(int n)
{
   vm_cur_region = n;
   vm_cur_camera = region_to_camera_mapping[n];
}

int vm_get_cur_region(void)
{
   return vm_cur_region;
}

void vm_cycle_camera(bool up)
{
   if (!vm_avail_regions) return;

   for(;;) {
      if (up) { if (++vm_cur_region >= MAX_CAMERAS) vm_cur_region=0; }
      else { if (--vm_cur_region < 0) vm_cur_region = MAX_CAMERAS-1; }

      if (vm_avail_regions & (1 << vm_cur_region))
         break;
   }

   // Need to call UPDATE_CAMERA; otherwise the frame to indicate
   // the current camera won't be redrawn.
   UPDATE_CAMERA(vm_cur_camera);
   vm_cur_camera = region_to_camera_mapping[vm_cur_region];
   UPDATE_CAMERA(vm_cur_camera);
}

// Need to call UPDATE_CAMERA; otherwise the frame to indicate
// the current camera won't be redrawn.
void vm_set_cur_camera(int n)
{
   UPDATE_CAMERA(vm_cur_camera);
   vm_cur_camera = n;
   vm_cur_region = camera_to_region_mapping[n];
   UPDATE_CAMERA(vm_cur_camera);
}

int vm_current_camera(void)
{
   return vm_cur_camera;
}

void vm_disable_region(int r)
{
   if (vm_avail_regions & (1 << r)) {
      vm_avail_regions ^= (1 << r);
      if (!VIS_CAM(vm_cur_camera)) vm_cycle_camera(TRUE);
   } else
      Warning(("vm_disable_region: tried to disable disabled region.\n"));
}

void vm_enable_region(int r)
{
   if (!(vm_avail_regions & (1 << r))) {
      vm_avail_regions ^= (1 << r);
      if (!VIS_CAM(vm_cur_camera)) vm_cycle_camera(TRUE);
   } else
      Warning(("vm_enable_region: tried to enable enabled region.\n"));
}

void vm_enable_all_regions(void)
{
   vm_avail_regions = 0xf;

   if (!VIS_CAM(vm_cur_camera)) vm_cycle_camera(TRUE);
}

void vm_swap_cameras(int x, int y)
{
   int rx,ry;

   rx = camera_to_region_mapping[x];
   ry = camera_to_region_mapping[y];

   camera_to_region_mapping[x] = ry;
   camera_to_region_mapping[y] = rx;

   region_to_camera_mapping[rx] = y;
   region_to_camera_mapping[ry] = x;

   vm_cur_camera = camera_to_region_mapping[vm_cur_region];
}


////////////////////////////////////////////////////////////
//
//  managing camera contexts
//

//
// render mode management
//

#define RM_WIREFRAME_BRUSHES 1
#define RM_SOLID_PORTAL 2
#define RM_WIREFRAME_CURRENT 4
#define RM_WIREFRAME_PORTAL 8

static uchar cycle_mode(uchar x)
{
   uchar y;

   if (x == RM_WIREFRAME_PORTAL)
      return RM_WIREFRAME_BRUSHES;

   y = x & RM_WIREFRAME_PORTAL;
   x &= ~RM_WIREFRAME_PORTAL;

     // guess what the "primary" mode
     // is, and go to the next one

   switch(x) {
      case RM_WIREFRAME_BRUSHES:
         return RM_SOLID_PORTAL | y;
      case RM_SOLID_PORTAL:
         return RM_SOLID_PORTAL | RM_WIREFRAME_CURRENT | y;
      case RM_SOLID_PORTAL | RM_WIREFRAME_CURRENT:
         return RM_SOLID_PORTAL | RM_WIREFRAME_BRUSHES | y;
      case RM_SOLID_PORTAL | RM_WIREFRAME_BRUSHES:
         return RM_WIREFRAME_BRUSHES | y;

      // other cases shouldn't happen
   }
   return RM_WIREFRAME_BRUSHES | y;
}

static uchar fix_mode(uchar x, uchar old)
{
   // have to have something
   if (!x) return RM_WIREFRAME_BRUSHES;

   if ((x & RM_WIREFRAME_BRUSHES) && (x & RM_WIREFRAME_CURRENT)) {
      // have to clear one.  wonder which one you just changed!
      if (old & RM_WIREFRAME_BRUSHES) {
         x &= ~RM_WIREFRAME_BRUSHES;
      } else if (old & RM_WIREFRAME_CURRENT) {
         x &= ~RM_WIREFRAME_CURRENT;
      } else {
         x &= ~RM_WIREFRAME_CURRENT;
      }
   }

   if (x == RM_WIREFRAME_CURRENT)
      return RM_WIREFRAME_BRUSHES;

   return x;
}

//
//  axis definitions for axis-aligned cameras
//
//
// 0 = top-down
// 1 = front
// 2 = side (from right)
// 3 = bottom-up
// 4 = back
// 5 = side (from left)

static char *axis_names[]={"top","front","right","bottom","back","left"};

static mxs_vector screen_x[6] =
{
   { 0, 1, 0 },
   { 0, 1, 0 },
   {-1, 0, 0 },
   { 0, 1, 0 },
   { 0,-1, 0 },
   { 1, 0, 0 }
};

static mxs_vector screen_y[6] =
{
   { 1,0,0 },
   { 0,0,-1 },
   { 0,0,-1 },
   { -1,0,0 },
   { 0,0,-1 },
   { 0,0,-1 }
};

  // which axis the view is along
static int bogus_axis[6] = { 2,0,1,2,0,1 };
static int x_axis[6] = { 1,1,0,1,1,0 };
static int y_axis[6] = { 0,2,2,0,2,2 };
static int normal_axis[6] = { 2,0,1,5,3,4 };

static mxs_angvec axis_angles[6] =
{
   { 0, 0x4000, 0x8000 },
   { 0, 0, 0x8000 },
   { 0, 0, 0xc000 },
   { 0, 0xc000, 0 },
   { 0, 0, 0 },
   { 0, 0, 0x4000 }
};

//
// camera structure
//

typedef struct
{
     // are we in 3d or 2d mode?
   bool camera_3d;
   uchar render_mode;

     // 3d state
   Location loc;
   mxs_angvec ang;
   mxs_real  zoom;
   bool perspective;

     // 2d state
   Location loc_2d;
   mxs_real scale;
   int axis;    // axis we're looking along
   bool synch;  // do we just follow the 1st 3d view?
} CameraView;

static CameraView camera[MAX_CAMERAS];

#define zero_ang(a) ((a).tx = 0, (a).ty = 0, (a).tz = 0)
#define zero_loc(a) MakeLocation(&(a), 0,0,0)

#define CM camera[c]
void vm_init_camera(int c)
{
   static int view_axis[4] = { 0,0,2,1 };
   UPDATE_CAMERA(c);
   switch (c) {
      case 0:
         CM.camera_3d = TRUE;
         CM.render_mode = 1;
         zero_loc(CM.loc);
         zero_ang(CM.ang);
         CM.zoom = 1.0;
         CM.perspective = TRUE;

         zero_loc(CM.loc_2d);
         CM.scale = 64.0;
         CM.axis = 0;
         CM.synch = FALSE;
         break;

      case 1: case 2: case 3:
         CM.camera_3d = FALSE;
         CM.render_mode = 1;
         zero_loc(CM.loc);
         zero_ang(CM.ang);
         CM.zoom = 1.0;
         CM.perspective = TRUE;

         zero_loc(CM.loc_2d);
         CM.scale = 64.0;
         CM.axis = view_axis[c];
         CM.synch = TRUE;
         break;
    }
}
#undef CM

float vm_get_effective_region_scale(int c)
{
   int r = camera_to_region_mapping[c];
   return camera[c].scale * vmGetSizeRatio(r,NULL,NULL);
}

void vm_init_cameras(void)
{
   int i;
   for (i=0; i < MAX_CAMERAS_REAL; ++i)
      vm_init_camera(i);
}

static int synch_camera(void)
{
   int i;
   for (i=0; i < MAX_CAMERAS; ++i)
      if (camera[i].camera_3d && VIS_CAM(i))
         return i;
   return -1;
}

static int real_camera(int r)
{
   int n;
   if (camera[r].camera_3d || !camera[r].synch)
      return r;
   n = synch_camera();
   return n == -1 ? r : n;
}

bool vm_spotlight_loc(mxs_vector **loc, mxs_angvec **ang)
{
   int n = synch_camera();
   if (n == -1)
      return FALSE;

   *loc = &camera[n].loc.vec;
   *ang = &camera[n].ang;
   return TRUE;
}

#define mmax(x,y)  ((x) < (y) ? (y) : (x))

  // fit all the cameras to the current region, even cameras
  // that aren't currently exposed, but only 2d cameras
void vm_fit_cameras_to_region(mxs_vector *start, mxs_vector *end)
{
   mxs_vector center;
   mxs_vector length;
   int i, rc;

   mx_scale_vec(&center, start, 0.5);
   mx_scale_addeq_vec(&center, end, 0.5);

   mx_sub_vec(&length, start, end);
   length.x = fabs(length.x);
   length.y = fabs(length.y);
   length.z = fabs(length.z);

   for (i=0; i < MAX_CAMERAS; ++i)
      if (!camera[i].camera_3d && camera[i].synch)
         break;

   if (i < MAX_CAMERAS) {
      rc = synch_camera();
      if (rc >= 0)
         MakeLocationFromVector(&camera[rc].loc, &center);
   }

   for (i=0; i < MAX_CAMERAS; ++i)
      if (!camera[i].camera_3d)
      {
         int a = camera[i].axis;
         int x = x_axis[a], y = y_axis[a];
         float xsc,ysc;

         UPDATE_CAMERA(i);

         MakeLocationFromVector(&camera[i].loc, &center);

         // ok, I don't know why 5/3, I think that's approximately
         // the screen size ratio of x & y default window sizes;
         // yet it doesn't account for aspect ratio.  Huh.  The 1.2
         // is there to give a bit of a boundary; maybe it's effectively
         // giving some boundary in x, and doing aspect ratio in y.
         if (vmGetSizeRatio(camera_to_region_mapping[i],&xsc,&ysc))
            camera[i].scale=mmax(length.el[x]/xsc,length.el[y]*5/3/ysc)*1.2;
      }
}

  // get location of current view
mxs_vector *vm_cur_loc(void)
{
   int n = real_camera(vm_cur_camera);
   if (camera[n].camera_3d)
      return &camera[n].loc.vec;
   else
      return &camera[n].loc_2d.vec;
}

void vm_cur_loc_set(mxs_vector *loc)
{
   int n = real_camera(vm_cur_camera);
   UPDATE_CAMERA(n);
   if (camera[n].camera_3d)
      MakeLocationFromVector(&camera[n].loc, loc);
   else
      MakeLocationFromVector(&camera[n].loc_2d, loc);
}

bool vm_cur_3d(void)
{
   return camera[vm_cur_camera].camera_3d;
}

static int vm_get_3d_camera_to_use(void)
{
   int camera_to_use=vm_cur_camera, i;
   if (!camera[camera_to_use].camera_3d)
      for (i=0; i<MAX_CAMERAS_REAL; i++)
         if (i!=vm_cur_camera)
            if (camera[i].camera_3d)
               camera_to_use=i;
   return camera_to_use;
}

void vm_cur_slew(mxs_vector *slew)
{
   int camera_to_use=vm_get_3d_camera_to_use();
   if (camera[camera_to_use].camera_3d)
   {
      NEW_CAMERA(camera_to_use);
      r3_start_frame();
      r3_set_view_angles(&camera[camera_to_use].loc.vec,&camera[camera_to_use].ang,R3_DEFANG);
      mx_scale_addeq_vec(&camera[camera_to_use].loc.vec, r3_get_forward_slew(), slew->x);
      mx_scale_addeq_vec(&camera[camera_to_use].loc.vec, r3_get_left_slew(), slew->y);
      mx_scale_addeq_vec(&camera[camera_to_use].loc.vec, r3_get_up_slew(), slew->z);
      UpdateChangedLocation(&camera[camera_to_use].loc);
      r3_end_frame();
   } else {
      Warning(("vm_cur_slew: tried slewing 2d camera - no 3d cameras avialable\n"));
   }
}

void vm_cur_scroll(mxs_real x, mxs_real y)
{
   if (camera[vm_cur_camera].camera_3d) {
      Warning(("vm_cur_scroll: tried to scroll a 3d camera.\n"));
   } else {
      int a = camera[vm_cur_camera].axis, n = vm_cur_camera;
      // auto unsynch
      UPDATE_CAMERA(n);
      if (camera[n].synch)
         vm_set_synch(n, FALSE);
      mx_scale_addeq_vec(&camera[n].loc_2d.vec, &screen_x[a], x);
      mx_scale_addeq_vec(&camera[n].loc_2d.vec, &screen_y[a], y);
      UpdateChangedLocation(&camera[n].loc_2d);
   }
}

void vm_cur_rotate(mxs_angvec *rot)
{
   int camera_to_use=vm_get_3d_camera_to_use();
   if (camera[camera_to_use].camera_3d) {
      NEW_CAMERA(camera_to_use);
      camera[camera_to_use].ang.tx += rot->tx;
      camera[camera_to_use].ang.ty += rot->ty;
      camera[camera_to_use].ang.tz += rot->tz;
   } else {
      Warning(("vm_cur_rotate: tried rotating 2d camera - no 3d cameras available\n"));
   }
}

void vm_cur_level (int axis)
{
   if (!camera[vm_cur_camera].camera_3d)
   {
      Warning (("vm_cur_level: tried to level a 2d camera.\n"));
      return;
   }

   if (axis < 0 || axis > 2)
   {
      Warning (("vm_cur_level: illegal axis %d, must be between 0 and 2\n"));
      return;
   }

   UPDATE_CAMERA(vm_cur_camera);
   camera[vm_cur_camera].ang.el[axis] = 0;
}

void vm_cur_scale(mxs_real scale)
{
   if (camera[vm_cur_camera].camera_3d)
      Warning(("vm_cur_scale: tried to rescale a 3d camera.\n"));
   else {
      UPDATE_CAMERA(vm_cur_camera);
      if (vm_menu_inprog)
      {
         mxs_vector temp, *loc;
         int a = vm_map_screen_to_world(vm_cur_camera, &temp, vm_menu_click_x, vm_menu_click_y);
         camera[vm_cur_camera].synch=FALSE;
         loc=vm_cur_loc();
         loc->el[(a+1)%3] = temp.el[(a+1)%3];
         loc->el[(a+2)%3] = temp.el[(a+2)%3];
      }
      camera[vm_cur_camera].scale *= scale;
   }
}

void vm_cur_cycle_mode(void)
{
   UPDATE_CAMERA(vm_cur_camera);
   camera[vm_cur_camera].render_mode = cycle_mode(camera[vm_cur_camera].render_mode);
}

void vm_cur_set_mode(int n)
{
   UPDATE_CAMERA(vm_cur_camera);
   camera[vm_cur_camera].render_mode = fix_mode((uchar)n, camera[vm_cur_camera].render_mode);
}

void vm_cur_toggle_mode(uchar toggle)
{
   UPDATE_CAMERA(vm_cur_camera);
   camera[vm_cur_camera].render_mode = fix_mode((uchar)(camera[vm_cur_camera].render_mode ^ toggle), camera[vm_cur_camera].render_mode);
}

void vm_cur_toggle_3d(void)
{
   UPDATE_CAMERA(vm_cur_camera);
   camera[vm_cur_camera].camera_3d = !camera[vm_cur_camera].camera_3d;
}

void vm_cur_toggle_persp(void)
{
   UPDATE_CAMERA(vm_cur_camera);
   if (camera[vm_cur_camera].camera_3d)
      camera[vm_cur_camera].perspective = !camera[vm_cur_camera].perspective;
   else
      Warning(("vm_cur_toggle_persp: tried to toggle perspective in 2d view.\n"));
}

void vm_cur_toggle_synch(void)
{
   UPDATE_CAMERA(vm_cur_camera);
   if (camera[vm_cur_camera].camera_3d)
      Warning(("vm_cur_toggle_synch: tried to toggle synch mode on a 3d view.\n"));
   else
      vm_set_synch(vm_cur_camera, (bool)(!camera[vm_cur_camera].synch));
}

void vm_set_synch_all(bool mode)
{
   int i;
   redraw = TRUE;
   for (i=0; i < MAX_CAMERAS; ++i)
      vm_set_synch(i, mode);
}

void vm_scale_all(mxs_real scale)
{
   int i;
   redraw = TRUE;
   for (i=0; i < MAX_CAMERAS; ++i)
      camera[i].scale *= scale;
}


////////////////////////////////////////////////////////////
//
//  rendering the cameras
//

static Location *cur_loc;
static mxs_angvec *cur_ang;

void vm_start_3d(int c)
{
   int rc = real_camera(c);

   r3_start_frame();
   if (camera[c].camera_3d) {
      cur_loc = &camera[c].loc;
      cur_ang = &camera[c].ang;

      r3_set_view_angles(&cur_loc->vec, cur_ang,R3_DEFANG);
      if (camera[c].perspective)
      {  // hmmm.. try project space?
//         r3_set_space(R3_CLIPPING_SPACE);
         r3_set_space(R3_PROJECT_SPACE);
      }
      else
      {
         r3_set_space(R3_LINEAR_SPACE);
         r3_set_linear_screen_width(16.0);  // why 16?
      }
   } else {
      cur_loc = camera[rc].camera_3d ? &camera[rc].loc : &camera[rc].loc_2d;
      cur_ang = &axis_angles[camera[c].axis];
      r3_set_view_angles(&cur_loc->vec, cur_ang, R3_DEFANG);
      r3_set_space(R3_LINEAR_SPACE);
      r3_set_linear_screen_width(vm_get_effective_region_scale(c));
   }
}

void vm_get_3d_camera_loc(mxs_vector **pos, mxs_angvec **ang)
{
   if (pos) *pos=&cur_loc->vec;
   if (ang) *ang=cur_ang;
}

// fills in x and y, returns bogus axis
int vm_get_camera_axis(int c, int *x, int *y)
{
   if (x) *x=x_axis[camera[c].axis];
   if (y) *y=y_axis[camera[c].axis];
   return bogus_axis[camera[c].axis];
}

#pragma off(unreferenced)
void vm_end_3d(int c)
{
   r3_end_frame();
}
#pragma on(unreferenced)

  // map point in camera c's (x,y) coordinates
  // to an output location, returning which axis
  // number is bogus; -1 means it's not a 2d camera

int vm_map_screen_to_world(int c, mxs_vector *dest, int x, int y)
{
   int reg = camera_to_region_mapping[c];
   Region* uireg = vmGetRegion(reg);
   int rc, a;
   mxs_real sx,sy,scale;
   int xsz = RectWidth(uireg->r);
   int ysz = RectHeight(uireg->r);

   if (camera[c].camera_3d) return -1;

   sx = x / (float) xsz - 0.5;
   sy = (y - ysz/2) / (float) xsz;

   rc = real_camera(c);
   if (c == rc)
      *dest = camera[rc].loc_2d.vec;
   else
      *dest = camera[rc].loc.vec;

   a = camera[c].axis;
   scale=vm_get_effective_region_scale(c);  // was camera[c].scale
   mx_scale_addeq_vec(dest, &screen_x[a], sx * scale);
   mx_scale_addeq_vec(dest, &screen_y[a], sy * scale);

   return bogus_axis[a];
}

BOOL vm_camera_scr_size(int c, int *w, int *h)
{
   int reg = camera_to_region_mapping[c];
   Region* uireg = vmGetRegion(reg);

   *w = RectWidth(uireg->r);
   *h = RectHeight(uireg->r);
   return TRUE;
}

int vm_normal_axis(int c)
{
   if (camera[c].camera_3d) return -1;
   return normal_axis[camera[c].axis];
}

bool vm_screen_axes(int c, mxs_vector *x, mxs_vector *y)
{
   int a, reg = camera_to_region_mapping[c];
   Region *uireg = vmGetRegion(reg);
   mxs_real scale;

   int xsz = RectWidth(uireg->r);
   //int ysz = RectHeight(uireg->r);

   mxs_real sx,sy;

   if (camera[c].camera_3d) return FALSE;

   sx = 1 / (float) xsz;
   sy = 1 / (float) xsz;

   a = camera[c].axis;

   scale=vm_get_effective_region_scale(c);  // was camera[c].scale
   mx_scale_vec(x, &screen_x[a], sx * scale);
   mx_scale_vec(y, &screen_y[a], sy * scale);

   return TRUE;
}

bool vm_show_grid=TRUE, vm_show_grid_3d=TRUE;
int vm_3d_grid_axis=2;
mxs_real vm_3d_grid_height;
extern Grid cur_global_grid;

int view_grid_color=7, view_select_color=1;

#define GRID_COLOR uiRGB(0x39,0x39,0x39)   // some kinda grey
#define SELECT_COLOR uiRGB(0xba,0xba,0xba) // off-white
void vm_pick_colors(void)
{
   view_grid_color = guiScreenColor(GRID_COLOR);
   view_select_color = guiScreenColor(SELECT_COLOR);
}



static void render_grid(int c)
{
   mxs_vector start,end;
   r3_set_color(view_grid_color);
   if (camera[c].camera_3d) {
      start = end = camera[c].loc.vec;

      start.x -= 20 * cur_global_grid.line_spacing;
      start.y -= 20 * cur_global_grid.line_spacing;
      start.z -= 20 * cur_global_grid.line_spacing;

      end.x += 20 * cur_global_grid.line_spacing;
      end.y += 20 * cur_global_grid.line_spacing;
      end.z += 20 * cur_global_grid.line_spacing;

      gedit_render_grid(&cur_global_grid, vm_3d_grid_axis, vm_3d_grid_height, &start, &end);
   } else {
      int rc = real_camera(c), a = camera[c].axis;
      mxs_real x_scale, y_scale;

      vmGetSizeRatio(camera_to_region_mapping[c],&x_scale,&y_scale);
      x_scale*=camera[c].scale; y_scale*=camera[c].scale;

      if (c == rc)
         start = end = camera[rc].loc_2d.vec;
      else
         start = end = camera[rc].loc.vec;

      start.el[x_axis[a]] -= x_scale/2;  // these were all camera[c].scale
        end.el[x_axis[a]] += x_scale/2;

      start.el[y_axis[a]] -= y_scale/2;
        end.el[y_axis[a]] += y_scale/2;

      gedit_render_grid(&cur_global_grid, bogus_axis[a], 0, &start, &end);
   }
}

void vm_set_camera_canvas(int c)
{
   int reg = camera_to_region_mapping[c];
   vm_set_region_canvas(reg);
}

void vm_unset_camera_canvas(void)
{
   vm_unset_region_canvas();
}

bool vm_display_enable=TRUE, show_raycasts = FALSE;
extern void render_failures(void);

BOOL vm_pick_camera(int c, int x, int y, int *brush, int *face)
{
   BOOL rv=FALSE;
   uchar mode;

   if (!vm_display_enable) return rv;
   if (!VIS_CAM(c)) return rv;

   vm_set_camera_canvas(c);
   mode = camera[c].render_mode;

   if (mode & RM_SOLID_PORTAL)
      if (gedcsg_level_valid)
      {
         extern int *wr_brfaces[MAX_REGIONS];   // this is brush_id*256 + face
         int rc = real_camera(c);
         Position pos;
         int prend_ret;  // this is cell*256 + poly
         int cell, poly;

         pos.loc = *(camera[rc].camera_3d ? &camera[rc].loc : &camera[rc].loc_2d);
         pos.fac = *(camera[c].camera_3d ? &camera[c].ang :
                     &axis_angles[camera[c].axis]);
         prend_ret=PortalRenderPick(&pos,x,y,camera[c].zoom);
         poly=prend_ret&0xff;
         cell=(prend_ret-poly)>>8;
         if (cell!=CELL_INVALID)
         {
            *face=wr_brfaces[cell][poly]&0xff;
            *brush=wr_brfaces[cell][poly]>>8;
            rv=TRUE;
         }
      }
   vm_unset_camera_canvas();
   return rv;
}

// help functions for render_camera
static void _vm_rend_start(int c, BOOL show_grid)
{
   gr_clear(0);
   if (show_grid)
      render_grid(c);
}

static void _vm_rend_message_2line(char *line1, char *line2)
{
   guiStyleSetupFont(NULL,StyleFontNormal);
   gr_set_fcolor(guiStyleGetColor(NULL,StyleColorFG));
   gr_string(line1,
             (grd_canvas->bm.w-gr_string_width(line1))/2,
             (grd_canvas->bm.h/2)-15);
   gr_string(line2,
             (grd_canvas->bm.w-gr_string_width(line2))/2,
             (grd_canvas->bm.h/2)+5);
   guiStyleCleanupFont(NULL,StyleFontNormal);
}

#define CORNER_RIGHT  1
#define CORNER_BOTTOM 2
static int _vm_name_corner=0;
static void _vm_rend_message_corner(int corner_id, char *msg)
{
   int x=1,y=1;
   if (corner_id==-1) return;
   guiStyleSetupFont(NULL,StyleFontNormal);
   gr_set_fcolor(guiStyleGetColor(NULL,StyleColorFG));
   if (corner_id&CORNER_RIGHT)
      x=grd_canvas->bm.w-gr_string_width(msg)-1;
   if (corner_id&CORNER_BOTTOM)
      y=grd_canvas->bm.h-gr_string_height(msg)-1;
   gr_string(msg,x,y);
   guiStyleCleanupFont(NULL,StyleFontNormal);
}

static void _vm_show_camera_in2d(int c)
{
   mxs_vector *locp;
   mxs_angvec *angp;

   if (vm_spotlight_loc (&locp, &angp))       // hmmm, should this one stay the old way?
      gedrendRenderCameraLoc (locp, angp, vm_get_effective_region_scale(c));
}

static grs_bitmap *camera_saves[MAX_CAMERAS_REAL]={NULL,NULL,NULL,NULL};

#ifdef WE_NEVER_CALL_THIS_SHOULD_WE
static void _vm_camera_saves_init(void)
{
   int i;
   for (i=0; i<MAX_CAMERAS_REAL; i++)
      camera_saves[i]=NULL;
}
#endif

static void _vm_camera_saves_term(void)
{
   int i;
   for (i=0; i<MAX_CAMERAS_REAL; i++)
      if (camera_saves[i])
      {
         gr_free(camera_saves[i]);
         camera_saves[i]=NULL;
      }
}

static void _vm_save_camera_bitmap(int c)
{
   BOOL get_new_bm=TRUE;
   if (camera_saves[c]!=NULL)
      if ((camera_saves[c]->w==grd_canvas->bm.w)&&(camera_saves[c]->h==grd_canvas->bm.h))
         get_new_bm=FALSE;
      else
      {
         gr_free(camera_saves[c]);
         camera_saves[c]=NULL;
      }
   if (get_new_bm)
      camera_saves[c]=gr_alloc_bitmap(grd_canvas->bm.type,0,grd_canvas->bm.w,grd_canvas->bm.h);
   gr_get_bitmap(camera_saves[c],0,0);  // get the current canvas to save
}

static void _vm_restore_camera_bitmap(int c)
{
   if (camera_saves[c])
       gr_bitmap(camera_saves[c],0,0);
}

extern void cam_render_scene(Position *pos, double zoom);

static BOOL update_links = TRUE;
// ok, secretly knows there is the "new_camera" and "new_select" subflags of redraw....
void vm_render_camera(int c)
{
   int reg, rv_flag=0;
   BOOL restore_bm=FALSE, show_grid;
   uchar mode;

   if (!vm_display_enable) return;
   if (!VIS_CAM(c)) return;

   if (update_links)
      DrawRelations();

   reg = camera_to_region_mapping[c];
   vm_set_region_canvas(reg);
   vm_start_3d(c);

   mode = camera[c].render_mode;

// New stuff here:
   if (!config_is_defined("Editor_NoInvalidCellCheck"))
   {
      if (camera[c].camera_3d)
      {
         if (CellFromLoc(&camera[c].loc)==CELL_INVALID)
         {
            mode &= ~RM_SOLID_PORTAL;
            mode |= RM_WIREFRAME_BRUSHES;
         }
      }
      else
      {
         if (CellFromLoc(&camera[c].loc_2d)==CELL_INVALID)
         {
            mode &= ~RM_SOLID_PORTAL;
            mode |= RM_WIREFRAME_BRUSHES;
         }
      }
   }

   if (!camera[c].camera_3d)
      rv_flag|=brFlag_IsoView;
   if (mode & RM_WIREFRAME_PORTAL)
      Warning(("vm_render_camera: Wireframe portal view not yet supported.\n"));
   show_grid=camera[c].camera_3d ? vm_show_grid_3d : vm_show_grid;

   if (camera[c].camera_3d)
   {
      BOOL redraw_3d=FALSE;
      if (mode & RM_SOLID_PORTAL)
         if (redraw || new_camera || new_render)
            redraw_3d=TRUE;
      if (mode & RM_WIREFRAME_BRUSHES)
         if (redraw || new_camera)
            redraw_3d=TRUE;
      redraw_3d |= (show_grid && (redraw || new_camera));
      if (redraw_3d)
      {
         _vm_rend_start(c,show_grid);
         if (mode & RM_SOLID_PORTAL)
         {
            if (gedcsg_level_valid)
            {
               int rc = real_camera(c);
               Position pos;
               // we probably could use the r3d frame stack and not bother
               // shutting it down and restarting, but I'm not gonna risk it
               vm_end_3d(c);
               pos.loc = *(camera[rc].camera_3d ? &camera[rc].loc : &camera[rc].loc_2d);
               pos.fac = *(camera[c].camera_3d ? &camera[c].ang : &axis_angles[camera[c].axis]);
               cam_render_scene(&pos, camera[c].zoom);
               vm_start_3d(c);
            }
            else
               _vm_rend_message_2line("Current Portalization","Out of date");
         }

         if (mode & RM_WIREFRAME_BRUSHES)
            gedrendRenderView(rv_flag, c);

         if (show_raycasts)
            render_failures();   // ????????

         if (_vm_name_corner!=-1)
            _vm_rend_message_corner(CORNER_RIGHT|CORNER_BOTTOM,"3d View");
      }
      else restore_bm=TRUE;
   }
   else
   {  // this is the 2d camera case, which neither camera nor select influences
      // how do we deal with it if the camera moves and we are synched...?
      if (redraw || (new_camera && camera[c].synch))
      {
         _vm_rend_start(c,show_grid);
         if (mode & RM_WIREFRAME_BRUSHES)
            gedrendRenderView(rv_flag, c);

         _vm_rend_message_corner(_vm_name_corner,axis_names[camera[c].axis]);
      }
      else
         restore_bm=TRUE;
   }

   // This is here because it predates the modern line drawing system.
   AIPathFindDrawDB();

   if (restore_bm)
      _vm_restore_camera_bitmap(c) ; // get old bitmap save as background
   else
      _vm_save_camera_bitmap(c);     // here is where to save off "baseline" camera data

   if (!camera[c].camera_3d)
      _vm_show_camera_in2d(c);

   if (mode & (RM_WIREFRAME_BRUSHES | RM_WIREFRAME_CURRENT))
      gedrendRenderView(rv_flag | GEDREND_FLAG_CURSORONLY, c);

   vm_end_3d(c);
   gr_set_fcolor(c == vm_cur_camera ? view_select_color : view_grid_color );
   gr_box(0,0,grd_bm.w,grd_bm.h);
   vm_unset_region_canvas();
}

void vm_render_cameras(void)
{
   int i;

   if (!(redraw || new_select || new_camera || new_render))
      return;

   // i really really dont get this?
   // if we reportalized, we need to invalidate cached cell #s
   // ummmm.... right, so why do we do this each time?
   // and, while we are at it, why vm_cur_camera...
   for (i=0; i < MAX_CAMERAS; ++i) {
      UpdateChangedLocation(&camera[i].loc);    // these were both vm_cur_camera???
      UpdateChangedLocation(&camera[i].loc_2d); // not quite sure what is supposed to be happening here...
   }

   DrawRelations();
   update_links = FALSE;

   for (i=0; i < MAX_CAMERAS; ++i)
      vm_render_camera(i);

   update_links = TRUE;

   redraw = vmRenderAlways;
   new_select = new_camera = new_render = FALSE;
}

////////////////////////////////////////////////////////////
//
//  dealing with UI
//

static int warp_x_pos, warp_y_pos, warp_camera;
void vm_menu_warp_camera(void)
{
   mxs_vector *loc;
   mxs_angvec *fac;

   if (vm_spotlight_loc(&loc, &fac)) {
      mxs_vector temp;
      int a;
      a = vm_map_screen_to_world(warp_camera, &temp, warp_x_pos, warp_y_pos);

      loc->el[(a+1)%3] = temp.el[(a+1)%3];
      loc->el[(a+2)%3] = temp.el[(a+2)%3];
   }
}

void vm_swap_cameras_string(char *arg)
{
   int x,y;
   if (sscanf(arg, "%d%d", &x, &y) == 2) {
      if (x >= 0 && y >= 0 && x < MAX_CAMERAS && y < MAX_CAMERAS && x != y) {
         UPDATE_CAMERA(x);
         UPDATE_CAMERA(y);
         vm_swap_cameras(x,y);
      }
   } else
      Warning(("Invalid swap command.\n"));
}

void vm_move_grid(float x)
{
   redraw = TRUE;
   vm_3d_grid_height += x;
}

void vm_resynch_oneshot(void)
{
   vm_set_synch_all(TRUE);
   vm_redraw();
   vm_render_cameras();
   vm_set_synch_all(FALSE);
}

static void vm_teleport_cam(char *new_coords)
{
   mxs_vector loc;
   if (sscanf(new_coords,"%f,%f,%f",&loc.x,&loc.y,&loc.z)==3)
      vm_cur_loc_set(&loc);
   else
      Status("Couldnt parse location");
}

Command vm_commands[] =
{
   { "grid_3d", TOGGLE_BOOL, &vm_show_grid_3d, "toggle grid display in 3d" },
   { "grid_2d", TOGGLE_BOOL, &vm_show_grid, "toggle grid display in 2d" },
   { "grid_3d_axis", VAR_INT, &vm_3d_grid_axis, "3d grid normal axis #" },
   { "grid_move", FUNC_FLOAT, vm_move_grid, "translate 3d grid" },
   { "cycle_view", FUNC_BOOL, vm_cycle_camera, "change current camera" },
   { "toggle_3d", FUNC_VOID, vm_cur_toggle_3d, "change current 2d/3d mode" },
   { "zoom_all", FUNC_FLOAT, vm_scale_all, "zoom all 2d cameras" },
   { "zoom_2d", FUNC_FLOAT, vm_cur_scale, "zoom current camera" },
   { "synch_all", FUNC_BOOL, vm_set_synch_all, "set all 2d synch modes" },
   { "cam_swap", FUNC_STRING, vm_swap_cameras_string, "swap two cameras" },
   { "cycle_mode", FUNC_VOID, vm_cur_cycle_mode, "change rendering mode" },
   { "set_mode", FUNC_INT, vm_cur_set_mode, "set rendering mode" },
   { "toggle_synch", FUNC_VOID, vm_cur_toggle_synch, "toggle 2d synch mode" },
   { "toggle_persp", FUNC_VOID, vm_cur_toggle_persp, "toggle 3d perspective" },
   { "xmouse", TOGGLE_BOOL, &vm_xmouse, "auto-select camera under mouse" },
   { "cam_warp", FUNC_VOID, vm_menu_warp_camera, "warp camera to mouse loc" },
   { "toggle_mode", FUNC_INT, vm_cur_toggle_mode, "toggle a display aspect" },
   { "solo_toggle", FUNC_VOID, vmToggleGUIFull, "toggle this view being soloed" },
   { "redraw_always", TOGGLE_BOOL, &vmRenderAlways, "does the editor continually redraw" },
   { "vm_refresh", FUNC_VOID, vm_redraw, "redraw all views" },
   { "quick_resynch", FUNC_VOID, vm_resynch_oneshot, "synch; redraw; then desynch" },
   { "vm_win_mode", FUNC_INT, vmWinCfgSetMode, "wincfg set mode" },
   { "vm_layout", FUNC_INT, vmWinCfgCycleLayout, "cycle/set vm win layout" },
   { "vm_name_corner", VAR_INT, &_vm_name_corner, "set corner for names (-1 no draw)" },
   { "vm_teleport", FUNC_STRING, vm_teleport_cam, "move camera to x,y,z" },
};

void vm_init(void)
{
   COMMANDS(vm_commands, HK_EDITOR);
}

void vm_term(void)
{  // is this too late, ie. Malloc/Free is already dead?  i dont think so
   _vm_camera_saves_term();
}

void vm_suspend(void)
{
   // Free the camera saves
   _vm_camera_saves_term();
}

void vm_resume(void)
{
}

  // build a popup-menu for a given camera
void vm_get_popup_menu(int cam, char ***names, char ***command, int *count, int x, int y)
{
   extern void vm_mouse_relativize(int c, int *x, int *y);
   static char *command_list[32];
   static char *name_list[32];

   int i=0, c3 = camera[cam].camera_3d;
//   int persp = camera[cam].perspective;  // unloved by the people
   int cs = camera[cam].synch;

     // HACK: save away the location of the mouse and the
     // camera info in case it turns out to be cam_warp

   warp_x_pos = x;
   warp_y_pos = y;
   warp_camera = cam;
   vm_mouse_relativize(cam, &warp_x_pos, &warp_y_pos);

#define ADD(x,y)   (name_list[i]=(x),command_list[i]=(y),++i)
#define MULTI_NAME(w,x,y,z) ADD(((w) ? (x) : (y)), (z))

   if (c3)  MULTI_NAME(vm_show_grid_3d, "hide grid", "show grid", "grid_3d");
   if (!c3) MULTI_NAME(vm_show_grid,    "hide grid", "show grid", "grid_2d");

   if (!c3) ADD("teleport camera", "cam_warp");

   MULTI_NAME(vmSoloed, "un-solo", "solo view", "solo_toggle");

   // no one seems to love these
   //   MULTI_NAME(c3, "2d view", "3d view", "toggle_3d");
   //   if (c3)  MULTI_NAME(persp, "isometric", "perspective", "toggle_persp");

   if (c3) ADD("wireframe brushes", "set_mode 1");
   if (c3) ADD("solid world", "set_mode 2");
   if (c3) ADD("solid + selection", "set_mode 6");
   if (c3) ADD("solid + all wireframe", "set_mode 3");

   if (!c3 &&  cs) ADD("asynch all", "synch_all false");
   if (!c3 && !cs) ADD( "synch all", "synch_all true");

   if (!c3) ADD("zoom in", "zoom_2d 0.5");
   if (!c3) ADD("zoom out", "zoom_2d 2.0");

   if (!c3) ADD("zoom in all", "zoom_all 0.5");
   if (!c3) ADD("zoom out all", "zoom_all 2.0");

   if (!c3) ADD("fit to region", "fit_cameras false");

#undef ADD
#undef MULTI_NAME

   *names = name_list;
   *command = command_list;
   *count = i;
}

////////////////////////////////////////////////////////////
//
//  accessing methods
//

bool        vm_get_3d      (int c) { return camera[c].camera_3d; }
mxs_vector *vm_get_location(int c) { return &camera[c].loc.vec; }
mxs_angvec *vm_get_facing  (int c) { return &camera[c].ang; }
mxs_real    vm_get_zoom    (int c) { return camera[c].zoom; }
mxs_real    vm_get_scale   (int c) { return camera[c].scale; }
mxs_vector *vm_get_loc_2d  (int c) { return &camera[c].loc_2d.vec; }
bool        vm_get_synch   (int c) { return camera[c].synch; }
int         vm_get_mode    (int c) { return camera[c].render_mode; }

void vm_set_3d(int c, bool flag)
{
   UPDATE_CAMERA(c);
   camera[c].camera_3d = flag;
}

void vm_set_render_mode(int c, uchar mode)
{
   UPDATE_CAMERA(c);
   camera[c].render_mode = mode; // no longer force it to be valid - so it doesnt make me want to kill it
}

void vm_set_location(int c, mxs_vector *loc)
{
   UPDATE_CAMERA(c);
   if (camera[c].camera_3d)
   {
      camera[c].loc.vec = *loc;
      UpdateChangedLocation(&camera[c].loc);
   }
   else
   {
      camera[c].loc_2d.vec = *loc;
      UpdateChangedLocation(&camera[c].loc_2d);
   }
}

void vm_set_facing(int c, mxs_angvec *fac)
{
   UPDATE_CAMERA(c);
   camera[c].ang = *fac;
}

void vm_set_zoom(int c, mxs_real zoom)
{
   UPDATE_CAMERA(c);
   camera[c].zoom = zoom;
}

void vm_set_perspective(int c, bool flag)
{
   UPDATE_CAMERA(c);
   camera[c].perspective = flag;
}

void vm_set_scale(int c, mxs_real scale)
{
   UPDATE_CAMERA(c);
   camera[c].scale = scale;
}

void vm_set_axis(int c, int a)
{
   UPDATE_CAMERA(c);
   camera[c].axis = a;
}

void vm_set_synch(int c, bool flag)
{
   UPDATE_CAMERA(c);
   if (camera[c].synch && !flag) {
      int rc = synch_camera();
      if (rc >= 0) {
         camera[c].loc_2d = camera[rc].loc;
      }
   }
   camera[c].synch = flag;
}
// $Header: r:/t2repos/thief2/src/editor/vbr_math.h,v 1.3 2000/01/29 13:13:24 adurant Exp $
// math ops for virtual brush manipulation fun (tm)
#pragma once

#ifndef __VBR_MATH_H
#define __VBR_MATH_H

#include <matrixs.h>
#include <matrixds.h>
#include <editbrs.h>

// we need a better way to do this, but for now
EXTERN bool vBrush_relative_motion;
EXTERN bool vBrush_axial_scale;

////////////
// misc exposed utility math things

// given v1 and v2, basically builds mx_eldiveq_vec
EXTERN BOOL compute_scale_fac(mxs_vector *scale, mxs_vector *old_v, mxs_vector *new_v);

// well, we dont have angvec funcs, so this is targ=v1-v2
EXTERN BOOL sub_angvecs(mxs_angvec *targ, mxs_angvec *v1, mxs_angvec *v2);

// this takes two angvecs, quantizes, subs into diff, and returns if diff is non-zero
EXTERN BOOL ang_quantize_and_sub(mxds_vector *diff, mxs_angvec *v1, mxs_angvec *v2);

// find the origin of a brush
EXTERN BOOL find_brush_origin(editBrush *us, mxs_vector *origin, mxs_angvec *ang_in);

///////////
// operators

// actual operator setup calls
EXTERN void br_translate_setup(mxs_vector *raw_vec);
EXTERN void br_scale_setup(mxs_vector *raw_vec);
EXTERN void br_rotate_setup(mxs_angvec *rot);
EXTERN void br_rotate_rad_setup(mxds_vector *real_rot);
   
// actual operators
EXTERN void br_translate(editBrush *us);
EXTERN void br_scale(editBrush *us);
EXTERN void br_rotate(editBrush *us);

// expose a parameter or two for now for the load hacks
// it would be nice to modularize this and get rid of it
EXTERN mxs_vector *br_trans_vec;

/////////////
// crazy "back and store" of brush vecs system
EXTERN BOOL store_BrushVecs(void);
EXTERN void clear_BrushVecs(void);
EXTERN void restore_BrushVecs(int which);
#define brVec_NONE (-1)
#define brVec_ANG  1
#define brVec_POS  2
#define brVec_SZ   4

#endif  // __VBR_MATH_H
// $Header: r:/t2repos/thief2/src/editor/viewmgr.h,v 1.20 2000/01/29 13:13:25 adurant Exp $
#pragma once

#ifndef __VIEWMGR_H
#define __VIEWMGR_H

#include <wr.h>

#ifdef __cplusplus
extern "C" {
#endif 

void vm_init(void);
void vm_term(void);

EXTERN void vm_suspend(void);
EXTERN void vm_resume(void); 

void vm_init_cameras(void);
void vm_init_camera(int c);

void vm_cycle_camera(bool up);
void vm_disable_region(int r);
void vm_enable_region(int r);
void vm_enable_all_regions(void);
void vm_swap_cameras(int x, int y);
mxs_vector *vm_cur_loc(void);
void vm_cur_loc_set(mxs_vector *loc);
bool vm_cur_3d(void);
void vm_cur_slew(mxs_vector *slew);
void vm_cur_scroll(mxs_real x, mxs_real y);
void vm_cur_rotate(mxs_angvec *rot);
void vm_cur_level (int axis);
void vm_cur_cycle_mode(void);
void vm_cur_toggle_mode(uchar toggle);
void vm_cur_toggle_3d(void);
void vm_cur_toggle_persp(void);
void vm_cur_toggle_synch(void);

// various levels of redraw of the windows
void vm_redraw(void);
void vm_redraw_from_select(void);
void vm_redraw_from_camera(void);
void vm_redraw_from_new3d(void);

// 3d setup/control
void vm_start_3d(int c);
void vm_end_3d(int c);
// gets 3d camera location for the current started 3d
// if you call this at a bad time, sad day for you
void vm_get_3d_camera_loc(mxs_vector **pos, mxs_angvec **ang);

// setups
void vm_cur_scale(mxs_real scale);
void vm_scale_all(mxs_real scale);
void vm_fit_cameras_to_region(mxs_vector *, mxs_vector *);

// rendering a camera
void vm_render_camera(int c);
void vm_render_cameras(void);
// grid control for now - used by render to decide about grids
EXTERN bool vm_show_grid, vm_show_grid_3d;

// returns whether the pick worked or not
// if so, the two vm_pick variables will be set validly
BOOL vm_pick_camera(int c, int x, int y, int *brush, int *face);

bool vm_spotlight_loc(mxs_vector **loc, mxs_angvec **ang);

// so you dont need to know about the canvas<->region mapping silliness
void vm_set_camera_canvas(int c);
void vm_unset_camera_canvas(void);

// to set the currently selected region
void vm_set_cur_region(int n);
int vm_get_cur_region(void);

// camera set/get
void vm_set_cur_camera(int);
int vm_current_camera(void);

// rendering mode defines
#define RM_WIREFRAME_BRUSHES 1
#define RM_SOLID_PORTAL 2
#define RM_WIREFRAME_CURRENT 4
#define RM_WIREFRAME_PORTAL 8

// low-level accessing methods, specify a camera

bool        vm_get_3d      (int c);
mxs_vector *vm_get_location(int c);
mxs_angvec *vm_get_facing  (int c);
mxs_real    vm_get_zoom    (int c);
mxs_real    vm_get_scale   (int c);
mxs_vector *vm_get_loc_2d  (int c);
bool        vm_get_synch   (int c);
int         vm_get_mode    (int c);

void vm_set_3d(int c, bool flag);
void vm_set_render_mode(int c, uchar mode);
void vm_set_location(int c, mxs_vector *loc);
void vm_set_facing(int c, mxs_angvec *fac);
void vm_set_zoom(int c, mxs_real zoom);
void vm_set_perspective(int c, bool flag);
void vm_set_scale(int c, mxs_real scale);
void vm_set_axis(int c, int a);
void vm_set_synch(int c, bool flag);

// utility for world location stuff
int vm_map_screen_to_world(int c, mxs_vector *dest, int x, int y);
bool vm_screen_axes(int c, mxs_vector *x, mxs_vector *y);
int vm_normal_axis(int c);
// returns the bogus axis, fills in which axis generally for x and y
int vm_get_camera_axis(int c, int *x, int *y);
// get screen size of cameras region
BOOL vm_camera_scr_size(int c, int *w, int *h);

// pick colors
void vm_pick_colors(void); 

#ifdef __cplusplus
}
#endif

#endif


/*
Local Variables:
typedefs:("mxs_angvec" "mxs_real" "mxs_vector" "uchar")
End:
*/
// $Header: r:/t2repos/thief2/src/editor/viewmgr_.h,v 1.3 2000/01/29 13:13:27 adurant Exp $
#pragma once

#ifndef ___VIEWMGR_H
#define ___VIEWMGR_H

#define MAX_CAMERAS 16
#define MAX_CAMERAS_REAL 4

EXTERN uchar camera_to_region_mapping[];
EXTERN uchar region_to_camera_mapping[];

EXTERN int vm_avail_regions;
EXTERN int vm_cur_region; 
EXTERN int vm_cur_camera;

EXTERN void vm_set_region_canvas(int r);
EXTERN void vm_unset_region_canvas(void);


#define VIEW_AVAIL(x) (vm_avail_regions & (1 << (x)))
#define VIS_CAM(x)  (vm_avail_regions & (1 << camera_to_region_mapping[x]))


#endif // ___VIEWMGR_H
// $Header: r:/t2repos/thief2/src/editor/vmwincfg.c,v 1.16 2000/02/19 13:13:44 toml Exp $
//
// view manager window configuation controller 
//  has mouse handlers, region size/shape computation, drag resize, 
//  and solo/nonsolo window sizing, as well as maybe multi layouts

// this system manages a single rectangular slab of screen, which it 
//   partitions as it sees fit into subwindows for display of 3d 
//   information in.  it supports a mouse UI for sliding around the 
//   "center" of this region, from which it derives the size/shape of 
//   the other windows.  it also supports "soloing" the current view 
//   to be full screen.  
// it also may someday support multiple "layouts".  for now, the only
//   supported layout is a 2x2, with the center partitioning it out.
//   the next obvious layout is a 1 next to 3, or 1 above 3, with one
//   big window and 3 little ones next to or below it.

// WARNING: the rest of this code base (vumanui in particular) presupposes
//   (in its own way) a virtually unlimited number of windows, and makes 
//   reference to this in the MAX_REAL_CAMERAS and, in particular, the 
//   ViewGrid thing.  this WinCfg UI _KNOWS THERE ARE 4_ and knows in
//   particular that row and col will be small.  if we really have some
//   cool mode which is not 4, we can add it later, i guess, but it will
//   probably be messy.

#include <2d.h>
#include <reg.h>
#include <mprintf.h>
#include <gadget.h>
#include <gcompose.h>
#include <kbcook.h>
#include <config.h>
#include <status.h>
#include <matrix.h>

#include <modalui.h>
#include <vumanui.h>
#include <vmwincfg.h>
#include <viewmgr.h>
#include <viewmgr_.h>
#include <editor.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

// exported data
BOOL  vmSoloed=FALSE;     // are we currently soloed on a particular view
int   vmWinCfgMode=vmWINCFG_MODE_NORMAL;

// static layout control - shape and form fun
static BOOL  vmLayout2by2=TRUE;  // are we 2x2 or 3x1 (ignoring being Soloed, o'course)
static BOOL  vmLayoutVerticalSplit=TRUE; // if 3x1, which axis split
static Point vmGUIDims;          // size of the current GUI
static Point vmGUITop;           // absolute UpperLeft corner of GUI
static Point vmGUICenter={0,0};  // sliding center point of GUI - 0,0 means uninitialized
static Rect  vmGUIRect;

// locals
static int par_handler_cookie;
static Region *vmWinParent=NULL;

// definitions/constants
#define VIEW_MARGIN_X 3  // xsize pixel border, per side
#define VIEW_MARGIN_Y 2  // ysize pixel border, per side

// THE BIG THING - determines where the windows are in real life...
// returns whether the rect is currently visible? fills in params
BOOL vmGetRegionInfo(int i, Point *origin, Point *size)
{
   BOOL rv=TRUE;

   *origin=vmGUITop;
   if (vmSoloed)
   {
      if (vm_get_cur_region()==i)
         *size=vmGUIDims;   // soloed and current region, so full screen
      else
      {
         *origin=*size=MakePoint(0,0);
         rv=FALSE;
      }
   }
   else if (vmLayout2by2)
   {
      int col = i % 2;  // was ViewGrid craziness, but lets face it, this stuff is 2x2 hardcoded
      int row = (i - (col)) / 2;

      if (col)
      {
         origin->x+=vmGUICenter.x + VIEW_MARGIN_X;
         size->x=vmGUIDims.x - vmGUICenter.x - VIEW_MARGIN_X - 1;
      }
      else
         size->x=vmGUICenter.x;

      if (row)
      {
         origin->y+=vmGUICenter.y + VIEW_MARGIN_Y;
         size->y=vmGUIDims.y - vmGUICenter.y - VIEW_MARGIN_Y - 1;
      }
      else
         size->y=vmGUICenter.y;
   }
   else // thus, by implication, we are an unsoloed 3x1 on some axis or other
   {
      if (i==0) // base view
      {
         *size=vmGUIDims;
         if (vmLayoutVerticalSplit)
            size->x=vmGUICenter.x - VIEW_MARGIN_X;
         else
            size->y=vmGUICenter.y - VIEW_MARGIN_Y;
      }
      else  // equispaced other 3
      {
         if (vmLayoutVerticalSplit)
         {
            size->x=vmGUIDims.x - vmGUICenter.x - VIEW_MARGIN_X;
            size->y=vmGUIDims.y/3;
            origin->x+=vmGUICenter.x + VIEW_MARGIN_X;
            if (i!=1)  // keep first 1 flush
               origin->y+=(i-1)*size->y + VIEW_MARGIN_Y;
            if (i!=3)  // keep last 1 flush
               size->y-=VIEW_MARGIN_Y;
         }
         else
         {
            size->x=vmGUIDims.x/3;
            size->y=vmGUIDims.y - vmGUICenter.y - VIEW_MARGIN_Y;
            if (i!=1)  // keep first 1 flush
               origin->x+=(i-1)*size->x + VIEW_MARGIN_X;
            origin->y+=vmGUICenter.y + VIEW_MARGIN_Y;
            if (i!=3)  // keep last 1 flush
               size->x-=VIEW_MARGIN_X;
         }
      }
   }
   return rv;
}

// draw outline skeletons of each window
void vmDrawWindowSkeletons(void)
{
   Point loc, size;
   int i;
   
   GUIErase(&vmGUIRect);
   gr_set_fcolor(guiStyleGetColor(NULL,StyleColorFG));
   for (i=0; i<MAX_CAMERAS_REAL; i++)
      if (vmGetRegionInfo(i,&loc,&size))  // draw the rectangle for our region info, eh?
         gd_box(loc.x,loc.y,loc.x+size.x-2,loc.y+size.y-2);
}

// do region math and then clear the area out
static void cleanup_region(int which)
{
   Rect r;
   region_abs_rect(&vmRegions[which],vmRegions[which].r,&r);
   GUIErase(&r);
}

// actually toggle from soloed to nonsoloed
void vmToggleGUIFull(void)
{
   int i=vm_get_cur_region(), j;
   Region *reg=&vmRegions[i];
   Point loc, size;

   if (!vmAllViewsAvailable()) return;
   if (vmSoloed) cleanup_region(i);   // we were soloed
   else if (vm_menu_inprog) vm_menu_camera_lock=TRUE;  // we arent, so keep new window
   vmSoloed=!vmSoloed;
   if (!vmGetRegionInfo(i,&loc,&size))
   {
      Warning(("Hey! GetRegionInfo of bogus region %d in ToggleFull\n",i));
      return;
   }
   region_resize(reg,size.x,size.y);
   region_move(reg,loc.x,loc.y,reg->z);
   for (j=0; j<MAX_CAMERAS_REAL; j++)
      if (i!=j)
      {
         region_set_invisible(&vmRegions[j],vmSoloed);
         if (vmSoloed)
         {
            cleanup_region(j);
            vm_disable_region(j);
         }
         else
            vm_enable_region(j);
      }
   vm_redraw();
}

// correctly redraw all windows, if "resize" is set, first regenerate and size them
void vmWindowsRefresh(BOOL resize)
{
   //   GUIErase(&vmGUIRect);
   gr_set_fcolor(0);   // i just cant get this to work... argh!!!
   gr_rect(vmGUIRect.ul.x,vmGUIRect.ul.y,vmGUIRect.lr.x,vmGUIRect.lr.y+1);
   if (resize)
   {
      Point loc, size;
      Region *reg;
      int i;
      for (i=0; i<MAX_CAMERAS_REAL; i++)
         if (vmGetRegionInfo(i,&loc,&size))
         {
            reg=&vmRegions[i];
            region_resize(reg,size.x,size.y);
            region_move(reg,loc.x,loc.y,reg->z);
         }
   }
   vm_redraw();   // do we have to expose or something here?
}

// set a new bounding rectangle
// why cant we set an origin too? who knows, have to fix it, clearly
void vmNewBoundingRect(Rect *bounds)
{
   float scale_x=(float)RectWidth(bounds)/(float)RectWidth(&vmGUIRect);
   float scale_y=(float)RectHeight(bounds)/(float)RectHeight(&vmGUIRect);

   vmGUIDims   = MakePoint(RectWidth(bounds),RectHeight(bounds));
   vmGUIRect   = *bounds;

   vmGUICenter.x = (short) (scale_x * vmGUICenter.x);
   vmGUICenter.y = (short) (scale_y * vmGUICenter.y);
}

// utilities to find out about scale/size of current window layout
void vmGetReferenceSize(Point *size)
{
   *size = MakePoint(vmGUIDims.x/2,vmGUIDims.y/2);
}

// returns X size ratio by default
float vmGetSizeRatio(int r, float *xrat, float *yrat)
{
   Point orig, our_size, ref_size;
   float xr;

   vmGetRegionInfo(r,&orig,&our_size);
   vmGetReferenceSize(&ref_size);
   xr=(float)our_size.x/(float)ref_size.x;
   if (xrat) *xrat=xr;
   if (yrat) *yrat=(float)our_size.y/(float)ref_size.y;
   return xr;
}

///////////////////
// window layout control UI

#define AXIS_MASK_X        0x01
#define AXIS_MASK_Y        0x02

// maybe someday?
#define AXIS_MASK_LEFT_EDGE    0x04
#define AXIS_MASK_RIGHT_EDGE   0x08
#define AXIS_MASK_TOP_EDGE     0x10
#define AXIS_MASK_BOTTOM_EDGE  0x20

#define ismouse(ev) ((ev).type & (UI_EVENT_MOUSE | UI_EVENT_MOUSE_MOVE))
#define iskbd(ev)   ((ev).type == UI_EVENT_KBD_COOKED)

// modal drag window layout commands

#define DRAG_BORDER 10

// should we perhaps put the mouse back in the right place at some point?
// returns whether we moved anything or not
static BOOL _doWinDrag(int axis_mask)
{
   Point init_center=vmGUICenter;
   uiEvent ev;

   if (!modal_ui_start(MODAL_CHECK_LEFT)) return FALSE;
   uiHideMouse(NULL);
   do {
      modal_ui_update();
      while (modal_ui_get_event(&ev))
      {
         if (ismouse(ev))
         {
            BOOL slam_mouse=FALSE;
            uiMouseEvent *mev = (uiMouseEvent *)&ev;
            if (mev->action & MOUSE_LUP)
               goto mouse_up;
            if ((mev->pos.x<0)||(mev->pos.x>=grd_visible_canvas->bm.w)||
                (mev->pos.y<0)||(mev->pos.y>=grd_visible_canvas->bm.h))
               slam_mouse=TRUE;
            else if (axis_mask&AXIS_MASK_X)
            {
               vmGUICenter.x=mev->pos.x;  // must clip to our box
               if (vmGUICenter.x<vmGUITop.x+DRAG_BORDER)
                  vmGUICenter.x=vmGUITop.x+DRAG_BORDER;
               else if (vmGUICenter.x>=vmGUITop.x+vmGUIDims.x-DRAG_BORDER)
                  vmGUICenter.x=vmGUITop.x+vmGUIDims.x-DRAG_BORDER-1;
               slam_mouse|=(vmGUICenter.x!=mev->pos.x);
            }
            if (axis_mask&AXIS_MASK_Y)
            {
               vmGUICenter.y=mev->pos.y;
               if (vmGUICenter.y<vmGUITop.y+DRAG_BORDER)
                  vmGUICenter.y=vmGUITop.y+DRAG_BORDER;
               else if (vmGUICenter.y>=vmGUITop.y+vmGUIDims.y-DRAG_BORDER)
                  vmGUICenter.y=vmGUITop.y+vmGUIDims.y-DRAG_BORDER-1;
               slam_mouse|=(vmGUICenter.y!=mev->pos.y);
            }
            if (slam_mouse)
               mouse_put_xy(vmGUICenter.x,vmGUICenter.y);
            vmDrawWindowSkeletons();
         }
         else if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               goto esc;
         }
      }
   } while (1);

esc:
   vmGUICenter=init_center;
mouse_up:
   modal_ui_end();
   uiShowMouse(NULL);
   return (vmGUICenter.x!=init_center.x)||(vmGUICenter.y!=init_center.y);
}

#define DEAD_SPOT_SIZE (8)
static BOOL _doWinScroll(int c)
{
   mxs_vector start_loc=*vm_get_location(c);  // this is where we started
   mxs_vector cur_loc=start_loc;             // which, for now, is where we are
   mxs_vector x_sc, y_sc;                     // pixel to world ratio on each axis
   Point loc, size;
   short x_cen, y_cen;                        // absolute screen coord of center
   uiEvent ev;

   vmGetRegionInfo(camera_to_region_mapping[c],&loc,&size);
   vm_screen_axes(c,&x_sc,&y_sc);
   x_cen=(short)(loc.x+(size.x/2));
   y_cen=(short)(loc.y+(size.y/2));
   vm_render_camera(c);
   if (!modal_ui_start(MODAL_CHECK_LEFT)) return FALSE;
   mouse_put_xy(x_cen,y_cen);
   do {
      modal_ui_update();
      while (modal_ui_get_event(&ev))
      {
         if (ismouse(ev))
         {
            uiMouseEvent *mev = (uiMouseEvent *)&ev;
            int x_off=mev->pos.x-x_cen, y_off=mev->pos.y-y_cen;
            BOOL chg=FALSE;
            if (mev->action & MOUSE_LUP)
               goto mouse_up;
            if (abs(x_off)>DEAD_SPOT_SIZE)
            {
               mx_scale_addeq_vec(&cur_loc,&x_sc,((float)x_off*2.0/(float)DEAD_SPOT_SIZE));
               chg=TRUE;
            }
            if (abs(y_off)>DEAD_SPOT_SIZE)
            {
               mx_scale_addeq_vec(&cur_loc,&y_sc,((float)y_off*2.0/(float)DEAD_SPOT_SIZE));
               chg=TRUE;
            }
            if (chg)  // need to redraw somehow
            {
               extern BOOL zip;
               vm_set_location(c,&cur_loc);
               vm_render_camera(c);
            }
         }
         else if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               goto esc;
         }
      }
   } while (1);

esc:
   cur_loc=start_loc;
   vm_set_location(c,&cur_loc);
   vm_render_camera(c);
mouse_up:
   modal_ui_end();
   return (start_loc.x!=cur_loc.x)||(start_loc.y!=cur_loc.y)||(start_loc.z!=cur_loc.z);
}

#define CENTER_TOL (VIEW_MARGIN_X*4)
// actually setup for and execute the windows resizing drag
static BOOL setup_center_drag(int x_pos, int y_pos)
{
   Point offset;
   int allowAxisMask;
   
   offset.x=x_pos-vmGUICenter.x;   // get distance from center of GUI
   offset.y=y_pos-vmGUICenter.y;
   
   if ((abs(offset.x)<CENTER_TOL)&&(abs(offset.y)<CENTER_TOL))
      allowAxisMask=AXIS_MASK_X|AXIS_MASK_Y;
   else
      if (abs(offset.x)>abs(offset.y))
         allowAxisMask=AXIS_MASK_Y;
      else
         allowAxisMask=AXIS_MASK_X;
   if (!vmLayout2by2)  // 1by3, dont allow off axis motion
      if (vmLayoutVerticalSplit) allowAxisMask&=~AXIS_MASK_Y;
      else                       allowAxisMask&=~AXIS_MASK_X;
   if (allowAxisMask&AXIS_MASK_X) x_pos=vmGUICenter.x;
   if (allowAxisMask&AXIS_MASK_Y) y_pos=vmGUICenter.y;
   mouse_put_xy(x_pos,y_pos);
   return _doWinDrag(allowAxisMask);
}

// this is really ugly, eh?
BOOL vmScrollCamera(int c)
{
   int oc=vm_current_camera();
   int omode=vm_get_mode(c);
   bool oldgrid=vm_show_grid;
   BOOL rv=FALSE;
   
   if (vm_get_3d(c))
    { Status("Cant scroll 3d cameras"); return rv; }
   vm_set_cur_camera(c);
   vm_set_render_mode(c,RM_WIREFRAME_CURRENT);
   vm_show_grid=TRUE;     // for now, show current brush, grid, and camera only
   vm_set_synch(c,FALSE); // desynch always - perhaps should save state for abort case?
   rv=_doWinScroll(c);
   vm_show_grid=oldgrid;
   vm_set_render_mode(c,omode);
   vm_set_cur_camera(oc);
   vm_redraw();
   return rv;
}

// mouse handler for clicks which make it onto the parent region - ie the cracks between the views
// sadly this is untrue, since the parent region seems to be the whole display... so we check rect bounds now
// return TRUE if i eat the event
static bool vm_parent_mouse_handler(uiEvent* _ev, Region* reg, void* _data)
{
   uiMouseEvent* ev = (uiMouseEvent*)_ev;
   BOOL changed_setup=FALSE;

   if (vmWinCfgMode==vmWINCFG_MODE_SCROLL)
   {  // this scroll handler is just here to catch scroll inits not on vm views
      if (ev->action&MOUSE_LDOWN)  // clicked outside - just punt
         vmWinCfgSetMode(vmWINCFG_MODE_NORMAL);
      return TRUE;
   }

   if ((ev->pos.x>vmGUIDims.x)||(ev->pos.y>vmGUIDims.y))
      return FALSE;

   // this is the "modal" selector up front
   switch (vmWinCfgMode)
   {
   case vmWINCFG_MODE_NORMAL:     // if we made it to here, we are doing a standard parent mouse handler window resizing thing
      if (vmSoloed || !vmAllViewsAvailable())
         return FALSE;
      
      if (ev->action&MOUSE_LDOWN)
         changed_setup=setup_center_drag(ev->pos.x,ev->pos.y);
      else if (ev->action&MOUSE_RDOWN)
      {  // for now, we cycle through the available layouts
         vmWinCfgCycleLayout(vmWINCFG_C_NOUPDATE);
         changed_setup=TRUE;
      }
      else
         return FALSE;
      vmWindowsRefresh(changed_setup);
      return TRUE;
   }
   return FALSE;
}

// takes input from vmWINCFG_ defines in header
void vmWinCfgCycleLayout(int new_layout)
{
   BOOL refresh=TRUE, noSolo=FALSE;;
   switch (new_layout)
   {
   case vmWINCFG_C_NOUPDATE:
      refresh=FALSE; // really just for usage by the callback - so fall through
   case vmWINCFG_CYCLE:
      noSolo=TRUE;
      if (vmLayout2by2)
         vmLayout2by2=!vmLayout2by2;
      else
      {
         vmLayoutVerticalSplit=!vmLayoutVerticalSplit;
         if (vmLayoutVerticalSplit)
            vmLayout2by2=!vmLayout2by2;
      }
      break;
   case vmWINCFG_2by2:       vmLayout2by2=TRUE;  vmLayoutVerticalSplit=TRUE;  noSolo=TRUE; break;
   case vmWINCFG_1by3_VERT:  vmLayout2by2=FALSE; vmLayoutVerticalSplit=TRUE;  noSolo=TRUE; break;
   case vmWINCFG_1by3_HORIZ: vmLayout2by2=FALSE; vmLayoutVerticalSplit=FALSE; noSolo=TRUE; break;
   case vmWINCFG_RECENTER:   vmGUICenter.x=vmGUIDims.x/2; vmGUICenter.y=vmGUIDims.y/2; break;
   case vmWINCFG_SOLO:       vmToggleGUIFull(); return;
   }
   if (noSolo && vmSoloed)
      vmToggleGUIFull();
   if (refresh)
      vmWindowsRefresh(TRUE);
}

int vmWinCfgGetLayout(void)
{
   if (vmSoloed)                   return vmWINCFG_SOLO;
   else if (vmLayout2by2)          return vmWINCFG_2by2;
   else if (vmLayoutVerticalSplit) return vmWINCFG_1by3_VERT;
   else                            return vmWINCFG_1by3_HORIZ;
}

//////////////////
// setup and overall control

// this is the actual setup of the regions and globals
void vmWinCfgCreate(Region* parent, Rect* bounds)
{
   float cenX=0.5, cenY=0.5;
   
   vmGUITop    = bounds->ul;  // should do this in some better way
   vmGUIDims   = MakePoint(RectWidth(bounds)-1,RectHeight(bounds)-1);
   vmGUIRect   = *bounds;

   config_get_float("vmCenterX",&cenX);
   config_get_float("vmCenterY",&cenY);
   vmGUICenter = MakePoint((int)(RectWidth(bounds)*cenX),(int)RectHeight(bounds)*cenY);

#ifdef SEE_BORDERS_CLEARLY
   vmGUIDims.x -= 10; vmGUIDims.y -= 10;
   vmGUITop.x  += 5;  vmGUITop.y  += 5;
#endif

   uiInstallRegionHandler(parent, UI_EVENT_MOUSE|UI_EVENT_MOUSE_MOVE, vm_parent_mouse_handler, NULL, &par_handler_cookie);
   vmWinParent=parent;
}

// close down the shop
void vmWinCfgDestroy(void)
{
   float cenX=(float)vmGUICenter.x/(float)vmGUIDims.x;
   float cenY=(float)vmGUICenter.y/(float)vmGUIDims.y;
   uiRemoveRegionHandler(vmWinParent,par_handler_cookie);
   vmWinParent=NULL;
   config_set_float_from_var("vmCenterX",cenX);
   config_set_float_from_var("vmCenterY",cenY);
   config_set_priority("vmCenterX",CONFIG_DFT_LO_PRI);
   config_set_priority("vmCenterY",CONFIG_DFT_LO_PRI);   
}

// this is the beginnings of a "move the whole thing"
// currently just takes bounds, clearly not enough
void vmWinCfgResize(Rect *bounds)
{
   vmNewBoundingRect(bounds);
   vmWindowsRefresh(TRUE);
}

void vmWinCfgSetMode(int new_mode)
{
   if (vmWinParent==NULL) return;
   if (vmWinCfgMode==new_mode) return;
   if (vmWinCfgMode==vmWINCFG_MODE_NORMAL)
   {
      uiGrabFocus(vmWinParent,ALL_EVENTS); // gonna need to grab focus, leaving normal
      Status("WinCfg going modal");
   }
   if (new_mode==vmWINCFG_MODE_NORMAL)
   {
      uiReleaseFocus(vmWinParent,ALL_EVENTS); // relinquish focus, done with special mode
      Status("WinCfg eschews modality");
   }
   vmWinCfgMode=new_mode;
}

EXTERN int vmWinCfgGetMode(void)
{
   return vmWinCfgMode;
}
// $Header: r:/t2repos/thief2/src/editor/vmwincfg.h,v 1.5 2000/01/29 13:13:28 adurant Exp $
//
// view manager window configuation controller 
#pragma once

#ifndef __VMWINCFG_H
#define __VMWINCFG_H

// if you just want to know if soloed or not
EXTERN BOOL vmSoloed;

// if you want to put the parent handler in modal state
EXTERN void vmWinCfgSetMode(int new_mode);
#define vmWINCFG_MODE_NORMAL 0
#define vmWINCFG_MODE_SCROLL 1
EXTERN int vmWinCfgGetMode(void);

// when we get a new overall parent and size - set up mouse handlers and such
EXTERN void vmWinCfgCreate(Region* parent, Rect* bounds);
EXTERN void vmWinCfgDestroy(void);

// get origin and size of a region
EXTERN BOOL vmGetRegionInfo(int i, Point *origin, Point *size);

// utilities to find out about sizes/shapes of windows at the moment
// in relation to expected values
EXTERN void vmGetReferenceSize(Point *size);
EXTERN float vmGetSizeRatio(int r, float *xrat, float *yrat);

// draw the current window config outlines
EXTERN void vmDrawWindowSkeletons(void);

// go in and out of vmSoloed mode
EXTERN void vmToggleGUIFull(void);

// layout controls - all but C_NOUPDATE do a screen update and such
EXTERN void vmWinCfgCycleLayout(int new_layout);
#define vmWINCFG_C_NOUPDATE (-1)  // special cycle with no refresh/screen update
#define vmWINCFG_CYCLE      ( 0)  // cycle to next layout
#define vmWINCFG_2by2       ( 1)  
#define vmWINCFG_1by3_VERT  ( 2)  
#define vmWINCFG_1by3_HORIZ ( 3)
#define vmWINCFG_RECENTER   ( 4)  // just recenter positional controler, leave layout form alone
#define vmWINCFG_SOLO       ( 5)  // really just a convient aux entry to vmToggleGUIFull

EXTERN int vmWinCfgGetLayout(void);

// resize the overall GUI area
EXTERN void vmWinCfgResize(Rect *bounds);

// support to scroll a camera view around
BOOL vmScrollCamera(int c);

#endif  // __VMWINCFG_H
// $Header: r:/t2repos/thief2/src/editor/vslider.c,v 1.10 2000/02/19 13:13:45 toml Exp $
// arbitrary axis virtual slider gadgets

#include <stdlib.h>

#include <lg.h>
#include <2d.h>

#include <event.h>
#include <mouse.h>
#include <kbcook.h>

#include <mprintf.h>

#define __VSLIDER_C
#include <modalui.h>
#include <vslider.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

static int last_x, last_y;
static float mouse_sens=1.0;

#define ismouse(ev) ((ev).type & (UI_EVENT_MOUSE | UI_EVENT_MOUSE_MOVE))
#define iskbd(ev)   ((ev).type == UI_EVENT_KBD_COOKED)

static short _vs_mouse_x, _vs_mouse_y;
static int   _vs_scr_wid, _vs_scr_hgt;

void _vslider_mouse_recenter(void)
{
   mouse_put_xy((short)(_vs_scr_wid/2), (short)(_vs_scr_hgt/2));
}

void _vslider_mouse_start(void)
{
   uiHideMouse(NULL);
   _vs_scr_wid=grd_visible_canvas->bm.w;
   _vs_scr_hgt=grd_visible_canvas->bm.h;
   mouse_get_xy(&_vs_mouse_x,&_vs_mouse_y);
   _vslider_mouse_recenter();
}

void _vslider_mouse_end(void)
{
   uiShowMouse(NULL);
   mouse_put_xy(_vs_mouse_x,_vs_mouse_y);
}

int _vslider_mouse_get(uiMouseEvent *mev, float *vals)
{
   float dist[2];
   if ((mev->pos.x<0)||(mev->pos.x>=_vs_scr_wid)||
       (mev->pos.y<0)||(mev->pos.y>=_vs_scr_hgt))
      dist[0]=dist[1]=0;
   else
   {
      dist[0]=((float)(mev->pos.x-(_vs_scr_wid/2)))/(float)(_vs_scr_wid/2);
      dist[1]=((float)(mev->pos.y-(_vs_scr_hgt/2)))/(float)(_vs_scr_hgt/2);
   }
   vals[0]=dist[0]*mouse_sens;
   vals[1]=dist[1]*mouse_sens;
   _vslider_mouse_recenter();
   return 2;         // mouse has 2 valid axis
}

void virtual_slider_mouse_start(void)
{
   last_x=-1;
   last_y=-1;
}

#define ForAllRealSliderAxis(exp,n) \
   for (i=0; i<min(n_axis,n); i++)  \
      if (axis[i]!=NULL) exp

#define parsefunc(i) (slds[i]->parse)

int virtual_slider(int n_axis, void **axis, void (*update_world)(void))
{
   bool          change=FALSE,in_loop=TRUE;  // we set this to false on up or ESC
   uiMouseEvent *use_event;                  // null if no event to process this frame
   uiEvent       ev;
   anonSlider  **slds=(anonSlider **)axis;
   int           i, rcode=VSLIDER_CHANGED;   // assume we are going to change

   if (!modal_ui_start(MODAL_CHECK_ALL)) return VSLIDER_MOUSEUP;
   _vslider_mouse_start();

   ForAllRealSliderAxis( (*parsefunc(i))(0.0,axis[i],SLIDER_START), n_axis );

   while (in_loop)
   {
      use_event=NULL;
      modal_ui_update();
      while (in_loop&&modal_ui_get_event(&ev))
      {
         if (ismouse(ev))
         {
            use_event=(uiMouseEvent *)&ev;
            if (use_event->action & (MOUSE_LUP|MOUSE_RUP))
               in_loop=FALSE;
         }
         else if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
            {
               ForAllRealSliderAxis(
                  (*parsefunc(i))(0.0,axis[i],SLIDER_ABORT), n_axis );
               use_event=NULL;
               in_loop=FALSE;
               rcode=VSLIDER_ABORTED;  // so we return ABORT, not SAMEVAL
            }
         }
      }
      if (use_event)
      {
         bool update=FALSE; float inputs[6]; int n_inp;
         
         n_inp=_vslider_mouse_get(use_event,inputs);
         ForAllRealSliderAxis(
            update|=(*parsefunc(i))(inputs[i],axis[i],SLIDER_SLIDE), n_inp );
         if (update) (*update_world)();
      }
   }
   ForAllRealSliderAxis(change|=(*parsefunc(i))(0.0,axis[i],SLIDER_END),n_axis);
   _vslider_mouse_end();
   modal_ui_end();
   if ((rcode==VSLIDER_CHANGED)&&!change)
      rcode=VSLIDER_SAMEVAL;   // we didnt abort, but we didnt change the values
   return rcode;
}
// $Header: r:/t2repos/thief2/src/editor/vslider.h,v 1.8 2000/01/29 13:13:29 adurant Exp $
// virtual slider header file
#pragma once

#ifndef __VSLIDER_H
#define __VSLIDER_H
#include <vsliderg.h>

///////////////////////////////////
// the real call

int virtual_slider(int n_axis, void **axis, void (*update_world)(void));
// values virtual_slider can return
#define VSLIDER_MOUSEUP (-1)   // means the mouse was already up when we were called
#define VSLIDER_ABORTED ( 0)   // user hit esc to cancel
#define VSLIDER_CHANGED ( 1)   // we changed the brush
#define VSLIDER_SAMEVAL ( 2)   // user used us, but never did anything

///////////////////////////////////
// actual typed stuff

// these generate groups will prototype
//   void *VSlider##type##Build(##type##Slider *s)
// as well as the ##type##Slider struct
// which will look like
//      bool (*parse)(float inp, void *data, int act);
//      type *val;
//      type lo,hi;
//      float scale;
// parse will be defaulted to the internal parser
// val lo and hi MUST be set
// if lo==hi then it is an infinite slider
// scale is multiplied in, defaults to 1.0, i guess

// if you want to write your own parse function
// inp is -1 to 1, data is the ##type##Slider struct, act is a define
#define SLIDER_START  (1)
#define SLIDER_SLIDE  (2)
#define SLIDER_END    (3)
#define SLIDER_ABORT  (4)
#define SLIDER_UPDATE (5)

GenerateVSliderType(float);
GenerateVSliderParse(float);
GenerateVSliderBuild(float);

GenerateVSliderType(fixang);
GenerateVSliderParse(fixang);
GenerateVSliderBuild(fixang);

GenerateVSliderType(int);
GenerateVSliderParse(int);
GenerateVSliderBuild(int);

GenerateVSliderType(short);
GenerateVSliderParse(short);
GenerateVSliderBuild(short);


#endif
// $Header: r:/t2repos/thief2/src/editor/vsliderg.h,v 1.5 2000/01/29 13:13:30 adurant Exp $
// virtual slider generation garbage
#pragma once

#ifndef ___VSLIDER_H
#define ___VSLIDER_H

typedef struct {
   bool (*parse)(float inp, void *data, int act);
} anonSlider;

#define GenerateVSliderType(type)                     \
   typedef struct {                                   \
      bool (*parse)(float inp, void *data, int act);  \
      type *val;                                      \
      type lo,hi;                                     \
      type old_val;                                   \
      float scale;                                    \
      float extra;                                    \
   } ##type##Slider;                                  \
   EXTERN void *VSlider##type##Build(##type##Slider *s)

// these really are only for use by the actual vslider thing itself
#ifdef __VSLIDER_C
#define GenerateVSliderBuild(type)                    \
   void *VSlider##type##Build(##type##Slider *s)      \
   {                                                  \
      s->parse=VSlider##type##Parse;                  \
      s->scale=1.0;                                   \
      s->extra=0.0;                                   \
      return s;                                       \
   }


#define GenerateVSliderParse(type)                    \
   bool VSlider##type##Parse(float delta, ##type##Slider *s, int action) \
   {                                                  \
      switch (action)                                 \
      {                                               \
      case SLIDER_START:                              \
         s->old_val=*s->val;                          \
         return TRUE;  /* in case we have to abort */ \
      case SLIDER_SLIDE:                              \
         {                                            \
            type old=*s->val;                         \
            float coeff;                              \
            if (s->lo==s->hi)    /* infinite range */ \
            {                                         \
               coeff = s->scale;                      \
               *s->val+=delta*coeff + s->extra;       \
            }                                         \
            else                /* standard slider */ \
            {      /* 1/20 of range is sens 1 full */ \
               coeff = 0.1*(s->hi-s->lo)*s->scale;    \
               *s->val+=delta*coeff + s->extra;       \
               if (*s->val<s->lo) *s->val=s->lo, coeff = 0.0;      \
               else if (*s->val>s->hi) *s->val=s->hi, coeff = 0.0; \
            }                                         \
            if (coeff == 0.0) s->extra = 0.0;          \
            else s->extra = delta*coeff + s->extra - (float)(*s->val - old); \
            return *s->val!=old;                      \
         }                                            \
      case SLIDER_ABORT:                              \
         *s->val=s->old_val;                          \
         return TRUE;      /* auto restore old val */ \
      case SLIDER_END:                                \
            { bool retval = s->old_val!=*s->val;      \
              s->old_val = *s->val;                   \
              return retval;}                         \
      case SLIDER_UPDATE:                             \
         s->old_val = *s->val;                        \
         return FALSE;                                \
      }                                               \
      return FALSE;       /* should never get here */ \
   }
#else    // this is the ! part of __VSLIDER_C
#define GenerateVSliderBuild(type)
#define GenerateVSliderParse(type)
#endif   // __VSLIDER_C

#endif

// $Header: r:/t2repos/thief2/src/editor/vumanui.c,v 1.24 2000/02/19 13:13:47 toml Exp $

#include <string.h>

#include <2d.h>
#include <reg.h>
#include <mprintf.h>
#include <gadget.h>
#include <drawelem.h>
#include <gcompose.h>
#include <config.h>
#include <cfgdbg.h>

#include <command.h>
#include <vumanui.h>
#include <viewmgr_.h>
#include <viewmgr.h>
#include <vmwincfg.h>
#include <editor.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


Region vmParent;
Region vmRegions[MAX_CAMERAS_REAL];

typedef struct vmMouseData
{
   int viewnum;
} vmMouseData;

static vmMouseData ViewRegionData[MAX_CAMERAS_REAL];
static LGadRoot* view_roots[MAX_CAMERAS_REAL];

//////////////////////////////////////////
// VIEW MOUSE HANDLER
//

  // x&y are relative pixel coordinates for this camera
bool brush_edit_mouse(uiMouseEvent *, int camera, int x, int y);

void vm_popup_menu(uiMouseEvent *, int c);
bool vm_mouse_handler(uiEvent* _ev, Region* reg, void* _data)
{
   static int lastview = -1;
   extern bool vm_xmouse;

   uiMouseEvent* ev = (uiMouseEvent*)_ev;
   vmMouseData* data = (vmMouseData*)_data;
   int view = data->viewnum;

   if (!VIEW_AVAIL(view))
      return FALSE;

   if (lastview != view && vm_xmouse)
      vm_set_cur_region(view);
   lastview = view;
   
   // should we perhaps discard non-down events to save time???
   switch (vmWinCfgGetMode())
   {
   case vmWINCFG_MODE_NORMAL:
      if (!brush_edit_mouse(ev, region_to_camera_mapping[view],
                            ev->pos.x - reg->abs_x, ev->pos.y - reg->abs_y))
         vm_popup_menu(ev, region_to_camera_mapping[view]);
      break;
   case vmWINCFG_MODE_SCROLL:
      if (ev->action&MOUSE_LDOWN)
      {
         vmScrollCamera(region_to_camera_mapping[view]);
         vmWinCfgSetMode(vmWINCFG_MODE_NORMAL);
      }
      break;
   }
   return TRUE;
}


DrawElement titledraw = { DRAWTYPE_TEXT, "My Title", 0, 6, 1 };

static LGadMenu vmpop;
static int popup_cam;
static char **popup_commands;
extern bool vm_display_enable;

// is this a fuckup, or what - global state for menus in vm
// this means a menu is in progress, if you need to know
BOOL vm_menu_inprog=FALSE;
// set this if you want to leave "cur camera" focused
BOOL vm_menu_camera_lock=FALSE;
// will have mouse coordinates
int vm_menu_click_x, vm_menu_click_y;

static bool vm_popup_select(int res, LGadMenu *men)
{
   if (res >= 0) {
      int oc = vm_current_camera();
      vm_set_cur_camera(popup_cam);  // hmm, why isnt this happening
      vm_menu_inprog=TRUE; vm_menu_camera_lock=FALSE;
      CommandExecute(popup_commands[res]);
      vm_menu_inprog=FALSE;
      if (!vm_menu_camera_lock)
         vm_set_cur_camera(oc);
   }
   vm_display_enable = TRUE;
   return TRUE;
}

void vm_popup_menu(uiMouseEvent *ev, int c)
{
   extern void vm_get_popup_menu(int c, char ***, char ***, int *, int, int);
   DrawElement *elems;
   char **names, **commands;
   Region *reg=vmGetRegion(camera_to_region_mapping[c]);  // this is stupid
   int x,y, count, i;

   popup_cam = c;
   vm_menu_click_x=ev->pos.x-reg->abs_x;
   vm_menu_click_y=ev->pos.y-reg->abs_y;

   x = ev->pos.x - 20;
   y = ev->pos.y - 20;

   if (x + 40 > grd_bm.w) x = grd_bm.w - 60;
   if (y + 120 > grd_bm.h) y = grd_bm.h - 120;

   if (x < 0) x = 0;
   if (y < 0) y = 0;

   vm_display_enable = FALSE;

   vm_get_popup_menu(c, &names, &commands, &count, ev->pos.x, ev->pos.y);

   popup_commands = commands;

   elems = Malloc(sizeof(DrawElement) * count);

   for (i=0; i < count; ++i) 
   {
      ElementClear(&elems[i]);
      elems[i].draw_type = DRAWTYPE_TEXT;
      elems[i].draw_data = names[i];
   }

   LGadCreateMenuArgs(&vmpop, LGadCurrentRoot(), (short)x, (short)y, -1, -1,
       (short)count, (short)count, elems, vm_popup_select, 0,
       MENU_GRAB_FOCUS | MENU_OUTER_DISMISS | MENU_ALLOC_ELEMS,
       BORDER(DRAWFLAG_BORDER_OUTLINE), &titledraw, 0);
   Free(elems);
}

void vm_mouse_relativize(int c, int *x, int *y)
{
   Region *reg = &vmRegions[camera_to_region_mapping[c]];
   *x -= reg->abs_x;
   *y -= reg->abs_y;
}

//
// Create/Control the GUI
//

void vmCreateGUI(Region* parent, Rect* bounds)
{
   int i;
   make_region(parent,&vmParent,bounds,0,NULL);
   parent = &vmParent;
   vmWinCfgCreate(parent,bounds);
   for (i = 0; i < MAX_CAMERAS_REAL; i++)
   {
      Region* reg = &vmRegions[i];
      Point base, size;
      Rect area;  // area for new region
      int cookie;

      vmGetRegionInfo(i,&base,&size);
      area.ul=base;
      area.lr.x=area.ul.x + size.x;
      area.lr.y=area.ul.y + size.y;
      
      // actually make the region
      make_region(parent,reg,&area,0,NULL);

      ViewRegionData[i].viewnum = i;   // fill in data      
      view_roots[i] = NULL;            // initialize roots      

      // install mouse handler
      uiInstallRegionHandler(reg, UI_EVENT_MOUSE|UI_EVENT_MOUSE_MOVE, vm_mouse_handler, &ViewRegionData[i], &cookie);
   }
}

void vmDestroyGUI(void)
{
   int i;
   vmReleaseAllViews();
   for (i = 0; i < MAX_CAMERAS_REAL; i++)
      region_destroy(&vmRegions[i],FALSE);
   vmWinCfgDestroy();   
}

////////////////////////////////////////////////////////////
// Set/unset region canvas

static int vm_viewreg;
static grs_canvas vm_canv; 
static GUIcompose vm_compose;   

void vm_set_region_canvas(int view)
{
   Region* reg = &vmRegions[view]; 
   Rect r;

   vm_viewreg = view; 
   region_abs_rect(reg,reg->r,&r);
   uiHideMouse(&r); 
   GUIsetup(&vm_compose,&r,ComposeFlagRead,GUI_CANV_ANY); 
}

void vm_unset_region_canvas(void)
{

   GUIdone(&vm_compose);
   uiShowMouse(&vm_compose.area); 

}

////////////////////////////////////////////////////////////
// View grabbage
//

// an array of masks of valid view combos by parm, in default priority order
// @MEMORY: second dim doesn't need to be quite this big

// really needs a 3x1 as well

#define VIEW(x) (1 << (x))
static ubyte view_layouts[vmNumParms][8] = 
{
   // vmGrabSingle
   { 
      VIEW(3),
      VIEW(2), 
      VIEW(1), 
      VIEW(0), 
      0,
   },
   // vmGrabTwoWide
   {
      VIEW(2)|VIEW(3),
      VIEW(0)|VIEW(1),
      0,
   },
   // vmGrabTwoHigh
   {
      VIEW(1)|VIEW(3),
      VIEW(0)|VIEW(2),
      0,
   },
};


ubyte find_view_mask(vmGrabParm parm)
{
   int i;
   ubyte* layouts = &view_layouts[parm][0];
   for (i = 0; layouts[i] != 0; i++)
   {
      ubyte mask = layouts[i];
      bool accept = TRUE;
      int j;
      // check the mask for availible views
      for (j = 0; j < MAX_CAMERAS_REAL; j++)
         if (mask & (1 << j))
            if (view_roots[j] != NULL)
            {
               accept = FALSE;
               break;
            }
      if (accept) return mask;
   }
   return 0;
}

#define MIN_COORD (1 << 16)
#define MAX_COORD (MIN_COORD - 1)

static void build_mask_rect(ulong mask, Rect* r)
{
   bool first = TRUE;
   int i;

   for (i = 0; i < MAX_CAMERAS_REAL; i++)
      if (mask & (1 << i))
      {     
         Region* reg = &vmRegions[i];
         Rect regr;

         region_abs_rect(reg,reg->r,&regr);
         
         if (first) 
         {
            *r = regr;
            first = FALSE;
         }
         else
         {
            RECT_UNION(&regr,r,r);
         }
      }
}

LGadRoot* vmGrabViews(vmGrabParm parm)
{
   ubyte layout = find_view_mask(parm);
   Rect r;
   LGadRoot* root;
   int i;
   
   if (layout == 0)
   {
      Warning(("Failed to grab views. parm = %d\n",parm));
      return NULL;
   }
   
   build_mask_rect(layout,&r);
   root = LGadSetupSubRoot(NULL, LGadCurrentRoot(),r.ul.x,r.ul.y,
        (short)RectWidth(&r),(short)RectHeight(&r));
   GUIErase(&r);

   for (i = 0; i < MAX_CAMERAS_REAL; i++)
      if (layout & (1 << i))
      {
         view_roots[i] = root;
         vm_disable_region(i);
      }
   return root;
}

////////////////////////////////////////

int vmReleaseViews(LGadRoot* release)
{
   int i;
   int count = 0;
   for (i = 0; i < MAX_CAMERAS_REAL; i++)
   {
      if (view_roots[i] == release)
      {
         view_roots[i] = NULL;
         vm_enable_region(i);
         count++;
      }
   }
   if (count > 0)
   {  
      LGadDestroyRoot(release);  
      vm_redraw();
   }
   else
   {
      Warning(("Tried to release a root with no associated views\n"));
   }
   return count;
}

int vmReleaseAllViews(void)
{
   int i;
   int count = 0;

   for(i = 0; i < MAX_CAMERAS_REAL; i++)
      if (view_roots[i] != NULL)
         count += vmReleaseViews(view_roots[i]);
   return count;
}

BOOL vmAllViewsAvailable(void)
{
   int i;
   for(i = 0; i < MAX_CAMERAS_REAL; i++)
      if (view_roots[i] != NULL)
         return FALSE;
   return TRUE;
}
// $Header: r:/t2repos/thief2/src/editor/vumanui.h,v 1.7 2000/01/29 13:13:31 adurant Exp $
#pragma once

#include <region.h>
#include <event.h>
#include <gadbox.h>

#ifndef __VUMANUI_H
#define __VUMANUI_H

//////////////////////////////////////////////////////////////
//   VIEW MANAGER GUI
//////////////////////////////////////////////////////////////

//
// Create the gui, given a bounding rect
//

EXTERN void vmCreateGUI(Region* parent, Rect* bounds);
EXTERN void vmDestroyGUI(void);

//
// Get a view's region
//

EXTERN Region vmRegions[];
#define vmGetRegion(x)  (&vmRegions[x])

//
// Grab some number of views, and make them into a gadget
// 

typedef enum 
{
   vmGrabSingle,  // grab a single view
   vmGrabTwoWide, // grab two side-by-side views
   vmGrabTwoHigh, // grab two up-and-down views
   vmNumParms,
} vmGrabParm;


// create and return an LGadRoot from grabbed views.
EXTERN LGadRoot* vmGrabViews(vmGrabParm parm);

// destroy an LGadRoot and release views.  Return number released.
EXTERN int vmReleaseViews(LGadRoot* release);
EXTERN int vmReleaseAllViews(void);

// see if the views are all free
EXTERN BOOL vmAllViewsAvailable(void);

///////////////
// menuing horror control state

// is this a fuckup, or what - global state for menus in vm
// this means a menu is in progress, if you need to know
EXTERN BOOL vm_menu_inprog;
// set this if you want to leave "cur camera" focused
EXTERN BOOL vm_menu_camera_lock;
// will have mouse coordinates
EXTERN int vm_menu_click_x, vm_menu_click_y;

#endif // __VUMANUI_H

// $Header: r:/t2repos/thief2/src/editor/geditold.rcs,v 1.234 1998/12/31 03:48:11 dc Exp $

// gedit.c
// contains functionality for test program

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>

#include <lg.h>
#include <mprintf.h>
#include <appagg.h>
#include <r3d.h>
#include <md.h>
#include <star.h>
#include <event.h>
#include <config.h>
#include <kbcook.h>
#include <appagg.h>

#include <portal.h>
#include <command.h>
#include <cfgtool.h>

#include <objpos.h>
#include <objedit.h>
#include <osysbase.h>

#include <animlgt.h>
#include <cvtbrush.h>
#include <editbr.h>
#include <editbr_.h>
#include <primal.h>
#include <brlist.h>
#include <brinfo.h>
#include <brobjpro.h>
#include <brrend.h>
#include <vbrush.h>
#include <editobj.h>
#include <csg.h>
#include <csgbrush.h>
#include <viewmgr.h>
#include <status.h>
#include <undoredo.h>
#include <brundo.h>
#include <brquery.h>
#include <gridsnap.h>
#include <gedit.h>
#include <ged_rend.h>
#include <ged_undo.h>
#include <ged_csg.h>
#include <ged_line.h>
#include <winui.h>
#include <ged_room.h>
#include <animlit.h>
#include <family.h>     // for texture family loads and unloads, commands
#include <texprop.h>
#include <media.h>
#include <mediaop.h>
#include <editobj.h>
#include <filetool.h>
#include <vumanui.h>
#include <gamecam.h>
#include <appsfx.h>
#include <scrnman.h>
#include <texmem.h>
#include <txtpnp.h>
#include <objlight.h>
#include <wrmem.h>
#include <preload.h>
#include <modalui.h>
#include <starhack.h>
#include <bldstair.h>
#include <hilight.h>
#include <gedmedmo.h>
#include <doorphys.h>
#include <iobjsys.h>
#include <physapi.h>
#include <missrend.h>
#include <pgrpprop.h>
#include <saveload.h>

#include <resapi.h>
#include <imgrstyp.h>

#include <prof.h>
#include <objshape.h>
#include <objmodel.h>
#include <editsave.h>

#include <rendobj.h>    // for rendobj_name_color

#include <dbmem.h>      // last included file

extern int scale_factor;

Grid cur_global_grid = { 4.0, { 0,0,0 }, { 0,0,0 }, TRUE};

void gedit_register(void);

// initialize geom editor, specifically brush lists
void gedit_init(void)
{
   gedit_register();
   undoStackInit();
   gedLineInit();
}

void gedit_full_redraw(void)
{
   vm_redraw();
}

void gedit_redraw_3d(void)
{
   vm_redraw_from_new3d();
}

void gedit_term(void)
{
   undoStackFree();
   gedLineTerm();
}

static editBrush *gedit_find_point(int camera, int x, int y)
{
   editBrush *us, *winner=NULL;
   int useFlag=brFlag_COLOR_NONE, hIter;
   float best_dist=DISTANCE_INF;  // bigger than x+y screen coordinates

   if (!vm_get_3d(camera)) useFlag|=brFlag_IsoView;
   brushSetupDraw(useFlag,camera);
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      float dist=brushClickCheck(us,x,y);
      if (dist<best_dist)
      {
         winner=us;
         best_dist=dist;
      }
      us=blistIterNext(hIter);
   }
   return winner;
}

BOOL gedit_click(int flags, int x, int y, int camera)
{
   editBrush *us;
   BOOL rv=FALSE;
   int brush, face;

   if (flags&GEDIT_CLICK_IS3D)
      rv=vm_pick_camera(camera,x,y,&brush,&face);

   if (rv)  // if it wasnt 3d, rv is always false here
   {   // this is only taken on 3d cameras which vm can pick for (ie. solid)
      int cur_txt;
      us=csg_brush[brush];
      if ((us)&&(brushGetType(us)!=brType_HOTREGION))
      {
         BOOL do_select=TRUE;
         // some autotexture if palette up thing here....?
         cur_txt=txtPnP_pal_query();
         if (cur_txt!=TXTPNP_NO_PAL_UP)
         {
            int old_face=us->cur_face;  // save face, cause we dont want to change selection
            us->cur_face=face;          //    in tpal mode
            gedit_texture_brush(us,cur_txt);
            us->cur_face=old_face;
            do_select=config_is_defined("txtrpal_select");
            if (txtPnP_attached())
            {
               if (!config_is_defined("txtrpal_no_detach"))
                  txtPnP_detach(); // people hate this....
               if (txtPnP_attached())
                  do_select=TRUE;
            }

         }
         if (do_select)
         {
            us->cur_face=face;
            flags&=~GEDIT_CLICK_FANCY;  // cant be a fancy click in 3d scene
            flags|=GEDIT_CLICK_NOTOGGLE;
            brSelect_Flag(us)&=~brSelect_COMPLEX;
            vBrush_click(us,flags,x,y);   // needs xy for fancy clicks
         }
      }
      else
         rv=FALSE;
   }                              // or should fancy clicks autotexture?
   else
   {
      vm_set_camera_canvas(camera);
      vm_start_3d(camera);
      us=gedit_find_point(camera,x,y);
      if (us)
      {
         vBrush_click(us,flags,x,y);   // needs xy for fancy clicks
         rv=TRUE;
      }
      vm_end_3d(camera);
      vm_unset_camera_canvas();
   }
   return rv;
}

// get the maximal extent of a level
mxs_vector *gedit_get_extent(BOOL hot_region_p)
{
   static mxs_vector bounds[2];
   int hot_found=0, hIter;
   editBrush *us;

   mx_mk_vec(&bounds[0],0.0,0.0,0.0);
   mx_mk_vec(&bounds[1],0.0,0.0,0.0);
   brushConvertStart();
   us=blistIterStart(&hIter);
   while (us!=NULL)
   {
      if (hot_region_p)
      {
         if (brushGetType(us)==brType_HOTREGION)
         {
            brushCheckExtents(us,bounds);
            hot_found++;
         }
      }
      else
         brushCheckExtents(us,bounds);
      us=blistIterNext(hIter);
   }
   brushConvertEnd();
   if (hot_region_p&&hot_found==0)
   {  // bounds are still 0, since we saw nothing, so lets just go do everything
      brushConvertStart();
      us=blistIterStart(&hIter);
      while (us!=NULL)
      {
         brushCheckExtents(us,bounds);
         us=blistIterNext(hIter);
      }
      brushConvertEnd();
      Warning(("no hot region\n"));
   }
   return &bounds[0];
}

// if you need to take all objects out and put them back in?
static void gedit_replace_all_objs(void)
{
   editobjFullDeref();
   editobjFullReref();
}

static int focus_br_id=-1;

// inside gedit, we want non scripted lights, so this deals
void gedit_enter(void)
{
#ifdef FAST_DYNAMIC_LIGHTING
   gedcsg_relight_level();
#endif
   if (focus_br_id!=-1)
      vBrush_SelectBrush(brFind(focus_br_id));
   editUndoSuspend(FALSE);
   vm_resume(); 
}

void gedit_exit(void)
{
   if (gedit_editted)
   {
      if (winui_GetYorN("Portalization Not Up to Date.  Reportalize?"))
         build_level();
   }
   else if (!gedcsg_lighting_ok)
      if (winui_GetYorN("Lighting Not Up to Date.  Relight?"))
         gedcsg_relight_level();

   if (!g_RoomsOK)
   {
#if 0
      if (winui_GetYorN("Room database Not Up to Date.  Recompile?"))
#endif
         ged_compile_rooms();
   }

#ifdef FAST_DYNAMIC_LIGHTING
   gedcsg_relight_level();
#endif
   editUndoSuspend(TRUE);
   undoClearUndoStack();
   focus_br_id=vBrush_GetSel()->br_id;
   vm_suspend(); 
}

///////////////////
// snapping control

// this is to make following brush getting code easier/smaller (and backwards compatible, to boot)
#define cur vBrush_editBrush_Get

#define FLOAT_SNAP_TOL 0.00001
static float  gedit_snap_pos=0.5, gedit_snap_sz=0.5;
static fixang gedit_snap_ang=0x1000;
static BOOL   gedit_snap_placement=TRUE;

// returns whether or not it snapped, in its mind
BOOL _floatSnap(float *val, float snap)
{
   float newval=floor(((*val)+snap/2) / snap) * snap;
   float oldval=*val;
   *val=newval;
   return newval!=oldval;
}

BOOL _fixangSnap(fixang *val, fixang snap)
{
   fixang toround=(*val)+snap/2;
   fixang newval=toround-(toround%snap);
   fixang oldval=*val;
   *val=newval;
   return newval!=oldval;
}

BOOL _gedit_float_snap(float *val)
{
   return _floatSnap(val,cur_global_grid.line_spacing);
}

static mxs_vector vbrush_hack_delta;

static void delta_snap_op(editBrush *us)
{
   mx_addeq_vec(&us->pos,&vbrush_hack_delta);
}


BOOL snap_brush_by_vertex_hack(editBrush *us)
{
   int i;
   BOOL snapped = FALSE;
   mxs_vector bounds[2];
   mxs_vector size;
   float r;

   brushConvertStart();
   mx_copy_vec(&bounds[0],&us->pos);
   mx_copy_vec(&bounds[1],&us->pos);
   brushCheckExtents(us,bounds);
   brushConvertEnd();
   mx_sub_vec(&size,&bounds[1],&bounds[0]);
   mx_diveq_vec(&size,2.0F);
   for (i=0; i<3; i++)
   {
      // okay, now figure out whether to snap real or half
      r = (float)fmod((double)size.el[i],(double)cur_global_grid.line_spacing);
      // if we were 1.0 aligned, center must also be 1.0 aligned
      if (r <= cur_global_grid.line_spacing / 4) // if exact match, 1.0 aligned
      {
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing);
      }
      else
      {
         // if we were 0.5 aligned, center must also be 0.5 aligned, but NOT 1.0 aligned
         us->pos.el[i] += cur_global_grid.line_spacing / 2; // first put it off by 0.5
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing); // then "1.0" align
         us->pos.el[i] -= cur_global_grid.line_spacing / 2; // now restore from offset
      }
   }

   return(snapped);
}

BOOL gedit_snap_brush(editBrush *us)
{
   BOOL snapped=FALSE;
   int i;

   if (!cur_global_grid.grid_enabled)
      return FALSE;
   if (us==NULL)
      us=cur();
   if (brSelect_Flag(us)==brSelect_VIRTUAL)
   {
      // note that vbrush snap only defined for positioning, 
      // not angle or size, is this OK?
      if (config_is_defined("vbrush_snap"))
      {
         editBrush *mbsel;
         mxs_vector oldpos;

         // record old data
         mbsel = vBrush_GetSel();
         mx_copy_vec(&oldpos, &mbsel->pos);

         // snap center point
         snap_brush_by_vertex_hack(mbsel);

         // note delta and restore
         mx_sub_vec(&vbrush_hack_delta,&mbsel->pos,&oldpos);
         mx_copy_vec(&mbsel->pos,&oldpos);

         // apply delta to all brushes individually
         // since we have no mechanism for passing data into this we stuff
         // the translation factor into the aptly named vbrush_hack_delta
         vBrush_GroupOp(FALSE, delta_snap_op);

         return snapped;
      }
      else
         return FALSE;
   }
   if (!((brushGetType(us)==brType_TERRAIN)||(brushGetType(us)==brType_ROOM)))
      return FALSE;
   if (config_is_defined("new_snap"))
   {
      for (i=0; i<3; i++)
      {  
         // note we snap size first to keep the game from resizing already happily sized brushes
         // find the closest size that can be 0.5 or 1.0 aligned
         snapped|=_floatSnap(&us->sz.el[i],cur_global_grid.line_spacing/2);
      }
      snapped |= snap_brush_by_vertex_hack(us);
      for (i=0; i < 3; i++)
         snapped|=_fixangSnap(&us->ang.el[i],gedit_snap_ang);
   }
   else
   {
      for (i=0; i<3; i++) {
         snapped|=_floatSnap(&us->pos.el[i],cur_global_grid.line_spacing);
         snapped|=_floatSnap(&us->sz.el[i],cur_global_grid.line_spacing);
         snapped|=_fixangSnap(&us->ang.el[i],gedit_snap_ang);
      }
   }
   return snapped;
}

void gedit_set_snaps(float snap_pos, float snap_sz, fixang snap_ang)
{
   if (snap_pos>0) gedit_snap_pos=snap_pos;
   if ( snap_sz>0) gedit_snap_sz =snap_sz;
   if (snap_ang>0) gedit_snap_ang=snap_ang;  // 1 really means no snap
}

////////////////////
/// grid stuff

void grid_get_from_current(void)
{
   cur_global_grid = cur()->grid;
   gedit_full_redraw();
}

void grid_set_from_current(void)
{
   cur()->grid = cur_global_grid;
}

void grid_toggle(void)
{
   cur_global_grid.grid_enabled = !cur_global_grid.grid_enabled;
   gedit_full_redraw();
}

void grid_scale(float scale)
{
   cur_global_grid.line_spacing *= scale;
   gedit_full_redraw();
}

void grid_abs_scale(float scale)
{
   cur_global_grid.line_spacing = scale;
   gedit_full_redraw();
}

void grid_pow2_scale(int pow2)
{
   float real_scale=scale_pow2int_to_float(pow2);
   grid_abs_scale(real_scale);
}

// this, sadly, needs to convert the scale (currently a spacing float) to a pow2 rep
// so we do the stupid thing, cause we are, as they say... stupid
int get_pow2_scale(void)
{
   float val;
   int i;

   for (i=8; i<18; i++)
   {
      val=scale_pow2int_to_float(i);
      if (val>=cur_global_grid.line_spacing)
         return i;
   }
   return 16;  // default, since we dont know
}

//////////////
// brush build/control stuff

int brush_build_type=brType_TERRAIN;

// if build_type is -1, then if old that is type, else type is left alone, else use build_type
// if old is non-Null, then misc_settings (old format) are assumed, and old is passed down to field_update
// at_end means place new brush at end, else place at current
BOOL gedit_full_create_brush(editBrush *new_br, editBrush *old, ulong flags, int build_type)
{
   IObjectSystem *pObjSys = AppGetObj(IObjectSystem);
   BOOL at_end = flags & GEDIT_CREATE_AT_END;
   ulong field_flags = brField_New;

   IObjectSystem_Lock(pObjSys);

   if (build_type!=-1)
      brushSetType(new_br,build_type);
   else if (old)
      brushSetType(new_br,brushGetType(old));

   if (flags & GEDIT_CREATE_CLONE)
      field_flags |= brField_Clone;
   brush_field_update(new_br,old,field_flags);      // copy over relevant settings - we are always a new brush

   blistSeek(0,at_end?SEEK_END:SEEK_CUR);    // now actually put the thing there
   blistInsert(new_br);                      // put us in the list
   editUndoStoreCreate(new_br);
   if (brushGetType(new_br)==brType_TERRAIN)
      gedit_db_update(FALSE);
   gedit_full_redraw();

   IObjectSystem_Unlock(pObjSys);
   SafeRelease(pObjSys);

   return TRUE;
}

void gedit_set_default_brush_type(int br_type)
{
   brush_build_type=br_type;
}

int gedit_default_brush_type(void)
{
   return brush_build_type;
}

///////////////////
// status and control

static BOOL auto_portalize;
static BOOL auto_roombuild;

BOOL gedit_editted=TRUE;

void gedit_db_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_portalize)
   {
      build_level();
      gedit_redraw_3d();
   }
   else
   {
      gedit_editted=TRUE;
      StatusField(SF_FILESTATE,"*");
   }
}

void gedit_light_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_portalize)
   {
      gedcsg_relight_level();
      gedit_redraw_3d();
   }
   else
   {
      gedcsg_lighting_ok=FALSE;
      StatusField(SF_FILESTATE,"*");
   }
}

void gedit_room_update(BOOL redraw)
{
   if (redraw)
      gedit_full_redraw();
   if (auto_roombuild)
      ged_compile_rooms();
   else
   {
      g_RoomsOK = FALSE;
      StatusField(SF_FILESTATE,"*");
   }
}

// @VBRUSH
// fully general find a brush, move it to n
// kinda icky since all brush ops op on current, so it is a mess
// i should just go do this right
bool set_brush_to_time_n(editBrush *br, int n)
{
   editBrush *old_Curs=blistGet();
   int oldPos=blistCheck(br);
   bool is_us=(br==old_Curs), rv=TRUE;

   if (oldPos==-1) return FALSE;
   if (oldPos==n)  return TRUE;
   if (!is_us)
      blistSetPostoBrush(br);
#ifdef DBG_ON
   if (br!=blistDelete())
      Warning(("Hey delete didnt delete us???"));
#else
   blistDelete();
#endif
   //   if ((n<oldPos)&&(n>0)) n--;   // ????
   if (n>0) n--;
   if (!blistSeek(n,SEEK_SET))
   {
      rv=FALSE;
      Warning(("Hey, couldnt seek to new time"));
   }
   blistInsert(br);
   blistSetPostoBrush(is_us?br:old_Curs);
   if (brushGetType(br)==brType_TERRAIN)   // if we are terrain, the db needs to rebuild now
      gedit_db_update(FALSE);
   return rv;
}

// @TODO: undo support for these!!
static void move_brush_to_end_of_time(void)
{
   editBrush *modBrush=blistDelete();          // delete the existing place for the brush
   blistSeek(0,SEEK_END);                      //   get to the end of time
   blistInsert(modBrush);                      //   put us back in the list
   brush_field_update(modBrush,NULL,brField_Old);    // update any field data
   if (brushGetType(modBrush)==brType_TERRAIN) // if we are terrain, the db needs to rebuild now
      gedit_db_update(FALSE);
}

static void move_brush_to_time_n(int n)
{
   set_brush_to_time_n(cur(),n);
}

/////////////////////////////
// texture control

short *_geditGetTxPtr(editBrush *br)
{
   short *tx;
   if (br->cur_face == -1)     // global texture, or per face
      tx=&br->tx_id;
   else
      tx=&br->txs[br->cur_face].tx_id;
   return tx;
}

// this is incomplete
// it needs to have real code for multiwallset
bool geditTxCycle(editBrush *br, int cycle)
{
   short *tx=_geditGetTxPtr(br);

   if (*tx+cycle>=texmemGetMax())
      *tx=0;
   else if (*tx+cycle<0)
      *tx=texmemGetMax()-1;
   else
      *tx=*tx+cycle;

   return TRUE;
}

// returns if it made the change
BOOL gedit_reassign_texture(editBrush *br, BOOL texture_only)
{
   if (gedit_editted)
      Status("Must reportalize to see texture.");
   else
      ReassignTexture(br->br_id,texture_only);
   return !gedit_editted;
}

static void _tex_finish(editBrush *br)
{
   if (gedit_reassign_texture(br,TRUE))
      gedit_redraw_3d();
   editUndoStoreBrush(br);
}

static void cycle_tex(int dir)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   geditTxCycle(modBrush, dir);
   _tex_finish(modBrush);     // does the undo
}


void gedit_texture_brush(editBrush *br, int new_tx)
{
   short *tx;
   editUndoStoreStart(br);
   tx=_geditGetTxPtr(br);
   *tx=new_tx;
   _tex_finish(br);     // does the undo
}

static void gedit_set_brush_tx(int new_tx)
{
   gedit_texture_brush(cur(),new_tx);
}

static void gedit_reset_br_textures(int new_tx)
{
   editBrush *modBrush=cur();
   short *tx;
   int i;

   if (new_tx==-1) { Warning(("Given -1 as new_tx\n")); new_tx=0; }
   editUndoStoreStart(modBrush);
   modBrush->cur_face=-1;     // set to default face
   tx=_geditGetTxPtr(modBrush);
   *tx=new_tx;
   for (i=0; i<modBrush->num_faces; i++)
   {
      modBrush->cur_face=i;
      tx=_geditGetTxPtr(modBrush);
      *tx=-1;
      if (gedit_reassign_texture(modBrush,TRUE))
         gedit_redraw_3d();
   }
   //   _tex_finish(modBrush);     // does the undo - but a reassign as well?
   editUndoStoreBrush(modBrush);
}

static void sky_tex(void)
{
   editBrush *modBrush=cur();
   short *tx=_geditGetTxPtr(modBrush);
   editUndoStoreStart(modBrush);
   *tx = 249;
   _tex_finish(modBrush);     // does the undo
}

static void hack_align_texture(void)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   if (modBrush->cur_face == -1)
   {
      int i;
      for (i=0; i<modBrush->num_faces; i++)
         modBrush->txs[i].tx_rot = TEXINFO_HACK_ALIGN;
   } else
      modBrush->txs[modBrush->cur_face].tx_rot = TEXINFO_HACK_ALIGN;
   _tex_finish(modBrush);
}

//////////////////////
// media control

static void media_change(editBrush *modBrush, int med)
{
   editUndoStoreStart(modBrush);
   modBrush->media = med;
   editUndoStoreBrush(modBrush);
   gedit_db_update(FALSE);
}

static void cycle_media(int dir)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
      media_change(modBrush,(modBrush->media + dir + num_media_ops) % num_media_ops );
}

static void set_medium(int med)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
      media_change(modBrush,med);
}

///////////////
// misc hacks start around here..

// if im a terrain brush, change me to a room
void gedit_brush_to_room(float grow_pct)
{
   editBrush *tmp;
   editBrush *modBrush = cur();
   if ((brushGetType(modBrush)!=brType_TERRAIN)&&(brushGetType(modBrush)!=brType_HOTREGION))
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }
   /*
   // this removed to allow area & funky shaped brushes to room-ize, though they
   // do so a little oddly, it can still be useful.  Xemu 5/14/98
   if (modBrush->primal_id!=PRIMAL_CUBE_IDX)
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }
   */
   if (brSelect_Flag(modBrush)==brSelect_VIRTUAL)
   {
      Status("Not a valid brush to clone to room\n");
      return;
   }

   tmp=brushInstantiate(PRIMAL_CUBE_IDX);
   tmp->pos=modBrush->pos;
   tmp->sz=modBrush->sz;
   tmp->ang=modBrush->ang;
   if (grow_pct>0.01)
      mx_scaleeq_vec(&tmp->sz,1.0+(grow_pct/100.0));
   gedit_full_create_brush(tmp,modBrush,GEDIT_CREATE_AT_END,brType_ROOM);
   vBrush_NewBrush(tmp);
}

// if im a terrain brush, do appropriate parameter adoption to rest of selection
void gedit_brush_adopt(int which_val)
{
   editBrush *modBrush = cur();
   if (brushGetType(modBrush) == brType_TERRAIN)
   {

   }
}

static int prim_cur_sides=4, prim_cur_type=0, prim_cur_face=0;

static void prim_finish(void)
{
   if (prim_cur_type==0)
      editbr_default_primal=PRIMAL_CUBE_IDX;
   else
      editbr_default_primal=primalID_FullMake(prim_cur_type,prim_cur_face,prim_cur_sides);
}

void gedit_set_primal_sides(int n)
{
   if ((n<3)||(n>=USED_PRIMAL_SIDES))
      Warning(("Invalid number of sides\n"));
   else
   {
      prim_cur_sides=n;
      prim_finish();
   }
}

// 0 is cube, 1 cyl, 2 pyr, 3 corner pyr
void gedit_set_primal_type(int t)
{
   if ((t<0)||(t>=PRIMAL_TYPE_MAX))
      Warning(("Invalid primal type\n"));
   else
   {
      prim_cur_type=t;
      prim_finish();
   }
}

// are we face or vertex aligned
void gedit_set_primal_facevertex(bool use_face)
{
   prim_cur_face=use_face?PRIMAL_ALIGN_FACE:0;
   prim_finish();
}

// hmmmm....
void gedit_set_cube(void)
{
   editbr_default_primal=PRIMAL_CUBE_IDX;
}

void gedit_set_special(int spectype)
{
   editbr_default_primal=primalID_Make(PRIMAL_TYPE_SPECIAL,spectype);
}

static void reset(void)
{
   editBrush *modBrush=cur();
   editUndoStoreStart(modBrush);
   modBrush->ang.tx = modBrush->ang.ty = modBrush->ang.tz = 0;
   editUndoStoreBrush(modBrush);
   gedit_db_update(TRUE);
}

void fit_world(bool mode)
{
   mxs_vector *res = gedit_get_extent(mode);
   if (res)
      vm_fit_cameras_to_region(res,res+1);
   gedit_full_redraw();
}

void gedit_cam_to_brush(void)
{
   static int which_ang[]={2,2,2,2,1,1};
   static int what_to_add[]={0x8000,0xC000,0,0x4000,0xC000,0x4000};
   mxs_vector *pos;
   mxs_angvec *ang;
   editBrush *br=blistGet();

   if (br!=NULL)
      if (vm_spotlight_loc(&pos,&ang))
         if ((pos!=NULL)&&(ang!=NULL))
         {
            *pos=br->pos;
            *ang=br->ang;
            if (brushGetType(br)==brType_TERRAIN)
               if (br->cur_face!=-1)
                  ang->el[which_ang[br->cur_face]]+=what_to_add[br->cur_face];
            vm_redraw_from_camera();
         }
}

static bool gedit_allow_lazy_updates=FALSE;
static bool gedit_lazy_oldstate;
static BOOL gedit_drag_happening=FALSE;
static BOOL cur_sel_changed=FALSE;

BOOL gedit_is_drag_in_prog(void)
{
   return gedit_drag_happening;
}

void gedit_setup_check_lazy_drag(void)
{
   if (!gedit_allow_lazy_updates)
   {
      gedrend_show_current=FALSE;
      vm_redraw();
      vm_render_cameras();
      gedrend_show_current=TRUE;
      vm_redraw_from_select();
      vm_render_cameras();
   }
   gedit_lazy_oldstate=gedit_allow_lazy_updates;
   gedit_allow_lazy_updates=TRUE;
   gedit_drag_happening=TRUE;
}

void gedit_finish_check_lazy_drag(void)
{
   gedit_allow_lazy_updates=gedit_lazy_oldstate;
   if (!gedit_allow_lazy_updates)
      gedit_full_redraw();  // really should look at lazy update i guess....?
   gedit_drag_happening=FALSE;
}

// will not bother redrawing, unless user has turned on no_lazy_updates
static void gedit_lazy_update(editBrush *br)
{  // shouldnt be blistGet, should be multibrush compatible!!
   if ((br!=vBrush_editBrush_Get())||!gedit_allow_lazy_updates)
      gedit_full_redraw();      // anal mode, always redraw
   else
      vm_redraw_from_select();  // of course, lazy update may have already flagged it all to redraw...
}

// @TODO: rethink this when i can think
// raw change and refresh
void gedit_raw_change_brush(editBrush *us, BOOL is_new, BOOL change_world, BOOL change_db)
{
   if (brSelect_Flag(us) == brSelect_VIRTUAL)  // do we need this???
   {
      gedit_lazy_update(us);
   }
   else
   if (brushGetType(us) == brType_TERRAIN)
   {
      if (change_db)
         gedit_db_update(FALSE);
   }
#ifdef INCREMENTAL_FLOW_UPDATE
   else
   if (brushGetType(us) == brType_FLOW)
   {
      change_world = TRUE;
      GEdMedMoMarkWaterAllBrushes();
   }
#endif
   else
   if ((brushGetType(us) == brType_LIGHT)||
       ((brushGetType(us) == brType_OBJECT) && (brObjProp_getLightLevel(brObj_ID(us)) >= 0.0)))
   {
      if (!is_new)
      {
         if (change_db)
            gedit_light_update(FALSE);
      }
      else
         change_world=TRUE;
   }
   else
   if ((brushGetType(us) == brType_OBJECT) && IsDoor(brObj_ID(us)))
   {
      UpdateDoorBrush(brObj_ID(us));
      gedit_lazy_update(us);
   }
   else
   if (brushGetType(us) == brType_ROOM)
   {
      change_world = TRUE;
      if (change_db)
         gedit_room_update(FALSE);
   }
   else
      gedit_lazy_update(us);

   //   vm_redraw_from_select();  // of course, lazy update may have already flagged it all to redraw...
   gedit_lazy_update(us);
   if (change_world || (brushGetType(us) == brType_OBJECT))
      gedit_redraw_3d();    // this still isnt quite right - we still do this too much
   cur_sel_changed=TRUE;
}

// @VBRUSH: should this go in vbrush, perhaps?
// call me when you change a brush, really
void i_changed_the_brush(editBrush *us, BOOL snap, BOOL is_new, BOOL change_world)
{
   if (us==NULL)
      return;
   brush_field_update(us,NULL,brField_Old);
   if (snap)
      gedit_snap_brush(us);
   gedit_raw_change_brush(us,is_new,change_world,TRUE);
}

void gedit_change_selection(void)
{  // really needs to know if brush selection was changed
   if (cur_sel_changed&&gedit_allow_lazy_updates)
      vm_redraw();
   else
      vm_redraw_from_select();
   cur_sel_changed=FALSE;
}

void gedit_redraw_selection(void)
{
   vm_redraw_from_select();
}

// says - ok - data has changed - set me to changed, but dont do much else
void gedit_change_current_brush(void)
{
   if (gedit_allow_lazy_updates)
   {
      vm_redraw_from_select();
      cur_sel_changed=TRUE;
   }
   else
   {
      vm_redraw();
      cur_sel_changed=FALSE;
   }
}

/////////////////
// moving brushes around

static void stretch(int axis)
{
   editBrush *modBrush=cur();
   float amt = 0.125 * scale_factor;
   if (axis >= 3) { amt = -amt; axis -= 3; }
   if (axis >= 0 && axis < 3) {
      // don't allow a brush to be shrunk to nothing
      if (amt < 0 && modBrush->sz.el[axis] <= -amt)
         return;
      editUndoStoreStart(modBrush);
      modBrush->sz.el[axis] += amt;
      i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
      editUndoStoreBrush(modBrush);
   }
}

void translate(int axis)
{
   editBrush *modBrush = cur();
   float amt;
   if (config_is_defined("translate_by_grid"))
   {
      amt = cur_global_grid.line_spacing;
      //mprintf("spacing = %g\n",cur_global_grid.line_spacing);
   }
   else
      amt = 0.125 * scale_factor;
   if (axis >= 3) { amt = -amt; axis -= 3; }
   if (axis >= 0 && axis < 3) {
      editUndoStoreStart(modBrush);
      modBrush->pos.el[axis] += amt;
      i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
      editUndoStoreBrush(modBrush);
   }
}

static void rotate(int axis)
{
   editBrush *modBrush = cur();
   int amt = 0x100 * scale_factor;
   if (axis >= 3) { amt = -amt; axis -= 3; }
   editUndoStoreStart(modBrush);
   switch (axis) {
      case 0: modBrush->ang.tx += amt; break;
      case 1: modBrush->ang.ty += amt; break;
      case 2: modBrush->ang.tz += amt; break;
   }
   i_changed_the_brush(modBrush,FALSE,FALSE,FALSE);
   editUndoStoreBrush(modBrush);
}

// if current brush is an object, floor it correctly
void gedit_floor_brush(editBrush *us, mxs_vector *dir)
{
   Location cur_loc, down_loc, bbox_hit_loc, phys_hit_loc;
   mxs_vector minv,maxv;
   mxs_vector down;
   ObjPos *cur_pos;
   ObjID obj_id;
   mxs_vector new_vec;
   int i;

   BOOL bbox_hit = FALSE;
   BOOL phys_hit = FALSE;

   mxs_vector bbox_offset;
   mxs_vector phys_offset;

   if (brushGetType(us)!=brType_OBJECT) return;   // needs to be an object
   if (brSelect_Flag(us)&brSelect_VIRTUAL) return; // and to be real

   // do the real work
   mx_copy_vec(&down, dir);

   obj_id=brObj_ID(us);
   cur_pos=ObjPosGet(obj_id);
   if (cur_pos==NULL)  // hmmm... cant find us
   {
      Warning(("Tried to floor a non-existant object\n"));
      return;
   }
   cur_loc=cur_pos->loc;
   if ((cur_loc.vec.x!=us->pos.x)||(cur_loc.vec.y!=us->pos.y)||(cur_loc.vec.z!=us->pos.z))
      Warning(("Brush isnt where object is\n"));

   ObjGetObjOffsetBBox(obj_id,&minv,&maxv);
   mx_addeq_vec(&down,&cur_loc.vec);  // bottom of case
   MakeHintedLocationFromVector(&down_loc,&down,&cur_loc);

   if (!PortalRaycast(&cur_loc, &down_loc, &bbox_hit_loc, 0))
   {
      bbox_hit = TRUE;
    
      mx_sub_vec(&bbox_offset, &bbox_hit_loc.vec, &cur_loc.vec);

      for (i=0; i<3; i++)
      {
         if (dir->el[i] > 0)
            bbox_offset.el[i] -= maxv.el[i];
         else
         if (dir->el[i] < 0)
            bbox_offset.el[i] -= minv.el[i];
      }
   }

   if (!PhysObjMoveDir(brObj_ID(us), &cur_loc, &down_loc, &phys_hit_loc))
   {
      phys_hit = TRUE;

      mx_sub_vec(&phys_offset, &phys_hit_loc.vec, &cur_loc.vec);
   }

   if (bbox_hit && phys_hit)
   {
      if (mx_mag2_vec(&bbox_offset) < mx_mag2_vec(&phys_offset))
         mx_add_vec(&new_vec, &cur_loc.vec, &bbox_offset);
      else
         mx_add_vec(&new_vec, &cur_loc.vec, &phys_offset);
   }
   else
   if (bbox_hit)
   {
      mx_add_vec(&new_vec, &cur_loc.vec, &bbox_offset);
   } 
   else
   if (phys_hit)
   {
      mx_add_vec(&new_vec, &cur_loc.vec, &phys_offset);
   }
   else
   {
      Warning(("cound't find the ground!\n"));
      return;
   }

   us->pos = new_vec;
   i_changed_the_brush(us, FALSE, FALSE, TRUE);
   editUndoStoreBrush(us);
}

void gedit_floor_me(void)
{
   mxs_vector down;
   down.x = 0; down.y = 0; down.z = -20.0;
   gedit_floor_brush(cur(),&down);
}

void gedit_ceil_me(void)
{
   mxs_vector up;
   up.x = 0; up.y = 0; up.z = 20.0;
   gedit_floor_brush(cur(),&up);
}

void gedit_wall_me(void)
{
   mxs_vector walldir,unitvec;
   mxs_matrix rotmat;
   ObjID obj_id;
   ObjPos *cur_pos;

   obj_id=brObj_ID(cur());
   if (obj_id == OBJ_NULL)
      return;

   cur_pos=ObjPosGet(obj_id);

   // reverse our orientation vector
   mx_ang2mat(&rotmat, &cur_pos->fac);
   unitvec.x = -20.0F; unitvec.y = 0; unitvec.z = 0;
   mx_mat_mul_vec(&walldir, &rotmat, &unitvec);

   gedit_floor_brush(cur(),&walldir);
}

/////////////////////////

void gedit_info_window(void)
{
   char *info=(char *)Malloc(1024);
   editBrush *loop;
   int br_per_type[brType_ROOM-brType_TERRAIN+1];
   int act_hr=0, me_only=0;
   int hIter;

   // gather brush stats   
   memset(br_per_type,0,sizeof(br_per_type));
   loop=blistIterStart(&hIter);
   while (loop!=NULL)      // go through and make any other MeOnly's active
   {
      br_per_type[brushGetType(loop)-brType_TERRAIN]++;
      if (brushGetType(loop)==brType_HOTREGION)
         if (brHot_IsMEONLY(loop))   // this was a meonly
            me_only++;
         else if (brHot_Status(loop)==brHot_ACTIVE)   // this was a meonly
            act_hr++;
      loop=blistIterNext(hIter);
   }
   strcpy(info,"Brush Counts\n");
   sprintf(info+strlen(info),"%d Terrain ",br_per_type[brType_TERRAIN-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Object\n",br_per_type[brType_OBJECT-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Light ",br_per_type[brType_LIGHT-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Room\n",br_per_type[brType_ROOM-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Flow ",br_per_type[brType_FLOW-brType_TERRAIN]);
   sprintf(info+strlen(info),"%d Area -",br_per_type[brType_HOTREGION-brType_TERRAIN]);
   if (me_only)
      strcat(info,"MeOnly'd");
   else
      sprintf(info+strlen(info)," %d active\n",act_hr);
   _editsave_text_info(info);
   winui_Text(info);
   Free(info);
}

void gedit_brush_to_mono(int brush_id)
{
   editBrush *br;
   char buf[200];
   if (brush_id==0)
      br=cur();
   else
      br=brFind(brush_id);
   mprintf("Brush %d (0x%x)\n",br->br_id,br->br_id);
   sprintf(buf,"  Pos: %.9f %.9f %.9f\n",br->pos.el[0],br->pos.el[1],br->pos.el[2]);
   mprintf(buf);
   sprintf(buf,"   Sz: %.9f %.9f %.9f\n",br->sz.el[0],br->sz.el[1],br->sz.el[2]);
   mprintf(buf);
   sprintf(buf,"  Ang: %x %x %x\n",br->ang.el[0],br->ang.el[1],br->ang.el[2]);
   mprintf(buf);
}

/////////////////////////

editBrush *gedit_get_meonly_brush(void)
{
   editBrush *loop;
   int hIter;

   loop=blistIterStart(&hIter);
   while (loop!=NULL)      // go through and make any other MeOnly's active
   {
      if (brushGetType(loop)==brType_HOTREGION)
         if (brHot_IsMEONLY(loop))   // this was a meonly
            break;
      loop=blistIterNext(hIter);
   }
   if (loop!=NULL)
      blistIterDone(hIter);
   return loop;
}

static void gedit_go_to_meonly(void)
{
   editBrush *br=gedit_get_meonly_brush();
   if (br)
      vBrush_SelectBrush(br);
   else
      Status("No MeOnly brush");
}

static void gedit_hots_state(int new_state)
{
   editBrush *us=cur();

   if (brushGetType(us)!=brType_HOTREGION)
      return;   // we arent a hot region, so go home
   // parse the toggles first
   if (new_state==brHot_TOGMEONLY)
   {
      if (brHot_IsMEONLY(us))              // we are the meonly, so we just need
         new_state=brHot_GetBase(us);      // to revert to our base type
      else                                 // else we need to go check if there is
      {                                    // a meonly and clear it, then set us
         editBrush *old_meonly=gedit_get_meonly_brush();
         new_state=brHot_GetBase(us)|brHot_MEONLY;
         if (old_meonly)
            brHot_Status(old_meonly)&=brHot_BASEMASK;  // so filter the meonly out
      }
   }
   else if (new_state==brHot_TOGACTIVE)
   {
      new_state=(brHot_GetBase(us)==brHot_ACTIVE)?brHot_INACTIVE:brHot_ACTIVE;
      if (brHot_IsMEONLY(us)) new_state|=brHot_MEONLY;
   }
   brHot_Status(us)=new_state;
   gedit_full_redraw();
}

///////////////////////////
// busywait/full screen mode

// lifted from dragbox, perhaps they should be in some header?
#define ismouse(ev)     ((ev).type & (UI_EVENT_MOUSE | UI_EVENT_MOUSE_MOVE))
#define iskbd(ev)       ((ev).type == UI_EVENT_KBD_COOKED)

extern void redraw_all_cmd(void);

// do a busywait in modal ui for next event we care about
void gedit_busywait(BOOL clear)
{
   uiEvent ev;

   modal_ui_start(MODAL_CHECK_NONE);
   while (1)
   {
      if (modal_ui_get_event(&ev))
         if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               break;
         }
      modal_ui_update();
   }
   modal_ui_end();
   if (clear) gr_clear(0);
   redraw_all_cmd();
}

// show an image file
static void gedit_show_image(char *str)
{
   IResMan *pResMan = AppGetObj(IResMan);
   IRes *pRes = IResMan_Bind(pResMan, str, RESTYPE_IMAGE, NULL, NULL, 0);

   if (pRes)
   {  // really should check screen size and mode here, maybe switch in and out
      grs_bitmap *bm=(grs_bitmap *) IRes_Lock(pRes);
      gr_clear(0);
      gr_bitmap(bm, 0, 0);
      gedit_busywait(TRUE);
      IRes_Unlock(pRes);
      SafeRelease(pRes);
   }
   else
      Warning(("Cant find %s\n",str));

   SafeRelease(pResMan);
}

static void gedit_get_pixel_color(char *str)
{
   uiEvent ev;

   if (str && *str!='\0')
   {
      int x=1,y=1, c;
      sscanf(str,"%d %d",&x,&y);
      c=gr_get_pixel(x,y);
      mprintf("Pixel at %d,%d is color %d (0x%x) (%d %d %d)\n",x,y,c,c,grd_pal[c*3],grd_pal[c*3+1],grd_pal[c*3+2]);
      return;
   }
   // unhide mouse here?? - if we support game mode, or something?
   uiShowMouse(NULL);
   modal_ui_start(MODAL_CHECK_NONE);
   while (1)
   {
      if (modal_ui_get_event(&ev))
         if (iskbd(ev))
         {
            uiCookedKeyEvent *kev = (uiCookedKeyEvent *) &ev;
            if (kev->code == (27 | KB_FLAG_DOWN))
               break;
         }
         else if (ismouse(ev))
         {
            uiMouseEvent *mev=(uiMouseEvent *)&ev;
            if (mev->action&(MOUSE_LUP|MOUSE_RUP))
            {
               int x=mev->pos.x, y=mev->pos.y, c;
               c=gr_get_pixel(x,y);
               mprintf("Pixel at %d,%d is color %d (0x%x) (%d %d %d)\n",x,y,c,c,grd_pal[c*3],grd_pal[c*3+1],grd_pal[c*3+2]);
               if (mev->action&MOUSE_LUP)  // left button breaks out
                  break;                   // right button keeps going
            }
         }
      modal_ui_update();
   }
   modal_ui_end();
   uiHideMouse(NULL);
}

// preload a sound
static void gedit_preload_snd(char *str)
{
   preload_data(PRELOAD_SOUND,str,NULL);
}

// preload a sound
static void gedit_preload_mot(char *str)
{
   preload_data(PRELOAD_BIN,str,"motions/");
}

extern void preload_dump_stats(void);

#ifdef DBG_ON

static void showPalette(void)
{
   static bool display=TRUE;
   static LGadRoot *root;
   static Rect *box;
   uchar const *use_ipal=ScrnGetInvPalette();
   int x, y;

   if (display)
   {
      root = vmGrabViews(vmGrabSingle);
      box = LGadBoxRect(root);

      // do the palette first
      for (y=0; y<16; y++)
         for (x=0; x<16; x++)
         {
            gr_set_fcolor(x+y*16);
            gr_rect(x*8+box->ul.x, y*8+box->ul.y, x*8+8+box->ul.x, y*8+8+box->ul.y);
         }

      // next, show the ipal
      for (y=0; y<16; y++)
         for (x=0; x<16; x++)
         {  // get an 888 rgb value
            long rgb = grd_pal[(x+y*16)*3];
            rgb |= grd_pal[(x+y*16)*3+1] << 8;
            rgb |= grd_pal[(x+y*16)*3+2] << 16;
            gr_set_fcolor(use_ipal[gr_index_lrgb(rgb)]);
            gr_rect(x*8+box->ul.x + 150, y*8+box->ul.y, x*8+8+box->ul.x + 150, y*8+8+box->ul.y);
         }

#ifdef SHOW_PCX
      {
         // *If* firetile is already loaded, then fetch it and show it.
         grs_bitmap *bm;
         IResMan *pResMan = AppGetObj(pResMan);
         IRes *pRes = IResMan_Lookup(pResMan, 
                                     "firetile.pcx", 
                                     RESTYPE_IMAGE,
                                     NULL);
         if (pRes)
         {
            bm = (grs_bitmap *) IRes_DataPeek(pRes);
            if (bm)
            {
               gr_bitmap(bm, x*8+box->ul.x, box->ul.y);
            }
         }
      }
#endif
   }
   else
      vmReleaseViews(root);

   display = !display;
}

#endif

void gedit_run_script_hack(char *script_name)
{
   char buf[256];
   find_file_in_config_path(buf,script_name,"script_path");
   CommandRunScript(buf);
}

void set_global_ambient(char *arg)
{
   if (arg==NULL || strlen(arg)==0) {
      mprintf("global ambient is %d\n",global_ambient);
   } else {
      sMissionRenderParams parms;
      parms = *GetMissionRenderParams();
      parms.ambient_light = atof(arg)/256.0;
      SetMissionRenderParams(&parms);
   }
}

void gedit_saveload_flag_hack(void)
{
   saveloadFixFlagField();
}

// split every model into every cell - not sure if still supported
#ifndef SHIP
extern BOOL always_split_all_models;
#endif

// are hotregions actively put in the portalizations, or just a filter
extern bool passive_hotregions;

#ifdef SEAN_STUFF
extern bool debug_cell_traversal;
#endif

Command gedit_edit_only_keys[] =
{
   { "refresh_particle_links", FUNC_VOID, ParticleGroupRefreshLinks, "Update all ParticleAttachement links" },

   { "cycle_tex", FUNC_INT, cycle_tex },
   { "sky_tex", FUNC_VOID, sky_tex },
   { "align_tex", FUNC_VOID, hack_align_texture },
   { "cycle_media", FUNC_INT, cycle_media },
   { "set_debug_tex", FUNC_INT, objmodel_set_debug_tex },

   { "reset_brush", FUNC_VOID, reset },
   { "brush_stretch", FUNC_INT, stretch, "stretch current brush" },
   { "brush_rotate", FUNC_INT, rotate, "rotate current brush" },
   { "brush_translate", FUNC_INT, translate, "translate current brush" },
   { "floor_object", FUNC_VOID, gedit_floor_me },
   { "wall_object", FUNC_VOID, gedit_wall_me },
   { "ceil_object", FUNC_VOID, gedit_ceil_me },
   { "fit_cameras", FUNC_BOOL, fit_world, "fit cameras to world/hot region" },
   { "auto_portalize", TOGGLE_BOOL, &auto_portalize },
   { "auto_roombuild", TOGGLE_BOOL, &auto_roombuild },

   { "go_to_meonly", FUNC_VOID, gedit_go_to_meonly },

   { "brush_to_room", FUNC_FLOAT, gedit_brush_to_room, "terrain->room (grow by arg on all axis)" },
   { "brush_adopt", FUNC_INT, gedit_brush_adopt, "all brushes adopt from us (arg for which parameter)" },

   { "spiral_serf", FUNC_INT, spiral_stair_cmd, "build spiral stair, 0 for dialog" },
   { "stair_serf", FUNC_INT, straight_stair_cmd, "build straight stair, 0 for dialog" },

   { "ambient", FUNC_STRING, set_global_ambient },
   { "snap_placement", TOGGLE_BOOL, &gedit_snap_placement },
   { "clear_brushes", FUNC_VOID, brushClearAll, "clear all brushes" },
   { "set_medium", FUNC_INT, set_medium, "set brush medium" },

   { "blist_dump", FUNC_VOID, blistDump },

   { "get_grid", FUNC_VOID, grid_get_from_current, "get grid from brush" },
   { "set_grid", FUNC_VOID, grid_set_from_current, "force brush to grid" },
   { "grid_toggle", FUNC_VOID, grid_toggle, "turn grid on off" },
   { "grid_scale", FUNC_FLOAT, grid_scale, "rescale the master grid" },
   { "grid_abs_scale", FUNC_FLOAT, grid_abs_scale, "set absolute scale of master grid" },
   { "brush_go_last", FUNC_VOID, move_brush_to_end_of_time, "move current brush to temporal last" },
   { "brush_set_time", FUNC_INT, move_brush_to_time_n, "move current brush to time n" },
   { "load_object", FUNC_STRING, objmodel_command, "load 3d object" },

   { "preload_sound", FUNC_STRING, gedit_preload_snd },
   { "preload_motion", FUNC_STRING, gedit_preload_mot },
   { "preload_stats", FUNC_VOID, preload_dump_stats },

#ifdef DBG_ON
   { "show_pal", FUNC_VOID, showPalette },
   { "primal_mprint", FUNC_INT, primalBr_mprint },
#endif

   { "brush_color", VAR_INT, &editbr_color_mode },
   { "brush_filter", VAR_INT, &editbr_filter },
   { "hots_filter", TOGGLE_BOOL, &renderHotsOnly },
   { "hots_state", FUNC_INT, gedit_hots_state },
   { "time_filter_lo", VAR_INT, &editbr_filter_time_lo },
   { "time_filter_hi", VAR_INT, &editbr_filter_time_hi },
   { "size_filter", VAR_FLOAT, &editbr_filter_size },

   { "set_brush_tx", FUNC_INT, gedit_set_brush_tx },
   { "set_brush_type", FUNC_INT, gedit_set_default_brush_type },
   { "reset_brush_tx", FUNC_INT, gedit_reset_br_textures },
   { "cam_to_brush", FUNC_VOID, gedit_cam_to_brush, "move camera to look at cur brush" },
   { "obj_ambient", VAR_FLOAT, &mdd_lt_amb },
   { "obj_diffuse", VAR_FLOAT, &mdd_lt_diff },

   { "zap_brush_flags", FUNC_VOID, gedit_saveload_flag_hack, "secret clear flags stuff" },

#ifdef SEAN_STUFF
   { "debug_cell", TOGGLE_BOOL, &debug_cell_traversal },
#endif

   { "info_window", FUNC_VOID, gedit_info_window },

   { "lazy_update", TOGGLE_BOOL, &gedit_allow_lazy_updates, "do we update instantly, or only on new brush selection" },
   { "run_cmd_script", FUNC_STRING, gedit_run_script_hack },

   { "set_primal", VAR_INT, &editbr_default_primal, "set default primal" },
   { "prim_sides", FUNC_INT, gedit_set_primal_sides, "# of sides on primals" },
   { "prim_type", FUNC_INT, gedit_set_primal_type, "1=cyl, 2=pyr, 3=cpyr, 0=cube " },
   { "prim_facealign", FUNC_BOOL, gedit_set_primal_facevertex, "are we face aligned" },
   { "cube", FUNC_VOID, gedit_set_cube, "set cube" },
   { "prim_special", FUNC_INT, gedit_set_special, "set 'special' primal type" },
   { "brush_to_mono", FUNC_INT, gedit_brush_to_mono, "show brush info on mono" },

#ifndef SHIP
   { "obj_split", TOGGLE_BOOL, &always_split_all_models, "always portal split objects" },
#endif
   { "obj_re_place", FUNC_VOID, gedit_replace_all_objs, "replace all objects in world" },
   { "passive_hotregions", TOGGLE_BOOL, &passive_hotregions, "are hotregions in the CSG, or just filters" },

   // these want to make it down to the list below - but arent ready for it yet - as does obj_pal
   { "show_image", FUNC_STRING, gedit_show_image, "load image from disk" },
};

// for keys you want to work in game mode as well, but ONLY In editor builds
// really, this should probably go somewhere else at some point
Command gedit_all_mode_keys[] =
{
#ifndef SHIP
   { "play_sfx", FUNC_STRING, SFX_command },
#endif
   { "get_pixel_color", FUNC_STRING, gedit_get_pixel_color, "click on pixel, get told color" },
   { "heapchk", FUNC_VOID, &_heapchk, "Test the heap, if debugging heap enabled" },
   { "monodebug", TOGGLE_BOOL, &mono_to_debugger, "output mono to Windows debug stream" },
#ifdef RN_STATS
   { "rn_stat_clear", FUNC_VOID, rnStatClear },
   { "rn_stat_show", FUNC_VOID, rnStatShow },
#endif
};


// register all of the subsystems here as well
void gedit_register(void)
{
   COMMANDS(gedit_edit_only_keys, HK_BRUSH_EDIT);
   COMMANDS(gedit_all_mode_keys, HK_ALL);
   gedcsgCommandRegister();
   gedundoCommandRegister();
   hilightCommandRegister();
}
