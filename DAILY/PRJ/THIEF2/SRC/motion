// $Header: r:/t2repos/thief2/src/motion/biploop.c,v 1.28 1999/08/05 17:04:40 Justin Exp $

#include <lg.h>
#include <loopapi.h>
#include <dispatch.h>
#include <dispbase.h>
#include <loopmsg.h>
#include <simman.h>
#include <simdef.h>
#include <simloop.h>
#include <dspchdef.h>
#include <appagg.h>
#include <iobjsys.h>
#include <objdef.h>

#include <dbasemsg.h>
#include <tagfile.h>
#include <vernum.h>

#include <objloop.h>
#include <biploop.h>
#include <creatext.h>
#include <objmodel.h>
#include <timer.h>

#include <simstate.h>
#include <simflags.h>
#include <simtime.h>
#include <simloop.h>

#include <puppet.h>
#include <motmngr.h>
#include <mvrflags.h>
#include <mvrutils.h>

// This must be last
#include <dbmem.h>


/////////////////////////////////////////////////////////////
// SAMPLE LOOP CLIENT
////////////////////////////////////////////////////////////

//////////////////
// CONSTANTS
//
//
#define MY_GUID   LOOPID_Biped

//
// @INSTRUCTIONS: If your client requires context data, you should publish the 
// type of the context data, and then change the "void" in the typedef below
// to your context data type.  See Resloop.c and .h for an example.
//
typedef void Context;

//
// @INSTRUCITONS: If your client requires any state, add the state variables as 
// fields to this structure. 
// 
typedef struct _StateRecord
{
   Context* context;
} StateRecord;



//////////////////////////////////////////////////
// Tag File Stuff

static ITagFile* tagfile = NULL;
static void movefunc(void *buf, size_t elsize, size_t nelem)
{
   ITagFile_Move(tagfile,(char*)buf,elsize*nelem);
}

TagFileTag CreatureSystemTag = { "CRET_SYSTEM" };
TagVersion CreatureSystemVersion = { 0, 1 };

static BOOL setup_tagfile(ITagFile* file, TagFileTag *tag, 
                          TagVersion *version)
{
   HRESULT result;
   TagVersion found_version = *version;
   tagfile = file;

   result = ITagFile_OpenBlock(file, tag, &found_version);
   return (result == S_OK
        && found_version.major == version->major
        && found_version.minor == version->minor);
}

static void cleanup_tagfile(ITagFile* file)
{
   ITagFile_CloseBlock(file);
}

EXTERN BOOL g_SimRunning;

static void sim_msg(const sDispatchMsg* msg, const sDispatchListenerDesc* desc)
{
   switch (msg->kind)
   {
      case kSimInit:
      case kSimResume:
      {
         InitGroundHeightObjects();
         g_SimRunning = TRUE;
         break;
      }

      case kSimSuspend:
      case kSimTerm: // @Q (toml 09-15-98): unused branch?
      {
         g_SimRunning = FALSE;
         break;
      }
   }
}

static sDispatchListenerDesc sim_listen =
{
   &LOOPID_Biped,       // my guid
   kSimInit|kSimResume|kSimSuspend|kSimTerm,   // interests
   sim_msg,
};

static void init_sim_message()
{
   ISimManager *pSimMan = AppGetObj(ISimManager);
   IMessageDispatch_Listen(pSimMan, &sim_listen);
   SafeRelease(pSimMan);
}

////////////////////////////////////////
//
// OBJECT MESSAGE HANDLER
//
#pragma off(unreferenced)
static void obj_message(ObjID obj, eObjNotifyMsg msg, void* data)
{
   switch (msg) 
   {
      case kObjNotifyDelete:
         ClearMotionFlagListeners(obj);
         break;
   }
}
#pragma on(unreferenced)

static void init_obj_message(void)
{
   IObjectSystem* pObjSys = AppGetObj(IObjectSystem); 
   sObjListenerDesc desc = { obj_message, NULL }; 
   IObjectSystem_Listen(pObjSys,&desc);
   SafeRelease(pObjSys);    
}

////////////////////////////////////////
// DATABASE MESSAGE HANDLER
//
static void db_message(DispatchData * msg)
{
   msgDatabaseData data;
   data.raw = msg->data;

   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
         MotionManagerReset();
         TermGroundHeightObjects();
         break;

      // Hey, look, we really should be loading motion stuff out of the briefcase too
      // but the motion system doesn't seem to handle merge loading, so for the moment
      // we are just going to load out of the mission. Someone can fix this for real
      // sometime in the future (after Shock ships). (Jon 5/27/99)
      case kDatabaseSave:
         if (msg->subtype & kObjPartConcrete)
         {
            if (setup_tagfile(data.save, &CreatureSystemTag, 
                              &CreatureSystemVersion)) {
               CreaturesWrite((fCreatureReadWrite)movefunc,NOTIFY_PARTITION(msg->subtype));
               cleanup_tagfile(data.save);
            }
         }
         break;

      case kDatabaseLoad:
         if (msg->subtype & kDBMission)
         {
            MotionManagerLoad();
         }
         if (msg->subtype & kObjPartConcrete)
         {
            if (setup_tagfile(data.load, &CreatureSystemTag, 
                              &CreatureSystemVersion)) {
               CreaturesRead((fCreatureReadWrite)movefunc,NOTIFY_PARTITION(msg->subtype));
               cleanup_tagfile(data.load);
            }
         }
         break;
         
      case kDatabasePostLoad:
         if (msg->subtype & kObjPartConcrete)
         {
            InitGroundHeightObjects();
         }
         break;
   }
}

////////////////////////////////////////
//
// LOOP/DISPATCH callback
// Here's where we do the dirty work.
//

#pragma off(unreferenced)
static eLoopMessageResult LGAPI _LoopFunc(void* data, eLoopMessage msg, tLoopMessageData hdata)
{
   // useful stuff for most clients
   eLoopMessageResult result = kLoopDispatchContinue; 
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;
   long cur_time;

   info.raw = hdata; 

   switch(msg)
   {

      case kMsgNormalFrame:
         if (SimStateCheckFlags(kSimAI))
         {
            cur_time = GetSimFrameTime();
            PuppetsUpdate(cur_time);
            CreaturesUpdate(cur_time);
            // update other multipeds here too
         }
         break;

      case kMsgAppInit:
         MotionManagerInit();
         MotionFlagsInit();
         PuppetsInit();
         init_sim_message();
         init_obj_message(); 
         break;

      case kMsgAppTerm:
         MotionFlagsTerm();
         MotionManagerClose();
         break;

      case kMsgDatabase:
         db_message(info.dispatch);
         break;

      case kMsgEnd:
         Free(state);
         break;   
   }
   return result;
}

////////////////////////////////////////////////////////////
// Frome here on in is boiler plate code.
// Nothing need be changed.
//


// 
// Loop client factory function. 
//

#pragma off(unreferenced)
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc, tLoopClientData data)
{
   StateRecord* state;
   // allocate space for our state, and fill out the fields
   state = (StateRecord*)Malloc(sizeof(StateRecord));
   state->context = (Context*)data;
   
   return CreateSimpleLoopClient(_LoopFunc,state,&BipedLoopClientDesc);
}
#pragma on(unreferenced)

///////////////
// DESCRIPTOR
// 

sLoopClientDesc BipedLoopClientDesc =
{
   &MY_GUID,
   "Biped Client",              
   kPriorityNormal,              
   kMsgEnd | kMsgsFrameMid | kMsgsAppOuter | kMsgDatabase,

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,

// XXX should constrain this to happen BEFORE renderer.  But where is renderer?
   {
      {kConstrainAfter, &LOOPID_ObjSys, kMsgDatabase},
      {kConstrainAfter, &LOOPID_ObjSys, kMsgsAppOuter}, // to install listener
#if 0
      {kConstrainAfter, &LOOPID_ObjSys, kMsgAppInit}, // to install listener
      {kConstrainBefore, &LOOPID_ObjSys, kMsgAppTerm}, // to detach weapons
#endif
      {kConstrainBefore, &LOOPID_SimFinish, kMsgsFrameMid},

      {kNullConstraint} // terminator
   }
};


// $Header: r:/t2repos/thief2/src/motion/biploop.h,v 1.3 2000/01/29 13:21:58 adurant Exp $
#pragma once
#ifndef __BIPLOOP_H
#define __BIPLOOP_H

DEFINE_LG_GUID(LOOPID_Biped, 0x34);

EXTERN struct sLoopClientDesc  BipedLoopClientDesc;

//
// KEEP THIS FILE RELATIVELY CLEAR OF JUNK!  DO NOT PUT YOUR SYSTEM'S API HERE! 
// DO NOT INCLUDE OTHER HEADER FILES FROM THIS FILE!
//

 
#endif // __BIPLOOP_H


// $Header: r:/t2repos/thief2/src/motion/cerebllm.cpp,v 1.5 2000/02/19 12:29:51 toml Exp $
//
// XXX This is kind of inelegant since whenever you want new kinds of things
// to be able to have cerebellums, they need to be explicitly added here, instead
// of setting a property or something at the place where they get defined, 
// but really I think this is sufficient.
//                                                          KJ 12/97

#include <cbllmapi.h>
#include <puppet.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

ICerebellum *CbllmGetFromObj(ObjID obj)
{
   ICerebellum *pCbllm;

   // next check if automaton
   if(NULL!=(pCbllm=PuppetGetCerebellum(obj)))
      return pCbllm;

   // next check if player

   return NULL;
}
// $Header: r:/t2repos/thief2/src/motion/crattach.cpp,v 1.30 1999/12/09 20:15:23 BODISAFA Exp $

#include <lg.h>
#include <comtools.h>
#include <appagg.h>
#include <config.h>
#include <cfgdbg.h>

#include <traitman.h>
#include <iobjsys.h>
#include <objsys.h>
#include <osysbase.h>
#include <objpos.h>
#include <linkman.h>
#include <linkbase.h>
#include <lnkquery.h>
#include <relation.h>

#include <sdesc.h>
#include <sdesbase.h>

#include <crjoint.h>
#include <schema.h>
#include <rendprop.h>
#include <weaphit.h>
#include <weaphalo.h>
#include <weapon.h>
#include <plycbllm.h>

#include <crattach.h>
#include <creatapi.h>
#include <creatext.h>
#include <creature.h>
#include <creatur_.h>
#include <crwpnapi.h>

#include <mprintf.h>

#include <phflist.h>
#include <physapi.h>
#include <dmgmodel.h>
#include <dmgbase.h>
#include <playrobj.h>

// for physics listeners
#include <phcore.h>
#include <phlistn_.h>

// Must be last header
#include <dbmem.h>

static sRelationDesc sAttachRelDesc = 
{ 
   CREATURE_ATTACH_RELATION_NAME, 
   0,
};

static sRelationDataDesc sAttachRelDataDesc = LINK_DATA_DESC_FLAGS(sCreatureAttachInfo, kRelationDataAutoCreate);

static sFieldDesc sAttachRelFields[] =
{
   { "Joint",      kFieldTypeEnum, FieldLocation(sCreatureAttachInfo, joint),     kFieldFlagNone, 0, 22, 22, g_pJointNames },
   { "Is Weapon?", kFieldTypeBool, FieldLocation(sCreatureAttachInfo, is_weapon), kFieldFlagNotEdit },
};

static sStructDesc sAttachRelStructDesc = StructDescBuild(sCreatureAttachInfo, kStructFlagNone, sAttachRelFields);

IRelation *g_pCreatureAttachRelation = NULL;

void LGAPI CreatureAttachRelationListener(sRelationListenMsg *msg, RelationListenerData data)
{
   if (msg->type & kListenLinkBirth)
   {
      sCreatureAttachInfo *pAttachInfo = (sCreatureAttachInfo *)g_pCreatureAttachRelation->GetData(msg->id);

      if (!pAttachInfo->is_weapon)
      {
         pAttachInfo->weapon = kCrWeap_Invalid;

         BOOL all_zero = TRUE;
         for (int i=0; i<9 && all_zero; i++)
         {
            if (pAttachInfo->relTrans.mat.el[i] != 0.0)
               all_zero = FALSE;
         }

         if (all_zero)
            mx_identity_mat(&pAttachInfo->relTrans.mat);

         g_pCreatureAttachRelation->SetData(msg->id, (void *)pAttachInfo);
      }
   }
}

void InitCreatureAttachments()
{
   Assert_(g_pCreatureAttachRelation == NULL);

   // install item attachment relation
   g_pCreatureAttachRelation = CreateStandardRelation(&sAttachRelDesc, &sAttachRelDataDesc, kQCaseSetSourceKnown);
   g_pCreatureAttachRelation->Listen(kListenLinkBirth, CreatureAttachRelationListener, NULL);

   StructDescRegister(&sAttachRelStructDesc);
}

void TermCreatureAttachments()
{
   Assert_(g_pCreatureAttachRelation != NULL);

   SafeRelease(g_pCreatureAttachRelation);
}

// weapon gets attached.  Is left non-physical by default
BOOL CreatureAttachWeapon(ObjID creature, ObjID weaponObj, int weaponType)
{
   LinkID linkID;
   sCreatureAttachInfo attachInfo;

   if(!OBJ_IS_CONCRETE(weaponObj))
   {
      Warning(("Unable to attach weapon %d to creature %d\n",creature,weaponObj));
      return FALSE;
   }
   cCreature *pCreature=CreatureFromObj(creature);

   if(pCreature)
   {
      pCreature->GetWeaponAttachDefaults(weaponType,&attachInfo);
   }

   // Set link
   linkID = g_pCreatureAttachRelation->AddFull(creature, weaponObj, (void *)&attachInfo);

   // Reffed, but invisible
   if (!config_is_defined("show_weapon"))
      ObjSetRenderType(weaponObj, kRenderNotAtAll);
   ObjSetHasRefs(weaponObj, TRUE);

   return linkID != LINKID_NULL;
}

void CreatureDetachWeapon(ObjID creature, ObjID weaponObj)
{
   // Visible, but unreffed
   ObjSetHasRefs(weaponObj, FALSE);
   if (!config_is_defined("show_weapon"))
   {
      ObjSetRenderType(weaponObj, kRenderNormally);
   }
   
   CreatureMakeWeaponNonPhysical(creature,weaponObj);
   CreatureDetachItem(creature,weaponObj);
}

BOOL CreatureMakeWeaponPhysical(ObjID creature, ObjID weapon, int weaponType)
{
   if(weapon==OBJ_NULL)
      return FALSE;
   cCreature *pCreature=CreatureFromObj(creature);

   if(!pCreature)
   {
      Warning(("No creature with objID %d\n",creature));
      return FALSE;
   }
   return pCreature->MakeWeaponPhysical(weapon,weaponType);
}

void CreatureMakeWeaponNonPhysical(ObjID creature, ObjID weapon)
{
   if(weapon==OBJ_NULL)
      return;

   cCreature *pCreature=CreatureFromObj(creature);

   if(!pCreature)
   {
      Warning(("No creature with objID %d\n",creature));
      return;
   }
   pCreature->MakeWeaponNonPhysical(weapon);
}

BOOL CreatureAttachItem(ObjID creature, ObjID item, const sCreatureAttachInfo *pAttachInfo)
{
   LinkID linkID;

   if(!CreatureExists(creature) || !OBJ_IS_CONCRETE(creature) || !OBJ_IS_CONCRETE(item))
   {
      Warning(("Unable to attach item %d to creature %d\n",creature,item));
      return FALSE;
   }

   // Set link
   if(pAttachInfo)
      linkID = g_pCreatureAttachRelation->AddFull(creature, item, (void *)pAttachInfo);
   else   
      linkID = g_pCreatureAttachRelation->Add(creature, item);

   return linkID != LINKID_NULL;
}

// iterate over creature attachment links between the two items, 
// deleting links as you go.
void CreatureDetachItem(ObjID creature, ObjID item)
{
   LinkID linkID;

   ILinkQuery *Query = g_pCreatureAttachRelation->Query(creature, item);

   for(; !Query->Done(); Query->Next())
   {
      linkID=Query->ID();
      g_pCreatureAttachRelation->Remove(linkID);
   }

   SafeRelease(Query);
}

void CreatureDetachAllItems(ObjID creature)
{
   LinkID linkID;

   ILinkQuery *Query= g_pCreatureAttachRelation->Query(creature, LINKOBJ_WILDCARD);

   for(; !Query->Done(); Query->Next())
   {
      linkID=Query->ID();
      g_pCreatureAttachRelation->Remove(linkID);
   }
   SafeRelease(Query);
}

void CreatureAttachmentsPhysUpdate(ObjID creature)
{
   cCreature *pCreature;

   if(creature==OBJ_NULL || (NULL==(pCreature=CreatureFromObj(creature))) )
      return;

   ILinkQuery *Query = g_pCreatureAttachRelation->Query(creature, LINKOBJ_WILDCARD);

   for(; !Query->Done(); Query->Next())
   {
      sLink link;
      sCreatureAttachInfo *pInfo;
      sCrPhysModOffsetTable *pTable;
      eForceListResult forceListResult;
      int i;

      Query->Link(&link);
      if(!PhysObjHasPhysics(link.dest))
         continue;

      if(NULL!=(pInfo=(sCreatureAttachInfo *)g_pCreatureAttachRelation->GetData(Query->ID())))
      {
         if(pInfo->weapon==kCrWeap_Invalid)
         {
            Warning(("CreatureAttachmentsUpdate: do not support item with physics\n"));
         } else
         {
            // get positions of all the phys submodels
            if(NULL!=(pTable=pCreature->GetWeaponPhysOffsets(pInfo->weapon)))
            {
               sCrPhysModOffset *pMod=pTable->pPhysModels;
               mxs_vector  subPos;
               mxs_vector  endPos;
               mxs_vector  force;
               mxs_real    time;

               PhysicsListenerLock = TRUE;
               for(i=0;i<pTable->nPhysModels;i++,pMod++)
               {
                  pCreature->GetPhysSubModPos(pMod,&subPos);
                  forceListResult = PhysApplyForceList(link.dest, i, NULL, 0, 1, &subPos, &endPos, 
                                                       &force, &time, FALSE, TRUE);
                  // This is probably the wrong place to do this, i.e., we should really 
                  // do it in physics, I think.
                  if (!(forceListResult&kFLR_Success))
                  {
                     if (forceListResult & kFLR_TerrainCollision)
                     {
                        // for the moment, don't report terrain collisions
                     }
                     else
                     {
                        if (g_pPhysListeners->HasListener(link.dest, kCollisionMsg))
                        {
                           mxs_vector null = {0, 0, 0};
                           // this sucks, because we don't have most of the information here.
                           g_pPhysListeners->CallCollision(link.dest, 0, kPC_Object, OBJ_NULL, 0, null, 0, null);
                        }
                     }
                  }
                  if (forceListResult & kFLR_TerrainCollision)
                  {
                     HandleWeaponHit(OBJ_NULL, link.dest);
                     WeaponPostHit(OBJ_NULL, link.dest, OBJ_NULL); 
                     break;
                  }
                  if (forceListResult & kFLR_MadeNonPhysical)
                     break;
               }
               WeaponHaloUpdate(creature, link.dest, pTable->nPhysModels);
               PhysicsListenerLock = FALSE;
            }
         }
      } else
      {
         if(PhysObjHasPhysics(link.dest))
         {
            Warning(("CreatureAttachmentsUpdate: do not support item with physics\n"));
         }
      }
   }
   SafeRelease(Query);
}

// update object positions of all attached objects
EXTERN void CreatureAttachmentsPosUpdate(ObjID creature)
{
   IMesh *pMesh;

   if(NULL==(pMesh=CreatureGetMeshInterface(creature)))
      return;

   ILinkQuery *Query = g_pCreatureAttachRelation->Query(creature, LINKOBJ_WILDCARD);

   for(; !Query->Done(); Query->Next())
   {
      sLink link;

      PosPropLock++;

      Query->Link(&link);
      sCreatureAttachInfo *pInfo = (sCreatureAttachInfo *)g_pCreatureAttachRelation->GetData(Query->ID());
      if (pInfo != NULL)
      {
         if (pInfo->joint == kCJ_Invalid)
         {
            pInfo->joint = kCJ_Butt;
         }

         // Verify happy joint.
         AssertMsg1((pInfo->joint >= 0 && pInfo->joint < kCJ_NumCreatureJoints),
                  "CreatureAttachmentsPosUpdate: Bad joint %d\n", pInfo->joint);

         // update obj position of dst obj
         const mxs_vector *loc = &GetCreatureJointPos(creature, pInfo->joint);
         const mxs_matrix *orient = &GetCreatureJointOrient(creature, pInfo->joint);

         mxs_matrix temp_mat;
         mxs_vector temp_loc;
         mxs_angvec fac;

         mx_mul_mat(&temp_mat, orient, &pInfo->relTrans.mat);

         mx_mat_mul_vec(&temp_loc, orient, &pInfo->relTrans.vec);
         mx_addeq_vec(&temp_loc, loc);

         mx_mat2ang(&fac, &temp_mat);

         ObjPosUpdate(link.dest, &temp_loc, &fac);
      } else
      {
         ObjPos *pPos=ObjPosGet(link.source);
         ObjPosUpdate(link.dest,&pPos->loc.vec,&pPos->fac);
      }

      PosPropLock--;
   }
   SafeRelease(Query);
}

EXTERN void CreatureAttachmentModify(ObjID creature, ObjID item, sCreatureAttachInfo *pAttachInfo)
{
   ILinkQuery *Query = g_pCreatureAttachRelation->Query(creature, item);

   for(; !Query->Done(); Query->Next())
   {
      g_pCreatureAttachRelation->SetData(Query->ID(),(void *)pAttachInfo);
   }

   SafeRelease(Query);
}

// CreatureAttachmentGet:  Retrieve the nth item off of a creature.
EXTERN sCreatureAttachInfo* CreatureAttachmentGet(ObjID creature, ObjID item, const int& inItemIndex)
{
   ILinkQuery *Query = g_pCreatureAttachRelation->Query(creature, item);

   for(int i = 0; !Query->Done(); Query->Next())
   {
      if (i == inItemIndex)
      {
         return (sCreatureAttachInfo*) g_pCreatureAttachRelation->GetData(Query->ID());
      }
   }
   SafeRelease(Query);
   return NULL;
}

// $Header: r:/t2repos/thief2/src/motion/crattach.h,v 1.8 2000/01/29 13:21:59 adurant Exp $
#pragma once

#ifndef __CRATTACH_H
#define __CRATTACH_H

#include <matrixs.h>
#include <objtype.h>
#include <crettype.h>
#include <relation.h>

////////////////////////////////////////

#define CREATURE_ATTACH_RELATION_NAME "CreatureAttachment"

EXTERN IRelation *g_pCreatureAttachRelation;

struct sCreatureAttachInfo
{
   int  joint;
   BOOL is_weapon;

   mxs_trans relTrans;
   int weapon; // kCrWeap_Invalid if not a weapon
};

////////////////////////////////////////

EXTERN void InitCreatureAttachments();
EXTERN void TermCreatureAttachments();
EXTERN BOOL CreatureAttachItem(ObjID creature, ObjID item, const sCreatureAttachInfo *pAttachInfo);
EXTERN void CreatureDetachItem(ObjID creature, ObjID item);
EXTERN void CreatureDetachAllItems(ObjID creature);
EXTERN void CreatureAttachmentsPhysUpdate(ObjID creature);
EXTERN void CreatureAttachmentsPosUpdate(ObjID creature);
EXTERN BOOL CreatureAttachWeapon(ObjID creature, ObjID weaponObj, int weaponType);
EXTERN void CreatureDetachWeapon(ObjID creature, ObjID weaponObj);
EXTERN BOOL CreatureMakeWeaponPhysical(ObjID creature, ObjID weapon, int weaponType);
EXTERN void CreatureMakeWeaponNonPhysical(ObjID creature, ObjID weapon);
EXTERN void CreatureAttachmentModify(ObjID creature, ObjID weapon, sCreatureAttachInfo *pAttachInfo);
EXTERN sCreatureAttachInfo* CreatureAttachmentGet(ObjID creature, ObjID item, const int& inIndex);
////////////////////////////////////////

#endif
// $Header: r:/t2repos/thief2/src/motion/creature.cpp,v 1.206 2000/03/01 20:17:19 bfarquha Exp $
/////////
// ISSUES TO BE RESOLVED
//
// XXX Need to call "new" for all the SubFrameUpdate variables since can't
// make m_nJoints and m_nPhysModels const because
// Read from file constructor doesn't know type and objid going in.
// How to deal with changing creature types in general?  Not currently
// well supported
//
// XXX Need to get rid of the neck fixing hack, which means solving the
// underlying problem.
//
// NOTE: SphrSphereInWorld returns whether sphere intersects terrain.
//     must be passed a valid location (check using CellFromLoc).
//
// @TODO: get ballistic submodels of location controlled creatures working,
// so tails can wag as springs.

//#define PROFILE_ON

#include <cfgdbg.h>
#include <mprintf.h>
#include <timings.h>
#include <dynarray.h>

#include <meshapi.h>

#include <creature.h>
#include <creatur_.h>
#include <creatext.h>

#include <ai.h>
#include <aiapi.h>
#include <aiapiiai.h>

#include <cretprop.h>
#include <objtype.h>
#include <osysbase.h>
#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>
#include <propman.h>
#include <objedit.h>

#include <objpos.h>
#include <editobj.h>
#include <phprop.h>
#include <physapi.h>
#include <physcast.h>
#include <phflist.h>
#include <collprop.h>
#include <collide.h>
#include <sndgen.h>
#include <dmgmodel.h>
#include <dmgbase.h>

#include <ghostmvr.h>
#include <crattach.h>
#include <command.h>
#include <plycbllm.h> // for debugging stuff
#include <mnumprop.h> // for model name listener
#include <mnamprop.h>
#include <posprop.h>  // for PROP_POSITION_NAME
#include <crjoint.h>
#include <simtime.h>

#include <resapi.h>
#include <binrstyp.h>

#include <playrobj.h>

#include <mvrutils.h> // for flag setup function
#include <motprop.h>  // for global timewarp

#include <iobjsys.h> // woo hoo comm-y stuff
#include <appagg.h>
#include <motbase.h> // for update_flag_fake. XXX should move this elsewhere KJ 10/97

#include <matrix.h>
#include <fix.h>
#include <qt.h>
#include <math.h>
#include <fltang.h>
#include <portal.h>
#include <port.h>

#include <phcore.h>
#include <phmods.h>
#include <phmod.h>
#include <phmterr.h>
#include <phmtprop.h>
#include <phref.h>

#include <phmodsph.h>
#include <sphrcst.h>
#include <sphrcsts.h>
#include <phclsn.h>
#include <phutils.h>

#include <crexp.h>   // exploding creatures system

// weapon stuff
#include <weapon.h>
#include <weaphit.h>
#include <weaphalo.h>
#include <weapprop.h>
#include <crwpnapi.h>
#include <crwpnlst.h>

#include <textarch.h> //for the is_terrain hack

#include <motdmnge.h>
#include <motdesc.h>
#include <motmngr.h>

#ifdef SHOCK
#include <shkcrdrd.h>
#endif

// must be last header
#include <dbmem.h>


//enable this if you want to have globals set with every motion started
// #define CUR_MOTION_TRACKING

static const int g_kCreatureVersion=10;

#define CREATURE_FROM_OBJID_UNSAFE(objID) (CreatureHandle(obj_chandle_id(objID))->pCreature)


static sCreatureDesc **g_pCreatureDescPtr=NULL;
static cCreatureFactory **g_pCreatureFactories;
static int g_nCreatureTypes=0;

typedef struct sPhysSubModInfo
{
   sPhysForce *pPhysForce;
   int nForces;
   mxs_vector endPos;
   mxs_vector terrForce;
   mxs_vector objColForce;
   mxs_real collTime;
} sPhysSubModInfo;

static ICreatureProperty *g_pICreatureProperty=NULL;

// Only to be called internall by creature system
static void SetCretObjPos(ObjID objID, const mxs_vector *pos, const mxs_angvec *rot);

///////////////////////////////////////////////////

EXTERN int g_SimRunning;
int g_SimRunning = FALSE;

static BOOL g_MotionEnded=FALSE;
static BOOL gUseHeadTracking = FALSE;

typedef struct sMotEndData
{
   int motion_num;
   int frame;
   ulong flags;
} sMotEndData;

static sMotEndData g_MotEndData;

int CreatureMotEndCallback(multiped *mp, int motion_num, int frame, float timeSlop, ulong flags)
{
   AssertMsg(mp->app_ptr,"No creature for multiped!");

   if(flags&MP_UPDATE_FLAG_FAKE)
      return 1;

   cCreature *pCreature=(cCreature *)mp->app_ptr;

   sCreatureMotionEndNode node;
   node.motionNum=motion_num;
   node.timeSlop=timeSlop;
   node.flags=flags;
   node.frame=frame;
   node.pNext=NULL;
   pCreature->QueueCompletedMotion(&node);

//   ConfigSpew("CreatureTrace",("%d: finished motion %d (%s)\n",pCreature->GetObjID(),motion_num,MotDescGetName(motion_num)));
   return 1;
}

///////////////////////////////////////////////////

IMesh *CreatureGetMeshInterface(const ObjID objID)
{
   // @OPTIMIZE: this isn't inline yet

   return CreatureFromObj(objID);
}

///////////////////////////////////////////////////

IMotor *CreatureGetMotorInterface(const ObjID objID)
{
   return CreatureFromObj(objID);
}

///////////////////////////////////////////////////

#ifdef PLAYTEST

BOOL g_AssertValidPosition = TRUE;

BOOL IsCreaturePositionValid(ObjID objID)
{
   cCreature *pCreature = CreatureFromObj(objID);
   Position *pPos = ObjPosGet(objID);
   cPhysModel *pModel = g_PhysModels.Get(objID);

   if (g_SimRunning && g_AssertValidPosition &&
       pPos && pModel && pCreature &&
       ComputeCellForLocation(&pPos->loc) != CELL_INVALID &&
       pCreature->GetType() != 10)  // rope magic number
   {
      return (PhysObjValidPos(objID, NULL));
   }

   return TRUE;
}

BOOL ValidateCreaturePosition(ObjID objID)
{
   if (!IsCreaturePositionValid (objID))
   {
      mxs_vector loc;
      PhysGetModLocation(objID, &loc);
      if (config_is_defined("bad_pos_assert"))
         CriticalMsg4("%s in bad cret pos: %g,%g,%g\n",
            ObjWarnName(objID), loc.x, loc.y, loc.z);
      else
      {
         mprintf("%s in bad cret pos: %g,%g,%g\n",
            ObjWarnName(objID), loc.x, loc.y, loc.z);
         mprintf("   rad: ");
         cPhysModel *pModel = g_PhysModels.Get(objID);
         for (int i=0; i<pModel->NumSubModels(); i++)
            mprintf("%g  ", ((cPhysSphereModel *)pModel)->GetRadius(i));
         mprintf("\n");
      }
      return FALSE;
   }
   return TRUE;
}

#endif

///////////////////////////////////////////////////

void CreatureFixup()
{
   sCreatureHandle *pCHandle;
   cCreature *pCreature;
   int max;
   int i;

   AutoAppIPtr_(PropertyManager, pPropMan);

   ICreaturePoseProperty *pPoseProp= (ICreaturePoseProperty *)pPropMan->GetPropertyNamed(PROP_CREATUREPOSE_NAME);
   ICreatureProperty *pCreatureProp = (ICreatureProperty *)pPropMan->GetPropertyNamed(PROP_CREATURE_NAME);

   cDynArray<ObjID> creatureFixupList;

   max = max_chandle_id();
   for (i = 0; i < max; i++)
   {
      pCHandle=CreatureHandle(i);

      if(!pCHandle)
         continue;

      AssertMsg1(pCHandle->pCreature,"no creature at entry %d",i);
      pCreature = pCHandle->pCreature;

      if (pCreature->GetType() == 10) // rope magic number, yippee
         continue;

      creatureFixupList.Append(pCreature->GetObjID());
   }

   for (i=0; i<creatureFixupList.Size(); i++)
   {
      pCreatureProp->Delete(creatureFixupList[i]);
      pCreatureProp->Create(creatureFixupList[i]);

      if (ObjIsPosed(creatureFixupList[i]))
      {
         sCreaturePose *pPose;

         if (!pPoseProp->Get(creatureFixupList[i], &pPose))
            pPose = NULL;

         pPoseProp->Delete(creatureFixupList[i]);

         if (pPose)
            pPoseProp->Set(creatureFixupList[i], pPose);
         else
            pPoseProp->Create(creatureFixupList[i]);
      }
   }

   creatureFixupList.SetSize(0);
}

///////////////////////////////////////////////////

BOOL CreatureMakeBallistic(ObjID objID, int style)
{
#ifndef SHIP
   mxs_vector pre_pos[8];
   mxs_vector post_pos[8];
   int i;
#endif

   cCreature *pCreature=CreatureFromObj(objID);
   if(pCreature)
   {
      const sCreatureDesc *pCDesc=pCreature->GetCreatureDesc();

      if (!PhysObjHasPhysics(objID))
         pCreature->MakePhysical();
      pCreature->MoveButt(&ObjPosGet(objID)->loc.vec, &ObjPosGet(objID)->fac, TRUE);

#ifndef SHIP
      cPhysModel *pModel = g_PhysModels.Get(objID);

      if (pModel)
      {
         Assert_((pModel->NumSubModels() < 8) || (pCDesc->nPhysModels < 8));

         for (i=0; i<pModel->NumSubModels() && i<pCDesc->nPhysModels; i++)
            PhysGetSubModLocation(objID, i, &pre_pos[i]);
      }
#endif

      BOOL retval;

      if (style == kCMB_Compressed)
         retval = pCreature->MakeBallistic(style, TRUE);
      else
         retval = pCreature->MakeBallistic(style);

#ifndef SHIP
      if (pModel)
      {
         Assert_((pModel->NumSubModels() < 8) || (pCDesc->nPhysModels < 8));

         for (i=0; i<pModel->NumSubModels() && i<pCDesc->nPhysModels; i++)
         {
            mxs_vector delta;

            PhysGetSubModLocation(objID, i, &post_pos[i]);
            mx_sub_vec(&delta, &pre_pos[i], &post_pos[i]);

            if (mx_mag2_vec(&delta) > 0.001)
               if (config_is_defined("bad_ballistic_assert"))
                  CriticalMsg2(" %s made a bad ballistic transition (mag %g)!\n", ObjWarnName(objID), mx_mag2_vec(&delta));
               else
                  Warning((" %s made a bad ballistic transition (mag %g)!\n", ObjWarnName(objID), mx_mag2_vec(&delta)));
         }
      }
#endif

      return retval;
   }
   else
      return FALSE;
}

///////////////////////////////////////////////////

void CreatureMakeNonBallistic(ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);

   if(pCreature)
      pCreature->MakeNonBallistic();
}

///////////////////////////////////////////////////

void CreaturePrepareToDie(ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);

   if(pCreature)
      pCreature->PrepareToDie();
}

///////////////////////////////////////////////////

void CreatureBeDead(ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);

   if(pCreature)
      pCreature->BeDead();
}

///////////////////////////////////////////////////

void CreatureMakePhysical(ObjID objID)
{
   cCreature *pCreature = CreatureFromObj(objID);

   if (pCreature)
      pCreature->MakePhysical();
}

///////////////////////////////////////////////////

void CreatureMakeNonPhysical(ObjID objID)
{
   cCreature *pCreature = CreatureFromObj(objID);

   if (pCreature)
      pCreature->MakeNonPhysical();
}

///////////////////////////////////////////////////

// @HACK, brutal. only works for human-ish creatures
BOOL CreatureGetHeadTransform(ObjID objID, mxs_trans *pHead)
{
   cCreature *pCreature=CreatureFromObj(objID);

   if(!pCreature || !pHead)
      return FALSE;
   const multiped *pM=pCreature->GetMultiped();
   mx_copy_vec(&pHead->vec,&pM->joints[9]);
   mx_copy_mat(&pHead->mat,&pM->orients[9]);
   return TRUE;
}

////////////////////////////////////////////////////////////
// Debugging functions

#ifdef PLAYTEST

static ObjID g_DebugObj=OBJ_NULL;

void CreatureDebugSetObj(ObjID obj)
{
   g_DebugObj=obj;
}

void CreatureDebugAbortWeapon()
{
   if(g_DebugObj!=OBJ_NULL)
   {
      CreatureAbortWeaponMotion(g_DebugObj,OBJ_NULL);
   }
}

void CreatureDebugAbortPlayerWeapon()
{
   ObjID pa;

   if(OBJ_NULL!=(pa=PlayerArm()))
   {
      CreatureAbortWeaponMotion(pa,OBJ_NULL);
   }
}

void CreatureDebugSetFocusObj(char *cmd_string)
{
   ObjID creature;
   ObjID focus;

   sscanf(cmd_string, "%d,%d", &creature, &focus);

   CreatureSetFocusObj(creature, focus);
}

void CreatureDebugSetFocusLoc(char *cmd_string)
{
   ObjID creature;
   ObjID focus;

   sscanf(cmd_string, "%d,%d", &creature, &focus);

   Position *pos = ObjPosGet(focus);

   if (pos)
      CreatureSetFocusLoc(creature, &pos->loc.vec);
}

extern cDynArray<ObjID> standableObjectList;

static void CreatureSpewStandable()
{
   mprintf("Standable AI objects:\n");

   for (int i=0; i<standableObjectList.Size(); i++)
      mprintf(" %s\n", ObjWarnName(standableObjectList[i]));
}

static int MotSwizzle(int mot,motion_callback *pcallback);

void CreatureDebugSaveLoadTest()
{
   cCreature *pCreature=CreatureFromObj(g_DebugObj);

   if(!pCreature)
      return;
   mprintf("testing mp saveload\n");
   multiped *mp=(multiped *)pCreature->GetMultiped();
   int bsize=mp_get_write_buffsize(mp);
   int *buf=new int[bsize];
   mp_write_multiped(mp,buf);
   mp_free_multiped(mp);
   mp_init_multiped(mp);
   mp_read_multiped(mp,buf,MotSwizzle);
   delete buf;
}

EXTERN BOOL g_mot_quat_debug;
static Command creature_debug_keys[] =
{
   { "cret_set_debug_obj", FUNC_INT, CreatureDebugSetObj, "set debug obj"},
   { "cret_weap_abort",    FUNC_VOID, CreatureDebugAbortWeapon, "stop swing"},
   { "player_weap_abort",  FUNC_VOID, CreatureDebugAbortPlayerWeapon, "stop swing"},
   { "cret_set_focus_obj", FUNC_STRING, CreatureDebugSetFocusObj, "set creature's focus obj"},
   { "cret_set_focus_loc", FUNC_STRING, CreatureDebugSetFocusLoc, "set creature's focus loc"},
   { "cret_saveload_test", FUNC_VOID, CreatureDebugSaveLoadTest, "test creature saveload"},
   { "toggle_mot_quat_debug", TOGGLE_BOOL, &g_mot_quat_debug, "toggle motion quaternion debugging"},
   { "fixup_creature_phys", FUNC_VOID, CreatureFixup, "fix up physics for all creatures"},
   { "spew_creature_standable", FUNC_VOID, CreatureSpewStandable, "spew all object AIs can stand on"},
};

#endif

///////////////////////////////////////////////////
// creature model name listener

static void LGAPI CreatureModelNameListener(sPropertyListenMsg* msg, PropListenerData data)
{
   if (msg->type & (kListenPropModify|kListenPropSet)) // had unset
   {
      cCreature *pCreature;

      if (OBJ_IS_CONCRETE(msg->obj))
      {
         if(NULL!=(pCreature=CreatureFromObj(msg->obj)))
            pCreature->ResetLengths();
      }
      else // set lengths for all descendents
      {
         AutoAppIPtr_(TraitManager,TraitMan);
         IObjectQuery* query = TraitMan->Query(msg->obj,kTraitQueryAllDescendents);
         for (; !query->Done(); query->Next())
         {
            ObjID obj = query->Object();
            if (OBJ_IS_CONCRETE(obj))
               if(NULL!=(pCreature=CreatureFromObj(obj)))
                  pCreature->ResetLengths();
         }
         SafeRelease(query);
      }
   }
}

///////////////////////////////////////////////////
// creature non-phys listener

static BOOL g_NonPhysOverride=FALSE; // needed so unset can make creature physical successfully (KJ 8/98)

static void LGAPI CreatureNonPhysListener(sPropertyListenMsg* msg, PropListenerData data)
{
   if (msg->type & (kListenPropModify|kListenPropUnset))
   {
      cCreature *pCreature;
      BOOL isNonPhys=(msg->type&kListenPropUnset)?FALSE:msg->value.intval;

      if (OBJ_IS_CONCRETE(msg->obj))
      {
         if(NULL!=(pCreature=CreatureFromObj(msg->obj)))
         {
            if(isNonPhys)
               pCreature->MakeNonPhysical();
         }
      } else // set lengths for all descendents
      {
         AutoAppIPtr_(TraitManager,TraitMan);
         IObjectQuery* query = TraitMan->Query(msg->obj,kTraitQueryAllDescendents);
         for (; !query->Done(); query->Next())
         {
            ObjID obj = query->Object();
            if (OBJ_IS_CONCRETE(obj))
            {
               if(NULL!=(pCreature=CreatureFromObj(obj)))
               {
                  if(isNonPhys)
                  {
                     pCreature->MakeNonPhysical();
                  } else if(!pCreature->IsPhysical())
                  {
                     g_NonPhysOverride=TRUE;
                     pCreature->MakePhysical();
                     g_NonPhysOverride=FALSE;
                  }
               }
            }
         }
         SafeRelease(query);
      }
   }
}

///////////////////////////////////////////////////

// THIS IS A SEMAPHORE!!!
BOOL g_CreatureIsMovingObj = FALSE; // True if this class is moving an obj.  Set by UpdateObjPos
BOOL g_CreaturePosPropSemaphore = FALSE; // this is also, as expected, a semaphore

static int gCrPosPropLock = 0;

// This annoyance should be called before and after the physics frame,
// because we don't want creatures changing our changes inside physics
void CreaturePosPropLock()
{
   gCrPosPropLock++;
}
void CreaturePosPropUnlock()
{
   gCrPosPropLock--;
}

// @YO OVER HERE
void LGAPI CrPosPropListener(sPropertyListenMsg* msg, PropListenerData data)
   // Listener for the position property.
   // Updates the creature position, if something other than this class moved it.
{
   if (g_CreaturePosPropSemaphore)
      return;
   if (g_CreatureIsMovingObj || OBJ_IS_ABSTRACT(msg->obj))
      return;
   cCreature *pCreature=CreatureFromObj(msg->obj);
   if (!pCreature)
      return;

   if (!pCreature->IsBallistic())
      if (gCrPosPropLock > 0)
         return;

   g_CreaturePosPropSemaphore=TRUE;

   // maybe we should zfloor here in the ballistic case, cause we are so wack

   Position *pPosition=ObjPosGet(msg->obj);

   // can cause creature to become tilted
   pCreature->MoveButt(&pPosition->loc.vec,&pPosition->fac, TRUE,TRUE);
   pCreature->FlushRelativeState();
   CreatureAttachmentsPosUpdate(pCreature->GetObjID());

   IMotorResolver *pResolver=pCreature->GetMotorResolver();
   if(pResolver)
      pResolver->NotifyAboutMotorStateChange();

   g_CreaturePosPropSemaphore=FALSE;
}

///////////////////////////////////////////////////

void CreaturesInit(int nCreatureTypes, const sCreatureDesc **ppCreatureDescs, const char **pCreatureTypeNames, const cCreatureFactory **ppCreatureFactories)
{
   InitCreatureAttachments();

#ifdef PLAYTEST
   COMMANDS(creature_debug_keys,HK_ALL);
#endif

   g_nCreatureTypes=nCreatureTypes;
   // note: I know it's bad to cast a const ptr to non-const, but I don't
   // modify it, honest.  KJ 4/98
   g_pCreatureDescPtr=(sCreatureDesc **)ppCreatureDescs;
   g_pCreatureFactories=(cCreatureFactory **)ppCreatureFactories;

   if((g_pICreatureProperty=CreaturePropertiesInit(nCreatureTypes,pCreatureTypeNames)) == NULL)
   {
        AssertMsg(FALSE,"Failed To Initialize Creature Property!");
   }

   IPropertyManager *propman = AppGetObj(IPropertyManager);
   // install listener on model name property
   IProperty *prop=propman->GetPropertyNamed(PROP_MODELNAME_NAME);
   if(prop)
   {
      prop->Listen(kListenPropModify|kListenPropSet|kListenPropUnset,CreatureModelNameListener,NULL);
      SafeRelease(prop);
   }

   // install listener on creature non-phys property
   prop=propman->GetPropertyNamed(PROP_CREATURENONPHYS_NAME);
   if(prop)
   {
      prop->Listen(kListenPropModify|kListenPropUnset,CreatureNonPhysListener,NULL);
      SafeRelease(prop);
   }

   // install listener on the position property
   prop=propman->GetPropertyNamed(PROP_POSITION_NAME);
   if(prop)
   {
      prop->Listen(kListenPropModify|kListenPropSet,CrPosPropListener,NULL);
      SafeRelease(prop);
   }

   SafeRelease(propman);

   CreatureExplodeInit();
}

///////////////////////////////////////////////////

void CreaturesClose()
{
   TermCreatureAttachments();

   CreaturePropertiesTerm();
   g_pICreatureProperty=NULL;
   g_pCreatureDescPtr=NULL;
   g_nCreatureTypes=0;

}

///////////////////////////////////////////////////

cCreature *CreatureCreate(int type, const ObjID objID)
{
   Assert_(type>=0&&type<g_nCreatureTypes);

   if(g_pCreatureFactories[type])
   {
      return g_pCreatureFactories[type]->Create(type,objID);
   } else
   {
      return new cCreature(type,objID);
   }
}

///////////////////////////////////////////////////

DECLARE_TIMER(CREAT_Total, Average);

void CreaturesUpdate(const ulong timeDelta)
{
   AUTO_TIMER(CREAT_Total);

   int i;
   int max;
   sCreatureHandle *pCHandle;

   IObjectSystem *pObjSys=AppGetObj(IObjectSystem);
   Assert_(pObjSys);
   pObjSys->Lock(); // don't want objects to get deleted during creature update

   AutoAppIPtr_(AIManager, pAIMan);

   max = max_chandle_id();
   for (i = 0; i < max; i++)
   {
      pCHandle=CreatureHandle(i);

      if(!pCHandle)
         continue;

      AssertMsg1(pCHandle->pCreature,"no creature at entry %d",i);

      ValidateCreaturePosition(pCHandle->pCreature->GetObjID());

      cAI *pAI = (cAI *)pAIMan->GetAI(pCHandle->pCreature->GetObjID());

      if (pAI)
      {
         eAIMode mode = pAI->GetState()->GetMode();

         SafeRelease(pAI);

         if ((mode == kAIM_Asleep) ||
             (mode == kAIM_SuperEfficient) ||
             (mode == kAIM_Efficient))
            continue;
      }
      else
      {
         if (ObjIsPosed(pCHandle->pCreature->GetObjID()))
            continue;
      }

      if(!pCHandle->pCreature->IsFrozen())
         pCHandle->pCreature->Update(timeDelta);
   }
   pObjSys->Unlock();
   SafeRelease(pObjSys);
}

///////////////////////////////////////////////////

BOOL CreatureExists(const ObjID obj)
{
   int idx = obj_chandle_id(obj);
   return idx > 0 && CreatureHandle(idx)->pCreature;
}

///////////////////////////////////////////////////

BOOL CreatureSelfPropelled(const ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);
   if(!pCreature)
      return FALSE;
   return !pCreature->IsBallistic();
}

///////////////////////////////////////////////////

void CreatureFreeze(ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);
   if(!pCreature) return;
   if(!pCreature->IsFrozen())
      pCreature->Freeze();
}

///////////////////////////////////////////////////

void CreatureUnFreeze(ObjID objID)
{
   cCreature *pCreature=CreatureFromObj(objID);
   if(!pCreature) return;
   if(pCreature->IsFrozen())
      pCreature->UnFreeze();
}

///////////////////////////////////////////////////

cCreature *CreatureFromObj(ObjID obj)
{
   int idx = obj_chandle_id(obj);
   if (idx > 0)
      return CreatureHandle(idx)->pCreature;
   return NULL;
}

///////////////////////////////////////////////////

#if 0
sDippyLocoState *CreatureGetLocoStatePointer(const ObjID objID)
{
   AssertMsg1(CreatureExists(objID),"no creature for obj %d",objID);

   cCreature *pCreature=CreatureFromObj(objID);

   return &pCreature->m_sLocoState;
}

float CreatureGetButtHeight(const ObjID objID)
{
   AssertMsg1(CreatureExists(objID),"no creature for obj %d",objID);

   cCreature *pCreature=CreatureFromObj(objID);

   return 3.375*pCreature->m_PrimScale;
}
#endif

///////////////////////////////////////////////////

BOOL CreatureGetRenderHandle(const ObjID objID, long *pHandle)
{
   // check that object is a creature
   if(!CreatureExists(objID))
      return FALSE;

   *pHandle=(long)CreatureFromObj(objID);
   return TRUE;
}

///////////////////////////////////////////////////

void CreatureMeshJointPosCallback(const mms_model *m, const int jointID, mxs_trans *pTrans)
{
   AssertMsg(m->app_data,"Invalid Creature Pointer In Joint Callback");

   ((cCreature *)(m->app_data))->MeshJointPosCallback(jointID,pTrans);
}

///////////////////////////////////////////////////

void CreatureMeshStretchyJointCallback(const mms_model *m, const int jointID, mxs_trans *pTrans, quat *pRot)
{
   AssertMsg(m->app_data,"Invalid Creature Pointer In Joint Callback");

   ((cCreature *)(m->app_data))->MeshStretchyJointCallback(jointID,pTrans,pRot);
}

///////////////////////////////////////////////////

BOOL CreatureGetDefaultLengthsName(int type, char *name)
{
   Assert_(g_pCreatureDescPtr&&type<g_nCreatureTypes);
   if(!g_pCreatureDescPtr[type]->defLengthsName)
      return FALSE;
   strcpy(name,g_pCreatureDescPtr[type]->defLengthsName);
   return TRUE;
}

///////////////////////////////////////////////////

void CreatureAbortWeaponMotion(ObjID creature, ObjID weapon)
{
   cCreature *pCreature=CreatureFromObj(creature);

   if(pCreature)
      pCreature->AbortWeaponMotion(weapon);
}

///////////////////////////////////////////////////

void GetSubModelPos(ObjID objID, int submod, mxs_vector *pPos)
{
   cCreature *pCreature = CreatureFromObj(objID);

   if (pCreature != NULL)
      pCreature->GetSubModelPos(submod, pPos);
}

static void GetPhysSubModelPos(mxs_vector *pJoints, sCrPhysModOffset *pOffset, mxs_vector *pPos)
{
   if(pOffset->frac)
   {
      mxs_vector tmp;

      mx_copy_vec(&tmp,&pJoints[pOffset->j1]);
      mx_scaleeq_vec(&tmp,1.0-pOffset->frac);
      mx_copy_vec(pPos,&pJoints[pOffset->j2]);
      mx_scaleeq_vec(pPos,pOffset->frac);
      mx_addeq_vec(pPos,&tmp);
   } else
   {
      mx_copy_vec(pPos,&pJoints[pOffset->j1]);
   }
}

///////////////////////////////////////////////////

void CreatureSetFocusObj(ObjID creature, ObjID focusObj)
{
   cCreature *pCreature = CreatureFromObj(creature);

   if (pCreature)
      pCreature->SetTrackingObj(focusObj);
}

///////////////////////////////////////////////////

void CreatureSetFocusLoc(ObjID creature, const mxs_vector *loc)
{
   cCreature *pCreature = CreatureFromObj(creature);

   if (pCreature)
      pCreature->SetTrackingLoc(*loc);
}

///////////////////////////////////////////////////

void CreatureSetNoFocus(ObjID creature)
{
   cCreature *pCreature = CreatureFromObj(creature);

   if (pCreature)
      pCreature->SetNoTracking();
}

///////////////////////////////////////////////////

typedef struct
{
   int mot;
   Label name;
} sMotSwizzle;

static sMotSwizzle *g_pMotSwizzleMap=NULL;
static int g_nSwizzleMots;

void CreaturesRead(fCreatureReadWrite func, eObjPartition partition)
{
   int i, ver, num;
   if(g_pMotSwizzleMap)
   {
      delete g_pMotSwizzleMap;
      g_pMotSwizzleMap=NULL;
      g_nSwizzleMots=0;
   }

   AutoAppIPtr_(ObjectSystem,pObjSys);

   func(&ver, sizeof(int),1);
   //   AssertMsg1(ver==g_kCreatureVersion||ver==1,"Creature version %d not supported",ver);

   if(ver>=7)
   {
      // read in mot swizzle map
      func((void *)&g_nSwizzleMots, sizeof(int),1);

      g_pMotSwizzleMap=new sMotSwizzle[g_nSwizzleMots];
      func((void *)g_pMotSwizzleMap,sizeof(*g_pMotSwizzleMap),g_nSwizzleMots);
   }

   // read number of creatures
   func((void *)&num, sizeof(int),1);

   // read in creature data
   for (i = 0; i < num; i++)
   {
      ObjID obj;
      int type;
      cCreature *pCreature;

      // Read general info
      func((void *)&obj, sizeof(ObjID),1);
      obj = pObjSys->RemapOnLoad(obj);

      func((void *)&type, sizeof(type),1);

      Assert_(type>=0&&type<g_nCreatureTypes);

      if(g_pCreatureFactories[type])
      {
         pCreature=g_pCreatureFactories[type]->CreateFromFile(type,obj,func,ver);
      } else
      {
         pCreature = new cCreature(type,obj,func,ver);
      }

      sCreatureHandle *pCHandle;
      ObjID objID=pCreature->GetObjID();

      if (!pObjSys->IsObjLoadPartition(objID,partition)
          || !g_pICreatureProperty->Get(objID,&pCHandle))
      {
         Warning(("can't load creature %d\n",objID));
         delete pCreature;
         continue;
      }
      pCHandle = CreatureHandle(obj_chandle_id(objID));

      AssertMsg(pCHandle,"something wacko in creature loading");
      pCHandle->pCreature = pCreature;
   }
}

///////////////////////////////////////////////////

void CreaturesWrite(fCreatureReadWrite func, eObjPartition partition)
{
   int i, max, num, nmot, mot, j;
   sCreatureHandle *pCH;
   IObjectSystem *pObjSys=AppGetObj(IObjectSystem);

   func((void *)&g_kCreatureVersion, sizeof(int),1);

   max = max_chandle_id();

   // calc number of creatures (might not be max id), and how many playing motions
   num=0;
   nmot=0;
   for (i = 0; i < max; i++)
   {
      pCH=CreatureHandle(i);

      if(pCH&&pCH->type!=kCreatureTypeInvalid)
      {
         if(pCH->pCreature && pObjSys->IsObjSavePartition(pCH->pCreature->GetObjID(),partition))
         {
            num++;
            j = 1;  // so mp_get_multiped_motions doesn't just return...
            mp_get_multiped_motions((multiped *)pCH->pCreature->GetMultiped(),&mot,&j);
            if(j)
               nmot++;
         }
      }
   }

   // number of motions in swizzle map
   func((void *)&nmot, sizeof(int),1);

   // write mappings for currently playing motions to motion names, for swizzling
   // iterate over creatures, writing out their data
   for (i = 0; i < max; i++)
   {
      pCH=CreatureHandle(i);

      if (pCH && pCH->type!=kCreatureTypeInvalid)
      {
         AssertMsg1(pCH->pCreature!=NULL,"Creature type %d property, but not class pointer",pCH->type);
         if(pCH->pCreature && pObjSys->IsObjSavePartition(pCH->pCreature->GetObjID(),partition))
         {
            multiped *mp=(multiped *)(pCH->pCreature->GetMultiped());
            j = 1;  // so mp_get_multiped_motions doesn't just return...
            mp_get_multiped_motions(mp,&mot,&j);
            if(j)
            {
               func((void *)&mot, sizeof(int),1);
               Label *pname=g_pMotionSet->GetName(mot);
               func((void *)pname,sizeof(*pname),1);
            }
         }
      }
   }

   // write number of creatures
   func((void *)&num, sizeof(int),1);
   // iterate over creatures, writing out their data
   for (i = 0; i < max; i++)
   {
      pCH=CreatureHandle(i);

      if (pCH && pCH->type!=kCreatureTypeInvalid)
      {
         AssertMsg1(pCH->pCreature!=NULL,"Creature type %d property, but not class pointer",pCH->type);
         if(pObjSys->IsObjSavePartition(pCH->pCreature->GetObjID(),partition))
            pCH->pCreature->Write(func);
      }
   }
   SafeRelease(pObjSys);
}



///////////////////////////////////////////////////
///////////////////////////////////////////////////
////// Creature class implementation
//////
///////////////////////////////////////////////////

///////////////////////////////////////////////////

static void InitMotorState(sMotorState *pMotorState)
{
   memset(pMotorState,0,sizeof(*pMotorState));
   pMotorState->ballisticRefCount=0;
}

// always does something safe, even if it can't find correct lengths values
static void GetLengths(ObjID obj_id, const sCreatureDesc *pCDesc,torso *pTorsos,limb *pLimbs,float *pScale)
{
   char name[38];
   void *pData = NULL;
   BOOL failed=FALSE;
   int nTorsos,nLimbs;
   IRes *pRes;

   AutoAppIPtr(ResMan);

   if(!ObjGetModelName(obj_id,name))
   {
      AssertMsg(pCDesc->defLengthsName,"No default lengths for creature type");
      strcpy(name,pCDesc->defLengthsName);
   }
   strcat(name,".cal");
   pRes = pResMan->Bind(name, RESTYPE_BINARY, NULL, "mesh\\");

   if (pRes) {
      pData = pRes->Lock();
   }

   if (pData && (*((int *)pData)==kMPCalibVersion))
   {
      uchar *pCur;

      pData=(((int *)pData)+1);
      nTorsos=((sCreatureLengths *)pData)->nTorsos;
      nLimbs=((sCreatureLengths *)pData)->nLimbs;

      // verify lengths data consistent with creature type
      //
      AssertMsg3(nTorsos == pCDesc->nTorsos, "nTorsos differs (%d vs %d) for %s",
                 nTorsos, pCDesc->nTorsos, ObjWarnName(obj_id));
      AssertMsg3(nLimbs == pCDesc->nLimbs, "nLimbs differs (%d vs %d) for %s",
                 nLimbs, pCDesc->nLimbs, ObjWarnName(obj_id));

      pCur=(((uchar *)pData)+CL_BASE_SIZE);
      memcpy(pTorsos,pCur,nTorsos*sizeof(torso));
      pCur+=(nTorsos*sizeof(torso));
      memcpy(pLimbs,pCur,nLimbs*sizeof(limb));
      pCur+=(nLimbs*sizeof(limb));
      *pScale=*((float *)(pCur));
   } else
   {
      failed=TRUE;
   }

   if (pData) {
      pRes->Unlock();
   }

   if (pRes) {
      SafeRelease(pRes);
   }

   if(failed) // fill in with dummy data
   {
      Warning(("creature.cpp: GetLengths - can't find lengths for obj %d\n",obj_id));
      *pScale=1.0;
      AssertMsg(pCDesc->pDefTorsos&&pCDesc->pDefLimbs,"creature.cpp: no default limb or torsos for type");
      memcpy(pTorsos,pCDesc->pDefTorsos,pCDesc->nTorsos*sizeof(torso));
      memcpy(pLimbs,pCDesc->pDefLimbs,pCDesc->nLimbs*sizeof(limb));
   }
}


cCreature::cCreature(int type, ObjID objID)
 : m_ObjID(objID),
   m_CreatureType(type),
   m_scalePhys(1.0),
   m_ballisticStyle(kCMB_Normal)
{
   Assert_(g_pCreatureDescPtr&&type<g_nCreatureTypes);

   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[type];

   m_nJoints=g_pCreatureDescPtr[type]->nJoints;
   m_nPhysModels=g_pCreatureDescPtr[type]->nPhysModels;

// allocate necessary memory
//
   m_pJoints  = new mxs_vector[pCDesc->nJoints];
   m_pOrients = new mxs_matrix[pCDesc->nJoints];
   m_pTorsos  = new torso[pCDesc->nTorsos];
   m_pLimbs   = new limb[pCDesc->nLimbs];

   GetLengths(objID, pCDesc,m_pTorsos,m_pLimbs,&m_PrimScale);

   AssertMsg1(m_pTorsos[0].parent==-1,"Obj %d Torso does not follow convention",objID);
   m_iRootJoint=m_pTorsos[0].joint; // by convention

// setup multiped
//
   m_sMultiped.app_ptr=(void *)this;
//   m_sMultiped.app_ptr=(void *)objID;
   m_sMultiped.root_joint = m_iRootJoint;
   m_sMultiped.num_torsos = pCDesc->nTorsos;
   m_sMultiped.num_limbs  = pCDesc->nLimbs;
   m_sMultiped.num_joints = pCDesc->nJoints;
   m_sMultiped.torsos     = m_pTorsos;
   m_sMultiped.limbs      = m_pLimbs;
   m_sMultiped.joints     = m_pJoints;
   m_sMultiped.orients    = m_pOrients;
   // XXX TO DO: get rid of norm field in multiped struct, since never used.
   m_sMultiped.norm=NULL;

   // XXX should mp library do this?  it does orientation.. weird
   mx_zero_vec(&m_sMultiped.global_pos);
   mp_init_multiped(&m_sMultiped);

// initialize remaining data
//
   m_CreatureType=type;

   m_pMotorResolver=NULL;
   m_CompletedMotions=NULL;

   InitMotorState(&m_MotorState);

   const Position *pos=ObjPosGet(objID);

   if (pos)
   {
      MoveButt(&pos->loc.vec,&pos->fac,FALSE);

      ResetLengths();

      if(pCDesc->alwaysBallistic)
      {
         MakeBallistic(m_ballisticStyle, TRUE);  // do once, so makephysical does right thing.
      }
      else
      {
         MakeNonBallistic(TRUE);
      }

      ComputeBoundingData();
      m_DefaultButtZOffset=GetButtZOffset();
      m_MotorState.IsPhysical=MakePhysical();
   }
   else
   {
      Warning(("cCreature()#1: %s has no position\n", ObjWarnName(objID)));
   }

   MvrUtilsRegisterDefaultObjFlags(objID);

   m_trackingObj = OBJ_NULL;
   mx_zero_vec(&m_trackingLoc);
   mx_identity_mat(&m_headOrient);

   m_MaxAngVel = 0x3800;

   m_standingObj = OBJ_NULL;

   m_IsFrozen=FALSE;

}

///////////////////////////////////////////////////

static int MotSwizzle(int mot,motion_callback *pcallback)
{
   int i;
   sMotSwizzle *pSwizz;

   AssertMsg(g_pMotionSet,"can't swizzle mot when no motion set");
   if(pcallback)
      *pcallback=CreatureMotEndCallback;

   if(mot<0)
      return -1;

   // find swizzle entry for mot num
   pSwizz=g_pMotSwizzleMap;
   for(i=0;i<g_nSwizzleMots;i++,pSwizz++)
   {
      if(pSwizz->mot==mot)
         return g_pMotionSet->GetMotHandleFromName(&pSwizz->name);
   }
   return -1;
}

cCreature::cCreature(int type, ObjID objID, fCreatureReadWrite func, int version)
{
   AutoAppIPtr_(ObjectSystem,pObjSys);
   sCreatureLengths lengths;

   m_CreatureType=type;
   m_ObjID=objID;

   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

// allocate necessary memory
//
   m_pJoints = new mxs_vector[pCDesc->nJoints];
   m_pOrients= new mxs_matrix[pCDesc->nJoints];
   m_pTorsos = new torso[pCDesc->nTorsos];
   m_pLimbs = new limb[pCDesc->nLimbs];

   // Read Lengths
   switch (version)
   {
      case 10:
      case 9:
      case 8:
      case 7:
      case 6:
      case 5:
      case 4:
      case 3:
      {
         func((void *)&lengths.nTorsos,sizeof(int),1);
         func((void *)&lengths.nLimbs,sizeof(int),1);

         lengths.pTorsos = new torso[lengths.nTorsos];
         lengths.pLimbs = new limb[lengths.nLimbs];

         func((void *)lengths.pTorsos, sizeof(torso),lengths.nTorsos);
         func((void *)lengths.pLimbs, sizeof(limb),lengths.nLimbs);
         func((void *)&lengths.primScale, sizeof(float), 1);

         break;
      }

      case 2:
      {
         GetLengths(m_ObjID, pCDesc,m_pTorsos,m_pLimbs,&m_PrimScale);

         // read in old data so next read starts in right place, even though
         // it will be ignored
         func((void *)&lengths.nTorsos,sizeof(int),1);
         func((void *)&lengths.nLimbs,sizeof(int),1);

         lengths.pTorsos = new torso[lengths.nTorsos];
         lengths.pLimbs = new limb[lengths.nLimbs];

         // Load old torso
         int i;

         for (i=0; i<lengths.nTorsos; i++)
         {
            func((void *)&lengths.pTorsos[i].joint, sizeof(int), 1);
            func((void *)&lengths.pTorsos[i].parent, sizeof(int), 1);
            func((void *)&lengths.pTorsos[i].num_fixed_points, sizeof(int), 1);

            func((void *)lengths.pTorsos[i].joint_id, sizeof(int), 4);
            func((void *)lengths.pTorsos[i].pts, sizeof(mxs_vector), 4);
         }

         for (i=0; i<lengths.nLimbs; i++)
         {
             func((void *)&lengths.pLimbs[i].torso_id, sizeof(int), 1);
             func((void *)&lengths.pLimbs[i].bend, sizeof(int), 1);
             func((void *)&lengths.pLimbs[i].num_segments, sizeof(int), 1);

             func((void *)lengths.pLimbs[i].joint_id, sizeof(short), 5);
             func((void *)lengths.pLimbs[i].seg, sizeof(mxs_vector), 4);
             func((void *)lengths.pLimbs[i].seg_len, sizeof(mxs_real), 4);
         }

         func((void *)&lengths.primScale, sizeof(float), 1);

         break;
      }

      case 1:
      {
         AssertMsg(FALSE, "This is a really old level.  Creatures probably are broken.\n");

         GetLengths(m_ObjID, pCDesc,m_pTorsos,m_pLimbs,&m_PrimScale);

         // read in old data so next read starts in right place, even though
         // it will be ignored
         func((void *)&lengths.nTorsos,sizeof(int),1);
         func((void *)&lengths.nLimbs,sizeof(int),1);

         lengths.pTorsos = new torso[lengths.nTorsos];
         lengths.pLimbs = new limb[lengths.nLimbs];

         // old torso has one fewer fixed point
         func((void *)lengths.pTorsos, sizeof(torso)-((sizeof(mxs_vector)+sizeof(int)) * 13),lengths.nTorsos);
         // old torso has one fewer limb seg
         func((void *)lengths.pLimbs, sizeof(limb)-((sizeof(short)+sizeof(mxs_vector)+sizeof(mxs_real)) * 13),lengths.nLimbs);
         func((void *)&lengths.primScale, sizeof(float), 1);

         break;
      }

      default:
         CriticalMsg("Unknown version for loading creature lengths!\n");
   }

   if (version >= 4)
   {
      func((void *)&m_trackingObj, sizeof(ObjID), 1);
      m_trackingObj=pObjSys->RemapOnLoad(m_trackingObj);

      func((void *)&m_trackingLoc, sizeof(mxs_vector), 1);
      func((void *)&m_headOrient, sizeof(mxs_matrix), 1);
   }
   else
   {
      m_trackingObj = OBJ_NULL;
      mx_zero_vec(&m_trackingLoc);
      mx_identity_mat(&m_headOrient);
   }

   if (version == 4)
   {
      m_trackingObj = OBJ_NULL;
      mx_zero_vec(&m_trackingLoc);
      mx_identity_mat(&m_headOrient);
   }

   if (version >= 8)
      func((void *)&m_scalePhys, sizeof(float), 1);
   else
      m_scalePhys = 1.0;

   if (version >= 9)
      func((void *)&m_ballisticStyle, sizeof(int), 1);
   else
      m_ballisticStyle = kCMB_Normal;

   if(version >= 10)
      func((void *)&m_MaxAngVel, sizeof(fix), 1);
   else
      m_MaxAngVel = 0x3800;

   sCreatureLengths *pCreatureLengths=&lengths;

   // verify lengths data consistent with creature type
   //
   AssertMsg1(pCreatureLengths&&pCreatureLengths->nTorsos==pCDesc->nTorsos&&\
   pCreatureLengths->nLimbs==pCDesc->nLimbs,"Incompatable lengths for \
   creature type %d",m_CreatureType);

   memcpy(m_pTorsos,pCreatureLengths->pTorsos,pCDesc->nTorsos*sizeof(torso));
   memcpy(m_pLimbs,pCreatureLengths->pLimbs,pCDesc->nLimbs*sizeof(limb));
   m_PrimScale=pCreatureLengths->primScale;

   AssertMsg1(m_pTorsos[0].parent==-1,"Obj %d Torso does not follow convention",m_ObjID);
   m_iRootJoint=m_pTorsos[0].joint; // by convention

   // read in motor state
   InitMotorState(&m_MotorState);
   if(version>=6)
   {
      func((void *)&m_MotorState, sizeof(m_MotorState),1);
      // swizzle
      m_MotorState.focus=pObjSys->RemapOnLoad(m_MotorState.focus);
   }

// setup multiped
//
   m_sMultiped.app_ptr=(void *)this;
//   m_sMultiped.app_ptr=(void *)m_ObjID;
   m_sMultiped.root_joint=m_iRootJoint;
   m_sMultiped.num_torsos=pCDesc->nTorsos;
   m_sMultiped.num_limbs=pCDesc->nLimbs;
   m_sMultiped.num_joints=pCDesc->nJoints;
   m_sMultiped.torsos=m_pTorsos;
   m_sMultiped.limbs=m_pLimbs;
   m_sMultiped.joints=m_pJoints;
   m_sMultiped.orients=m_pOrients;
   // XXX TO DO: get rid of norm field in multiped struct, since never used.
   m_sMultiped.norm=NULL;

   // XXX should mp library do this?  it does orientation.. weird
   mx_zero_vec(&m_sMultiped.global_pos);
   mp_init_multiped(&m_sMultiped);

   // read in multiped save data
   if(version>=6)
   {
      int bufsize;

      func((void *)&bufsize,sizeof(int),1);
      int *buf=new int[bufsize];

      func((void *)buf,bufsize,1);

      mp_read_multiped(&m_sMultiped,buf,MotSwizzle);

      delete buf;
   }

// initialize remaining data
//
   m_nJoints=pCDesc->nJoints;
   m_nPhysModels=pCDesc->nPhysModels;

   m_pMotorResolver=NULL;
   m_CompletedMotions=NULL;

   m_IsFrozen=FALSE; // note this does not get saved/loaded


   const Position *pos=ObjPosGet(m_ObjID);

   if (pos)
   {
      // MoveButt will assume that the m_sMultiped position is where it is being
      // moved from, so we have to set it BEFORE calling MoveButt.
      mx_copy_vec(&m_sMultiped.global_pos, &pos->loc.vec);
      mx_mk_rot_z_mat(&m_sMultiped.global_orient, pos->fac.tz);

      MoveButt(&pos->loc.vec,&pos->fac,FALSE);

      ResetLengths();

      if (IsBallistic())
         MakeBallistic(m_ballisticStyle, TRUE);
      else
         MakeNonBallistic(TRUE);

      ComputeBoundingData();
      m_DefaultButtZOffset=GetButtZOffset();
      if (m_MotorState.IsPhysical)
      {
         MakePhysical();
      }
   }
   else
   {
      Warning(("cCreature()#2: %s has no position\n",ObjWarnName(m_ObjID)));
   }

   delete lengths.pTorsos;
   delete lengths.pLimbs;

   MvrUtilsRegisterDefaultObjFlags(m_ObjID);
}

///////////////////////////////////////////////////

cCreature::~cCreature()
{
   HackProcessCompletedMotions();
   if (CreatureWeaponObjDestroy)
   {
      (*CreatureWeaponObjDestroy)(m_ObjID);
   }

   if(m_pMotorResolver)
   {
      m_pMotorResolver->NotifyAboutMotorDestruction();
   }

   MakeNonPhysical();

   MvrUtilsUnRegisterDefaultObjFlags(m_ObjID);

   mp_stop_all_motions(&m_sMultiped);
   mp_free_multiped(&m_sMultiped);

   delete m_pJoints;
   delete m_pOrients;
   delete m_pTorsos;
   delete m_pLimbs;
}

///////////////////////////////////////////////////

void cCreature::SetMotorResolver(IMotorResolver *pResolver)
{
   m_pMotorResolver=pResolver;
//   m_sMultiped.app_ptr=(void *)pResolver;
}

///////////////////////////////////////////////////

int cCreature::GetActorType()
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType>=0&&m_CreatureType<g_nCreatureTypes);
   return g_pCreatureDescPtr[m_CreatureType]->actorType;
}

///////////////////////////////////////////////////

void cCreature::Write(fCreatureReadWrite func)
{
   // Write General Info, for sanity checking
   func((void *)&m_ObjID, sizeof(m_ObjID),1);
   func((void *)&m_CreatureType, sizeof(m_CreatureType),1);

   // Write Lengths
   func((void *)&m_sMultiped.num_torsos,sizeof(m_sMultiped.num_torsos),1);
   func((void *)&m_sMultiped.num_limbs,sizeof(m_sMultiped.num_limbs),1);
   func((void *)m_pTorsos, sizeof(*m_pTorsos),m_sMultiped.num_torsos);
   func((void *)m_pLimbs, sizeof(*m_pLimbs),m_sMultiped.num_limbs);
   func((void *)&m_PrimScale, sizeof(m_PrimScale), 1);

   // Write tracking stuff
   func((void *)&m_trackingObj, sizeof(ObjID), 1);
   func((void *)&m_trackingLoc, sizeof(mxs_vector), 1);
   func((void *)&m_headOrient, sizeof(mxs_matrix), 1);

   func((void *)&m_scalePhys, sizeof(float), 1);
   func((void *)&m_ballisticStyle, sizeof(int), 1);

   func((void *)&m_MaxAngVel,sizeof(fix),1);

   // Write motor state
   m_MotorState.IsPhysical = PhysObjHasPhysics(m_ObjID);
   func((void *)&m_MotorState, sizeof(m_MotorState),1);

   // Write multiped motion stuff
   const int msize=mp_get_write_buffsize(&m_sMultiped);
   func((void *)&msize,sizeof(msize),1);
   uchar *buf= new uchar[msize];
   mp_write_multiped(&m_sMultiped, (void *)buf);
   func((void *)buf,msize,1);
   delete buf;
}

///////////////////////////////////////////////////

void cCreature::ResetLengths()
{
   quat *rot = new quat[m_sMultiped.num_joints+1];
   mxs_vector v;

   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);

   GetLengths(m_ObjID,g_pCreatureDescPtr[m_CreatureType],m_pTorsos,m_pLimbs,&m_PrimScale);

   Assert_(rot);

   // store off current rotations
   memcpy(rot,m_sMultiped.rel_orients,(m_sMultiped.num_joints+1)*sizeof(*rot));
   quat_from_matrix(&rot[m_sMultiped.num_joints],&m_sMultiped.global_orient);
   mx_zero_vec(&v);

   // want buttzoffset of multiped in calibration position, which may be
   // very different from current position (like if creature was posed).
   mp_initial_update(&m_sMultiped);
   ComputeBoundingData();
   m_DefaultButtZOffset=GetButtZOffset();

   mp_apply_motion(&m_sMultiped,rot,&v,-1);

   ComputeBoundingData();

   if (m_CreatureType != 10) // rope magic number
   {
      const Position *pPos=ObjPosGet(m_ObjID);
      SetCretObjPos(m_ObjID,&pPos->loc.vec,&pPos->fac); // this needed to update brush and refs
   }
   delete rot;
}

///////////////////////////////////////////////////

// NOTE: this doesn't do any physics checking to see if this is safe, so use
// at your own peril.  phys models get teleported, bbox gets updated etc.
void cCreature::PoseAtMotionFrame(int motNum, float frame)
{
   mps_motion_node node;
   mxs_vector xlat;

   if(motNum<0||motNum>mp_num_motions)
      return;
   if(frame<0||frame>mp_motion_list[motNum].info.num_frames-1)
   {
      frame=mp_motion_list[motNum].info.num_frames-1;
   }

   quat *rot=new quat[m_sMultiped.num_joints+1];

   // intialize xlat and rots, in case motion is an overlay
   mx_zero_vec(&xlat);
   int i;
   for(i=0;i<m_sMultiped.num_joints+1;i++)
   {
      quat_identity(&rot[i]);
   }

   memset(&node,0,sizeof(node));
   node.frame=frame;
   node.handle=motNum;

   // want these to be zero if global frame of ref (or special MFRT_Arm frame of reference).
   if(GetMotFrameOfReference()!=kMFRT_RelStart)
   {
      mx_zero_vec(&node.base_pos);
      quat_identity(&node.base_orient);
   } else
   {
      mx_copy_vec(&node.base_pos,&m_sMultiped.global_pos);
      quat_from_matrix(&node.base_orient,&m_sMultiped.global_orient);
   }

   MotDmngeLock(motNum);
   mp_evaluate_motion(&m_sMultiped,&node,rot,&xlat);
   mx_zero_vec(&xlat); // want creature to stay in place.
   mp_apply_motion(&m_sMultiped,rot,&xlat,-1);
   MotDmngeUnlock(motNum);

   ComputeBoundingData();
   if(PhysObjHasPhysics(m_ObjID)&&!IsBallistic())
      SlamPhysicsModels();
   CreatureAttachmentsPosUpdate(m_ObjID);

   delete rot;
}

///////////////////////////////////////////////////

int cCreature::SwizzleMotion(int motNum)
{
   return MotSwizzle(motNum,NULL);
}

///////////////////////////////////////////////////

int cCreature::GetCurrentMotion()
{
   int mot,maxmot=1;
   mp_get_multiped_motions(&m_sMultiped,&mot,&maxmot);
   if(maxmot)
      return mot;
   return -1;
}

///////////////////////////////////////////////////

// XXX TO DO: make this faster.  what are the fancy float things to do again?
void cCreature::ComputeBoundingData()
{
   mxs_vector bigun,max_off,min_off;
   mxs_vector *j;
   mxs_vector *bmin=&m_BMin;
   mxs_vector *bmax=&m_BMax;
   int i;

   mx_copy_vec(bmin,&m_pJoints[m_iRootJoint]);
   mx_copy_vec(bmax,&m_pJoints[m_iRootJoint]);

   j=m_pJoints;

   for(i=0;i<m_nJoints;i++,j++)
   {
      if(j->x<bmin->x)
         bmin->x=j->x;
      else if (j->x>bmax->x)
         bmax->x=j->x;
      if(j->y<bmin->y)
         bmin->y=j->y;
      else if (j->y>bmax->y)
         bmax->y=j->y;
      if(j->z<bmin->z)
         bmin->z=j->z;
      else if (j->z>bmax->z)
         bmax->z=j->z;
   }

   // calc radius
   mx_sub_vec(&max_off,bmax,&m_pJoints[m_iRootJoint]);
   mx_sub_vec(&min_off,bmin,&m_pJoints[m_iRootJoint]);
   for(i=0;i<3;i++)
   {
      if(fabs(max_off.el[i])>fabs(min_off.el[i]))
         bigun.el[i]=max_off.el[i];
      else
         bigun.el[i]=min_off.el[i];
   }
   m_Radius=mx_mag_vec(&bigun);
}

///////////////////////////////////////////////////

// XXX don't want this really.  Want offset computed by motion processor
inline void cCreature::GetFeetJointIDs(int *pnJoints, int **ppJointIDs) const
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   *pnJoints=g_pCreatureDescPtr[m_CreatureType]->nFeet;
   *ppJointIDs=(int *)g_pCreatureDescPtr[m_CreatureType]->footJoints;
}

///////////////////////////////////////////////////

void cCreature::RecomputeJointPositions()
{
   quat *rot = new quat[m_sMultiped.num_joints+1];
   mxs_vector v;

   if(rot)
   {
      memcpy(rot,m_sMultiped.rel_orients,m_sMultiped.num_joints*sizeof(*rot));
      // global_orient and rel orient for root may be out of synch due to
      // MoveButt calls.  compensate here instead of in movebutt, because
      // otherwise movements are jerky
      quat_from_matrix(&rot[m_sMultiped.num_joints],&m_sMultiped.global_orient);
      mx_zero_vec(&v);
      mp_apply_motion(&m_sMultiped,rot,&v,-1);
      delete rot;
   } else
   {
      mp_initial_update(&m_sMultiped);
   }
}

///////////////////////////////////////////////////

// only valid for normalized vector
// WARNING: assumes normalized vec in X/Y plane.
static mxs_ang GetNormVecHeading(mxs_vector *vec)
{
   mxs_ang angle;

   angle=mx_rad2ang(acos(vec->x));
   if(angle>0)
   {
      if(vec->y<0) // -pi/2 < actual angle < 0
         angle=-angle;
   } else if (vec->y>0) // -pi < actual angle <= -pi/2
      angle=-angle;
   return angle;
}

static mxs_ang GetHeadingAngle(mxs_matrix *m)
{
   mxs_vector vec = m->vec[0];
   // Let's make this NOT quite zero, so normeq div0 won't occur.
   vec.z = 0.000001; // make sure it normalizes on X/Y plane. 'diff' is not used for anything else.
   mx_normeq_vec(&vec);

   return GetNormVecHeading(&vec);
}

#define CREATURE_FAC_ERR 0x0003

BOOL cCreature::MoveButt(const mxs_vector *pButtPos, const mxs_angvec *pAngles, BOOL updatePhysics, BOOL allowTilt)
{
   int i;
   mxs_vector *pJnt;
   mxs_vector d,old, trav;
   mxs_matrix mat,delt;
   quat dQ, tmp;
   mps_stack_node *mps;

   ConfigSpew("CreaturePosTrace",("%d moveButt: to %g, %g, %g, %x, mph=%d\n",m_ObjID,pButtPos->x,pButtPos->y,pButtPos->z,pAngles->tz,updatePhysics));

   mxs_vector new_butt_pos = *pButtPos;

   mx_copy_vec(&old,&m_sMultiped.global_pos);
   mx_copy_vec(&m_sMultiped.global_pos,&new_butt_pos);

   if(allowTilt)
   {
      mxs_matrix newor;

      mx_ang2mat(&newor,pAngles);
      mx_mult_mat(&mat,&newor,&m_sMultiped.global_orient);  // @TODO: this or tmul_mat?
      mx_copy_mat(&m_sMultiped.global_orient,&newor);
   } else
   {
      mxs_ang angle=GetHeadingAngle(&m_sMultiped.global_orient);

      if(((angle-pAngles->tz)>=0&&(angle-pAngles->tz)<CREATURE_FAC_ERR) || \
         ((angle-pAngles->tz)<0&&(angle-pAngles->tz)>-CREATURE_FAC_ERR))
      {
         mx_identity_mat(&mat);
      } else
      {
         mx_mk_rot_z_mat(&mat,pAngles->tz);
         mx_copy_mat(&m_sMultiped.global_orient,&mat);
         mx_mk_rot_z_mat(&delt,(mxs_ang)(-angle));
         mx_muleq_mat(&mat,&delt);
      }
   }

   mx_sub_vec(&d,&new_butt_pos,&old);

   quat_from_matrix(&dQ,&mat);
   mps=m_sMultiped.main_motion.head;
   while(mps)
   {
      if(mps->type==MN_MOTION)
      {
         // XXX TO DO: only modify if not a virtual motion

         mx_sub_vec(&trav,&old,&((mps_motion_node *)mps)->base_pos);
         mx_mat_muleq_vec(&mat,&trav);
         mx_sub_vec(&(((mps_motion_node *)mps)->base_pos),&new_butt_pos,&trav);
         //         mx_addeq_vec(&((mps_motion_node *)mps)->base_pos,&d);
         quat_copy(&tmp,&((mps_motion_node *)mps)->base_orient);
         quat_mul(&((mps_motion_node *)mps)->base_orient,&dQ,&tmp);
      }
      mps=mps->next;
   }

   pJnt=m_pJoints;
   for(i=0;i<m_nJoints;i++,pJnt++)
   {
      mx_sub_vec(&d,pJnt,&old);
      mx_mat_muleq_vec(&mat,&d);
      mx_add_vec(pJnt, &d, &m_sMultiped.global_pos);
      mx_mul_mat(&delt,&mat,&m_pOrients[i]);
      mx_copy_mat(&m_pOrients[i],&delt);
   }

   ComputeBoundingData();

   if (!g_SimRunning)
   {
      if (CreatureFromObj(m_ObjID) != NULL)
      {
         int head_joint = GetCreatureJointID(m_ObjID, kCJ_Neck);
         mx_copy_mat(&m_headOrient, &m_pOrients[head_joint]);
      }
      else
         mx_copy_mat(&m_headOrient, &m_sMultiped.global_orient);
   }

   ValidateCreaturePosition(m_ObjID);

   if(updatePhysics && PhysObjHasPhysics(m_ObjID) && !g_SimRunning) //&& IsBallistic()))
   {
      SlamPhysicsModels();
   }

   ValidateCreaturePosition(m_ObjID);

   // "floor" remote ghosts
   if (IsRemoteGhost(m_ObjID) && (CreatureFromObj(m_ObjID) != NULL))
   {
      Location start, end, hit;
      ObjID hit_obj;

      int filter = kCollideSphereHat | kCollideOBB | kCollideTerrain;

      if (GhostIsFloored(m_ObjID))
      {
         MakeHintedLocationFromVector(&start, pButtPos, &ObjPosGet(m_ObjID)->loc);
         MakeLocationFromVector(&end, pButtPos);
         end.vec.z -= 11.0;

         // Cast down to find floor height
         if (PhysRaycast(start, end, &hit, &hit_obj, 0, filter) != kCollideNone)
         {
            float height = start.vec.z - hit.vec.z;

            if ((height > 0) && (height < 10))
            {
               // Find height from butt to feet
               float left_butt_height, right_butt_height;

               mxs_vector butt, foot_left, foot_right;

               mx_copy_vec(&butt, &GetCreatureJointPos(m_ObjID, kCJ_Butt));
               mx_copy_vec(&foot_left, &GetCreatureJointPos(m_ObjID, kCJ_LToe));
               mx_copy_vec(&foot_right, &GetCreatureJointPos(m_ObjID, kCJ_RToe));

               left_butt_height = butt.z - foot_left.z;
               right_butt_height = butt.z - foot_right.z;

               if ((left_butt_height > 0) || (right_butt_height > 0))
               {
                  if (left_butt_height > right_butt_height)
                     new_butt_pos.z = hit.vec.z + left_butt_height;
                  else
                     new_butt_pos.z = hit.vec.z + right_butt_height;
               }
               else
               {
                  new_butt_pos.z = hit.vec.z + 1.0; // @TBD: lift a little here?
               }
            }
         }
      }
      else
      {
         MakeHintedLocationFromVector(&start, pButtPos, &ObjPosGet(m_ObjID)->loc);

         mxs_real left_z = 0;
         mxs_real right_z = 0;

         MakeLocationFromVector(&end, &GetCreatureJointPos(m_ObjID, kCJ_LToe));
         if (PhysRaycast(start, end, &hit, &hit_obj, 0, filter) != kCollideNone)
            left_z = hit.vec.z - end.vec.z;

         MakeLocationFromVector(&end, &GetCreatureJointPos(m_ObjID, kCJ_RToe));
         if (PhysRaycast(start, end, &hit, &hit_obj, 0, filter) != kCollideNone)
            right_z = hit.vec.z - end.vec.z;

         new_butt_pos.z += max(left_z, right_z);
      }

      mx_copy_vec(&old,&m_sMultiped.global_pos);
      mx_copy_vec(&m_sMultiped.global_pos,&new_butt_pos);
      mx_sub_vec(&d,&new_butt_pos,&old);

      pJnt=m_pJoints;
      for(i=0;i<m_nJoints;i++,pJnt++)
      {
         mx_sub_vec(&d,pJnt,&old);
         mx_mat_muleq_vec(&mat,&d);
         mx_add_vec(pJnt, &d, &m_sMultiped.global_pos);
         mx_mul_mat(&delt,&mat,&m_pOrients[i]);
         mx_copy_mat(&m_pOrients[i],&delt);
      }

      ComputeBoundingData();

      ValidateCreaturePosition(m_ObjID);

      if(updatePhysics && PhysObjHasPhysics(m_ObjID) && !g_SimRunning) //&& IsBallistic()))
      {
         SlamPhysicsModels();
      }

      ValidateCreaturePosition(m_ObjID);
   }

   mx_copy_vec(&m_MotorState.position,&new_butt_pos);
   m_MotorState.facing=*pAngles;
   return TRUE;
}

///////////////////////////////////////////////////

void cCreature::SlamPhysicsModels()
{
   int i;

   Assert_(g_pCreatureDescPtr && m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc = g_pCreatureDescPtr[m_CreatureType];

   if (m_CreatureType == 10) // rope magic number
      return;

   ConfigSpew("BipedPhys",("%d: forcing phys model pos\n",m_ObjID));

   cPhysModel *pModel;
   if ((pModel = g_PhysModels.Get(m_ObjID)) == NULL)
      return;

   PosPropLock++;

   gCrPosPropLock++;

   PhysSetModLocation(m_ObjID, &m_sMultiped.global_pos);
   PhysSetModRotation(m_ObjID, &ObjPosGet(m_ObjID)->fac);

   if (!IsMovingTerrain(m_ObjID)&&!(IsBallistic()&&m_ballisticStyle==kCMB_Corpse))
   {
      for(i=0; i<pCDesc->nPhysModels && i<pModel->NumSubModels(); i++)
      {
         mxs_vector subPos;

         GetPhysSubModelPos(m_pJoints, &pCDesc->pCrPhysModOffsets[i], &subPos);

         if (IsBallistic())
            PhysSetSubModLocation(m_ObjID, i, &subPos);
         else
            PhysControlSubModLocation(m_ObjID, i, &subPos);

         ConfigSpew("BipedPhys",("sub %d: %g,%g,%g\n",i,subPos.x,subPos.y,subPos.z));
      }
   }

   gCrPosPropLock--;

   ValidateCreaturePosition(m_ObjID);

   PosPropLock--;
}

///////////////////////////////////////////////////


#define MAX_WORLD_SIZE 60000

// Only to be called internall by creature system
void SetCretObjPos(ObjID objID, const mxs_vector *pos, const mxs_angvec *rot)
{
   // check position is valid
   AssertMsg3(pos->x>-MAX_WORLD_SIZE&&pos->x<MAX_WORLD_SIZE&&\
      pos->y>-MAX_WORLD_SIZE&&pos->y<MAX_WORLD_SIZE,\
      "SetCretObjPos: invalid new position for %d: %g, %g\n",
              objID, pos->x, pos->y);

   PosPropLock++;
   g_CreatureIsMovingObj = TRUE;  // tell PosPropListener not to bother.
   ObjPosUpdateUnsafe(objID,pos,rot);
   PhysUpdateRefsObj(objID);
   g_CreatureIsMovingObj = FALSE;
   PosPropLock--;
}

BOOL cCreature::UpdateObjPosition()
{
   mxs_angvec fac;

   fac.tz = GetHeadingAngle(&m_sMultiped.global_orient);
   fac.tx = fac.ty = 0;

   SetCretObjPos(m_ObjID,&m_sMultiped.global_pos,&fac);

   mx_copy_vec(&m_MotorState.position,&m_sMultiped.global_pos);
   m_MotorState.facing=fac;

   return TRUE;
}

///////////////////////////////////////////////////

// for when you don't want to blend to new global position.
void cCreature::FlushRelativeState()
{
   mx_copy_vec(&m_sMultiped.rel_xlat,&m_sMultiped.global_pos);
}

///////////////////////////////////////////////////
static BOOL GetMpMainMotionBaseOrient(multiped *mp,quat **ppRot,mxs_vector **ppPos)
{
   mps_stack_node *pStackNode;

   pStackNode=mp->main_motion.head;
   while(pStackNode)
   {
      if(pStackNode->type==MN_MOTION)
      {
         if(((mps_motion_node *)pStackNode)->handle>0) // so not a pose
         {
            *ppRot= &(((mps_motion_node *)pStackNode)->base_orient);
            *ppPos= &(((mps_motion_node *)pStackNode)->base_pos);
            return TRUE;
         }
      }
      pStackNode=pStackNode->next;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////

#define kMaxAngVel 0x3800   // in mxs_ang per sec

void cCreature::FilterMotionFrameData(const mps_motion_info *mi, quat *rot, mxs_vector *xlat)
{
#if 0
   ObjID focus=m_MotorState.focus;

   focus = gPlayerObj;

   // @TODO: focus stuff for head-turning
   // rotate base orientation to face focus.  (where base orientation is
   // starting orientation of motion.)
   // @NOTE that this won't work correctly for turns or motions that are being
   // bent, since global orientation varies over course of these motions instead
   // of always being base orientation.
   if(focus!=OBJ_NULL) // @TODO: don't use for ballistic creatures?
   {
      // set orientation of base joint

      quat *pBaseOrient;
      mxs_vector *pBasePos;

      if(GetMpMainMotionBaseOrient(&m_sMultiped,&pBaseOrient,&pBasePos))
      {
         ObjPos *pPos=ObjPosGet(focus); // @OPTIMIZE: store this off somewhere instead of computing every update
         // compute angle to focus obj
         mxs_vector diff;
         mxs_ang desFac,curFac,delta;
         mxs_matrix mat,mat2;
         fix maxTurn;  // needs to be fix due to overflow
         BOOL negRot=FALSE;

         mx_sub_vec(&diff,&pPos->loc.vec,&m_sMultiped.global_pos);
         // Let's make this NOT quite zero, so normeq div0 won't occur.
         diff.z = 0.000001; // make sure it normalizes on X/Y plane. 'diff' is not used for anything else.
         mx_normeq_vec(&diff);
         desFac=GetNormVecHeading(&diff);

         // compare to actual heading and clamp.
         curFac=GetHeadingAngle(&m_sMultiped.global_orient);
         delta=desFac-curFac;
         if(delta>MX_ANG_PI)
         {
            delta=-delta;
            negRot=TRUE;
         }
#if 0
         // @TODO: get msec from somewhere, do clamping
         maxTurn=fix_mul(kMaxAngVel,(fix_from_float(time_delta_ms/1000)));
         if(delta>maxTurn) // clamp
         {
            delta=maxTurn;
         }
#endif
         if(negRot)
            delta=-delta;
         desFac=curFac+delta;

         // modify base rotation
         // @TODO: take out base rotation
         quat rotOff;
         mxs_matrix matOff;

         GetFocusRotOffset(&rotOff,pBaseOrient,rot);
         quat_to_matrix(&matOff,&rotOff);
         mx_transeq_mat(&matOff);
         mx_mk_rot_z_mat(&mat,desFac);
         mx_mul_mat(&mat2,&matOff,&mat);
         quat_from_matrix(&rot[GetFocusJoint()],&mat2);
//         quat_from_matrix(pBaseOrient,&mat);
      }
   }
#endif
}

///////////////////////////////////////////////////

void cCreature::PostUpdateFilter(const ulong dt)
{
   const sCreatureDesc *pCDesc = g_pCreatureDescPtr[m_CreatureType];

   if (m_CreatureType == 10) // rope magic number
   {
      cPhysModel *pModel;
      int i;

      if ((pModel = g_PhysModels.Get(m_ObjID)) == NULL)
      {
         Warning(("cCreature::PostUpdateFilter: rope (obj %d) has no physics model?\n", m_ObjID));
         return;
      }

      mxs_matrix orien;
      mxs_vector vec;

      for (i=0; i<pModel->NumSubModels() + 1; i++)
      {
         Assert_(i < m_nJoints);

         if (i == 8)
            mx_copy_vec(&m_pJoints[8], &m_pJoints[7]);
         else
            mx_copy_vec(&m_pJoints[i], &pModel->GetLocationVec(i));

         // Root orientation is always the identity
         if (i >= 7)
         {
            mx_copy_mat(&m_pOrients[i], &m_pOrients[i-1]);
            mx_identity_mat(&m_pOrients[0]);
         }
         else
         {
            // Build matrix
            mx_sub_vec(&orien.vec[2], &pModel->GetLocationVec(i+1), &pModel->GetLocationVec(i));
            mx_normeq_vec(&orien.vec[2]);

            mx_unit_vec(&vec, 1);
            mx_cross_vec(&orien.vec[0], &vec, &orien.vec[2]);
            mx_normeq_vec(&orien.vec[0]);

            mx_cross_vec(&orien.vec[1], &orien.vec[2], &orien.vec[0]);
            mx_normeq_vec(&orien.vec[1]);
            mx_copy_mat(&m_pOrients[i], &orien);
         }
      }
   }
   else
   if (pCDesc->canHeadTrack)
   {
      if (m_trackingObj == 0)
         m_trackingObj = m_MotorState.focus;

      #define sq(x)  ((x) * (x))

      int head_joint_id = GetCreatureJointID(m_ObjID, kCJ_Neck);
      int neck_joint_id = GetCreatureJointID(m_ObjID, kCJ_Abdomen);

      mxs_matrix *head_mat = &m_pOrients[head_joint_id];
      mxs_matrix *neck_mat = &m_pOrients[neck_joint_id];

      mxs_matrix head_delta;
      mxs_real   head_track_rate = 100.0;

      if ((m_trackingObj == -1) || (m_trackingObj > 0))
      {
         if (!PlayerObjectExists())
            return;

         // Find vector to our target
         mxs_vector to_target;

         if (m_trackingObj == PlayerObject())
            PhysGetSubModLocation(PlayerObject(), PLAYER_HEAD, &to_target);
         else
         if (m_trackingObj > 0)
         {
            ObjPos * pPos = ObjPosGet(m_trackingObj);
            if (!pPos)
            {
               m_trackingObj = NULL;
               return;
            }
            to_target = pPos->loc.vec;
         }
         else
            to_target = m_trackingLoc;

         mx_subeq_vec(&to_target, &GetCreatureJointPos(m_ObjID, kCJ_Head));
         if (mx_mag2_vec(&to_target) < 0.0001)
            return;

         mx_normeq_vec(&to_target);

         const float kMinXYNeckDot = 0.0;
         const float kMaxZNeckDiff = 0.8;

         mxs_vector xy_to_target;
         mxs_vector xy_neck;

         mx_mk_vec(&xy_to_target, to_target.x, to_target.y, 0);
         mx_mk_vec(&xy_neck, neck_mat->vec[0].x, neck_mat->vec[0].y, 0);

         mx_normeq_vec(&xy_to_target);
         mx_normeq_vec(&xy_neck);

         mxs_real xy_dot = mx_dot_vec(&xy_to_target, &xy_neck);
         mxs_real z_diff = fabs(to_target.z - neck_mat->vec[0].z);

         // See if we've gone too far
         if ((xy_dot > kMinXYNeckDot) && (z_diff < kMaxZNeckDiff))
         {
            if ((fabs(to_target.z) > 0.999) || (mx_mag2_vec(&to_target) < 0.001))
               return;

            // Build new head orientation matrix
            mxs_matrix new_head_orient;
            mxs_vector z_vec;

            mx_unit_vec(&z_vec, 2);

            mx_copy_vec(&new_head_orient.vec[0], &to_target);
            mx_cross_vec(&new_head_orient.vec[1], &z_vec, &new_head_orient.vec[0]);
            mx_normeq_vec(&new_head_orient.vec[1]);
            mx_cross_vec(&new_head_orient.vec[2], &new_head_orient.vec[0], &new_head_orient.vec[1]);
            mx_normeq_vec(&new_head_orient.vec[2]);

            for (int i=0; i<3; i++)
               mx_sub_vec(&head_delta.vec[i], &new_head_orient.vec[i], &m_headOrient.vec[i]);
         }
         else
         {
            for (int i=0; i<3; i++)
               mx_sub_vec(&head_delta.vec[i], &head_mat->vec[i], &m_headOrient.vec[i]);
         }
      }
      else
      {
         for (int i=0; i<3; i++)
            mx_sub_vec(&head_delta.vec[i], &head_mat->vec[i], &m_headOrient.vec[i]);

         head_track_rate = 100.0;
      }

      float scale_amt;

      scale_amt = ((float)dt) / head_track_rate;
      if (scale_amt > 1.0)
         scale_amt = 1.0;

      // Move head towards desired orientation
      for (int i=0; i<3; i++)
      {
         mx_scaleeq_vec(&head_delta.vec[i], scale_amt);
         mx_add_vec(&m_headOrient.vec[i], &m_headOrient.vec[i], &head_delta.vec[i]);
         mx_normeq_vec(&m_headOrient.vec[i]);
      }
   }
}

///////////////////////////////////////////////////

static void mp_get_current_motrel_xlat(mxs_vector *dst, multiped *mp,mps_motion_node *mn)
{
   mps_motion_param * p;
   mps_motion * m;
   int cur_frame, motion_num;

   // Get translational distance at start frame.

	if(!mn)
      return;

   cur_frame = (int) floor(mn->frame + 0.5);
   motion_num = MP_MOTNUM_FROM_NODE_HANDLE(mn->handle);
   p = &mn->params;

   m = mp_motion_list + motion_num;

   mp_get_xlat_at_frame(dst, motion_num, cur_frame);

   if (p)
   {
      if (p->flags & MP_BEND)
      {
         mxs_matrix mat;

         mx_mk_rot_z_mat(&mat, mx_rad2ang(p->bend));
         mx_mat_muleq_vec(&mat, dst);
      }
      if (p->flags & MP_STRETCH) // only gets applied to x and y components
      {
//         mx_scaleeq_vec(dst, p->stretch);
         dst->x*=p->stretch;
         dst->y*=p->stretch;
      }
      if(p->flags & MP_VSTRETCH)
      {
         dst->z*=p->vstretch;
      }
      if(p->flags & MP_VINC)
      {
         dst->z += (float)(cur_frame-mn->start_frame)*
            (p->vinc/(m->info.num_frames-1-mn->start_frame));
      }
   }
}

///////////////////////////////////////////////////

BOOL cCreature::SetTransform(const mxs_vector *pButtPos, const mxs_angvec *pAngles, BOOL movePhys)
{
   if(IsBallistic()) // creature not self-controlling, so can't set own pos
      return FALSE;
   return MoveButt(pButtPos,pAngles,movePhys)&&UpdateObjPosition();
}

///////////////////////////////////////////////////

BOOL cCreature::SetPosition(const mxs_vector *pButtPos, BOOL movePhys)
{
   mxs_vector opos;
   mxs_angvec ofac;

   if(IsBallistic()) // creature not self-controlling, so can't set own pos
      return FALSE;
   GetTransform(&opos,&ofac);
   return MoveButt(pButtPos,&ofac,movePhys)&&UpdateObjPosition();
}

///////////////////////////////////////////////////

BOOL cCreature::SetOrientation(const mxs_angvec *pAngles, BOOL movePhys)
{
   mxs_vector opos;
   mxs_angvec ofac;

   if(IsBallistic()) // creature not self-controlling, so can't set own rot
      return FALSE;
   GetTransform(&opos,&ofac);
   ConfigSpew("CreaturePosTrace",("%d setOrient: rotating to %x\n",m_ObjID,pAngles->tz));
   return MoveButt(&opos,pAngles,movePhys)&&UpdateObjPosition();
}

///////////////////////////////////////////////////

void cCreature::GetTransform(mxs_vector *pButtPos, mxs_angvec *pAngles)
{
   Position *pPos=ObjPosGet(m_ObjID);

   AssertMsg1(pPos,"No position for obj %d",m_ObjID);

   *pButtPos=pPos->loc.vec;
   *pAngles=pPos->fac;
}

///////////////////////////////////////////////////

BOOL cCreature::MakePhysical()
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);

   // don't to anything if property says it is never physical
   if(!g_NonPhysOverride&&ObjIsNonPhysicalCreature(m_ObjID))
      return FALSE;

   if (PhysObjHasPhysics(m_ObjID))
   {
      cPhysModel *pModel;

      if ((pModel = g_PhysModels.Get(m_ObjID)) != NULL)
         pModel->SetFlagState(kPMF_Creature, TRUE);

      return TRUE;
   }

   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];
   int i;
   ObjID objID=m_ObjID;
   ulong flags=NULL;

   if(!pCDesc->nPhysModels)
      return FALSE;

   // create new phys models
   PhysRegisterSphere(objID,pCDesc->nPhysModels,flags,pCDesc->physRadius);
   cPhysModel *pModel = g_PhysModels.Get(objID);

   if (pModel == NULL)
      return FALSE;

   pModel->SetFlagState(kPMF_Creature, TRUE);

   if (pCDesc->hasSpecialPhysics)
   {
      pModel->SetFlagState(kPMF_Special, TRUE);
      UpdatePhysProperty(objID, PHYS_TYPE);
   }

   SetPhysSubModScale(m_scalePhys);

   SlamPhysicsModels();

   for(i=0;i<pCDesc->nPhysModels && i<pModel->NumSubModels();i++)
   {
      // activate location control
      if(PhysSubModIsBallistic(i))
         MakePhysSubModBallistic(i, m_ballisticStyle);
   }

   m_MotorState.IsPhysical=PhysObjHasPhysics(objID);

   ValidateCreaturePosition(m_ObjID);

   #ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s physical\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
   #endif

   // Attach the weapon representation to the creature.
   if (CreatureWeaponObjSwizzle)
   {
      ((*CreatureWeaponObjSwizzle)(m_ObjID, kWeaponModeIdle));
   }

   return m_MotorState.IsPhysical;
}

///////////////////////////////////////////////////

void cCreature::MakeNonPhysical()
{
   if (!PhysObjHasPhysics(m_ObjID))
      return;

   ValidateCreaturePosition(m_ObjID);

#ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s going non-physical\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }

   SlamPhysicsModels();

   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s non-physical\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
#endif

   PhysDeregisterModel(m_ObjID);
   m_MotorState.IsPhysical=FALSE;
}

///////////////////////////////////////////////////

// shrink phys submodels
#define kDeathShrinkage 0.7

void cCreature::PrepareToDie()
{
   if(!IsPhysical())
      return;

   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);

   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   if(!pCDesc->nPhysModels)
      return;

   SetPhysSubModScale(kDeathShrinkage);

   // @TODO:  Bodisafa 12/7/1999
   // This should be hooked up to a motion.
   if (CreatureWeaponObjDrop)
   {
      (*CreatureWeaponObjDrop)(m_ObjID);
   }
   return;
}

///////////////////////////////////////////////////

// After a creature dies and plays its death motion, we can either remove its
// physics or leave it there.  Leaving it there is cool if we want the player to be
// able to push or attack the dead body.  In any event, the code for not removing
// physics is kind of broken. (Generally, the mesh becomes totally separated from
// the object and its physics, and the physics does weird stuff like slide around.)
// So, we currently favor removal of the physics.
#define REMOVE_DEAD_PHYSICS
#ifdef REMOVE_DEAD_PHYSICS

void cCreature::BeDead()
{
   if(!IsPhysical())
      return;

   ConfigSpew("CreatureTrace",("%d: is dead\n",m_ObjID));

   PhysDeregisterModel(m_ObjID);

   m_MotorState.IsPhysical = PhysObjHasPhysics(m_ObjID);

   AssertMsg1 (!(m_MotorState.IsPhysical), "Failed to remove physics from recently deceased %s",
               ObjWarnName(m_ObjID));
}

#else // !REMOVE_DEAD_PHYSICS

// make ballistic and change to one phys model with rest axis
void cCreature::BeDead()
{
   if(!IsPhysical())
      return;

   ConfigSpew("CreatureTrace",("%d: is dead\n",m_ObjID));

#if 0  // this doesn't work with load/save, so made into ballistic mode instead
   // get rid of old creature physics models
   PhysDeregisterModel(m_ObjID);

   // create new non-creature, rest-axis physics model
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   if(!pCDesc->nPhysModels)
      return;

   // create new phys models
   PhysRegisterSphere(m_ObjID,1,NULL,pCDesc->physRadius*(kDeathShrinkage));
   cPhysModel *pModel = g_PhysModels.Get(m_ObjID);

   if(pModel)
   {
      pModel->SetRestAxes(ZAxis);
   }
   m_MotorState.IsPhysical=PhysObjHasPhysics(m_ObjID);
#endif

   MakeBallistic(kCMB_Corpse);

   ValidateCreaturePosition(m_ObjID);

}

#endif // REMOVE_DEAD_PHYSICS

///////////////////////////////////////////////////

BOOL cCreature::MakeBallistic(int style, BOOL force)
{
   if (!force && IsBallistic())
      return FALSE;

   #ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s going ballistic\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
   #endif

   SetMotFrameOfReference(kMFRT_Global);
   if (m_MotorState.ballisticRefCount == 0)
      m_MotorState.ballisticRefCount++;

   m_ballisticStyle = style;

   // make phys models rigid
   if(IsPhysical())
   {
      const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

      Assert_(pCDesc&&(pCDesc->nPhysModels==0||pCDesc->pCrPhysModOffsets));

      cPhysModel *pModel;

      if ((pModel = g_PhysModels.Get(m_ObjID)) == NULL)
         return FALSE;

      if(style==kCMB_Corpse)
         pModel->SetRestAxes(ZAxis);

      for(int i=0; i<pCDesc->nPhysModels && i<pModel->NumSubModels(); i++)
      {
         MakePhysSubModBallistic(i, style);
      }

      SlamPhysicsModels();
      mxs_vector z;
      mx_zero_vec(&z);
      PhysSetRotationalVelocity(m_ObjID,&z);
   }

   BOOL rv = PhysObjHasPhysics(m_ObjID) && PhysObjValidPos(m_ObjID, NULL);

#if 0
   if (rv != TRUE)
      MakeNonBallistic();
#endif

   #ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s ballistic\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
   #endif

   ValidateCreaturePosition(m_ObjID);

   return rv;
}

///////////////////////////////////////////////////

void cCreature::MakePhysSubModBallistic(int index, int style)
{
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   mxs_vector subPos;
   mxs_vector world_subPos;

   PhysStopControlLocation(GetObjID());

   switch (style)
   {
      case kCMB_Normal:
      {
         GetPhysSubModelPos(m_pJoints, &pCDesc->pCrPhysModOffsets[index], &subPos);
         mx_subeq_vec(&subPos,&m_sMultiped.global_pos);
         mx_mat_tmul_vec(&world_subPos, &m_sMultiped.global_orient, &subPos);

         PhysSetSubModLocation(m_ObjID, index, &m_sMultiped.global_pos);
         PhysSetSubModRelLocation(m_ObjID, index, &world_subPos);

         SetPhysSubModScale(kDeathShrinkage, index);

         break;
      }

      case kCMB_Efficient:
      {
         mxs_angvec rot;

         rot = ObjPosGet(GetObjID())->fac;
         PhysControlRotation(GetObjID(), &rot);

         mxs_matrix orient;
         mxs_vector cur_unrot_offset;
         mxs_vector cur_offset;

         mx_ang2mat(&orient, &rot);
         PhysGetSubModLocation(m_ObjID, index, &cur_offset);
         mx_subeq_vec(&cur_offset, &ObjPosGet(m_ObjID)->loc.vec);

         mx_mat_tmul_vec(&cur_unrot_offset, &orient, &cur_offset);

         cPhysModel *pModel = g_PhysModels.Get(m_ObjID);

         if (pModel)
            pModel->SetSubModOffset(index, cur_unrot_offset);

         break;
      }

      case kCMB_WithFeet:
      {
         GetPhysSubModelPos(m_pJoints, &pCDesc->pCrPhysModOffsets[index], &subPos);
         mx_subeq_vec(&subPos,&m_sMultiped.global_pos);
         mx_mat_tmul_vec(&world_subPos, &m_sMultiped.global_orient, &subPos);

         if (index < 2)
         {
            PhysSetSubModLocation(m_ObjID, index, &m_sMultiped.global_pos);
            PhysSetSubModRelLocation(m_ObjID, index, &world_subPos);
         }
         else
         {
            Location start, end, hit;
            mxs_vector knee, foot;

            mx_add_vec(&knee, &world_subPos, &m_sMultiped.global_pos);

            if (pCDesc->footJoints)
            {
               mx_copy_vec(&subPos, &m_pJoints[pCDesc->footJoints[index-2]]);
               mx_subeq_vec(&subPos,&m_sMultiped.global_pos);
               mx_mat_tmul_vec(&world_subPos, &m_sMultiped.global_orient, &subPos);
               mx_add_vec(&foot, &world_subPos, &m_sMultiped.global_pos);
            }
            else
               mx_copy_vec(&foot, &knee);

            MakeLocationFromVector(&start, &knee);
            MakeLocationFromVector(&end, &foot);

            ComputeCellForLocation(&start);
            if (!PortalRaycast(&start, &end, &hit, TRUE))
            {
               mxs_vector shin;

               mx_sub_vec(&shin, &hit.vec, &knee);
               mx_scaleeq_vec(&shin, 0.99);
               mx_add_vec(&foot, &knee, &shin);
            }

            mx_subeq_vec(&foot, &m_sMultiped.global_pos);

            PhysSetSubModLocation(m_ObjID, index, &m_sMultiped.global_pos);
            PhysSetSubModRelLocation(m_ObjID, index, &foot);
         }

         break;
      }

      case kCMB_Posed:
      {
         GetPhysSubModelPos(m_pJoints, &pCDesc->pCrPhysModOffsets[index], &subPos);
         mx_subeq_vec(&subPos,&m_sMultiped.global_pos);
         mx_mat_tmul_vec(&world_subPos, &m_sMultiped.global_orient, &subPos);

         PhysSetSubModLocation(m_ObjID, index, &m_sMultiped.global_pos);
         PhysSetSubModRelLocation(m_ObjID, index, &world_subPos);

         break;
      }

      case kCMB_Compressed:
      {
         mxs_angvec rot;

         rot = ObjPosGet(GetObjID())->fac;
         PhysControlRotation(GetObjID(), &rot);

         mxs_vector loc;
         mxs_vector zero;

         PhysGetModLocation(m_ObjID, &loc);
         mx_zero_vec(&zero);

         PhysSetSubModRelLocation(m_ObjID, index, &zero);
         PhysSetSubModLocation(m_ObjID, index, &loc);

         SetPhysSubModScale(kDeathShrinkage, index);

         break;
      }
      case kCMB_Corpse:
      {
         mxs_vector loc;
         mxs_vector zero;

         PhysGetModLocation(m_ObjID, &loc);
         mx_zero_vec(&zero);

         PhysSetSubModRelLocation(m_ObjID, index, &zero);
         PhysSetSubModLocation(m_ObjID, index, &loc);

         SetPhysSubModScale(kDeathShrinkage, index);

         break;
      }
   }
}

///////////////////////////////////////////////////

void cCreature::MakeNonBallistic(BOOL force)
{
   if (!force && !IsBallistic())
      return;

   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   Assert_(pCDesc);

   if(pCDesc->alwaysBallistic) // don't do anything if creature type always ballistic
      return;

   #ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s going non-ballistic\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
   #endif

   ValidateCreaturePosition(m_ObjID);

   if(m_MotorState.ballisticRefCount>0)
      m_MotorState.ballisticRefCount--;

   if(m_MotorState.ballisticRefCount>0)   // still ballistic
   {
#ifndef SHIP
      mprintf("%s ballistic ref count still > 0? (%d specifically)\n", ObjWarnName(m_ObjID), m_MotorState.ballisticRefCount);
#endif
      return;
   }

   SetMotFrameOfReference(kMFRT_RelStart); // @TODO: make this creature type dependent

   // @TODO: notify physics system

   // @HACK: remove when we have different physics for posed corpse
   if (PhysObjHasPhysics(m_ObjID))
   {
      PhysStopControlRotation(m_ObjID);

      SetPhysSubModScale(m_scalePhys);
      SlamPhysicsModels();
   }

   #ifndef SHIP
   if (config_is_defined("CreatureBallisticSpew"))
   {
      mprintf("%s non-ballistic\n", ObjWarnName(m_ObjID));
      cPhysModel *pModel = g_PhysModels.Get(m_ObjID);
      if (pModel)
      {
         for (int j=0; j<pModel->NumSubModels(); j++)
            mprintf(" [%d] %g %g %g\n", j, pModel->GetLocationVec(j).x,
                    pModel->GetLocationVec(j).y, pModel->GetLocationVec(j).z);
      }
   }
   #endif

   ValidateCreaturePosition(m_ObjID);
}

void cCreature::SetPhysSubModScale(float scale, int submodel)
{
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   if (!PhysObjHasPhysics(m_ObjID))
      return;

   if (IsMovingTerrain(m_ObjID))  // um, don't ask
      return;

   if (submodel == -1)
   {
      cPhysModel *pModel;

      if ((pModel = g_PhysModels.Get(m_ObjID)) == NULL)
         return;

      for(int i=0; i<pCDesc->nPhysModels && i<pModel->NumSubModels(); i++)
         PhysSetSubModRadius(m_ObjID, i, pCDesc->pCrPhysModOffsets[i].radius * scale);

      m_scalePhys = scale;
   }
   else
      PhysSetSubModRadius(m_ObjID, submodel, pCDesc->pCrPhysModOffsets[submodel].radius * scale);

}

///////////////////////////////////////////////////
///////////////////////////////////////////////////
/////
///// Attachment/Weapon functions
/////
///////////////////////////////////////////////////
///////////////////////////////////////////////////

void cCreature::GetWeaponAttachDefaults(int wtype, sCreatureAttachInfo *pInfo)
{
   if(!pInfo)
   {
      return;
   }

   pInfo->weapon = wtype;
   pInfo->is_weapon = TRUE;

   mx_zero_vec(&pInfo->relTrans.vec);
   mx_identity_mat(&pInfo->relTrans.mat);

   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];
   sCrPhysModOffsetTable *pWPO;
   sCrPhysModOffset *pMod;

   Assert_(wtype<pCDesc->nWeapons);

   if(!pCDesc || (NULL==(pWPO=pCDesc->pWeapPhysOffsets)) || wtype==kCrWeap_Invalid)
   {
      pInfo->joint=0;
      return;
   }
   pMod=pWPO[wtype].pPhysModels;

   if(!pMod)
   {
      pInfo->joint=0;
      return;
   }
   pInfo->joint = kCJ_Butt;
}

extern int g_CollisionObj1;
extern int g_CollisionObj2;
extern int g_CollisionSubmod1;
extern int g_CollisionSubmod2;
extern mxs_vector g_collision_location;

///////////////////////////////////////////////////////
//
// Default physcast callback
//

typedef struct sWeaponPhyscastData
{
   ObjID myID;
   ObjID ownerID;
} sWeaponPhyscastData;

static BOOL WeaponPhyscastCallback(ObjID objID, const cPhysModel* pModel, sWeaponPhyscastData* pData)
{
   // ignore myself
   if ((objID == pData->myID) || (objID == pData->ownerID))
      return FALSE;
   return TRUE;
}


BOOL cCreature::MakeWeaponPhysical(ObjID weapon, int wtype)
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];
   sCrPhysModOffsetTable *pWPO;
   sCrPhysModOffset *pMod;
   int nPhysMods,i;

   Assert_(wtype<pCDesc->nWeapons);

   // Check that we're a concrete object.  If we've switched weapons, during a swing, before our
   // previous weapon has become physical, then we get here with our new weapon as the "weapon"
   // parameter.  We really want to check that our weapon parameter matches our weapon at the
   // start of the swing, but simply bailing out if we've switched to an arrow works (though
   // you will be able to switch between the sword and the blackjack).  It's not the right
   // solution, but hey, 7 days till gold master.
   if (OBJ_IS_ABSTRACT(weapon))
      return FALSE;
   if(!pCDesc || (NULL==(pWPO=pCDesc->pWeapPhysOffsets)) || wtype==kCrWeap_Invalid)
      return FALSE;
   if((nPhysMods=pWPO[wtype].nPhysModels)<=0)
      return FALSE;
   pMod=pWPO[wtype].pPhysModels;
   if(!pMod)
      return FALSE;

   ConfigSpew("CreatureTrace",("%d: Making weapon physical\n",m_ObjID));

   // create new phys models
   PhysRegisterSphere(weapon,nPhysMods+kWH_NumModels,kPMCF_Creature|kPMCF_Weapon,pCDesc->physRadius);

   for(i=0;i<nPhysMods;i++,pMod++)
   {
      mxs_vector subPos;

      GetPhysSubModelPos(m_pJoints,pMod,&subPos);
      PhysSetSubModLocation(weapon,i,&subPos);
      PhysSetSubModRadius(weapon,i,pMod->radius * m_scalePhys);

      // activate location control
      PhysControlSubModLocation(weapon, i, &subPos);

      #if 0
      // check if it's a valid position
      mxs_vector zero;
      mx_zero_vec(&zero);  // this is really moronic
      if (!PhysObjValidPos(weapon, &zero))
      {
         ObjID owner;

         if ((owner = GetWeaponOwnerObjID(weapon)) != OBJ_NULL)
         {
            HandleWeaponHit(OBJ_NULL, weapon, owner, NULL);
            return FALSE;
         }
         else
            Warning(("Weapon started in invalid position with no owner?\n"));
      }
      #endif
   }

   ObjID ownerObj;

   if (GetObjID() == PlayerArm())
      ownerObj = PlayerObject();
   else
      ownerObj = GetObjID();

   Location owner_loc;
   Location submod_loc;
   Location hit_loc;
   ObjID    hit_obj;

   mxs_real min_hit_time = 1.0;
   Location min_hit_loc;
   ObjID    min_hit_obj = OBJ_NULL;
   int      min_hit_result;

   cPhysModel *pModel = g_PhysModels.Get(ownerObj);

   if (pModel == NULL)
      return FALSE;

   owner_loc = pModel->GetLocation();

   pMod=pWPO[wtype].pPhysModels;

   // physcast to our starting location, hitting anything in our way
   for (i=0; i<nPhysMods; i++)
   {
      PhysGetSubModLocation(weapon, i, &submod_loc.vec);
      MakeLocationFromVector(&submod_loc, &submod_loc.vec);

      int hit_result;

      if (ownerObj == PlayerObject())
      {
         sWeaponPhyscastData data = {weapon, ownerObj};
         PhysRaycastSetCallback(tPhyscastObjTest(WeaponPhyscastCallback), (void*)&data);
         hit_result = PhysRaycast(owner_loc, submod_loc, &hit_loc, &hit_obj, pMod[i].radius, kCollideSphere|kCollideSphereHat|kCollideOBB|kCollideTerrain);
         PhysRaycastClearCallback();
      }
      else
      {
         ObjID player_obj = PlayerObject();

         PhysRaycastSetObjlist(&player_obj, 1);
         hit_result = PhysRaycast(owner_loc, submod_loc, &hit_loc, &hit_obj, pMod[i].radius, kCollideSphere|kCollideSphereHat|kCollideOBB|kCollideTerrain);
         PhysRaycastClearObjlist();
      }

      //so if it's a weapon, and what it's hitting is terrain(has an obj
      //texture, to copy the trick in collide.cpp), and
      //the weapon is set to not collide with terrain, then don't
      //actually cause a hit.  Phew.  AMSD.
      if ((GetObjTextureIdx(hit_obj)>=0) && (IsWeapon(weapon)))
	  if (!GetWeaponTerrainCollision(weapon))
	     hit_result = kCollideNone;

      if (hit_result != kCollideNone)
      {
         mxs_real cast_len = mx_dist_vec(&owner_loc.vec, &submod_loc.vec);
         mxs_real hit_len = mx_dist_vec(&owner_loc.vec, &hit_loc.vec);

         if (cast_len == 0.0)
            continue;

         mxs_real hit_time = hit_len / cast_len;

         if (hit_time < min_hit_time)
         {
	    min_hit_loc = hit_loc;
            min_hit_time = hit_time;
            min_hit_obj = hit_obj;
            min_hit_result = hit_result;
         }
      }
   }

   if ((min_hit_obj != OBJ_NULL) &&
       (min_hit_obj != weapon) &&
       (min_hit_obj != ownerObj))
   {
      ObjID owner = GetWeaponOwnerObjID(weapon);

      if (owner != OBJ_NULL)
      {
         // cause the sound event
         int coll_type_hit = 0;
         int coll_type_weapon = 0;
         int bits = CollideTest(min_hit_obj, weapon);

         ObjGetCollisionType(min_hit_obj, &coll_type_hit);
         ObjGetCollisionType(weapon, &coll_type_weapon);

#define DEFAULT_IMPACT 20

         if (!(coll_type_weapon & COLLISION_NO_SOUND) ||
             !(coll_type_hit & COLLISION_NO_SOUND))
         {
            CollisionSoundObjects(weapon, min_hit_obj, bits, DEFAULT_IMPACT);
         }

         // Set up our completely hacked globals
         g_CollisionObj1 = weapon;
         g_CollisionObj2 = min_hit_obj;
         g_CollisionSubmod1 = 0;
         g_CollisionSubmod2 = 0;
	 mx_copy_vec(&g_collision_location, &min_hit_loc.vec);

         // cause an impact event
         sImpact impact = { DEFAULT_IMPACT };

         AutoAppIPtr_(DamageModel, pDamageModel);
         pDamageModel->HandleImpact(min_hit_obj, weapon, &impact, NULL);
      }
   }

   WeaponHaloInit(m_ObjID, weapon, nPhysMods);

   return PhysObjHasPhysics(weapon);
}

void cCreature::MakeWeaponNonPhysical(ObjID weapon)
{
   if(PhysObjHasPhysics(weapon))
   {
      PhysDeregisterModel(weapon);
      ConfigSpew("CreatureTrace",("%d: Making weapon non-physical\n",m_ObjID));
   }
   WeaponHaloTerm(m_ObjID, weapon);
}

// notify motor resolver, since that actually makes all stop motion
// decisions except in case of deletion
void cCreature::AbortWeaponMotion(ObjID weapon)
{
   if(!m_pMotorResolver)
      return;
   m_pMotorResolver->NotifyAboutMotionAbortRequest();
}

sCrPhysModOffsetTable *cCreature::GetWeaponPhysOffsets(int wtype)
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];
   sCrPhysModOffsetTable *pWPO;

   Assert_(wtype<pCDesc->nWeapons);

   if(!pCDesc || (NULL==(pWPO=pCDesc->pWeapPhysOffsets)) || wtype==kCrWeap_Invalid)
      return NULL;
   return &pWPO[wtype];
}

void cCreature::GetPhysSubModPos(sCrPhysModOffset *pOffset,mxs_vector *pPos)
{
   if(pOffset->frac)
   {
      mxs_vector tmp;

      mx_copy_vec(&tmp,&m_pJoints[pOffset->j1]);
      mx_scaleeq_vec(&tmp,1.0-pOffset->frac);
      mx_copy_vec(pPos,&m_pJoints[pOffset->j2]);
      mx_scaleeq_vec(pPos,pOffset->frac);
      mx_addeq_vec(pPos,&tmp);
   } else
   {
      mx_copy_vec(pPos,&m_pJoints[pOffset->j1]);
   }
}

void cCreature::GetSubModelPos(int submod, mxs_vector *pPos)
{
   GetPhysSubModelPos(m_sMultiped.joints, &g_pCreatureDescPtr[m_CreatureType]->pCrPhysModOffsets[submod], pPos);
}

BOOL cCreature::PhysSubModIsBallistic(int index)
{
   Assert_(g_pCreatureDescPtr&&m_CreatureType<g_nCreatureTypes);
   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   return IsBallistic()||(pCDesc->pCrPhysModOffsets&&pCDesc->pCrPhysModOffsets[index].isBallistic);
}

///////////////////////////////////////////////////

///////////////////////////////////////////////////

#define E398_HACK

#ifdef E398_HACK

EXTERN BOOL g_DoRootHack; // from motset.cpp
EXTERN int  g_HackButtJointID; // from motset.cpp

#endif

#define kMaxAngVel 0x3800   // in mxs_ang per sec

// this should go away once motion are reprocessed so there is separate
// base rotation channel from butt rotation
// @HACK: E398 hack, really.
static uint HackMpUpdate(multiped * mp, float time_delta_ms, ulong app_flags, ObjID focus)
{
#ifdef E398_HACK
   // set global with butt joint id, so that capture callback knows to take
   // base rotation out of this.
   g_DoRootHack=TRUE;
   g_HackButtJointID=mp->root_joint;
#endif

   // rotate base orientation to face focus.  (where base orientation is
   // starting orientation of motion.)
   // @NOTE that this won't work correctly for turns or motions that are being
   // bent, since global orientation varies over course of these motions instead
   // of always being base orientation.
   if(focus!=OBJ_NULL && !((cCreature *)(mp->app_ptr))->IsBallistic())
   {
      quat *pBaseOrient;
      mxs_vector *pBasePos;

      if(GetMpMainMotionBaseOrient(mp,&pBaseOrient,&pBasePos))
      {
         ObjPos *pPos=ObjPosGet(focus); // @OPTIMIZE: store this off somewhere instead of computing every update

         if (pPos != NULL)
         {
            // compute angle to focus obj
            mxs_vector diff;
            mxs_ang desFac,curFac,delta;
            mxs_matrix mat;
            fix maxTurn;  // needs to be fix due to overflow
            BOOL negRot=FALSE;

            mx_sub_vec(&diff,&pPos->loc.vec,&mp->global_pos);
            // Let's make this NOT quite zero, so normeq div0 won't occur.
            diff.z = 0.000001; // make sure it normalizes on X/Y plane. 'diff' is not used for anything else.
            mx_normeq_vec(&diff);
            desFac=GetNormVecHeading(&diff);

            // compare to actual heading and clamp.
            curFac=GetHeadingAngle(&mp->global_orient);
            delta=desFac-curFac;
            if(delta>MX_ANG_PI)
            {
               delta=-delta;
               negRot=TRUE;
            }
            maxTurn=fix_mul(((cCreature *)(mp->app_ptr))->GetMaxAngVel(),(fix_from_float(time_delta_ms/1000)));
            if(delta>maxTurn) // clamp
            {
               delta=maxTurn;
            }
            if(negRot)
               delta=-delta;
            desFac=curFac+delta;

            // modify base rotation
            mx_mk_rot_z_mat(&mat,desFac);
            quat_from_matrix(pBaseOrient,&mat);

            // modify base position, so current position will remain unchanged
            mx_sub_vec(&diff,&mp->global_pos,pBasePos);
            mx_mk_rot_z_mat(&mat,delta);
            mx_mat_muleq_vec(&mat,&diff);
            mx_sub_vec(pBasePos,&mp->global_pos,&diff);
         }
      }
   }

   int retval=mp_update(mp,time_delta_ms,app_flags);

#ifdef E398_HACK
   g_DoRootHack=FALSE;
#endif

   return retval;
}

#define MOT_SCALE_TOLERANCE 0.1

#ifdef CUR_MOTION_TRACKING
char *cur_motion_name;
char  cur_motion_id;
#endif

#define kMaxTiltTolerance 0.8
#define kForceBlendLength 500

// This always applies a scale factor to stretch the motion based on
// creature size.  Stretch parameters computed by maneuvers should take
// this into account.
void cCreature::StartMotionWithParam(const int motionNum, mps_motion_param *pParam, ulong flags, int startFrame)
{
   mps_start_info info;
   mps_motion_param defParam;

   info.flags=NULL;

   if(motionNum<0 || motionNum>=mp_num_motions)
      Warning(("cCreature::StartMotionWithParam, bad motion number %d\n",motionNum));

#ifdef CUR_MOTION_TRACKING
   cur_motion_name=MotDescGetName(motionNum);
   cur_motion_id++;
#endif

   float scale = GetMotionScale();

   // if timeslop, offset start frame accordingly.
   const sMotorState *pState=GetMotorState();
   mps_motion *pMotion=((mps_motion *)mp_motion_list+motionNum);

   g_pMotionSet->GetStartEndFrames(motionNum,&info.start_frame,&info.callback_frame);
   if(flags&kMotStartFlag_SetStartFrame)
   {
      info.start_frame=startFrame;
   } else
   {
      if(pState->timeSlop>0&&pMotion->info.type==MT_CAPTURE)
      {
         float frame_offset;

         frame_offset = pState->timeSlop*pMotion->info.freq;
         if(pParam&&pParam->flags&MP_DURATION_SCALE)
         {
            frame_offset/=pParam->duration_scalar;
         }
         if((int)(frame_offset+1)<pMotion->info.num_frames-info.start_frame)
         {
            if(info.start_frame==0) // okay to keep xlat, since just for timeslop from beginning KJ 10/98
            {
               info.flags|=MStrtFlag_KeepXlat;
            }
            info.start_frame+=(int)(frame_offset);
         }
      }
   }
   if(info.callback_frame>=0 && info.start_frame>info.callback_frame)
   {
      info.start_frame=info.callback_frame;
   }
   info.callback = CreatureMotEndCallback;
   info.motion_num = motionNum;
   info.trans_duration=MotDescBlendLength(info.motion_num);
   if(flags&kMotStartFlag_ForceBlend)
   {
      if(info.trans_duration<kForceBlendLength)
         info.trans_duration=kForceBlendLength;
   }
   if(pParam)
   {
      defParam=*pParam;
   } else
   {
      defParam.flags=NULL;
   }
   if(IsBallistic()) // ignore params that affect xlat
   {
      defParam.flags&=~(MP_BEND|MP_STRETCH|MP_VSTRETCH|MP_VINC);
   }
   info.params=&defParam;
   info.callback_num=0;

   if(!IsBallistic() && (scale<1.0-MOT_SCALE_TOLERANCE || scale >1.0+MOT_SCALE_TOLERANCE))
   {
      // stretch motion
      if(info.params->flags&MP_STRETCH)
      {
         info.params->stretch*=scale;
      } else
      {
         info.params->stretch=scale;
         info.params->flags|=MP_STRETCH;
      }
   }
   // check for global timewarp
   float tw;
   if(ObjGetTimeWarp(m_ObjID,&tw))
   {
      if(info.params->flags&MP_DURATION_SCALE)
      {
         info.params->duration_scalar*=tw;
      } else
      {
         info.params->flags|=MP_DURATION_SCALE;
         info.params->duration_scalar=tw;
      }
   }

   mp_start_motion(&m_sMultiped, (mps_start_info *)&info);

   ConfigSpew("CreatureTrace",("%d starting motion %d (%s)\n",m_ObjID,motionNum,MotDescGetName(motionNum)));
}

///////////////////////////////////////////////////

// @NOTE: this actually stops all motions on creature because otherwise
// we run into problems if two full-body motions are playing, since mp_stop_motion
// will set the joint map to 255 but leave one motion on the multiped.
// The result being that the remain motions' rotations never get applied while it
// plays.  Alternative is to have StartMotion stop any other non-overlay motions
// that are playing before starting a new one (or do this mp_start_motion),
// or have mp_stop_motion check and do joint_map correctly.
// It's kind of mysterious, since only one maneuver executes a time, and I
// thought that each stopped all motions it started, so we should never have
// two non-overlay motions playing at once anyway.    (KJ 8/98)
void cCreature::StopMotion(const int motionNum)
{
//   mp_stop_motion(&m_sMultiped,motionNum);
   mp_stop_all_motions(&m_sMultiped); // see big comment above
   HackMpUpdate(&m_sMultiped,0,NULL,m_MotorState.focus);
   ConfigSpew("CreatureTrace",("%d CreatureTrace: stop mot %d\n",m_ObjID,motionNum));
}

///////////////////////////////////////////////////

void cCreature::Pause()
{
}

///////////////////////////////////////////////////
// Mesh shape functions
//
///////////////////////////////////////////////////

float cCreature::GetRadius()
{
   return m_Radius;
}

///////////////////////////////////////////////////

void cCreature::GetWorldBBox(mxs_vector *pBMin, mxs_vector *pBMax)
{
   mx_copy_vec(pBMin,&m_BMin);
   mx_copy_vec(pBMax,&m_BMax);
}



///////////////////////////////////////////////////
// Mesh renderer functions
//
///////////////////////////////////////////////////

void cCreature::MeshJointPosCallback(const int jointID, mxs_trans *pTrans)
{
   AssertMsg1(jointID>=0&&jointID<m_nJoints,"Invalid JointID %d for Creature",jointID);

   mx_copy_vec(&pTrans->vec,&m_pJoints[jointID]);

   if ((gUseHeadTracking || IsRemoteGhost(m_ObjID)) && (jointID == GetCreatureJointID(m_ObjID, kCJ_Neck)))
      mx_copy_mat(&pTrans->mat, &m_headOrient);
   else
      mx_copy_mat(&pTrans->mat,&m_pOrients[jointID]);
}

///////////////////////////////////////////////////

void cCreature::MeshStretchyJointCallback(const int jointID, mxs_trans *pTrans, quat *pRot)
{
   int iParentJoint;

   AssertMsg1(jointID>=0&&jointID<m_nJoints,"Invalid JointID %d for Creature",jointID);

   quat_copy(pRot,&m_sMultiped.rel_orients[jointID]);
   mx_copy_vec(&pTrans->vec,&m_pJoints[jointID]);

   iParentJoint=g_pCreatureDescPtr[m_CreatureType]->pJointParents[jointID];
   mx_copy_mat(&pTrans->mat,&m_pOrients[iParentJoint]);
}

///////////////////////////////////////////////////

void cCreature::QueueCompletedMotion(const sCreatureMotionEndNode *pNode)
{
   sCreatureMotionEndNode *pNewNode = new sCreatureMotionEndNode;
   sCreatureMotionEndNode **pHead;

   *pNewNode=*pNode;
   pNewNode->pNext=NULL;

   pHead=&m_CompletedMotions;
   while(*pHead)
   {
      pHead=&((*pHead)->pNext);
   }
   *pHead=pNewNode;
}

// XXX NOTE: this could get messed up if the motor resolver decides to respond
// to the motion ending by stopping some other motion.
// This is incorrect at the moment to emulate how things worked in the
// days of g_MotionEnded.  Really need to modify all the motor controllers
// to handle things robustly.
void cCreature::ProcessCompletedMotions()
{
   sCreatureMotionEndNode *pNode,*pNext;

   pNode=m_CompletedMotions;
   // give completion messages
   if(m_pMotorResolver)
   {
      while(pNode)
      {
         m_MotorState.timeSlop=pNode->timeSlop;
         // if frame!=-1, then motion may not actually be done yet, so
         // stop it.  Stop it here instead of in motendcallback because
         // want to make sure we're not in the middle of an mp_update
         // (frame!=-1 for motions which had a frame flagged
         // as end frame, instead of just ending at end).  (KJ 8/98)
         if(pNode->frame>=0)
            StopMotion(pNode->motionNum);
         m_pMotorResolver->NotifyAboutMotionEnd(pNode->motionNum, \
            pNode->frame, pNode->flags);
         pNode=pNode->pNext;
      }
   }
   // delete nodes
   pNode=m_CompletedMotions;
   while(pNode)
   {
      pNext=pNode->pNext;
      delete pNode;
      pNode=pNext;
   }
   m_CompletedMotions=NULL;
}

// This is here to process all motions that ended outside of creature update.
// Currently just spews and does nothing, to emulate behavior from
// g_MotionEnded days.  Really want to make motor controllers more robust
// so they can behave sensibly when motions stopped outside of frame, I
// think, and then regular ProcessCompletedMotions should be called instead.
void cCreature::HackProcessCompletedMotions()
{
   sCreatureMotionEndNode *pNode,*pNext;

   pNode=m_CompletedMotions;
   // give completion messages
   if(m_pMotorResolver)
   {
      while(pNode)
      {
         ConfigSpew("CreatureHack",("%d: motion %d ended outside of frame\n",GetObjID(),pNode->motionNum));
         pNode=pNode->pNext;
      }
   }
   // delete nodes
   pNode=m_CompletedMotions;
   while(pNode)
   {
      pNext=pNode->pNext;
      delete pNode;
      pNode=pNext;
   }
   m_CompletedMotions=NULL;
}

///////////////////////////////////////////////////

#define CREATURE_UPDATE_DT_MAX 500
#define CREATURE_FRAME_LEN     100

DECLARE_TIMER(CREAT_Update, Average);

void cCreature::Update(const ulong timeDelta)
{
   AUTO_TIMER(CREAT_Update);

#if 0
   ulong t,tRemaining;
#endif
   ulong dtThreshold = min(timeDelta, CREATURE_UPDATE_DT_MAX);
   BOOL moved = FALSE;

#if 0
   if(!m_pMotorResolver) // allowed, but can't update.  like for corpse
      return;
#endif

   // reset time slop, since no motions have ended yet this frame
   m_MotorState.timeSlop=0;

   // process motions that were stopped outside of creature frame
   // XXX could be troublesome.  "forget" about them for now for testing
   HackProcessCompletedMotions();

#if 0
   // Run multiped update frames
   for (t=CREATURE_FRAME_LEN; t<dtThreshold; t+=CREATURE_FRAME_LEN)
   {
      moved = SubFrameUpdate(CREATURE_FRAME_LEN) || moved;
   }

   tRemaining=dtThreshold-(t-CREATURE_FRAME_LEN);
   if(tRemaining>0)
   {
      moved = SubFrameUpdate(tRemaining)||moved;
   }
#endif

   gUseHeadTracking = TRUE;

   // Only run a single frame for now...
   moved = SubFrameUpdate(timeDelta);

   if(moved)
   {
      ComputeBoundingData();
      if (!IsBallistic() && !PhysObjIsRope(m_ObjID))
         UpdateObjPosition();
      CreatureAttachmentsPosUpdate(m_ObjID);
   }

   gUseHeadTracking = FALSE;
}


///////////////////////////////////////////////////

const sCreatureDesc *cCreature::GetCreatureDesc()
{
   return g_pCreatureDescPtr[m_CreatureType];
}

///////////////////////////////////////////////////


#if 0 // this not actually used

static BOOL StoreBackup(multiped *back, const multiped *src)
{
   mp_clone_multiped(back,(multiped *)src);
   return TRUE;
}

// XXX should probably make this smarter, since joint map and
// relorients don't need to be constantly freed and realloced, and
// list ptrs could just be swapped.
static BOOL RestoreFromBackup(multiped *dst, multiped *back)
{
   mp_free_multiped(dst);
   mp_clone_multiped(dst,back);
   return TRUE;
}

static void FreeBackup(multiped *back)
{
   mp_free_multiped(back);
}

#endif

///////////////////////////////////////////////////

void UpdateCreatureOnObject(cCreature *pCreature, ObjID standing_obj, mxs_vector *new_pos)
{
   if (standing_obj == OBJ_NULL)
      return;

   if (IsMovingTerrainMoving(standing_obj))
   {
      mx_add_vec(new_pos, &ObjPosGet(standing_obj)->loc.vec, &pCreature->GetStandingOffset());

      mxs_angvec orient;

      mx_mat2ang(&orient, &pCreature->GetMultiped()->global_orient);
      pCreature->MoveButt(new_pos, &orient, FALSE);
      pCreature->UpdateObjPosition();
      pCreature->SlamPhysicsModels();
   }
}

DECLARE_TIMER(CREAT_SubFrameUpdate, Average);
DECLARE_TIMER(CREAT_HackMpUpdate, Average);
DECLARE_TIMER(CREAT_UpdatePhysics, Average);
DECLARE_TIMER(CREAT_PostUpdate, Average);

BOOL cCreature::SubFrameUpdate(const ulong dt)
{
   AUTO_TIMER(CREAT_SubFrameUpdate);

   int flags;
   BOOL okay=TRUE;

   const sCreatureDesc *pCDesc=g_pCreatureDescPtr[m_CreatureType];

   char *collideSpeech[]={"OW! My groin!","OW! Me chest!","Arghhh matey!","No chicken feet!\n"};

   g_MotionEnded=FALSE;

   if (!m_pMotorResolver)
      goto post_update;

   // reset time slop, since no motions have ended yet this sub-frame
   // want to keep timeSlop zero if no motions ended
   if(m_MotorState.timeSlop>0)
      m_MotorState.timeSlop+=(((float)dt)/1000);

   m_pMotorResolver->NotifyAboutFrameUpdateBegin();

   if(!IsPlayingMotion())
   {
      if (IsBallistic())
         PostUpdateFilter(dt);

      mxs_vector dummy_pos;
      UpdateCreatureOnObject(this, GetStandingObj(), &dummy_pos);

      m_pMotorResolver->NotifyAboutFrameUpdateEnd();
      return FALSE;
   }

   // Don't do any of this for ropes -- the post update filter handles all the
   // positioning/orienting
   if (m_CreatureType == 10) // rope magic number
      goto post_update;

   // update is simple if creature not physical or ballistic
   // (since then not responsible for moving its own phys models
   if(!IsPhysical() || IsBallistic())
   {
      flags = HackMpUpdate(&m_sMultiped, dt,NULL,m_MotorState.focus); // need this to get flags, callbacks etc
      if (IsBallistic())
         MoveButt(&ObjPosGet(GetObjID())->loc.vec, &ObjPosGet(GetObjID())->fac, TRUE);
   }
   else
   {

      TIMER_Start(CREAT_HackMpUpdate);
      flags=HackMpUpdate(&m_sMultiped, dt,NULL,m_MotorState.focus);
      TIMER_MarkStop(CREAT_HackMpUpdate);

      mxs_vector new_pos;
      mx_copy_vec(&new_pos, &m_sMultiped.global_pos);

      UpdateCreatureOnObject(this, GetStandingObj(), &new_pos);

      ValidateCreaturePosition(m_ObjID);

      TIMER_Start(CREAT_UpdatePhysics);
      if (UpdateCreaturePhysics(m_ObjID, &new_pos))
      {
         mxs_angvec orient;

         mx_mat2ang(&orient, &m_sMultiped.global_orient);
         MoveButt(&new_pos, &orient, TRUE);
      }
      TIMER_MarkStop(CREAT_UpdatePhysics);

      ValidateCreaturePosition(m_ObjID);
   }
post_update:

   {
      AUTO_TIMER(CREAT_PostUpdate);

   PostUpdateFilter(dt);

   // XXX this should check if terrain collision occured when updating
   // physics models, and deal accordingly
   CreatureAttachmentsPhysUpdate(m_ObjID);

   // notify about flags reached during frame
   if(m_pMotorResolver && flags)
      m_pMotorResolver->NotifyAboutFrameFlags(flags);

   // process motions that ended during creature frame
   ProcessCompletedMotions();

   if (m_pMotorResolver)
      m_pMotorResolver->NotifyAboutFrameUpdateEnd();

   }
   return TRUE;
}







// $Header: r:/t2repos/thief2/src/motion/creature.h,v 1.50 2000/01/29 13:22:00 adurant Exp $
#pragma once

#ifndef __CREATURE_H
#define __CREATURE_H

#include <mp.h>
#include <motorapi.h>
#include <meshapi.h>
#include <mmresapi.h>
#include <matrixs.h>
#include <crettype.h>
#include <creatext.h>
#include <objtype.h>

// offset to torso * in lengths struct
#define CL_BASE_SIZE (2*sizeof(int))

#define kMPCalibVersion 1

// Creature location validation
#ifdef PLAYTEST

EXTERN BOOL g_AssertValidPosition;
#define VALIDATE_CREATURE_POS(x)   do { g_AssertValidPosition = x; } while (0);
BOOL IsCreaturePositionValid(ObjID objID);

#else

#define VALIDATE_CREATURE_POS(x)
#define IsCreaturePositionValid(x) (TRUE)
#define ValidateCreaturePosition(x)

#endif

typedef struct sCreatureLengths
{
   int nTorsos;
   int nLimbs;
   torso *pTorsos;
   limb  *pLimbs;
   float primScale; // how much limbs off the root toro are scaled from original
                    // motion capture skeleton.
} sCreatureLengths;

typedef struct _sCreatureMotionEndNode
{
   int motionNum;
   int frame;
   ulong flags;
   float timeSlop;
   _sCreatureMotionEndNode *pNext;
} sCreatureMotionEndNode;

class cCreatureFactory
{
public:
   virtual cCreature *Create(int type, ObjID objID) = 0;
   virtual cCreature *CreateFromFile(int type, ObjID objID, fCreatureReadWrite func, int version) = 0;
};

class cCreature: public IMotor, public IMesh
{
public:
// Constructor/Destructor
//
// XXX should remember to make this set multiped rel_orients and sig pointers. KJ 10/97
   cCreature(int type, ObjID objID);
// for reading from file
   cCreature(int type, ObjID objID,fCreatureReadWrite func, int version);
   virtual ~cCreature();

   void Write(fCreatureReadWrite func);

// Motor functions
//
   virtual void SetMotorResolver(IMotorResolver *pResolver);
   virtual int  GetActorType();
   virtual void StartMotion(const int motionNum) { StartMotionWithParam(motionNum,NULL,0,NULL); }
   virtual void StartMotionWithParam(const int motionNum,mps_motion_param *pParam,ulong flags,int startFrame);
   virtual void PoseAtMotionFrame(int motNum, float frame);
   virtual int  SwizzleMotion(int motNum);
   virtual int  GetCurrentMotion();

   virtual BOOL SetTransform(const mxs_vector *, const mxs_angvec *, BOOL movePhys=TRUE);
   virtual BOOL SetPosition(const mxs_vector *, BOOL movePhys=TRUE);
   virtual BOOL SetOrientation(const mxs_angvec *, BOOL movePhys=TRUE);
   virtual void GetTransform(mxs_vector *, mxs_angvec *);

   virtual const Location *GetLocation() const;
   virtual mxs_real GetButtZOffset() const;
   virtual mxs_real GetDefaultButtZOffset() const { return m_DefaultButtZOffset; }
   virtual void GetFeetJointIDs(int *numJoints, int **jointIDs) const;
   virtual ObjID GetObjID() const { return m_ObjID; };
   // OBJ_NULL means no focus
   virtual void SetFocus(ObjID obj,fix fSpeed) { m_MaxAngVel = fSpeed; m_MotorState.focus=obj; };
   virtual void SetFocus(ObjID obj) { SetFocus(obj,0x3800); };

   virtual const sMotorState *GetMotorState() const { return &m_MotorState; }
   virtual void SetContact(ulong flags) { m_MotorState.contactFlags=flags; }
   virtual void SetVelocity(const mxs_angvec *dir, const mxs_real speed) {};
   virtual BOOL IsPhysical() { return m_MotorState.IsPhysical; }
   virtual BOOL MakePhysical();
   virtual void MakeNonPhysical();
   virtual BOOL MakeBallistic(int style, BOOL force = FALSE);
   virtual void MakeNonBallistic(BOOL force = FALSE);
   virtual BOOL IsBallistic() { return m_MotorState.ballisticRefCount>0; }
   virtual BOOL PhysSubModIsBallistic(int index);
   virtual void MakePhysSubModBallistic(int index, int style);  // see creatext for styles
   virtual void SetPhysSubModScale(float scale, int submodel = -1);

   virtual void SetMotFrameOfReference(int type) { m_sMultiped.frame_of_reference=type; }
   virtual int GetMotFrameOfReference() { return m_sMultiped.frame_of_reference; }
   virtual void StopMotion(const int motionNum);
   virtual void Pause();

   virtual const multiped *GetMultiped() const;
   virtual float GetMotionScale() const;
   virtual int   GetRootJointID() const { return m_iRootJoint; }
   
   
// Mesh shape functions
//
   virtual float GetRadius();
   virtual void GetWorldBBox(mxs_vector *pBMin, mxs_vector *pBMax);

// Mesh renderer functions
//
   virtual void MeshJointPosCallback(const int jointID, mxs_trans *pTrans);
   virtual void MeshStretchyJointCallback(const int jointID, mxs_trans *pTrans, quat *pRot);

// Attachment/weapon functions
   virtual void GetWeaponAttachDefaults(int wtype, sCreatureAttachInfo *pInfo);
   virtual BOOL MakeWeaponPhysical(ObjID weapon, int wtype);
   virtual void MakeWeaponNonPhysical(ObjID weapon);
   virtual void AbortWeaponMotion(ObjID weapon);
   virtual sCrPhysModOffsetTable *GetWeaponPhysOffsets(int wtype);
   virtual void GetPhysSubModPos(sCrPhysModOffset *off,mxs_vector *pos);
   virtual void GetSubModelPos(int submod, mxs_vector *pPos);

// creature module functions
//
   void Update(const ulong timeDelta);
   fix GetMaxAngVel() const { return m_MaxAngVel; };

   int GetType() { return m_CreatureType; };
   mxs_vector &GetJoint(int joint) { return m_pJoints[joint]; };
   mxs_matrix &GetJointOrient(int joint) { return m_pOrients[joint]; };
   
   const sCreatureDesc *GetCreatureDesc();

   // moves creature joints, but does not update obj position in object system
   BOOL MoveButt(const mxs_vector *v, const mxs_angvec *, BOOL updatePhysics, BOOL allowTilt=FALSE);

   BOOL IsPlayingMotion() const;

   void PrepareToDie();
   void BeDead();

   IMotorResolver *GetMotorResolver() { return m_pMotorResolver; }

   void QueueCompletedMotion(const sCreatureMotionEndNode *pNode);
   void ProcessCompletedMotions();
   void HackProcessCompletedMotions();
   void ResetLengths();
   void SlamPhysicsModels();
   void FlushRelativeState();
   virtual void FilterMotionFrameData(const mps_motion_info *mi, quat *rot, mxs_vector *xlat);
   virtual void PostUpdateFilter(const ulong dt);

   mxs_matrix &GetHeadOrient();

   void SetTrackingObj(ObjID objID);
   void SetTrackingLoc(const mxs_vector &dir);
   void SetNoTracking();

   void  SetStandingObj(ObjID objID);
   ObjID GetStandingObj() const;

   void        SetStandingOffset(mxs_vector &vec);
   mxs_vector &GetStandingOffset();

   void Freeze() { m_IsFrozen=TRUE; }
   void UnFreeze() { m_IsFrozen=FALSE; }
   BOOL IsFrozen() { return m_IsFrozen; }

   BOOL UpdateObjPosition();

protected:

   BOOL SubFrameUpdate(const ulong dt);
   void RecomputeJointPositions();
   virtual void ComputeBoundingData();
   virtual int GetFocusJoint() { return m_sMultiped.num_joints; }
   virtual void GetFocusRotOffset(quat *pDest, const quat *pBase, const quat *rots) { quat_copy(pDest,(quat *)pBase); }
   
   int           m_ObjID;
   sMotorState   m_MotorState;
   int           m_CreatureType;
   int           m_nPhysModels;
   int           m_nJoints;
   float         m_PrimScale; // how much limbs off the root toro are scaled from original
                    // motion capture skeleton.
   float         m_DefaultButtZOffset;
   
   multiped    m_sMultiped;
   mxs_vector  m_BMin;
   mxs_vector  m_BMax;
   float       m_Radius;
   int         m_iRootJoint;
   mxs_vector *m_pJoints;
   mxs_matrix  *m_pOrients;
   torso      *m_pTorsos;  // number of these comes from multiped
   limb       *m_pLimbs;
   IMotorResolver *m_pMotorResolver; // this pointer should be set by motion coordinator
   sCreatureMotionEndNode *m_CompletedMotions;

   mxs_matrix m_headOrient;

   float      m_scalePhys;
   int        m_ballisticStyle;

   ObjID      m_trackingObj;
   mxs_vector m_trackingLoc;
   BOOL       m_IsFrozen;  

   ObjID      m_standingObj;
   mxs_vector m_standingOffset;
   // Added by Johan, this is used to define the speed the creature can turn by.
   fix		  m_MaxAngVel;
   
};

////////////////////
// Inline cCreature functions

inline const multiped *cCreature::GetMultiped() const
{
   return &m_sMultiped;
}

inline float cCreature::GetMotionScale() const
{
   return m_PrimScale;
}

inline BOOL cCreature::IsPlayingMotion() const
{
   return (mp_list_count(&m_sMultiped.main_motion)>0||m_sMultiped.num_overlays>0);
}

inline const Location *cCreature::GetLocation() const
{
   Position *pPos=ObjPosGet(m_ObjID);

   AssertMsg1(pPos,"No position for obj 0",m_ObjID);

   return &pPos->loc;
}

inline mxs_real cCreature::GetButtZOffset() const
{
   return m_sMultiped.global_pos.z-m_BMin.z;
}

inline mxs_matrix &cCreature::GetHeadOrient()
{
   return m_headOrient;
}

inline void cCreature::SetTrackingObj(ObjID objID)
{
   m_trackingObj = objID;
}

inline void cCreature::SetTrackingLoc(const mxs_vector &loc)
{
   m_trackingLoc = loc;
   m_trackingObj = -1;
}

inline void cCreature::SetNoTracking()
{
   m_trackingObj = OBJ_NULL;
}

inline void cCreature::SetStandingObj(ObjID objID)
{
   m_standingObj = objID;
}

inline ObjID cCreature::GetStandingObj() const
{
   return m_standingObj;
}

inline void cCreature::SetStandingOffset(mxs_vector &vec)
{
   m_standingOffset = vec;
}

inline mxs_vector &cCreature::GetStandingOffset()
{
   return m_standingOffset;
}

struct sCreatureHandle
{
   int type;
   cCreature     *pCreature;

   sCreatureHandle(int t = kCreatureTypeInvalid, cCreature* c = NULL) 
      : type(t),pCreature(c) {}; 

   sCreatureHandle(const sCreatureHandle& c) 
      :type(c.type),pCreature(c.pCreature) {};
};


// Creature system functions
//
EXTERN BOOL CreatureGetDefaultLengthsName(int type, char *name);

EXTERN cCreature *CreatureFromObj(ObjID obj);

#endif
// $Header: r:/t2repos/thief2/src/motion/cretprop.cpp,v 1.49 1999/10/18 14:57:04 BFarquha Exp $

#include <appagg.h>

// property stuff
#include <propbase.h>
#include <propert_.h>
#include <property.h>
#include <propsprs.h>
#include <propcary.h>
#include <propface.h>
#include <sdesc.h>
#include <sdesbase.h>

#include <aiapi.h>
#include <puppet.h>   // for puppet listener
#include <plycbllm.h> // for player listener

#include <schema.h>   // attempting to get tag stuff working
#include <motmngr.h>
#include <ctagset.h>
#include <motprop.h>
#include <tagdbin.h>

#include <mnamprop.h>
#include <posprop.h>

#include <cretprop.h>
#include <creature.h>
#include <creatur_.h>

#include <iobjsys.h>
#include <objnotif.h>

// must be last header
#include <dbmem.h>

EXTERN int g_SimRunning; // from biploop.c

////////////////////////
// Creature property value funcs.

class cCreatureDataOps: public cClassDataOps<sCreatureHandle>
{
public:
   // override default flags
   cCreatureDataOps() : cClassDataOps<sCreatureHandle>(kNoFlags) {};

   STDMETHOD(Delete)(sDatum dat)
   {
      sCreatureHandle* handle = (sCreatureHandle*)dat.value;
      if (handle)
      {
         if(handle->pCreature)
            delete handle->pCreature;
         delete handle;
      }
      return S_OK;
   }

   STDMETHOD(Read)(sDatum* pdat, IDataOpsFile* file, int v)
   {
      if (!pdat->value)
         *pdat = New();

      sCreatureHandle *pCHandle = (sCreatureHandle *)pdat->value;

      file->Read(&pCHandle->type,sizeof(pCHandle->type));
      return S_OK;
   }

   STDMETHOD(Write)(sDatum dat, IDataOpsFile* file)
   {
      sCreatureHandle *pCHandle = (sCreatureHandle *)dat.value;

      // write creature handle
      file->Write((void *)&(pCHandle->type), sizeof(pCHandle->type));
      return S_OK;
   }
};

//
// wsf: 10/18/99: code added to check for presence of physics. Before, physics was just deleted if
// pCreature existed. It is hoped this will fix the T2 rope arrow rope bug without affecting other
// creatures.
//
#if 0 // well, this doesn't work because after destruction, this isn't a registered physics model anymore.
static void MakeCreature(ObjID obj_id, sCreatureHandle *pHandle)
{
   BOOL bIsPhysical;
   BOOL bUpdatePhysics = FALSE;
   AutoAppIPtr(AIManager);

   if(pHandle->pCreature)
      {
      bIsPhysical = pHandle->pCreature->IsPhysical();
      delete pHandle->pCreature;
      bUpdatePhysics = TRUE;
      }

   pHandle->pCreature=CreatureCreate(pHandle->type,obj_id);

   // Update physics
   if (bUpdatePhysics && bIsPhysical)
      pHandle->pCreature->MakePhysical();

   // notify AI about new motor
   if (!!pAIManager)
      pAIManager->SetMotor(obj_id,pHandle->pCreature);
}
#else
static void MakeCreature(ObjID obj_id, sCreatureHandle *pHandle, BOOL bDestroy = TRUE)
{
   AutoAppIPtr(AIManager);
   if (pHandle->pCreature && bDestroy)
      delete pHandle->pCreature;
   pHandle->pCreature=CreatureCreate(pHandle->type,obj_id);
   // notify AI about new motor
   if (!!pAIManager)
      pAIManager->SetMotor(obj_id,pHandle->pCreature);
}
#endif


//
// Creature Property Store.
//

class cCreatureStore : public cCompactArrayPropertyStore<cArrayObjIndexMap,cCreatureDataOps>
{
   void OnFinalRelease() {}; // don't self-delete

public:
   STDMETHOD_(BOOL,GetCopy)(ObjID obj, sDatum* dat)
   {
      sDatum real;
      if (!Get(obj,&real)) return FALSE;
      sCreatureHandle* handle = (sCreatureHandle*)real.value;
      sCreatureHandle* out = new sCreatureHandle(*handle);
      dat->value = out;
      return TRUE;
   }

   STDMETHOD(ReleaseCopy)(ObjID obj, sDatum dat)
   {
      sCreatureHandle* handle = (sCreatureHandle*)dat.value;
      handle->pCreature = NULL;
      delete handle;
      return S_OK;
   }

};

//
// Creature Property
//


typedef cGenericProperty<ICreatureProperty,&IID_ICreatureProperty,sCreatureHandle*>
cBaseCreatureProp;

static LazyAggMember(IObjectSystem) gpObjSys;

static BOOL g_DontListen=FALSE;

class cCreatureProp : public cBaseCreatureProp
{
protected:
   cCreatureStore mStore;

public:
   cCreatureProp(const sPropertyDesc* desc)
      : cBaseCreatureProp(desc,NULL)
   {
      SetStore(&mStore);
   }

   ~cCreatureProp()
   {
      SetStore(NULL);
   }

   void OnListenMsg(ePropertyListenMsg msg, ObjID obj, uPropListenerValue value)
   {
      cBaseCreatureProp::OnListenMsg(msg,obj,value);

      if(g_DontListen) return;

      AutoAppIPtr(AIManager);
      sCreatureHandle* handle = (sCreatureHandle*)value.ptrval;

      if (msg & kListenPropLoad)
      {
         if ((void *)pAIManager && OBJ_IS_CONCRETE(obj) && handle->pCreature != NULL)
            pAIManager->SetMotor(obj,handle->pCreature);
         return ;
      }

      // create the creature object if necessary
      if ((msg & (kListenPropSet|kListenPropModify))
          && OBJ_IS_CONCRETE(obj)
          && handle->type != kCreatureTypeInvalid )
      {
         // Get the real handle
         Get(obj,&handle);
         MakeCreature(obj,handle);
         g_DontListen=TRUE;
         Set(obj,handle);
         g_DontListen=FALSE;
      }

      if ((void *)pAIManager && (msg & (kListenPropUnset)) && OBJ_IS_CONCRETE(obj) && gpObjSys->Exists(obj))
         pAIManager->SetMotor(obj,NULL);
   }

   STDMETHOD_(void,Notify)(ePropertyNotifyMsg msg, PropNotifyData data)
   {
      cBaseCreatureProp::Notify(msg,data);
// wsf: #ifndef added so that ropes from rope arrows will work. Without this, a Creature gets created twice.
// The first time it has a physics interface. The second creation destroys the first, then creates a new
// one without a physics, which is bad. Apparently, this piece of code was ADDED by Jon for some reason.
// Be warned that the side effects of removing it are not fully understood!
// wsf: Additional note. It is now apparent that this fix for the rope bug creates a new bug -
//      creting a new creature results in it having no skeleton. Damn. Will find another solution.
#ifndef FIX_ROPE_BUG
      ObjID obj = ObjID(data);
      sCreatureHandle* pHandle;

      switch (msg)
      {
      case kObjNotifyCreate:
         // Get the real handle
         if (Get(obj,&pHandle))
         {
            sCreatureHandle newHandle = *pHandle;
            MakeCreature(obj, &newHandle, FALSE);
            g_DontListen=TRUE;
            Set(obj, &newHandle);
            g_DontListen=FALSE;
         }
         break;
      }
#endif
   }


   STANDARD_DESCRIBE_TYPE(sCreatureHandle);


   cCreatureStore& Store() { return mStore; };

};


#pragma off(unreferenced)

static cCreatureProp *pCreatureProp;

static sPropertyConstraint creature_constraints[] =
{
   { kPropertyRequires, PROP_POSITION_NAME },
   { kPropertyNullConstraint },
};

static sPropertyDesc creature_desc =
{
   PROP_CREATURE_NAME,
//   "CREATURE",
   kPropertyConcrete|kPropertyNoClone|kPropertySendEndCreate,
   creature_constraints,
   1,  // version
   0,
   { "Creature", "Creature Type", },
   kPropertyChangeLocally,
};

#define NUM_STRINGS(name) (sizeof(name)/sizeof(name[0]))

char *g_aCreatureTypeNames[] = {"Dummy"};

static sFieldDesc creatureFields[] =
{
   { "Type", kFieldTypeEnum, FieldLocation(sCreatureHandle,type), kFieldFlagUnsigned, 0, NUM_STRINGS(g_aCreatureTypeNames), NUM_STRINGS(g_aCreatureTypeNames), g_aCreatureTypeNames},
};

static sStructDesc creatureInfoStruct = StructDescBuild(sCreatureHandle,kStructFlagNone,creatureFields);



//
// CREATURE POSE PROPERTY
//

class cCreaturePoseOps : public cClassDataOps<sCreaturePose>
{
public:
   cCreaturePoseOps(): cClassDataOps<sCreaturePose>(kNoFlags) {};
};

class cCreaturePoseStore : public cSparseHashPropertyStore<cCreaturePoseOps>
{
};

class cCreaturePoseProperty : public cSpecificProperty<ICreaturePoseProperty,&IID_ICreaturePoseProperty,sCreaturePose*,cCreaturePoseStore>
{
   typedef cSpecificProperty<ICreaturePoseProperty,&IID_ICreaturePoseProperty,sCreaturePose*,cCreaturePoseStore> cParent;

public:
   cCreaturePoseProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      SetRebuildConcretes(TRUE);
   }

   STANDARD_DESCRIBE_TYPE(sCreaturePose);

private:
   // NOTE: don't really want creature module to have to deal with tags
   // and schemas and such, but I couldn't think of a better place to put
   // this.  At least it's all isolated within in function, which is only used
   // by pose property listener.  (KJ 8/98)
   // @NOTE: i moved it here, so blame me too
   void DoPose(const sCreaturePose *pPose, cCreature *pCreature)
   {
      int motHandle;

      if (g_SimRunning)
         return;

      if(pPose->type==kCPT_MotionName)
      {
         motHandle=g_pMotionSet->GetMotHandleFromName((Label *)&pPose->motion);
         pCreature->PoseAtMotionFrame(motHandle,pPose->frac*(g_pMotionSet->GetNumFrames(motHandle)-1));
         pCreature->SetPhysSubModScale(pPose->scale);
         if (pPose->ballistic != pCreature->IsBallistic())
         {
            if (pPose->ballistic)
               pCreature->MakeBallistic(kCMB_Posed);
            else
               pCreature->MakeNonBallistic();
         }
         pCreature->MoveButt(&ObjPosGet(pCreature->GetObjID())->loc.vec,
                             &ObjPosGet(pCreature->GetObjID())->fac, TRUE);
      }
      else if (pPose->type==kCPT_Tags)
      {
         cTagSet tags(pPose->motion);
         cTagDBInput tagDBin;
         cMotionSchema *pSchema;

         tagDBin.Clear();
         tagDBin.AppendTagSet(&tags);
         if (g_pMotionDatabase->GetBestMatch(pCreature->GetActorType(),&tagDBin,&pSchema))
         {
            if (pSchema->GetMotion(0,&motHandle))
            {
               pCreature->PoseAtMotionFrame(motHandle,pPose->frac*(g_pMotionSet->GetNumFrames(motHandle)-1));
               pCreature->SetPhysSubModScale(pPose->scale);

               if (pPose->ballistic != pCreature->IsBallistic())
               {
                  if (pPose->ballistic)
                     pCreature->MakeBallistic(kCMB_Posed);
                  else
                     pCreature->MakeNonBallistic();
               }

               pCreature->MoveButt(&ObjPosGet(pCreature->GetObjID())->loc.vec,
                                   &ObjPosGet(pCreature->GetObjID())->fac, TRUE);
            }
         }
      }
   }

   void UnPose(cCreature *pCreature)
   {
      pCreature->SetPhysSubModScale(1.0);
      if (pCreature->IsBallistic())
         pCreature->MakeNonBallistic();
   }

   void RebuildConcrete(ObjID obj, BOOL fIsRelevant, uPropListenerValue val, ObjID donor)
   {
      if (!gpObjSys->Exists(obj))
         return;

      if (fIsRelevant)
      {
         sCreaturePose *pPose=(sCreaturePose *)val.ptrval;
    	   cCreature *pCreature=CreatureFromObj(obj);
         if (pCreature == NULL)
         {
            AutoAppIPtr(PropertyManager);
            IProperty *pCreatureProp = pPropertyManager->GetPropertyNamed(PROP_CREATURE_NAME);
            pCreatureProp->Create(obj);
            pCreature = CreatureFromObj(obj);
            Assert_(pCreature != NULL);
         }
         // mprintf("rebuildconcrete for %d (frel %d)..",obj,fIsRelevant);
         DoPose(pPose,pCreature);
         cParent::RebuildConcrete(obj,fIsRelevant,val,donor);
      }
      else
      {
         cCreature *pCreature = CreatureFromObj(obj);

         if (pCreature == NULL)
         {
            Warning(("Attempt to unpose non-creature object!\n"));
            return;
         }

         UnPose(pCreature);
         cParent::RebuildConcrete(obj,fIsRelevant,val,donor);
      }
   }
};

static cCreaturePoseProperty *pCreaturePoseProp;

static sPropertyDesc creaturePoseDesc =
{
   PROP_CREATUREPOSE_NAME,
   NULL,
   NULL,
   0,1, // version
   { "Creature", "Current Pose" },
   kPropertyChangeLocally,
};

static char *poseTypeNames[] =
{
   "Tags",
   "Motion Name",
};

// structure descriptor fun
static sFieldDesc creaturePoseFields [] =
{
   { "Type",        kFieldTypeEnum,   FieldLocation(sCreaturePose,type),FullFieldNames(poseTypeNames) },
   { "Motion",      kFieldTypeString, FieldLocation(sCreaturePose,motion) },
   { "Frac",        kFieldTypeFloat,  FieldLocation(sCreaturePose,frac) },
   { "Model scale", kFieldTypeFloat,  FieldLocation(sCreaturePose,scale) },
   { "Ballistic",   kFieldTypeBool,   FieldLocation(sCreaturePose,ballistic) },
};

static sStructDesc creaturePoseStruct = StructDescBuild(sCreaturePose,kStructFlagNone,creaturePoseFields);

////////////////////////////////////////////////
//
// MAKE CREATURE PHYSICAL PROP
//

static IBoolProperty *pCreatureNonPhysProp=NULL;

static sPropertyDesc creatureNonPhysDesc =
{
   PROP_CREATURENONPHYS_NAME,
   0,  // flags
   NULL, // constraints
   0, 0, // Version
   { "Creature", "Is Non-Physical" }, // ui strings
   kPropertyChangeLocally,
};

ICreatureProperty *CreaturePropertiesInit(int nCreatureTypes, const char **pCreatureTypeNames)
{
   cCreatureProp* prop = new cCreatureProp(&creature_desc);

   creatureInfoStruct.fields->max=nCreatureTypes;
   creatureInfoStruct.fields->datasize=nCreatureTypes;
   creatureInfoStruct.fields->data=(void *)pCreatureTypeNames;
   StructDescRegister(&creatureInfoStruct);

   pCreatureProp=prop;

   // install listeners
   prop->Listen(kListenPropModify | kListenPropSet | kListenPropUnset | kListenPropLoad, PuppetCreatureListener, NULL);
   prop->Listen(kListenPropModify | kListenPropSet | kListenPropUnset | kListenPropLoad, PlayerCreatureListener, NULL);

   // create non-phys property
   pCreatureNonPhysProp=CreateBoolProperty(&creatureNonPhysDesc,kPropertyImplSparseHash);

   // create pose property
   AutoAppIPtr_(StructDescTools,pTools);
   pTools->Register(&creaturePoseStruct);
   pCreaturePoseProp = new cCreaturePoseProperty(&creaturePoseDesc);

   // return pointer to creature property
   return prop;
}

void CreaturePropertiesTerm()
{
   SafeRelease(pCreatureProp);
   SafeRelease(pCreaturePoseProp);
   SafeRelease(pCreatureNonPhysProp);
}

void ObjSetCreatureType(ObjID obj, int type)
{
   sCreatureHandle cHandle;

   Assert_(pCreatureProp);
   cHandle.type=type;
   cHandle.pCreature=NULL;
   pCreatureProp->Set(obj,&cHandle);
}

BOOL ObjGetCreatureType(ObjID obj, int *pType)
{
   sCreatureHandle *pHandle;

   Assert_(pCreatureProp);
   if(pCreatureProp->Get(obj,&pHandle))
   {
      *pType=pHandle->type;
      return TRUE;
   }
   return FALSE;
}

EXTERN BOOL ObjIsNonPhysicalCreature(ObjID obj)
{
   Assert_(pCreatureNonPhysProp);
   BOOL result=FALSE;
   pCreatureNonPhysProp->Get(obj,&result);
   return result;
}

EXTERN BOOL ObjIsPosed(ObjID obj)
{
   Assert_(pCreaturePoseProp);

   return pCreaturePoseProp->IsRelevant(obj);
}

//
// Fast accessors to the creature property.  They should inline nicely
//


ObjID chandle_obj_id(int idx)
{
   return pCreatureProp->Store().Idx2Obj(idx);
}

sCreatureHandle* CreatureHandle(int idx)
{
   return (sCreatureHandle*)pCreatureProp->Store()[idx].value;
}

int obj_chandle_id(ObjID obj)
{
   return pCreatureProp->Store().Obj2Idx(obj);
}

int max_chandle_id()
{
   return pCreatureProp->Store().MaxIdx();
}


// $Header: r:/t2repos/thief2/src/motion/cretprop.h,v 1.11 2000/01/29 13:22:02 adurant Exp $
#pragma once

#ifndef __CRETPROP_H
#define __CRETPROP_H

#include <property.h>
#include <creature.h>
#include <objtype.h>
#include <label.h>

//------------------------------------------------------------
// Creature Property
//

#undef INTERFACE
#define INTERFACE ICreatureProperty
DECLARE_PROPERTY_INTERFACE(ICreatureProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(sCreatureHandle*); 
};

#define PROP_CREATURE_NAME "Creature"


//
// Creature pose property
//

typedef struct sCreaturePose
{
   int type;
   char motion[80];
   float frac;
   float scale;
   BOOL ballistic;

   sCreaturePose()
   {
      type = 0;
      memset(motion, 0, sizeof(char) * 80);
      frac = 0.0;
      scale = 1.0;
      ballistic = TRUE;
   };

} sCreaturePose;

enum eCreaturePoseType
{
   kCPT_Tags,
   kCPT_MotionName,
   kCPT_Invalid=0xffffffff,
};

#define PROP_CREATUREPOSE_NAME "CretPose"

F_DECLARE_INTERFACE(ICreaturePoseProperty);
#undef INTERFACE
#define INTERFACE ICreaturePoseProperty

DECLARE_PROPERTY_INTERFACE(ICreaturePoseProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sCreaturePose*);
};

//
//  Creature "non-physical" property
//

#define PROP_CREATURENONPHYS_NAME "NonPhysCreature"

//
// functions
//

EXTERN ICreatureProperty *CreaturePropertiesInit(int nCreatureTypes, const char **pCreatureTypeNames);

EXTERN void CreaturePropertiesTerm();

EXTERN void ObjSetCreatureType(ObjID obj, int type);

EXTERN BOOL ObjGetCreatureType(ObjID obj, int *pType);

EXTERN BOOL ObjIsNonPhysicalCreature(ObjID obj);

EXTERN BOOL ObjIsPosed(ObjID obj);

#endif
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/crexp.cpp,v 1.7 1999/10/26 16:53:08 BFarquha Exp $
//

//
// Exploding creatures
// To make a creature explode, add CorpsePart links from it to the body parts
// you want to appear. Each body part should be an md model with a vhot that
// indicates where it will appear relative to the dead object. Note that placing
// such a link will cause the original model to be destroyed when it is terminated.
//

// @TODO: I wonder if the trait query is slowing this down

#include <lg.h>
#include <mprintf.h>

#include <appagg.h>

#include <iobjsys.h>
#include <objdef.h>
#include <objpos.h>
#include <osetlnkq.h>
#include <traitbas.h>
#include <traitman.h>
#include <wrtype.h>

#include <dmgbase.h>
#include <dmgmodel.h>

// for vhot phys model placement
#include <md.h>
#include <mds.h>
#include <mnamprop.h>
#include <objmodel.h>
#include <physapi.h>

// for the link stuff
#include <relation.h>
#include <linkbase.h>
#include <lnkquery.h>

// for physics/testing in world
#include <phcore.h>
#include <phmods.h>
#include <phmod.h>
#include <phmodsph.h>
#include <sphrcst.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////
//
// CorpsePart Relation
//

IRelation *g_pCorpseParts;

static sRelationDesc CorpsePartRDesc =
{
   "CorpsePart",
};

static sRelationDataDesc CorpsePartDDesc = { "None", 0 };

void CreateCorpsePartRelation(void)
{
   g_pCorpseParts = CreateStandardRelation(&CorpsePartRDesc, &CorpsePartDDesc, kQCaseSetSourceKnown);
}

////////////////////////////////////////
//
// CorpsePart iterator
//

class cCorpsePartIter
{
public:
   cCorpsePartIter(ObjID objID, IRelation *pRelation);
   ~cCorpsePartIter(void);

   ObjID GetObj(void);
   int GetJointNum(void);
   BOOL Finished(void);
   void Next(void);

private:
   ILinkQuery *m_pQuery;
   ObjID m_startObj;    // we store off the first obj we find links from
};

///////////////////////////////////////////////

cCorpsePartIter::cCorpsePartIter(ObjID objID, IRelation *pRelation):
   m_startObj(OBJ_NULL)
{
   AutoAppIPtr(TraitManager);
   // @TODO: use trait cache
   IObjectQuery* donors = pTraitManager->Query(objID, kTraitQueryAllDonors);
   cLinkQueryFactory* factory = CreateSourceSetQueryFactory(pRelation, LINKOBJ_WILDCARD);

   m_pQuery = CreateObjSetLinkQuery(donors,factory);
   Assert_(m_pQuery != NULL);
   // set start object
   if (!Finished())
   {
      sLink link;
      m_pQuery->Link(&link);
      if (m_startObj == OBJ_NULL)
         m_startObj = link.source;
   }
   SafeRelease(donors);
}

///////////////////////////////////////////////

cCorpsePartIter::~cCorpsePartIter(void)
{
   SafeRelease(m_pQuery);
}

///////////////////////////////////////////////

ObjID cCorpsePartIter::GetObj(void)
{
   ObjID result = OBJ_NULL;

   Assert_(m_pQuery != NULL);
   if (!Finished())
   {
      sLink link;
      m_pQuery->Link(&link);
      result = link.dest;
   }
   return result;
}

///////////////////////////////////////////////

int cCorpsePartIter::GetJointNum(void)
{
   int result = -1;

   Assert_(m_pQuery != NULL);
   if (!Finished())
   {
      sLink link;
      m_pQuery->Link(&link);
      result = *((int*)(m_pQuery->Data()));
   }
   return result;
}

///////////////////////////////////////////////

BOOL cCorpsePartIter::Finished(void)
{
   Assert_(m_pQuery != NULL);
   if (!m_pQuery->Done())
   {
      // if query not done, check that we are still looking at links
      // from the initial object (to ensure that we don't return links
      // from archetypes higher up in the hierarchy)
      if (m_startObj == OBJ_NULL)
         return FALSE;
      sLink link;
      m_pQuery->Link(&link);
      return (m_startObj != link.source);
   }
   return TRUE;
}

///////////////////////////////////////////////

void cCorpsePartIter::Next(void)
{
   Assert_(m_pQuery != NULL);
   m_pQuery->Next();
}

///////////////////////////////////////////////

eDamageResult LGAPI CreatureExplodeDamageListener(const sDamageMsg* pMsg, tDamageCallbackData data)
{
   cCorpsePartIter iter(pMsg->victim, g_pCorpseParts);

   if (!iter.Finished())
   {
      mxs_matrix mat;
      char model_name[80];
      int modelIdx;
      mds_model* pModel;
      ObjID partID;
      ObjPos pos;
      float radius;
      AutoAppIPtr(ObjectSystem);

      while (!iter.Finished())
      {
         // setup
         pos = *ObjPosGet(pMsg->victim);
         UpdateChangedLocation(&pos.loc);
         radius = 0;
         partID = pObjectSystem->Create(iter.GetObj(), kObjectConcrete);

         // find model
         if (ObjGetModelName(partID, model_name))
         {
            modelIdx = objmodelGetIdx(model_name);
            if (objmodelGetModelType(modelIdx) == OM_TYPE_MD)
            {
               // add vhot location to obj pos, if we have one
               pModel = (mds_model*)objmodelGetModel(modelIdx);
               if (pModel->vhots>0)
               {
                  mds_vhot *pVhots = md_vhot_list(pModel);
                  mx_ang2mat(&mat, &pos.fac);

                  for (int i=0; i<3; i++)
                     mx_scale_addeq_vec(&pos.loc.vec, &mat.vec[i], pVhots->v.el[i]);
               }
            }
            else
            {
               Warning(("CreatureExplodeDamageListener: Object %d model is not an md model\n", partID));
               iter.Next();
               continue;
            }
         }
         else
            Warning(("CreatureExplodeDamageListener: Object %d has no model\n", partID));

         // check that new object position is OK
         // get physics size
         cPhysModel *pModel;

         if ((pModel = g_PhysModels.Get(partID)) != NULL)
         {
            if ((pModel->GetType(0) == kPMT_Sphere) ||
                (pModel->GetType(0) == kPMT_SphereHat))
            {
               radius = ((cPhysSphereModel *)pModel)->GetRadius(0);
            }
         }

         // this is not quite right, but we need to create the object to find out about its
         // model, so it's easier this way
         BOOL valid_pos = TRUE;

         if (radius > 0.0)
         {
            if (!SphrSphereInWorld(&pos.loc, radius * 1.05, 0))
               valid_pos = FALSE;
         }
         else
         {
            if (ComputeCellForLocation(&pos.loc) == CELL_INVALID)
               valid_pos = FALSE;
         }

         if (valid_pos)
            ObjPosUpdate(partID, &pos.loc.vec, &pos.fac);
         else
            pObjectSystem->Destroy(partID);

         iter.Next();
      }
      // remove original model
#ifdef SHOCK
      return kDamageTerminate;
#else
      return kDamageDestroy; // Originally in Thief, added back for Thief2 so zombie bodys will disappear after explosion.
#endif
   }
   return kDamageNoOpinion;
}

///////////////////////////////////////////////

void CreatureExplodeInit(void)
{
   AutoAppIPtr(DamageModel);
   pDamageModel->Listen(kDamageMsgTerminate, CreatureExplodeDamageListener, NULL);
   CreateCorpsePartRelation();
}

// $Header: r:/t2repos/thief2/src/motion/mschtype.h,v 1.3 2000/01/31 09:51:10 adurant Exp $
#pragma once

#ifndef __MSCHTYPE_H
#define __MSCHTYPE_H

typedef struct sMGaitSkillData sMGaitSkillData;
typedef struct sMPlayerSkillData sMPlayerSkillData;


#endif
// $Header: r:/t2repos/thief2/src/motion/mseltype.h,v 1.2 2000/01/31 09:51:11 adurant Exp $
//
// This declares all of the enums needed for motor skill selection via the
// motor skill set.  Some of these fields are explicitly set by the AI
// when it makes maneuver requests, and some are derived by the motion
// coordinator based on AI input and queries to the world rep etc.
//
// Convention is to place most common value first, so that if no value is
// specified in a request, its branch will be searched first
#pragma once

#ifndef __MSELTYPE_H
#define __MSELTYPE_H

#define MSEL_SIZE_PAD 0xff

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// Locomotion Enums
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

enum  // media modes
{
   kMS_Mode_OnGround,
   kMS_Mode_InWater,
   kMS_Mode_InAir,
   kMS_NumMediaModes,
   kMS_MediaModeInvalid = MSEL_SIZE_PAD,
};
typedef uchar eMS_MediaMode;

enum // facing offset from direction of motion
{
   kMS_Fac_Forwards,
   kMS_Fac_Left,
   kMS_Fac_Backwards,
   kMS_Fac_Right,
   kMS_NumFacings,
   kMS_FacingInvalid = MSEL_SIZE_PAD,
};
typedef uchar eMS_Facing;

enum // speed
{
   kMS_Speed_Normal,
   kMS_Speed_Stationary,
   kMS_Speed_Slow,
   kMS_Speed_Fast,
   kMS_NumSpeeds,
   kMS_SpeedInvalid = MSEL_SIZE_PAD,
};
typedef uchar eMS_Speed;

enum
{
   kMS_LocoKind_Normal,
   kMS_LocoKind_Searching,
   kMS_LocoKind_SwordCombat,
   kMS_NumLocoKinds,
   kMS_LocoKindInvalid = MSEL_SIZE_PAD,
};
typedef uchar eMS_LocoKind;

enum
{
   kMS_PhysCon_Normal,
   kMS_PhysCon_Vertical,
   kMS_PhysCon_Lateral,
   kMS_NumPhysConstraints,
   kMS_PhysConstraintInvalid = MSEL_SIZE_PAD,
};
typedef uchar eMS_PhysConstraint;

#endif

// $Header: r:/t2repos/thief2/src/motion/mtagvals.h,v 1.4 2000/01/31 09:51:12 adurant Exp $
#pragma once

#ifndef __MTAGVALS_H
#define __MTAGVALS_H

enum eMTagUnitary
{
   kMTV_set,
};

enum eMTagDirectionValues
{
   kMTV_middle,
   kMTV_left,
   kMTV_right,
   kMTV_forward,
   kMTV_backward,
   kMTV_high,
   kMTV_low,
   kMTV_front,
   kMTV_back,
};

enum eMTagSwordSwingValues
{
   kMTV_swing_short,
   kMTV_swing_medium,
   kMTV_swing_long,
};

enum eMTagStairValues
{
   kMTV_upstairs,
   kMTV_downstairs,
};

//////
//////
//    THESE ARE SOON TO BE OBSOLETE   KJ 5/8/98

// this defines the enums of values for motion tags used in code
// these values are also used by the motion schema file parser.

enum eMTagBoolean
{
   kMTV_true,
};

/* add this when needed.  ground-based ("walk") is default when tag not present
enum eMTagLocoModeValues
{
   kMTV_swim,
   kMTV_fly,
   kMTV_climb,
   kMTV_jump,
};
*/

enum eMTagLocoSpeedValues
{
   kMTV_fast,
   kMTV_stationary,
};

enum eMTagFacingOffsetValues
{
   kMTV_perpleft,
   kMTV_perpright,
   kMTV_backwards,
};

enum eMTagActivityValues
{
   kMTV_searching,
   kMTV_swordmelee,
   kMTV_alert,
};

enum eMTagStandardActionValues
{
   kMTV_gesture,
   kMTV_hurt,
   kMTV_die,
   kMTV_stunned,
   kMTV_surprised,
   kMTV_alerttrans1,
   kMTV_alerttrans2,
   kMTV_alerttrans3,
};

enum eMTagMeleeActionValues
{
   kMTV_swing,
   kMTV_dodge,
   kMTV_parry,
};

enum eMTagHurtValues
{
   kMTV_hurt_light,
   kMTV_hurt_heavy,
};

enum eMTagPoseValues
{
   kMTV_pose_calib,
   kMTV_pose_swordready,
};

/* do we want this or does it fall out of occupation/actor and activity tags?
enum eMTagWeaponValues
{
   kMTV_withsword,
};
*/

#endif // mtagvals
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/crexp.h,v 1.2 2000/01/29 13:22:03 adurant Exp $
//
//
#pragma once

// Exploding creatures

#ifndef __CREXP_H
#define __CREXP_H

extern void CreatureExplodeInit(void);

#endif __CREXP_H

////////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/crjoint.h,v 1.3 2000/01/29 13:22:04 adurant Exp $
//
// Creature joint accessor header
//
#pragma once

#ifndef __CRJOINT_H
#define __CRJOINT_H

#include <objtype.h>
#include <matrixs.h>


// List of joints you may request
enum eCreatureJoints
{
   kCJ_Invalid, 
   kCJ_Head,
   kCJ_Neck,
   kCJ_Abdomen,
   kCJ_Butt,

   kCJ_LShoulder,
   kCJ_RShoulder,
   kCJ_LElbow,
   kCJ_RElbow,
   kCJ_LWrist,
   kCJ_RWrist,
   kCJ_LFingers,
   kCJ_RFingers,

   kCJ_LHip,
   kCJ_RHip,
   kCJ_LKnee,
   kCJ_RKnee,
   kCJ_LAnkle,
   kCJ_RAnkle,
   kCJ_LToe,
   kCJ_RToe,
   kCJ_Tail,

   kCJ_NumCreatureJoints,
};

EXTERN char *g_pJointNames[];

EXTERN int  GetCreatureJointID(ObjID creature, int joint);

#ifdef __cplusplus
EXTERN const mxs_vector &GetCreatureJointPos(ObjID creature, int joint);
EXTERN const mxs_matrix &GetCreatureJointOrient(ObjID creature, int joint);
#endif

EXTERN void GetCreatureJointPosC(ObjID creature, int joint, mxs_vector *vec);
EXTERN void GetCreatureJointOrientC(ObjID creature, int joint, mxs_matrix *mat);

#endif
#pragma once
#ifndef _CRWPNAPI_H
#define _CRWPNAPI_H

typedef struct 
{
   ObjID obj;           // Creature's ID.
   ObjID weaponObj;     // Creature's weapon ID.
   int   nWeapon;       // Current Creature's weapon.
} sCreatureWeapon;

void CreatureWeaponInit(void);
void CreatureWeaponTerm(void);

EXTERN int  (*CreatureWeaponObjSwizzle) (ObjID weapon, int mode);
EXTERN BOOL (*CreatureWeaponObjCreate)  (ObjID id, int mode);
EXTERN void (*CreatureWeaponObjDestroy) (ObjID id);
EXTERN void (*CreatureWeaponObjDrop)    (ObjID id);

// WeaponModes - used for picking appropriate weapon for mode.
enum
{
   kWeaponModeInvalid = -1,
   kWeaponModeBlock   = (1<<0),
   kWeaponModeMelee   = (1<<1),
   kWeaponModeRanged  = (1<<2),
   kWeaponModeIdle    = (1<<3),
   kNumWeaponModes = 4
};

// Internal API
// ClearWeaponOffsetCache:  Make sure we don't have anything dangling about.
EXTERN void ClearWeaponOffsetCache(void);
#endif // _CRWPNAPI_H
#pragma once
#ifndef _CRWPNLST_H
#define _CRWPNLST_H

#include <hashset.h>
#include <crwpnapi.h>

typedef cHashSet<sCreatureWeapon *, ObjID, cHashFunctions> cCreatureWeaponTableBase;

class cCreatureWeaponHash : public cCreatureWeaponTableBase
{
   virtual tHashSetKey GetKey(tHashSetNode node) const
   {
      return (tHashSetKey)(((sCreatureWeapon *)(node))->obj);
   }
};

// Creature Weapon List init
void CreatureWeaponListInit(void);
void CreatureWeaponListTerm(void);

// Creature Weapon List accessors
sCreatureWeapon *CreatureWeaponGet(ObjID obj);

// Creature Weapon List manipulators
void CreatureWeaponAdd(ObjID obj);
void CreatureWeaponRem(ObjID obj);

#endif // _CRWPNLST_H
#pragma once
#ifndef _CRWPNLUP_H
#define _CRWPNLUP_H

DEFINE_LG_GUID(LOOPID_CreatureWeapon, 0x3a9);

EXTERN struct sLoopClientDesc CreatureWeaponLoopClientDesc;
#endif // !_CRWPNLUP_H
#pragma once

DEFINE_LG_GUID(IID_IMotionTable, 0x12d);

// $Header: r:/t2repos/thief2/src/motion/imottab.h,v 1.4 2000/01/29 13:22:10 adurant Exp $
#pragma once

#ifndef __IMOTTAB_H
#define __IMOTTAB_H

#include <comtools.h>

#ifdef __cplusplus
#define CONSTFUNC const
#else
#define CONSTFUNC
#endif 

#undef INTERFACE 
#define INTERFACE IMotionTable
DECLARE_INTERFACE_(IMotionTable,IUnknown)
{
   DECLARE_UNKNOWN_PURE(); 

   // get information about static motion array.  
   // this should only be used for motion loading purposes.
   // and should go away or change once the world is happily dynamic.
   STDMETHOD_(int,NumPossibleMotions)(THIS) CONSTFUNC PURE;
   STDMETHOD_(char*,GetNameFromHardIndex)(THIS_ int index) CONSTFUNC PURE;
   STDMETHOD_(void,AddMotionFromHardIndex)(THIS_ int index, int motionNum) PURE;

   // get information about a motion given its motion number
   STDMETHOD_(int,GetType)(THIS_ const int motionNum) CONSTFUNC PURE;
   STDMETHOD_(BOOL,NeckIsFixed)(THIS_ const int motionNum) CONSTFUNC PURE;
   STDMETHOD_(char*,GetName)(THIS_ const int motionNum) PURE;
   STDMETHOD_(int,GetBlendType)(THIS_ const int motionNum) CONSTFUNC PURE;
   STDMETHOD_(int,GetNumMotions)(THIS) CONSTFUNC PURE;

   // get the motion number for a motion based on other information
   STDMETHOD_(int,NameGetNum)(THIS_ const char *name) CONSTFUNC PURE;
   STDMETHOD_(int,TypeGetAllNums)(THIS_ const int type, int *pMotNums, int *maxMots) CONSTFUNC PURE;
   STDMETHOD_(int,TypeGetNumFast)(THIS_ const int type) CONSTFUNC PURE;

};

#endif // __IMOTTAB_H



///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/motion/locobase.h,v $
// $Author: adurant $
// $Date: 2000/01/29 13:22:11 $
// $Revision: 1.4 $
//
// Locomotion types
#pragma once

#ifndef __LOCOBASE_H
#define __LOCOBASE_H

#if 0
/*
  Motion flags. These must be set in the editor on the frames
  on which footfalls occur.
*/
#define MP_LEFT_FOOTFALL      0x02
#define MP_RIGHT_FOOTFALL     0x04
#define MP_LEFT_FOOTUP        0x08
#define MP_RIGHT_FOOTUP       0x10
#define MP_FEET_FLAGS (MP_LEFT_FOOTFALL|MP_RIGHT_FOOTFALL|MP_LEFT_FOOTUP|MP_RIGHT_FOOTUP)
#define MP_STANDING           0x20
#define MP_TRIGGER1           0x40

#endif

// flags for footfalls
#define NEITHER_FOOT 0
#define LEFT_FOOT 1
#define RIGHT_FOOT 2

#endif // __LOCOBASE_H
// $Header: r:/t2repos/thief2/src/motion/motdesc.cpp,v 1.26 1998/04/20 15:52:33 kate Exp $

#include <wtypes.h>

#include <motdesc.h>
#include <string.h>
#include <motmngr.h>

#include <dbmem.h> // must be last included header

int MotDescNumMotions()
{
   if(g_pMotionSet)
   {
      return g_pMotionSet->NumMotions();
   } else
   {
      Warning(("Motion Database Not Loaded!\n"));
      return 0;
   }
}


BOOL MotDescNeckFixed(int mot_num)
{
   if(g_pMotionSet)
   {
      return g_pMotionSet->NeckIsFixed(mot_num);
   } else
   {
      Warning(("Motion Database Not Loaded!\n"));
      return FALSE;
   }
}

char *MotDescGetName(int mot_num)
{
   if(g_pMotionSet)
   {
      return (char *)g_pMotionSet->GetName(mot_num);
   } else
   {
      Warning(("Motion Database Not Loaded!\n"));
      return NULL;
   }
}

#define kMotDefaultBlendLength 500 // in msec

int MotDescBlendLength(int mot_num)
{
   if(g_pMotionSet)
   {
      return g_pMotionSet->BlendLength(mot_num);
   } else
   {
      Warning(("Motion Database Not Loaded!\n"));
      return 0;
   }
}

int MotDescNameGetNum(char *name)
{
   if(!name) // don't bother looking
      return -1;
   if(g_pMotionSet)
   {
      // make sure this cast is safe
      Assert_(strlen(name)<sizeof(Label));
      return g_pMotionSet->GetMotHandleFromName((Label *)name);
   } else
   {
      Warning(("Motion Database Not Loaded!\n"));
      return -1;
   }
}

// $Header: r:/t2repos/thief2/src/motion/motdesc.h,v 1.14 2000/01/31 09:50:59 adurant Exp $
#pragma once

#ifndef __MOTDESC_H
#define __MOTDESC_H

#include <motion.h>
#include <motdbase.h>

EXTERN int MotDescNumMotions();
EXTERN BOOL MotDescNeckFixed(int index);
EXTERN char *MotDescGetName(int index);
EXTERN int MotDescNameGetNum(char *name);
EXTERN int MotDescBlendLength(int index);

#endif
// $Header: r:/t2repos/thief2/src/motion/motdmnge.h,v 1.3 2000/01/31 09:51:00 adurant Exp $
#pragma once

#ifndef __MOTDMNGE_H
#define __MOTDMNGE_H

EXTERN void MotDmngeInit(int num_motions);
EXTERN void MotDmngeClose();
EXTERN void MotDmngeLock(int mot_num);
EXTERN void MotDmngeUnlock(int mot_num);


#endif
// $Header: r:/t2repos/thief2/src/motion/motorapi.h,v 1.18 2000/01/31 09:51:01 adurant Exp $
#pragma once

#ifndef __MMOTRAPI_H
#define __MMOTRAPI_H

#include <matrixs.h>
#include <motrtype.h>
#include <multiped.h>
#include <wrtype.h>
#include <objpos.h> // XXX for inline functions
#include <fix.h>

struct sMotorState
{
   mxs_vector position;
   mxs_angvec facing;
   BOOL IsPhysical;
   ulong  contactFlags;
   mxs_angvec direction;
   float timeSlop; // how much time was left in last frame when motion ended
   ObjID focus;
   int ballisticRefCount;
};

#define kMotStartFlag_ForceBlend 0x1 // blend the motion even if it doesn't by default
#define kMotStartFlag_SetStartFrame 0x2 // start frame is given as optional param

enum eMotorMotFrameOfReference  // These must correspond to MFRT constants in multiped.h 
{
   kMFRT_RelStart,      
   kMFRT_Arm,
   kMFRT_Global,
   kMFRT_Invalid=0xffffffff,
};

class IMotor
{
public:
   virtual void SetMotorResolver(IMotorResolver *pResolver)=0;

   virtual int  GetActorType()=0;
   virtual void StartMotion(const int motionNum)=0;
   virtual void StartMotionWithParam(const int motionNum,mps_motion_param *pParam,ulong flags=0,int startFrame=0)=0;
   virtual void StopMotion(const int)=0;
   virtual void PoseAtMotionFrame(int motNum, float frame)=0;
   // for load/save
   virtual int  SwizzleMotion(int motNum)=0;
   virtual int  GetCurrentMotion()=0;

   virtual BOOL SetTransform(const mxs_vector *, const mxs_angvec *, BOOL movePhys=TRUE)=0;
   virtual BOOL SetPosition(const mxs_vector *, BOOL movePhys=TRUE)=0;
   virtual BOOL SetOrientation(const mxs_angvec *, BOOL movePhys=TRUE)=0;
   virtual void GetTransform(mxs_vector *, mxs_angvec *)=0;
   virtual const Location *GetLocation() const =0;
   virtual mxs_real GetButtZOffset() const =0;
   virtual mxs_real GetDefaultButtZOffset() const =0;
   virtual void GetFeetJointIDs(int *numJoints, int **jointIDs) const =0;
   virtual ObjID GetObjID() const=0;
   virtual void SetFocus(ObjID obj)=0; // obj_null means no focus
   virtual void SetFocus(ObjID obj,fix fSpeed)=0; // obj_null means no focus

   virtual const sMotorState *GetMotorState() const =0;
   virtual void SetContact(ulong)=0;
   virtual void SetVelocity(const mxs_angvec *dir, const mxs_real speed)=0;
   virtual BOOL MakePhysical()=0;
   virtual void MakeNonPhysical()=0;
   virtual BOOL IsBallistic()=0;
   virtual void SetMotFrameOfReference(int type) = 0;
   virtual int GetMotFrameOfReference() = 0;

   virtual void Pause()=0;
   virtual const multiped *GetMultiped() const =0;
   virtual float GetMotionScale() const=0;
   virtual int  GetRootJointID() const=0;
};

#endif
// $Header: r:/t2repos/thief2/src/motion/motrtype.h,v 1.3 2000/01/31 09:51:02 adurant Exp $
#pragma once

#ifndef __MOTRTYPE_H
#define __MOTRTYPE_H

typedef struct sMotorState sMotorState;
typedef class IMotor IMotor;
typedef class IMotorResolver IMotorResolver;

#endif
// $Header: r:/t2repos/thief2/src/motion/motschem.h,v 1.6 2000/01/31 09:51:03 adurant Exp $
#pragma once

//
// This header contains class interface for motion schemas and 
// motion schema sets.
//
// They are the return values from queries to the motion database, and can
// be used to generate motion plans.
//

#ifndef __MOTSCHEM_H
#define __MOTSCHEM_H

#include <dynarray.h>
#include <tagfile.h>
#include <objtype.h>
#include <label.h>
#include <motset.h> // for sMotStuff
#include <namemap.h>
#include <motdbtyp.h>


#define kMotSchemaID_Invalid -1

#define kMSchFlag_ArchObjSwizzle 0x1
#define kMSchFlag_FixedDuration  0x2
#define kMSchFlag_TimeWarp       0x4
#define kMSchFlag_Stretch        0x8
#define kMSchFlag_FixedDist      0x10

// these are the atomic units of the motion database, and the thing from
// which the motion system builds its plans.
// It's up to the app to associate data with the schema's archetype, and
// to know how to access that data

class cMotionSchema
{
public:
   cMotionSchema();

   ~cMotionSchema();

   // returns motion handle for a random motion in schema
   BOOL GetRandomMotion(int *pMotID) const;
   BOOL GetRandomMotionInRange(int min, int max, int *pMotID) const;
   BOOL GetMotion(int offset, int *pMotID) const;

   void SetDuration(float duration);
   void SetTimeWarp(float timeWarp);
   void SetDistance(float distance);
   void SetStretch(float timeWarp);
   BOOL GetDuration(float *pDuration) const;
   BOOL GetTimeWarp(float *pTimeWarp) const;
   BOOL GetDistance(float *pDist) const;
   BOOL GetStretch(float *pStretch) const;

   int NumMotions() const { return m_MotRunHandleList.Size(); }

   ObjID GetArchetype() const { return m_ArchObj; }

   int GetIndex() const { return m_ArchIndex; }

   int GetSchemaID() const { return m_SchemaID; }
   void SetSchemaID(int id) { m_SchemaID = id; }

   ulong GetFlags() const { return m_Flags; }
   void SetFlags(ulong flags) { m_Flags=flags; }

   // save/load
   BOOL Save(ITagFile *pFile);
   BOOL Load(ITagFile *pFile, cNameMap *pNameMap);
   void SetupRunTimeData(cNameMap *pNameMap);

   // db building
   void AddMotion(const Label *name, const sMotStuff *pStuff);
   void SetArchetype(int index); // index into name map provided by EndBuild and Load

private:
   ulong m_Flags;
   int m_ArchIndex;
   ObjID m_ArchObj;
   int m_SchemaID;
   float m_TimeModifier;
   float m_DistModifier;
   cDynArray<int> m_MotIndexList;
   cDynArray<int> m_MotRunHandleList;
};

inline void cMotionSchema::SetDuration(float duration)
{
   if(m_Flags&kMSchFlag_TimeWarp)
      m_Flags&=(~kMSchFlag_TimeWarp);
   m_Flags|=kMSchFlag_FixedDuration;
   m_TimeModifier=duration;
}

inline void cMotionSchema::SetTimeWarp(float timeWarp)
{
   if(m_Flags&kMSchFlag_FixedDuration)
      m_Flags&=(~kMSchFlag_FixedDuration);
   m_Flags|=kMSchFlag_TimeWarp;
   m_TimeModifier=timeWarp;
}

inline void cMotionSchema::SetDistance(float dist)
{
   if(m_Flags&kMSchFlag_Stretch)
      m_Flags&=(~kMSchFlag_Stretch);
   m_Flags|=kMSchFlag_FixedDist;
   m_DistModifier=dist;
}

inline void cMotionSchema::SetStretch(float stretch)
{
   if(m_Flags&kMSchFlag_FixedDist)
      m_Flags&=(~kMSchFlag_FixedDist);
   m_Flags|=kMSchFlag_Stretch;
   m_DistModifier=stretch;
}

inline BOOL cMotionSchema::GetDuration(float *pDuration) const
{
   if(m_Flags&kMSchFlag_FixedDuration)
   {
      *pDuration=m_TimeModifier;
      return TRUE;
   }
   return FALSE;
}

inline BOOL cMotionSchema::GetTimeWarp(float *pTimeWarp) const
{
   if(m_Flags&kMSchFlag_TimeWarp && !(m_Flags&kMSchFlag_FixedDuration))
   {
      *pTimeWarp=m_TimeModifier;
      return TRUE;
   }
   return FALSE;
}

inline BOOL cMotionSchema::GetDistance(float *pDist) const
{
   if(m_Flags&kMSchFlag_FixedDist)
   {
      *pDist=m_DistModifier;
      return TRUE;
   }
   return FALSE;
}

inline BOOL cMotionSchema::GetStretch(float *pStretch) const
{
   if(m_Flags&kMSchFlag_Stretch && !(m_Flags&kMSchFlag_FixedDist))
   {
      *pStretch=m_DistModifier;
      return TRUE;
   }
   return FALSE;
}

typedef cDynClassArray<cMotionSchema> cMotionSchemaSet;

typedef cDynArray<cMotionSchema *> cMotionSchemaPtrList;

#endif       // motschem_h
// $Header: r:/t2repos/thief2/src/motion/motset.h,v 1.6 2000/01/31 09:51:04 adurant Exp $
#pragma once

#ifndef __MOTSET_H
#define __MOTSET_H

#include <tagfile.h>
#include <label.h>
#include <dynarray.h>
#include <motion.h>
#include <motdbtyp.h>
#include <matrixs.h>

class IMotionSet
{
public:
   virtual ~IMotionSet() {}

// run-time functions
   virtual BOOL NeckIsFixed(int motHandle)=0;
   virtual int  BlendLength(int motHandle)=0;
   virtual Label *GetName(int motHandle)=0;
   virtual void GetStartEndFrames(int motHandle, int *pStart, int *pEnd)=0;
   virtual int GetNumFrames(int motHandle)=0;
   virtual mxs_ang GetEndHeading(int motHandle)=0;
   virtual void GetTranslation(int motHandle, mxs_vector *pXlat)=0;
   virtual float GetDuration(int motHandle)=0;
   virtual void GetSlidingVelocity(int motHandle, mxs_vector *pVel)=0;
   virtual BOOL WantInPlace(int motHandle)=0;

   virtual int  GetMotHandleFromName(const Label *name)=0;
   virtual int  NumMotions()=0;

// load/save functions
   virtual BOOL Load(ITagFile *pFile)=0;
   virtual BOOL Save(ITagFile *pFile)=0;
   virtual BOOL GetRunHandle(int index, int *pRunHandle)=0;

// set-building functions
   virtual void Clear()=0;
   virtual void StartBuild()=0;
   virtual void EndBuild()=0;
   virtual BOOL AddMotion(const Label *name, const sMotStuff *pStuff, int *pIndex)=0;

// virtual motion dealing.  These need to be registered before "add motion" gets called.
   virtual void RegisterVirtualMotion(const Label *name,const mps_motion *pMotion)=0;
};

IMotionSet *NewMotionSet();


#endif
// $Header: r:/t2repos/thief2/src/motion/mottype.h,v 1.8 2000/01/31 09:51:05 adurant Exp $
#pragma once

#ifndef __MOTTYPE_H
#define __MOTTYPE_H

#include <motion.h>

// motion types
#define MDT_NONE                          -1

#define MDT_TEST                          0
#define MDT_GUARD_CALIB                   1

#define MDT_STAND_GUARD_CASUAL            2
#define MDT_WALK_START_GUARD_CASUAL       3
#define MDT_WALK_END_GUARD_CASUAL         4
#define MDT_WALK_LEFT_GUARD_CASUAL        5
#define MDT_WALK_RIGHT_GUARD_CASUAL       6
#define MDT_CLIMB_LEFT_GUARD_CASUAL       7
#define MDT_CLIMB_RIGHT_GUARD_CASUAL      8
#define MDT_DESCEND_LEFT_GUARD_CASUAL     9
#define MDT_DESCEND_RIGHT_GUARD_CASUAL    10

#define MDT_STAND_GUARD_READY            22
#define MDT_WALK_START_GUARD_READY       23
#define MDT_WALK_END_GUARD_READY         24
#define MDT_WALK_LEFT_GUARD_READY        25
#define MDT_WALK_RIGHT_GUARD_READY       26
#define MDT_CLIMB_LEFT_GUARD_READY       27
#define MDT_CLIMB_RIGHT_GUARD_READY      28
#define MDT_DESCEND_LEFT_GUARD_READY     29
#define MDT_DESCEND_RIGHT_GUARD_READY    30
#define MDT_WALK_SEARCH_START_GUARD_READY  31
#define MDT_WALK_SEARCH_CYCLE_GUARD_READY 32

#define MDT_GESTURE_GUARD_CASUAL         40
#define MDT_ALERT1_GUARD                 41 
#define MDT_ALERT2_GUARD                 42
#define MDT_ALERT3_GUARD                 43 
#define MDT_CALLHELP_GUARD               44 
#define MDT_SWORD_ATTACK_GUARD           45 
#define MDT_SWORD_PARRY_GUARD            46
#define MDT_SWORD_DODGE_GUARD            47 
#define MDT_RETREAT_GUARD                48
#define MDT_ADVANCE_GUARD                49

#define MDT_DIE_GUARD                    51
#define MDT_HURT_GUARD                   52
#define MDT_SIDESTEP_LEFT_GUARD          53
#define MDT_SIDESTEP_RIGHT_GUARD         54

#define MDT_AWAKEN_SERVANT               55 
#define MDT_RUN_LEFT_SERVANT             56
#define MDT_RUN_RIGHT_SERVANT            57
#define MDT_RUN_TURN_180                 58

#define MDT_SWORD_ATTACK_SHORT           59
#define MDT_SWORD_ATTACK_MEDIUM          60 
#define MDT_SWORD_ATTACK_LONG            61 

#define MDT_HURT_BADLY                   62
#define MDT_HURT_LIGHTLY                 63

#define MDT_COMBAT_IDLE                  64
#define MDT_STUN_GUARD                   65

#define MDT_SURPRISE_LEFT                66  
#define MDT_SURPRISE_RIGHT               67
#define MDT_SURPRISE_AHEAD               68
#define MDT_SURPRISE_BEHIND              69 


#define NUM_MOTDESC_TYPES 70

#endif
///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/motion/mputil.h,v $
// $Author: adurant $
// $Date: 2000/01/31 09:51:06 $
// $Revision: 1.5 $
//
// Multiped utilities
#pragma once

#ifndef __MPUTIL_H
#define __MPUTIL_H

#include <multiped.h>

typedef void MpFile;
typedef BOOL (* MpFileFunc)(MpFile* file, void* buf, int len); 
extern void MpWriteMultiped(multiped *mp, MpFileFunc write, MpFile *file);
extern void MpReadMultiped(multiped *mp, MpFileFunc read, MpFile *file);

#endif // __MPUTIL_H
// $Header: r:/t2repos/thief2/src/motion/mschbase.h,v 1.8 2000/01/31 09:51:07 adurant Exp $
#pragma once

#ifndef __MSCHBASE_H
#define __MSCHBASE_H

#include <mschtype.h>

#define MAX_GAIT_TURNS 3

typedef struct sMGaitTurn
{
   int angle; // turn angle XXX can this be fixang yet edited in editor as degrees?
   int mot;
} sMGaitTurn;

struct sMGaitSkillData
{
   int leftStride;
   int rightStride;
   float maxAscend; 
   float maxDescend;
   float timeWarp; // slows down playback of all motions for this gait
   float stretch; // horizontally stretches all motions for this gait
   int maxAngVel;  // in degrees/second, used for smoothing
   int turnTolerance; // in degrees.  how close turn angle need to be to choose to turn
   float maxVel; // max "physically possible" velocity appropriate for gait
   float minVel;
   int numTurns;
   sMGaitTurn turns[MAX_GAIT_TURNS];
   float noise;
};

struct sMPlayerSkillData
{
   float      flexDuration; // time to max flex
   int        flexDegree; // maximum flex, in degrees
};

// for mvrcmbat motor controller
enum eMSwordActionType
{
   kMSAT_Swing,
   kMSAT_GeneralBlock,
   kMSAT_DirectedBlock,
   kMSAT_Invalid=0xffffffff,
};

#endif // __MSCHDATA_H
#pragma once
typedef union {
   char *strval;
   int  ival;
   float fval;
   BOOL  bval;
} MSCHSTYPE;
#define IDENT	257
#define STRING	258
#define INT	259
#define FLOAT	260
#define BOOLEAN	261
#define INCLUDE	262
#define DEFINE	263
#define LPAREN	264
#define RPAREN	265
#define EQUAL	266
#define COLON	267
#define SCHEMA	268
#define TAG	269
#define TAG_OPT	270
#define ACTOR	271
#define ACTORS_DECLARE	272
#define ARCHETYPE	273
#define MOTION	274
#define TAGLIST_HEADER	275
#define MOTLIST_HEADER	276
#define STRETCH	277
#define TIMEWARP	278
#define DURATION	279
#define DISTANCE	280
#define MOT_NECK_FIXED	281
#define MOT_NECK_NOT_FIXED	282
#define MOT_BLEND_NONE	283
#define MOT_BLEND_DEFAULT	284
#define MOT_IS_TURN	285
#define MOT_BLEND_LENGTH	286
#define MOT_IN_PLACE	287
#define MOT_IS_LOCO	288
extern MSCHSTYPE mschlval;
// $Header: r:/t2repos/thief2/src/motion/mctype.h,v 1.4 2000/01/31 09:50:10 adurant Exp $
#pragma once

#ifndef __MCTYPE_H
#define __MCTYPE_H

typedef class IMotionCoordinator IMotionCoordinator;
typedef class IManeuver IManeuver;
typedef class IMotionPlan IMotionPlan;

typedef struct sMcMoveState sMcMoveState;
typedef struct sMcMoveParams sMcMoveParams;

typedef void (*fMcMotorStateChangeCallback)(void *context);

typedef void (*fMcManeuverCompletionCallback)(void *context, IManeuver *pCompleted, IManeuver *pNext);

#endif
// $Header: r:/t2repos/thief2/src/motion/mctype_.h,v 1.3 2000/01/31 09:50:11 adurant Exp $
#pragma once

#ifndef __MCTYPE__H
#define __MCTYPE__H

// this contains forward declarations internal to the motion system

typedef struct sMcMotorState sMcMotorState;
typedef class cMotionCoordinator cMotionCoordinator;
typedef class cMotionPlan cMotionPlan;


#endif
// $Header: r:/t2repos/thief2/src/motion/meshapi.h,v 1.3 2000/01/31 09:50:12 adurant Exp $
#pragma once

#ifndef __MESHAPI_H
#define __MESHAPI_H

#include <qt.h>
#include <matrixs.h>
#include <mms.h>

class IMesh
{
public:
// renderer functions
//
   virtual void MeshJointPosCallback(const int jointID, mxs_trans *pTrans)=0;
   virtual void MeshStretchyJointCallback(const int jointID, mxs_trans *pTrans, quat *pRot)=0;

// shape functions
//
   virtual float GetRadius()=0;
   virtual void GetWorldBBox(mxs_vector *pBMin, mxs_vector *pBMax)=0;
private:

};

#endif
// $Header: r:/t2repos/thief2/src/motion/mmanuver.h,v 1.9 2000/01/31 09:50:13 adurant Exp $
#pragma once

#ifndef __MMANUVER_H
#define __MMANUVER_H

#include <motorapi.h>
#include <mclntapi.h>
#include <mctype.h>
#include <mctype_.h>
#include <dlist.h>
#include <motdbtyp.h>
#include <tagfile.h>

class cManeuver;
typedef cDList<cManeuver,1> cManeuverList;
typedef cDListNode<cManeuver, 1> cManeuverNode;

class cManeuver: public IManeuver, public cManeuverNode
{
public:
////////
// Motion System Client Functions
////////
   virtual ~cManeuver() {}

   virtual IManeuver *GetNextManeuver() { return GetNext(); }
   virtual IManeuver *GetPrevManeuver() { return GetPrevious(); }
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState) \
      { AssertMsg(FALSE,"GetExpectedEndMoveState not supported yet"); }

////////
// Motion Coordinator Functions
////////
   virtual void Save(ITagFile *pTagFile) {}
   virtual void SetAppData(ulong data)
      { m_AppData = data; }
   virtual ulong GetAppData() { return m_AppData; }

   virtual void Execute()=0;

   // tells maneuver to finish executing.  Often comes just before deletion.
   // this is the appropriate time for the maneuver to store off state to be used
   // by the next executing maneuver.
   virtual void Finish() {}

   virtual void SetMotor(IMotor *pMotor) { m_pMotor=pMotor; }

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) { mx_zero_vec(pNewVel); }
   virtual void NotifyAboutBeingStuck() {}
   virtual void NotifyAboutMotionAbortRequest() {}

   virtual void NotifyAboutFrameFlags(const int) {}
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags) {}

protected:
   IMotor *m_pMotor;
   cMotionCoordinator *m_pCoord;
   ulong m_AppData;
};

class cMotionPlan: public IMotionPlan, public cManeuverList
{
public:
   ~cMotionPlan() 
   {
      while (GetFirst())
         delete Remove(GetFirst());
   }

   virtual IManeuver *GetFirstManeuver() { return GetFirst(); }
   virtual IManeuver *GetLastManeuver() { return GetLast(); }
   virtual IManeuver *PopFirstManeuver() { return Remove( GetFirst() ); }
private:
// yadda yadda yadda.
};

class cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const cMotionSchema *schema, const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)=0;

   virtual IManeuver *LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile) { return NULL;}
};

#endif
// $Header: r:/t2repos/thief2/src/motion/mmnvrfac.h,v 1.2 2000/01/31 09:50:14 adurant Exp $
#pragma once

#ifndef __MMNVRFAC_H
#define __MMNVRFAC_H

// This module contains an array of all the factory methods for creating
// maneuvers

#include <mmanuver.h>

EXTERN cManeuverFactory *g_aManeuverFactoryTable;
EXTERN int g_iNumManeuverFactories;

#endif
// $Header: r:/t2repos/thief2/src/motion/mmresapi.h,v 1.5 2000/01/31 09:50:54 adurant Exp $
#pragma once

#ifndef __MMRESAPI_H
#define __MMRESAPI_H

#include <motrtype.h>
#include <matrixs.h>

typedef class IMotorResolver IMotorResolver;

class IMotorResolver
{
public:
//
// Physics resolving functions
//
   virtual void CalcEnvironmentEffect()=0;
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel)=0;
   virtual void NotifyAboutBeingStuck()=0;
   virtual void NotifyAboutMotionAbortRequest()=0;

//
// Motor status notification functions
//
   virtual void NotifyAboutMotorStateChange()=0;
   virtual void NotifyAboutMotorDestruction()=0;

//
// Motion status notification functions
//
   virtual void NotifyAboutFrameUpdateBegin()=0;
   virtual void NotifyAboutFrameUpdateEnd()=0;
   virtual void NotifyAboutFrameFlags(const int)=0;
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)=0;
};

#endif
///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/motion/motbase.h,v $
// $Author: adurant $
// $Date: 2000/01/31 09:50:55 $
// $Revision: 1.6 $
//
// Motion numbers
#pragma once

#ifndef __MOTBASE_H
#define __MOTBASE_H

#include <motion.h>

#define MP_UPDATE_FLAG_FAKE (1<<MP_RESERVED_CFLAG_SHIFT)

// motion numbers
#define MOT_NONE -1

#define MOT_STAND 0

#if 0 // obsolete.  see motdesc.[ch]
#define MOT_WALK 2
#define MOT_CLIMB_RIGHT 25
#define MOT_CLIMB_LEFT 26
#define MOT_WALK_RIGHT 28
#define MOT_WALK_LEFT 29
#define MOT_DESCEND_RIGHT 31
#define MOT_DESCEND_LEFT 32
#endif

// motion play priorities
#define MOT_PRI_DEFAULT 10

#endif // __MOTBASE_H
// $Header: r:/t2repos/thief2/src/motion/motdb_.h,v 1.2 2000/01/31 09:50:56 adurant Exp $
#pragma once

// utilities for building motion database

#ifndef __MOTDB__H
#define __MOTDB__H

#include <label.h>
#include <motdbtyp.h>
#include <fcytagdb.h>


EXTERN void MotDBCreate(int nActors);
EXTERN void MotDBRegisterTag(Label *pName, sTagInfo *pInfo);
EXTERN void MotDBAddSchema(sMotSchemaDesc *pSchema);

#endif // __MOTDB__H
// $Header: r:/t2repos/thief2/src/motion/motdbase.h,v 1.6 2000/01/31 09:50:57 adurant Exp $
#pragma once

// declaration of motdatabase structs that are forward declared in motdbtyp.h
#ifndef __MOTDBASE_H
#define __MOTDBASE_H

#include <label.h>
#include <motdbtyp.h>
#include <matrixs.h>

// blending types
#define BLEND_NONE 0
#define BLEND_DEFAULT 1

#define kMSF_NECK_IS_FIXED 0x1
#define kMSF_IS_TURN       0x2
#define kMSF_WANT_NO_XLAT  0x4
#define kMSF_IS_LOCO       0x8

struct sMotStuff
{
   ulong flags;
   ushort blendLength;
   mxs_ang endDirAction;
   mxs_vector xlat; // actual xlat of motion
   float duration;
};

struct sMotDesc
{
   Label name;
   sMotStuff stuff;
};

struct sTagDesc
{
   Label type;
   int value; /* could support value ranges, but don't think that's
                   needed for motion schemas. will add if needed */
};

struct sMotSchemaDesc
{
   Label name;
   BOOL archIsString;
   Label archName;
   int archInt;
   int actor;
   int nTags;
   sTagDesc *pTags;
   int nMots;
   sMotDesc *pMots;
   float duration;
   float timeWarp;
   float stretch;
   float distance;
};


#endif // motdbase.h

// $Header: r:/t2repos/thief2/src/motion/motdbtyp.h,v 1.2 2000/01/31 09:50:58 adurant Exp $
#pragma once

#ifndef __MOTDBTYP_H
#define __MOTDBTYP_H

#ifdef __cplusplus

// forward declarations of motion database classes

typedef class cMotionSchema cMotionSchema;
typedef class cMotionDatabase cMotionDatabase;
typedef class IMotionSet IMotionSet;

#endif // cplusplus

// forward declarations of internal structures
typedef struct sMotStuff sMotStuff;
typedef struct sMotDesc sMotDesc;
typedef struct sTagDesc sTagDesc;
typedef struct sMotSchemaDesc sMotSchemaDesc;

#endif // __MOTDBTYP_H
// $Header: r:/t2repos/thief2/src/motion/skillset.h,v 1.3 2000/01/31 09:50:00 adurant Exp $
// interface to get information about an object's skill abilities
#pragma once

#ifndef __SKILLSET_H
#define __SKILLSET_H

#include <objtype.h>
#include <skilltyp.h>

BOOL SkillSetGetForObj(const ObjID objID, int *nSkills, tSkillID **ppSkills);



#endif
// $Header: r:/t2repos/thief2/src/motion/skilltab.cpp,v 1.28 1998/02/23 14:07:51 kate Exp $
//
// XXX how to deal with alignment issues?  Guess I should pad structures
// (kNumLocoValues is currently derived from the size of a structure that really should
// get padded and isn't).
//
// XXX There's tons of junk pushed into cMSkill that isn't really motion-system
// related at all (player stuff).  This should get sorted out when this 
// starts using the object system.
//
// XXX There are also lots of player skill editing functions in here.
// The hope is to get this kind of editing done through dromed.
// The player cerebellum gets its skill information straight from here
// each time, which is slow since this is a naive implementation.  It may
// want to store off its own data like the motion system skill set does, but 
// again I want to hold off until I figure out what's going on for real. 
//                                                          KJ 12/97
//
// HOW TO ADD SKILLS OF AN EXISITING MOTION CATEGORY
//
// Go to the static array where that category's data is defined, and add a new 
// entry.
// Go to g_aSkills and add a line
//    cSkill( <skill name> , <skill category>, <offset of skill in category static array> ),

// HOW TO CREATE A NEW MOTION CATEGORY
//
// Add the motion category to the eMotionCategory enum in mclntapi.h
// Create a class for the new skill thats a subclass of cMSkill
// Create a factory method for your new class, and add it to the factory
// methods array, at the appropriate index for your category.
// Add a case to cSkillTable::GetSelectDescBasics to return info about
// skill selection for your category.
// Make sure your class sets m_KeyDesc fields if you want it to have skill
// selection criteria (otherwise can only have one skill for that category). 
//  - locomotion is a good example of this.


#include <mskilset.h>
//#include <msklhack.h>
#include <motdesc.h>
#include <mskltree.h>
#include <skilltab.h>
#include <mseltype.h>
#include <fix.h>
#include <skildtab.h>
#include <command.h>
#include <config.h>

// must be last header
#include <dbmem.h>


EXTERN cManeuverFactory *g_pTeleportManeuverFactory; // from mvrtport.cpp
EXTERN cManeuverFactory *g_pSingleManeuverFactory; // from mvrsngle.cpp
EXTERN cManeuverFactory *g_pGlideManeuverFactory; // from mvrglide.cpp
EXTERN cManeuverFactory *g_pGroundLocoManeuverFactory; // from mvrgloco.cpp
EXTERN cManeuverFactory *g_pPlayerStandardManeuverFactory; // from mvrplyr.cpp
EXTERN cManeuverFactory *g_pFlexBowManeuverFactory; // from mvrflbow.cpp
EXTERN cManeuverFactory *g_pCombatManeuverFactory; // from mvrcmbat.cpp

EXTERN cManeuverFactory *g_aManeuverFactory[] = {\
   g_pTeleportManeuverFactory,
   g_pSingleManeuverFactory,
   g_pGlideManeuverFactory,
   g_pGroundLocoManeuverFactory,
   g_pPlayerStandardManeuverFactory,
   g_pFlexBowManeuverFactory,
   g_pCombatManeuverFactory,
};   


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// DEFAULT MOTION DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

class cMDefaultSkill : public cMSkill
{
public:
   cMDefaultSkill(const char *name, const int controllerID) \
      { 
         m_Name=(char *)name; m_ControllerID=controllerID; m_Category=kMCat_Default; 
         m_KeyDesc.nValues=0; m_KeyDesc.pValues=NULL;
      }
};


class cMSkillFactory
{
public:
   // default implementation
   virtual cMSkill *Create(const char *name, const int offset) \
      {
         if(g_aDefaultDesc[offset].controllerID==kControllerInvalid)
            return NULL;
         return new cMDefaultSkill(name, g_aDefaultDesc[offset].controllerID);
      }
   virtual void BeginEdit(const char *name, const int offset) {}
   virtual void EndEdit(const char *name, const int offset) {}
};

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// SINGLEPLAY DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

class cMSinglePlaySkill : public cMSkill
{
public:
   cMSinglePlaySkill(const char *name, const int controllerID) \
      { 
         m_Name=(char *)name; m_ControllerID=controllerID; m_Category=kMCat_SinglePlay; 
         m_KeyDesc.nValues=0; m_KeyDesc.pValues=NULL;
      }
};


class cMSinglePlaySkillFactory : public cMSkillFactory
{
public:
   // default implementation
   virtual cMSkill *Create(const char *name, const int offset) \
      {
         if(g_aDefaultDesc[offset].controllerID==kControllerInvalid)
            return NULL;
         return new cMSinglePlaySkill(name, g_aSinglePlayDesc[offset].controllerID);
      }
};

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// COMBAT DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

class cMCombatSkill : public cMSkill
{
public:
   cMCombatSkill(const char *name, const int controllerID) \
      { 
         m_Name=(char *)name; m_ControllerID=controllerID; m_Category=kMCat_Combat; 
         m_KeyDesc.nValues=0; m_KeyDesc.pValues=NULL;
      }
};

sLocoFullDesc *g_pCombatEditDesc=NULL;

class cMCombatSkillFactory : public cMSkillFactory
{
public:
   // default implementation
   virtual cMSkill *Create(const char *name, const int offset) \
      {
         if(g_aDefaultDesc[offset].controllerID==kControllerInvalid)
            return NULL;
         return new cMCombatSkill(name, g_aCombatDesc[offset].controllerID);
      }
};

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// LOCOMOTION DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

const int kNumLocoValues=sizeof(sMLocoSelectDesc)/sizeof(uchar);

class cMLocomoteSkill : public cMSkill
{
public:
   cMLocomoteSkill(char *name, int controllerID, sMLocoSelectDesc *selectDesc, sMGaitSkillData *skillData) \
      {
         m_Name=name; m_ControllerID=controllerID; m_Category=kMCat_Locomote; 
         m_SelectDesc=*selectDesc; m_SkillData=*skillData;
         m_KeyDesc.nValues=kNumLocoValues; m_KeyDesc.pValues=m_SelectDesc.pValues;
      }


   ~cMLocomoteSkill() {}

   virtual sMGaitSkillData *GetGaitSkillData() { return &m_SkillData; }

private:
   sMGaitSkillData m_SkillData; // data to be used by maneuver for carring out gait
   // data to be used in gait selection
   sMLocoSelectDesc m_SelectDesc;

};

sLocoFullDesc *g_pLocoEditDesc=NULL;

class cMLocoSkillFactory : public cMSkillFactory
{
public:
   virtual cMSkill *Create(const char *name, const int offset) \
      {   sLocoFullDesc *pLDesc=&g_aLocoDesc[offset]; \
         if(g_aDefaultDesc[offset].controllerID==kControllerInvalid)
            return NULL;
          return new cMLocomoteSkill((char *)name,pLDesc->controllerID,&pLDesc->selDesc,&pLDesc->skillData);
      }


   virtual void BeginEdit(const char *name, const int offset) \
      { g_pLocoEditDesc=&g_aLocoDesc[offset];}

   virtual void EndEdit(const char *name, const int offset) { g_pLocoEditDesc=NULL; }

};


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// PLAYER SKILLS DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

const int kNumPlayerSkillValues=0; // don't go through skill selection tree that AIs do

#ifndef SHIP
EXTERN BOOL g_UseGlobalOffset;
EXTERN mxs_vector g_ArmRelPos;
EXTERN mxs_angvec g_ArmRelAng;
#endif

class cMPlayerSkill : public cMSkill
{
public:
   cMPlayerSkill(char *name, sPlayerSkillFullDesc *pDesc)
      {
         if(!pDesc)
            return;
         m_Name=name; m_Category=kMCat_Player; 
         m_ControllerID=pDesc->controllerID; 
         m_Connect=pDesc->connect; m_ModelName=pDesc->modelName; m_PlayerSkillData=pDesc->skillData;
         m_TimeToMax=pDesc->timeToMax; m_Shoot=pDesc->shoot;
         m_Transition=pDesc->trans;
         m_SchemaName=pDesc->schemaName;
         m_MouseSpeed=pDesc->mouseSpeed;
         m_MouseZone=pDesc->mouseZone;
         m_SlewSpeedScale=pDesc->slewSpeedScale;
         m_RotateSpeedScale=pDesc->rotateSpeedScale;
         m_KeyDesc.nValues=0; m_KeyDesc.pValues=NULL;
         m_IsIdleMotion=pDesc->IsIdleMotion;
      }
   ~cMPlayerSkill() {}

   virtual sSkillConnectDesc *GetSkillConnectData() { return &m_Connect; }
   virtual char *GetModelName() { return m_ModelName; }
   virtual char *GetSchemaName() { return m_SchemaName; }
   virtual ePlayerTransition GetTransitionType() { return m_Transition; }

   // NOTE: this modifies local data if g_UseGlobalOffset is set, and changes
   // remain even if g_UseGlobalOffset gets unset.
   virtual sMPlayerSkillData *GetPlayerSkillData() { 
#ifndef SHIP
      if(g_UseGlobalOffset)
      {
         mx_copy_vec(&m_PlayerSkillData.startPosOff,&g_ArmRelPos);
         m_PlayerSkillData.startAngOff=g_ArmRelAng;
      }
#endif
      return &m_PlayerSkillData; 
   }

   virtual BOOL Shoot() { return m_Shoot; }
   virtual float GetPowerUpTime() { return m_TimeToMax; }
   virtual int HasMouseParams() { return (m_MouseSpeed!=0||m_MouseZone!=0); }
   virtual int GetMouseSpeed() { return m_MouseSpeed; }
   virtual int GetMouseZone() { return m_MouseZone; }
   virtual BOOL HasSpeedScale() { return (m_SlewSpeedScale!=0||m_RotateSpeedScale!=0); }
   virtual float GetSlewSpeedScale() { return (m_SlewSpeedScale==0)?1.0:m_SlewSpeedScale; }
   virtual float GetRotateSpeedScale() { return (m_RotateSpeedScale==0)?1.0:m_RotateSpeedScale; }
   virtual BOOL IsIdleMotion() { return m_IsIdleMotion; }

private:
   sSkillConnectDesc m_Connect;
   char *m_ModelName;
   char *m_SchemaName;
   sMPlayerSkillData m_PlayerSkillData;
   float m_TimeToMax;
   BOOL m_Shoot;
   ePlayerTransition m_Transition;
   int m_MouseSpeed;
   int m_MouseZone;
   float m_SlewSpeedScale;
   float m_RotateSpeedScale;
   BOOL  m_IsIdleMotion;
};

sPlayerSkillFullDesc *g_pPlayerEditDesc=NULL;


class cMPlayerSkillFactory : public cMSkillFactory
{
public:
   virtual cMSkill *Create(const char *name, const int offset) \
      {   sPlayerSkillFullDesc *pDesc=&g_aPlayerSkillDesc[offset]; \
         if(g_aDefaultDesc[offset].controllerID==kControllerInvalid)
            return NULL;

          return new cMPlayerSkill((char *)name,pDesc);
      }

   virtual void BeginEdit(const char *name, const int offset) \
      { g_pPlayerEditDesc=&g_aPlayerSkillDesc[offset];}
   virtual void EndEdit(const char *name, const int offset) { g_pPlayerEditDesc=NULL; }

};

////////////////////////////////////////////////
////////////////////////////////////////////////
//
// DEBUGGING STUFF FOR PLAYER
//
////////////////////////////////////////////////
////////////////////////////////////////////////

// global editing routines for player skills

// ??   char *modelName; // XXX how to deal with this?

void PlayerEditSkillSetController(int controllerID)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->controllerID=controllerID;
   }
}

void PlayerEditSkillSetPowerupTime(float time)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->timeToMax=time;
      if(g_pPlayerEditDesc->skillData.flexDuration)
         g_pPlayerEditDesc->skillData.flexDuration=time;
   }
}

void PlayerEditSkillSetMaxFlex(int degrees)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.flexDegree=degrees;
   }
}

void PlayerEditSkillSetDuration(float time)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.duration=time;
   }
}

void PlayerEditSkillSetTimeScale(float time)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.timeScale=time;
   }
}

void PlayerEditSkillSetMouseSpeed(int speed)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->mouseSpeed=speed;
   }
}

void PlayerEditSkillSetMouseZone(int zone)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->mouseZone=zone;
   }
}

void PlayerEditSkillSetSlewSpeedScale(float scale)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->slewSpeedScale=scale;
   }
}

void PlayerEditSkillSetRotateSpeedScale(float scale)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->rotateSpeedScale=scale;
   }
}

void PlayerEditSkillSetStartPosOffset_X(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startPosOff.x=val;
   }
}

void PlayerEditSkillSetStartPosOffset_Y(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startPosOff.y=val;
   }
}

void PlayerEditSkillSetStartPosOffset_Z(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startPosOff.z=val;
   }
}

void PlayerEditSkillSetEndPosOffset_X(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endPosOff.x=val;
   }
}

void PlayerEditSkillSetEndPosOffset_Y(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endPosOff.y=val;
   }
}

void PlayerEditSkillSetEndPosOffset_Z(float val)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endPosOff.z=val;
   }
}

void PlayerEditSkillSetStartAngOffset_Vec(mxs_angvec *pVec)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startAngOff=*pVec;
   }
}

void PlayerEditSkillSetEndAngOffset_Vec(mxs_angvec *pVec)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endAngOff=*pVec;
   }
}

void PlayerEditSkillSetStartAngOffset_tX(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startAngOff.tx=degrees_to_fixang(angle);
   }
}

void PlayerEditSkillSetStartAngOffset_tY(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startAngOff.ty=degrees_to_fixang(angle);
   }
}

void PlayerEditSkillSetStartAngOffset_tZ(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.startAngOff.tz=degrees_to_fixang(angle);
   }
}

void PlayerEditSkillSetEndAngOffset_tX(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endAngOff.tx=degrees_to_fixang(angle);
   }
}

void PlayerEditSkillSetEndAngOffset_tY(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endAngOff.ty=degrees_to_fixang(angle);
   }
}

void PlayerEditSkillSetEndAngOffset_tZ(int angle)
{
   if(g_pPlayerEditDesc)
   {
      g_pPlayerEditDesc->skillData.endAngOff.tz=degrees_to_fixang(angle);
   }
}

////////////////////////////////////////////////
////////////////////////////////////////////////
//
// TWEAKING STUFF FOR LOCOMOTIONS
//
////////////////////////////////////////////////
////////////////////////////////////////////////

void LocoWalkTimeWarp(float warp)
{
   PlayerSetEditSkill("Walk");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();
}

void LocoWalkStretch(float stretch)
{
   PlayerSetEditSkill("Walk");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.stretch=stretch;
   }
   PlayerFinishEdit();
}

void LocoRunTimeWarp(float warp)
{
   PlayerSetEditSkill("Run");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();
}

void LocoRunStretch(float stretch)
{
   PlayerSetEditSkill("Run");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.stretch=stretch;
   }
   PlayerFinishEdit();
}

void LocoSearchTimeWarp(float warp)
{
   PlayerSetEditSkill("WalkSearching");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();
}

void LocoSearchStretch(float stretch)
{
   PlayerSetEditSkill("WalkSearching");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.stretch=stretch;
   }
   PlayerFinishEdit();
}

void LocoCombatTimeWarp(float warp)
{
   PlayerSetEditSkill("CombatAdvance");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();

   PlayerSetEditSkill("CombatBackup");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();

   PlayerSetEditSkill("CombatSSLeft");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();

   PlayerSetEditSkill("CombatSSRight");
   if(g_pLocoEditDesc)
   {
      g_pLocoEditDesc->skillData.timeWarp=warp;
   }
   PlayerFinishEdit();
}

EXTERN float g_CombatTimeWarp;
EXTERN float g_CombatStretch;

void CombatSwingTimeWarp(float warp)
{
   g_CombatTimeWarp=warp;
}

void CombatSwingStretch(float stretch)
{
   g_CombatStretch=stretch;
}


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// SKILL CREATION METHODS
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

cMSkillFactory g_DefaultFactory;
cMLocoSkillFactory g_LocoFactory;
cMSinglePlaySkillFactory g_SinglePlayFactory;
cMCombatSkillFactory g_CombatFactory;
cMPlayerSkillFactory g_PlayerSkillFactory;

cMSkillFactory *g_MSkillFactory[] = { &g_DefaultFactory, &g_LocoFactory, &g_SinglePlayFactory, &g_PlayerSkillFactory, &g_CombatFactory };

class cSkill
{
public:
   cSkill(const char *name, const eMotionCategory category, const int offset) \
      { m_Name=(char *)name; m_Offset=offset;
        m_pMotionSkill=g_MSkillFactory[category]->Create(name,offset);
        m_Category=category; }

   ~cSkill() { if(m_pMotionSkill) delete m_pMotionSkill; }

   cMSkill *GetMotionSkill() { return m_pMotionSkill; }

   // skill modification stuff
   void BeginEdit() 
      { g_MSkillFactory[m_Category]->BeginEdit(m_Name,m_Offset); }

   void EndEdit()
      { g_MSkillFactory[m_Category]->EndEdit(m_Name,m_Offset);
        ResetMotionSkill();
      }

   char    *GetName() { return m_Name; }
private:
   cMSkill *ResetMotionSkill() { 
      if(m_pMotionSkill)
         delete m_pMotionSkill;
      m_pMotionSkill=g_MSkillFactory[m_Category]->Create(m_Name,m_Offset); 
      return m_pMotionSkill; }

   char *m_Name;
   int m_Offset;
   cMSkill *m_pMotionSkill;
   eMotionCategory m_Category;
};

cSkill g_aSkill[] = {
// locomotion skills
   cSkill("Walk", kMCat_Locomote,0),
   cSkill("StandNormal", kMCat_Locomote,1),
   cSkill("StandSearching", kMCat_Locomote,2),
   cSkill("StandCombat", kMCat_Locomote,3),
   cSkill("WalkSearching", kMCat_Locomote,4),
   cSkill("Run", kMCat_Locomote,5),
   cSkill("CombatAdvance", kMCat_Locomote,6),
   cSkill("CombatBackup", kMCat_Locomote,7),
   cSkill("CombatSSLeft", kMCat_Locomote,8),
   cSkill("CombatSSRight", kMCat_Locomote,9),
// single play skills
   cSkill("SinglePlay", kMCat_SinglePlay,0),
// combat skills
   cSkill("SwordSwing", kMCat_Combat,0),
// player skills
   // sword
   cSkill("PlayerSwordReady", kMCat_Player, 0),
   cSkill("PlayerSwordBlock", kMCat_Player, 1),
   cSkill("PlayerSwordAtBlock", kMCat_Player, 2),
   cSkill("PlayerSwordWindShort", kMCat_Player, 3),
   cSkill("PlayerSwordAtWoundShort", kMCat_Player, 4),
   cSkill("PlayerSwordSwingShort", kMCat_Player, 5),
   cSkill("PlayerSwordWindMedium", kMCat_Player, 6),
   cSkill("PlayerSwordAtWoundMedium", kMCat_Player, 7),
   cSkill("PlayerSwordSwingMedium", kMCat_Player, 8),
   cSkill("PlayerSwordWindLong", kMCat_Player, 9),
   cSkill("PlayerSwordAtWoundLong", kMCat_Player, 10),
   cSkill("PlayerSwordSwingLong", kMCat_Player, 11),
   cSkill("PlayerSwordBegin", kMCat_Player, 12),
   cSkill("PlayerSwordEnd", kMCat_Player, 13),
   // empty handed
   cSkill("PlayerEmptyIdle", kMCat_Player, 14),
   // lock pick
   cSkill("PlayerLockPickIdle", kMCat_Player, 15),
   cSkill("PlayerLockPickRaise", kMCat_Player, 16),
   cSkill("PlayerLockPickFrob", kMCat_Player, 17),
   cSkill("PlayerLockPickLower", kMCat_Player, 18),
   // flexibow
   cSkill("FlexBowIdle", kMCat_Player, 19),
   cSkill("FlexBowAim", kMCat_Player, 20),
   cSkill("FlexBowDraw", kMCat_Player, 21),
   cSkill("FlexBowFire", kMCat_Player, 22),
   cSkill("FlexBowRelax", kMCat_Player, 23),
   cSkill("FlexBowBegin", kMCat_Player, 24),
   cSkill("FlexBowEnd", kMCat_Player, 25),
};

cSkillTable g_SkillTable;
EXTERN cSkillTable *g_pSkillTable=&g_SkillTable;

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
////
//// SKILL TABLE CLASS IMPLEMENTATION
////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

#ifndef SHIP

EXTERN void PlayerBowAlignArrow(); // from weapbow.cpp

Command SkillCommands[] =
{
   { "loco_walk_timewarp", FUNC_FLOAT, LocoWalkTimeWarp },
   { "loco_walk_stretch", FUNC_FLOAT, LocoWalkStretch },
   { "loco_run_timewarp", FUNC_FLOAT, LocoRunTimeWarp },
   { "loco_run_stretch", FUNC_FLOAT, LocoRunStretch },
   { "loco_search_timewarp", FUNC_FLOAT, LocoSearchTimeWarp },
   { "loco_search_stretch", FUNC_FLOAT, LocoSearchStretch },
   { "loco_combat_timewarp", FUNC_FLOAT, LocoCombatTimeWarp },
   { "combat_swing_timewarp", FUNC_FLOAT, CombatSwingTimeWarp },
   { "combat_swing_stretch", FUNC_FLOAT, CombatSwingStretch },
};

#define register_skill_commands() COMMANDS(SkillCommands,HK_GAME_MODE)

#else

#define register_skill_commands()

#endif

cSkillTable::cSkillTable()
{
   m_pSkills=g_aSkill;
   m_nSkills=sizeof(g_aSkill)/sizeof(g_aSkill[0]);
   m_pEditSkill=NULL;
}

cSkillTable::~cSkillTable()
{
}

BOOL cSkillTable::GetSelectDescBasics(eMotionCategory category, int *pNumValues, int *pMaxEntriesPerValue)
{
   switch(category)
   {
      case kMCat_Locomote:
         *pNumValues=kNumLocoValues;
         *pMaxEntriesPerValue=15;
         break;
      case kMCat_SinglePlay:
         *pNumValues=0; // no skill selection criteria, since only ever one skill
         *pMaxEntriesPerValue=15;
         break;
      case kMCat_Combat:
         *pNumValues=0; // no skill selection criteria, since only ever one skill
         *pMaxEntriesPerValue=15;
         break;
      case kMCat_Player: // this should never use keydesc
         *pNumValues=0;
         *pMaxEntriesPerValue=0;
         break;
      default:
         *pNumValues=0;
         *pMaxEntriesPerValue=15;
   }
   return TRUE;
}
   
// XXX TO DO: turn this into string hash table 
cMSkill *cSkillTable::GetMotionSkill(const tSkillID skill)
{
   int i;
   cSkill *pSkill;
 
   if(!skill)
      return NULL;
   pSkill=m_pSkills;
   for(i=0;i<m_nSkills;i++,pSkill++)
   {
      if(!strcmp(pSkill->GetName(),(char *)skill))
         return pSkill->GetMotionSkill();
   }
   return NULL;
}

// to allow designers to edit skills
void cSkillTable::SetEditSkill(const tSkillID skill)
{
   int i;
   cSkill *pSkill;
 
   if(!skill)
      return;
   pSkill=m_pSkills;
   for(i=0;i<m_nSkills;i++,pSkill++)
   {
      if(!strcmp(pSkill->GetName(),(char *)skill))
      {
         m_pEditSkill=pSkill;
         pSkill->BeginEdit();
      }
   }
}

void cSkillTable::FinishEdit()
{
   if(m_pEditSkill)
      m_pEditSkill->EndEdit();
   m_pEditSkill=NULL;
}

// XXX should really move these to cerebellum, but I'm being super-duper lame
// until I work out what the real skill table should be
void PlayerSetEditSkill(char *name)
{
   g_pSkillTable->SetEditSkill(name);
}

void PlayerFinishEdit()
{
   g_pSkillTable->FinishEdit();
}

void SkillTableInit()
{
   float val;

   register_skill_commands(); 
   // check for config variables
   if(config_get_float("loco_walk_timewarp",&val))
      LocoWalkTimeWarp(val);
   if(config_get_float("loco_walk_stretch",&val))
      LocoWalkStretch(val);
   if(config_get_float("loco_run_timewarp",&val))
      LocoRunTimeWarp(val);
   if(config_get_float("loco_run_stretch",&val))
      LocoRunStretch(val);
   if(config_get_float("loco_search_timewarp",&val))
      LocoSearchTimeWarp(val);
   if(config_get_float("loco_search_stretch",&val))
      LocoSearchStretch(val);
   if(config_get_float("loco_combat_timewarp",&val))
      LocoCombatTimeWarp(val);
   if(config_get_float("combat_swing_timewarp",&val))
      CombatSwingTimeWarp(val);
   if(config_get_float("combat_swing_stretch",&val))
      CombatSwingStretch(val);
}
// $Header: r:/t2repos/thief2/src/motion/skilltab.h,v 1.11 2000/01/31 09:50:01 adurant Exp $
#pragma once

#ifndef __SKILLTAB_H
#define __SKILLTAB_H

#include <skilltyp.h>

typedef struct sMLocoSelectDesc
{
   union {
      uchar pValues[5];
      struct {   
         uchar media;
         uchar facing;
         uchar speed;
         uchar kind;
         uchar phys;
      };   
   };
} sMLocoSelectDesc;

// this is used instead of skill selection desc for player, since 
// want player to always execute a pre-defined set of maneuvers when
// he start/ends/aborts using an item.  (Aborting using an item is what
// happens when player wants to switch items.)
// We don't need to match skills to best fit arbitrary control inputs.
typedef struct sSkillConnectDesc
{
   tSkillID nextDefault; // skill to perform next if no inputs received
   tSkillID nextIfStart; // skill to perform next if start action input received
   tSkillID nextIfFinish;// skill to perform next if finish action input received
   tSkillID nextIfAbort; // skill to perform next if abort action input received
} sSkillConnectDesc;

typedef enum ePlayerTransition
{
   kTrans_Immediate,
   kTrans_AtEnd,
   kTrans_Invalid=0xff,
} ePlayerTransition;

typedef struct sMPlayerSkillData
{
   char *motionName; // use name explicitly, since I don't think we want
                     // multi-mo-caps/descriptor flag stuff for player
   mxs_vector startPosOff;
   mxs_angvec startAngOff;
   mxs_vector endPosOff;
   mxs_angvec endAngOff;
   float      duration;   // for specifying fixed duration
   float      timeScale;  // for stretching motion captures proportionally
   float      flexDuration; // time to max flex
   int        flexDegree; // maximum flex, in degrees
} sMPlayerSkillData;



#ifdef __cplusplus ///////////////


#include <mskltype.h>
#include <mmanuver.h>
#include <mskltree.h>



typedef class cMSkill cMSkill;

EXTERN cManeuverFactory *g_aManeuverFactory[];

class cMSkill
{
public:
//   cMSkill(char *name, int controllerID);

   virtual ~cMSkill() {}

   virtual const sMSkillKeyDesc *GetKeyDesc() const { return &m_KeyDesc; }

   eMotionCategory GetCategory() const { return m_Category; }
//   int GetControllerID() const { return m_ControllerID; }
   cManeuverFactory *GetManeuverFactory() const { return g_aManeuverFactory[m_ControllerID]; }

   virtual char *GetName() { return m_Name; }

   virtual sMGaitSkillData *GetGaitSkillData() { return NULL; }

   // data that player maneuvers use to execute
   virtual sMPlayerSkillData *GetPlayerSkillData() { return NULL; }


   // XXX these really do not belong in cMSkill!
   // relevent for player skills only currently
   virtual sSkillConnectDesc *GetSkillConnectData() { return NULL; }
   virtual char *GetModelName() { return NULL; }
   virtual char *GetSchemaName() { return NULL; }
   virtual BOOL Shoot() { return FALSE; }
   virtual float GetPowerUpTime() { return 0; }
   virtual ePlayerTransition GetTransitionType() { return kTrans_Invalid; }
   virtual BOOL HasMouseParams() { return FALSE; }
   virtual int GetMouseSpeed() { return -1; }
   virtual int GetMouseZone() { return -1; }
   virtual BOOL HasSpeedScale() { return FALSE; }
   virtual float GetSlewSpeedScale() { return 1.0; }
   virtual float GetRotateSpeedScale() { return 1.0; }
   virtual BOOL IsIdleMotion() { return FALSE; }

protected:
   char *m_Name;
   eMotionCategory m_Category;
   int m_ControllerID;
   sMSkillKeyDesc m_KeyDesc;
};

class cSkillTable
{
public:
//
// Constructor/Destructor
//
   cSkillTable();
   ~cSkillTable();

   cMSkill *GetMotionSkill(const tSkillID skill);
   void SetEditSkill(const tSkillID skill);
   void FinishEdit();

   BOOL GetSelectDescBasics(eMotionCategory category, int *pNumValues, int *pMaxEntriesPerValue);

private:
   cSkill *m_pSkills;
   int m_nSkills;
   cSkill *m_pEditSkill;

// identifier -> handle hash table
// arrays of added skills
};

EXTERN cSkillTable *g_pSkillTable;

#endif /* for ifdef __cplusplus */

EXTERN void SkillTableInit();


#ifndef SHIP
/* editing funcs */

EXTERN void PlayerSetEditSkill(char *name);
EXTERN void PlayerFinishEdit();
EXTERN void PlayerEditSkillSetController(int controllerID);
EXTERN void PlayerEditSkillSetPowerupTime(float time);
EXTERN void PlayerEditSkillSetMaxFlex(int degrees);
EXTERN void PlayerEditSkillSetDuration(float time);
EXTERN void PlayerEditSkillSetTimeScale(float time);
EXTERN void PlayerEditSkillSetMouseSpeed(int speed);
EXTERN void PlayerEditSkillSetMouseZone(int zone);
EXTERN void PlayerEditSkillSetSlewSpeedScale(float scale);
EXTERN void PlayerEditSkillSetRotateSpeedScale(float scale);

EXTERN void PlayerEditSkillSetStartAngOffset_Vec(mxs_angvec *pVec);
EXTERN void PlayerEditSkillSetEndAngOffset_Vec(mxs_angvec *pVec);
EXTERN void PlayerEditSkillSetStartPosOffset_X(float val);
EXTERN void PlayerEditSkillSetStartPosOffset_Y(float val);
EXTERN void PlayerEditSkillSetStartPosOffset_Z(float val);
EXTERN void PlayerEditSkillSetEndPosOffset_X(float val);
EXTERN void PlayerEditSkillSetEndPosOffset_Y(float val);
EXTERN void PlayerEditSkillSetEndPosOffset_Z(float val);
EXTERN void PlayerEditSkillSetStartAngOffset_tX(int angle);
EXTERN void PlayerEditSkillSetStartAngOffset_tY(int angle);
EXTERN void PlayerEditSkillSetStartAngOffset_tZ(int angle);
EXTERN void PlayerEditSkillSetEndAngOffset_tX(int angle);
EXTERN void PlayerEditSkillSetEndAngOffset_tY(int angle);
EXTERN void PlayerEditSkillSetEndAngOffset_tZ(int angle);
#endif

#endif
// $Header: r:/t2repos/thief2/src/motion/skilltyp.h,v 1.3 2000/01/31 09:50:02 adurant Exp $
#pragma once

#ifndef __SKILLTYP_H
#define __SKILLTYP_H

#ifdef __cplusplus

typedef class cSkill cSkill;

#endif /* cplusplus */


typedef char *tSkillID;


#endif
// $Header: r:/t2repos/thief2/src/motion/cbllmapi.h,v 1.3 2000/01/31 09:50:03 adurant Exp $
// This module provides the abstract interface to a cerebellum, to be used
// by higher-level systems 
#pragma once

#ifndef __CBLLMAPI_H
#define __CBLLMAPI_H

#include <objtype.h>
#include <cbllmtyp.h>

#ifdef __cplusplus

class ICerebellum
{
public:
   virtual ~ICerebellum() {}
   virtual void PlayMotion(const char *name, eManeuverTransitionType trans=kMnvrTrans_Immediate, eManeuverPriority priority=kMnvrPri_Script) = 0;
   virtual void Update(ulong deltaTime) = 0;
};

EXTERN ICerebellum *CbllmGetFromObj(ObjID obj);

#endif // __cplusplus

#endif // __CBLLMAPI_H
// $Header: r:/t2repos/thief2/src/motion/cbllmtyp.h,v 1.4 2000/01/31 09:50:04 adurant Exp $
#pragma once

#ifndef __CBLLMTYP_H
#define __CBLLMTYP_H

typedef enum eManeuverTransitionType
{
   kMnvrTrans_Immediate,
   kMvnrTrans_AtEnd,
   kMnvrTrans_Invalid=0xff,
} eManeuverTransitionType;

// XXX NOTE: even idle motions actually preclude locomotions currently,
// since locomotive maneuvers are never explicity requested as such. KJ 1/98
typedef enum eManeuverPriority
{
   kMnvrPri_Death, // highest priority
   kMnvrPri_Script,
   kMnvrPri_Combat,
   kMnvrPri_Normal,
   kMnvrPri_Locomote,
   kMnvrPri_Idle,
   kMnvrPri_Invalid=0xff,
} eManeuverPriority;


#ifdef __cplusplus
   
typedef class ICerebellum ICerebellum;

#endif

#endif
// $Header: r:/t2repos/thief2/src/motion/creatapi.h,v 1.2 2000/01/31 09:50:05 adurant Exp $
// This used for getting class pointers for creatures
// Should only be included by cpp files that want to think of creature
// as mesh or motor
#pragma once

#ifndef __CREATAPI_H
#define __CREATAPI_H

#include <meshtype.h>
#include <motrtype.h>
#include <objtype.h>
// why include these?
#include <meshapi.h>
#include <motorapi.h>

IMesh *CreatureGetMeshInterface(const ObjID objID);
IMotor *CreatureGetMotorInterface(const ObjID objID);


#endif
// $Header: r:/t2repos/thief2/src/motion/creatext.h,v 1.23 2000/01/31 09:50:06 adurant Exp $
// external command file for creature module.
// used for calling from .c files
#pragma once

#ifndef __CREATEXT_H
#define __CREATEXT_H

#include <objtype.h>
#include <mms.h>
#include <matrixs.h>
#include <qt.h>
#include <stdlib.h>
#include <crettype.h>


// XXX can get rid of this if go through property system
typedef void (*fCreatureReadWrite) (void *buf, size_t elsize, size_t nelem);

#ifdef __cplusplus
EXTERN void CreaturesInit(int nCreatureTypes, const sCreatureDesc **ppCreatureDescs, const char **pCreatureTypeNames, const cCreatureFactory **ppCreatureFactories);

EXTERN cCreature *CreatureCreate(int type, const ObjID objID);
#endif

EXTERN void CreaturesClose();
EXTERN void CreaturesUpdate(const ulong timeDelta);

EXTERN void CreaturesRead(fCreatureReadWrite func, eObjPartition partition);
EXTERN void CreaturesWrite(fCreatureReadWrite func, eObjPartition partition);

EXTERN BOOL CreatureExists(const ObjID objID);
// returns FALSE if creature does not exist
EXTERN BOOL CreatureSelfPropelled(const ObjID objID);

EXTERN void CreatureFreeze(ObjID objID);

EXTERN void CreatureUnFreeze(ObjID objID);

EXTERN BOOL CreatureGetRenderHandle(const ObjID objID, long *pHandle);

EXTERN BOOL CreatureGetHeadTransform(ObjID objID, mxs_trans *pHead);

EXTERN void CreatureMeshJointPosCallback(const mms_model *m,const int jointID, mxs_trans *pTrans);
EXTERN void CreatureMeshStretchyJointCallback(const mms_model *m, const int jointID, mxs_trans *pTrans, quat *pRot);

EXTERN void CreatureAbortWeaponMotion(ObjID creature, ObjID weapon);

EXTERN void GetSubModelPos(ObjID objID, int submod, mxs_vector *pPos);

EXTERN void CreaturePrepareToDie(ObjID creature);
EXTERN void CreatureBeDead(ObjID creature);

enum eCMB_Styles
{
   kCMB_Normal,       // Frozen in place and shrunken
   kCMB_Efficient,    // Just frozen, and rotation controlled
   kCMB_WithFeet,     // Frozen with feet so it can stand
   kCMB_Posed,        // Simply ballistic, no other changes
   kCMB_Compressed,   // Physics all at objpos (so you can rotate around all axes)
   kCMB_Corpse        // One shrunked physics model at objpos, with rest axis
};

EXTERN BOOL CreatureMakeBallistic(ObjID creature, int style);
EXTERN void CreatureMakeNonBallistic(ObjID creature);

EXTERN void CreatureMakePhysical(ObjID creature);
EXTERN void CreatureMakeNonPhysical(ObjID creature);

EXTERN void CreatureSetFocusObj(ObjID creature, ObjID focusObj);
EXTERN void CreatureSetFocusLoc(ObjID creature, const mxs_vector *dir);
EXTERN void CreatureSetNoFocus(ObjID creature);

EXTERN void CreaturePosPropLock();
EXTERN void CreaturePosPropUnlock();

#endif
// $Header: r:/t2repos/thief2/src/motion/creatur_.h,v 1.12 2000/01/31 09:50:07 adurant Exp $
#pragma once

#ifndef __CREATUR__H
#define __CREATUR__H

#include <objtype.h>
#include <crettype.h>
#include <mp.h>

//// for property module
//

#define MAX_CREATURES 40

EXTERN ObjID chandle_obj_id(int idx); 
EXTERN sCreatureHandle* CreatureHandle(int idx); 
EXTERN int obj_chandle_id(ObjID obj); 
EXTERN int max_chandle_id(void);

//// for creature description modules (one per creature type)
//

// model can be placed at a fractional offset between two joints
struct sCrPhysModOffset
{
   int j1;
   int j2;
   float frac;
   float radius;
   BOOL isBallistic;
};

struct sCrPhysModOffsetTable
{
   int nPhysModels;
   sCrPhysModOffset *pPhysModels;
};

typedef struct sCreatureDesc
{
   int actorType;
   int nTorsos;
   int nLimbs;
   int nJoints;
   char *defLengthsName;
   int nPhysModels;
   float physRadius; 
   sCrPhysModOffset *pCrPhysModOffsets;
   int *pJointParents;
   int *pJointMap;
   int nFeet; // number of feet
   int *footJoints;
   torso *pDefTorsos; // default torso values (if defLengthsName not found)
   limb  *pDefLimbs; // default limb values (if defLengthsName not found)
   int nWeapons;
   sCrPhysModOffsetTable *pWeapPhysOffsets;
   BOOL  alwaysBallistic; // whether creature never self-propells via motions
   BOOL  canHeadTrack;
   BOOL hasSpecialPhysics; // do our physics models use the "special" flag?
} sCreatureDesc;

#endif

// $Header: r:/t2repos/thief2/src/motion/crettype.h,v 1.6 2000/01/31 09:50:08 adurant Exp $
#pragma once

#ifndef __CRETTYPE_H
#define __CRETTYPE_H

typedef struct sCreatureHandle sCreatureHandle;

typedef struct sCreatureAttachInfo sCreatureAttachInfo;

typedef struct sCrPhysModOffset sCrPhysModOffset;

typedef struct sCrPhysModOffsetTable sCrPhysModOffsetTable;

typedef struct sCreatureDesc sCreatureDesc;

#ifdef __cplusplus
typedef class cCreature cCreature;

typedef class cCreatureFactory cCreatureFactory;
#endif

#define kCrWeap_Invalid -1 // invalid weapon type
#define kCreatureTypeInvalid -1

#endif
// $Header: r:/t2repos/thief2/src/motion/mcoord.h,v 1.18 2000/01/31 09:50:09 adurant Exp $
#pragma once

#ifndef __MCOORD_H
#define __MCOORD_H

#include <mclntapi.h>
#include <mmresapi.h>
#include <motorapi.h>
#include <mskilset.h>
#include <mctype_.h>


// @TODO: rename this so "inter-maneuver state"-ish kind of thing.
// This should only be used as place for maneuvers to set things that
// next maneuver may want to know about.  Nobody else should set anything
// here.
struct sMcMotorState
{
   int   lastSchemaID;
   int   lastControllerID;
   ulong flags;
   float lastMotPercentCompleted;
};

class cMotionCoordinator: public IMotionCoordinator, public IMotorResolver
{
public:
   cMotionCoordinator();
   virtual ~cMotionCoordinator();

////////
// Motion Coordinator Functions
////////
   virtual void Load(ITagFile *pTagFile);
   virtual void Save(ITagFile *pTagFile);

   // these are tags to be applied to every motion and pose request
   virtual void SetPersistentTags(const cTagSet *pTags);

   virtual void SetMotor(IMotor *pMotor) { if(m_pMotor==pMotor) return; EndMotor(m_pMotor); StartMotor(pMotor); }
      
   virtual IMotionPlan *BuildPlan(const sMcMoveState *pStartState, const sMcMoveParams *pParams);


// this happens instantaneously, without blending or interrupting any
// currently executing maneuvers.  Coordinator chooses a motion
// (always that same one) that matches the tags, and poses the motor
// at the given fraction of the way through the motion.
   virtual void Pose(const cTagSet *pTags, float frac);

// 
   virtual eMCoordStatus GetStatus() const;

// Called by maneuver when it is completed
   virtual void NotifyAboutManeuverCompletion(IManeuver *pMnvr, sMcMoveState &endState);

// Called by outside systems when they move the creature/object without going through
// motion coordinator.
   virtual void NotifyAboutMotorStateChange();

// Called by outside systems when they delete the creature/motor without going through
// motion coordinator.
   virtual void NotifyAboutMotorDestruction();

// Used to set the maneuver to be executed when the currently executing one is
// completed.  This is necessary because maneuver completion may occur between
// client GetStatus calls.  If no next maneuver is set, the coordinator will
// do nothing once te current one is completed until a maneuver is set.
//
   virtual void SetNextManeuver(IManeuver *pMnvr);

// Used when the client wants to interrupt the currently executing maneuver with
// a new one, instead of making the new maneuver get executed when the current
// one is done.   
//
   virtual void SetCurrentManeuver(IManeuver *pMnvr);

// Used to get expected client state at the end of the currently executing 
// maneuver.  This state should be used for new plan building.
//
   virtual const sMcMoveState *GetNextEndState() const;

// Set callback for coordinator to use when motor it is controlling gets
// moved around by other systems (editor, scripts etc).
   virtual void SetMotorStateChangeCallback(fMcMotorStateChangeCallback callback, void *context)
      { m_MotorStateChangeCallback=callback; m_MotorStateChangeCallbackContext=context; }

// Set callback for coordinator to use when it completes a maneuver
   virtual void SetManeuverCompletionCallback(fMcManeuverCompletionCallback callback, void *context)
      { m_ManeuverCompletionCallback=callback; m_ManeuverCompletionCallbackContext=context; }


////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect();
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel);
   virtual void NotifyAboutBeingStuck();
   virtual void NotifyAboutMotionAbortRequest();

//
// Motion status notification functions
//
   virtual void NotifyAboutFrameUpdateBegin();
   virtual void NotifyAboutFrameUpdateEnd();
   virtual void NotifyAboutFrameFlags(const int);
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);
   // this only lasts for one frame
   virtual void NotifyThatCanInterrupt();

////////
// Maneuver-called functions
////////
   // @TODO: come up with better name for this
   // set state by getting ptr and futzing with it
   virtual sMcMotorState *GetInterMnvrState() { return &m_MotorState; }
   virtual void ClearInterMnvrState()
      { m_MotorState.lastSchemaID=-1;
        m_MotorState.lastControllerID=-1; 
        m_MotorState.flags=NULL;
        m_MotorState.lastMotPercentCompleted=0;
      }

private:
   void EndMotor(IMotor *pMotor);
   void StartMotor(IMotor *pMotor);
   BOOL InMotorFrame() { return m_InMotorFrame; }
   void StartNextManeuver();

   IMotor *m_pMotor;
   cMSkillSet m_SkillSet; 
   IManeuver *m_pCurrentManeuver;
   IManeuver *m_pNextManeuver;
   sMcMotorState m_MotorState;
   sMcMoveState m_NextMoveState;
   fMcMotorStateChangeCallback m_MotorStateChangeCallback;
   void *m_MotorStateChangeCallbackContext;
   fMcManeuverCompletionCallback m_ManeuverCompletionCallback;
   void *m_ManeuverCompletionCallbackContext;
   BOOL m_InMotorFrame;
   BOOL m_ManeuverCompleted;
   BOOL m_CanInterrupt;
// need to add state stuff for maneuvers
};

#endif
// $Header: r:/t2repos/thief2/src/motion/mvrsngle.cpp,v 1.22 1999/08/05 17:10:46 Justin Exp $

#include <config.h>
#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <motdesc.h>
#include <mclntapi.h>
#include <motschem.h>
#include <motmngr.h>
#include <ghostmvr.h>

      // must be last header
#include <dbmem.h>

class cSingleManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      

   virtual IManeuver *LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile);
};

typedef struct
{
   BOOL m_DoRotate;
   mxs_angvec m_Direction;
   int m_MotionNum;
   float m_Duration;
   float m_TimeWarp;
   float m_Distance;
   float m_Stretch;
} sSingleData;

class cSingleManeuver: public cManeuver, public sSingleData
{
public:
   cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema);
   cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const char *name);
   cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const mxs_angvec& direction);
   cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const int motionNum, const int dummy);
   cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success);
   ~cSingleManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();
   virtual void Save(ITagFile *pTagFile) { 
      ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
      ITagFile_Move(pTagFile,(char *)((sSingleData*)this),sizeof(*((sSingleData*)this)));
   }

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel); }
   virtual void NotifyAboutBeingStuck() { m_pMotor->StopMotion(m_MotionNum); }

#if 0
//
// Motion status notification functions
//
   virtual void NotifyAboutFrameUpdateBegin(const ObjID);
   virtual void NotifyAboutFrameUpdateEnd(const ObjID);
   virtual void NotifyAboutFrameFlags(const ObjID, const int);
#endif

   virtual void NotifyAboutFrameFlags(const int);
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);

private:
};

cSingleManeuverFactory g_SingleManeuverFactory;
EXTERN cManeuverFactory *g_pSingleManeuverFactory=&g_SingleManeuverFactory;


cMotionPlan *cSingleManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cSingleManeuver *pMnvr;

   if(params.mask&kMotParmFlag_Name)
   {
      pMnvr = new cSingleManeuver(pMotor, pCoord, (char *)params.name);
   } else if(params.mask&kMotParmFlag_MotNum)
   {
      pMnvr = new cSingleManeuver(pMotor, pCoord, params.motionNum,-1);
   } else
   {
      if(params.mask&kMotParmFlag_Facing)
      {
         pMnvr = new cSingleManeuver(pMotor, pCoord, pSchema, params.facing);
      } else
      {
         pMnvr = new cSingleManeuver(pMotor, pCoord, pSchema);
      }
   }
   AssertMsg(pMnvr,"could not alloc maneuver");

   pMnvr->m_Duration=-1.0;
   pMnvr->m_TimeWarp=1.0;
   pMnvr->m_Distance=-1.0;
   pMnvr->m_Stretch=1.0;
   if(!pSchema->GetDuration(&pMnvr->m_Duration))
      pSchema->GetTimeWarp(&pMnvr->m_TimeWarp);
   if(!pSchema->GetDistance(&pMnvr->m_Distance))
      pSchema->GetStretch(&pMnvr->m_Stretch);

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

IManeuver *cSingleManeuverFactory::LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile)
{
   BOOL success;
   cSingleManeuver *pMnvr=new cSingleManeuver(pMotor,pCoord,pTagFile,&success);

   if(!success)
   {
      delete pMnvr;
      return NULL;
   }
   return pMnvr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// Single MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define MAX_INTERESTED_MOTIONS 10

cSingleManeuver::cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;

   m_MotionNum=-1;
   if (IsRemoteGhost(pMotor->GetObjID()))
   {
      m_MotionNum = GetGhostMotionNumber();

#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("rSngle: Remote ghost %d playing schema %d, motion %d\n", 
                 pMotor->GetObjID(), pSchema->GetSchemaID(), m_MotionNum);
      }
#endif
   }
   if (m_MotionNum==-1)  // not a remoteghost, or remghost didnt want to deal 
   {
      Assert_(pSchema);
      if(!pSchema->GetRandomMotion(&m_MotionNum))
      {
         Warning(("rSngle: CombatManeuver(Liar!): unable to find motion\n"));
         m_MotionNum=-1;
      }

      if (IsLocalGhost(pMotor->GetObjID()))
      {
#ifndef SHIP
         if (config_is_defined("ghost_motion_spew"))
         {
            mprintf("rSngle: Local ghost %d informing remote about schema %d, motion %d\n", 
                    pMotor->GetObjID(), pSchema->GetSchemaID(), m_MotionNum);
         }
#endif
         // @TODO: CAC: tell remote ghost that we're playing a motion
         GhostSendMoCap(pMotor->GetObjID(),pSchema->GetSchemaID(),m_MotionNum,FALSE);
      }
   }
}

cSingleManeuver::cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const char *name)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;

   if (IsRemoteGhost(pMotor->GetObjID()))
      Warning(("illegal cSingleManeuver constructor for remote ghost %d\n", pMotor->GetObjID()));

   m_MotionNum=MotDescNameGetNum((char *)name);
   if(m_MotionNum==-1)
   {
      Warning(("SingleManeuver: unable to find motion named %s\n",(char *)name));
   }
}

cSingleManeuver::cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const int motionNum, const int dummy)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;

   m_MotionNum=motionNum;
   
   if(m_MotionNum==-1)
      Warning(("SingleManeuver: unable to find motion\n"));
}

cSingleManeuver::cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const mxs_angvec& direction)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_DoRotate=TRUE;
   m_Direction=direction;

   Assert_(pSchema);
   if(!pSchema->GetRandomMotion(&m_MotionNum))
   {
      Warning(("CombatManeuver: unable to find motion\n"));
      m_MotionNum=-1;
   }
}

cSingleManeuver::cSingleManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success)
{
   *success=TRUE;
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sSingleData*)this),sizeof(*((sSingleData*)this)));
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   Assert_(m_pMotor);
   if(m_pMotor&&m_MotionNum!=-1)
   {
      m_MotionNum=m_pMotor->SwizzleMotion(m_MotionNum);   
      if(m_MotionNum==-1) // couldn't swizzle
         *success=FALSE;
   }
   // check that motor is in same state we think we are
   if(m_pMotor->GetCurrentMotion()!=m_MotionNum)   // out of synch!
   {
      Warning(("cSingleManuever: cannot load maneuver because creature is out of synch\n"));
      m_MotionNum=-1;
      *success=FALSE;
   }
}

cSingleManeuver::~cSingleManeuver()
{
   // Stop motion if one is playing

   if(m_MotionNum>=0 && m_pMotor)
   {
      m_pMotor->StopMotion(m_MotionNum);

      // notify scripting system
      MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionEnd,NULL);
   }
}

void cSingleManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for single maneuver");
}

void cSingleManeuver::Execute()
{
   if(m_DoRotate)
   {
      // NOTE: this assumes that direction of action in motion capture
      // is along the x-axis

      m_pMotor->SetOrientation(&m_Direction);
   }
   if(m_MotionNum<0)
   {
      sMcMoveState state;
      // XXX need to rework this end state stuff

      AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   } else
   {
      if(m_pMotor)
      {
         mps_motion_param param;

         param.flags=0;

         if(m_Duration>=0)
         {
            param.flags|=MP_FIXED_DURATION;
            param.fixed_duration=m_Duration;
         } else if(m_TimeWarp!=1.0)
         {
            param.flags|=MP_DURATION_SCALE;
            param.duration_scalar=m_TimeWarp;
         }
         if(m_Distance>=0)
         {
            mxs_vector xlat;
            mxs_real mag;

            g_pMotionSet->GetTranslation(m_MotionNum,&xlat);
            mag=mx_mag_vec(&xlat);
            if(mag>0.1)
            {
               param.flags|=MP_STRETCH;
               param.stretch=m_Distance/mag;
            }
         } else if(m_Stretch!=1.0)
         {
            param.flags|=MP_STRETCH;
            param.stretch=m_Stretch;
         }
         m_pMotor->StartMotionWithParam(m_MotionNum,&param);
         // notify scripting system
         MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionStart,NULL);
      }
   }
}

void cSingleManeuver::NotifyAboutFrameFlags(const int flags)
{
   if(m_pMotor)
   {
      MvrProcessStandardFlags(m_pMotor,m_pCoord,flags);
      MvrSendMotionMessage(m_pMotor->GetObjID(), m_MotionNum,kMotionFlagReached,flags);
   }
}

// XXX need to rework this end state stuff
void cSingleManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");

   // notify scripting system
   if(m_pMotor)
      MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionEnd,NULL);

   m_MotionNum=-1;
   m_pCoord->NotifyAboutManeuverCompletion(this,state);
}
// $Header: r:/t2repos/thief2/src/motion/mvrtport.cpp,v 1.2 1997/12/19 15:28:33 TOML Exp $

#include <mmanuver.h>
#include <mcoord.h>

      // must be last header
#include <dbmem.h>

class cTeleportManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const tMSkillHandle skill,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      
};

class cTeleportManeuver: public cManeuver
{
public:
   cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_vector& position);
   cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_vector& position, const mxs_angvec& facing);
   cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_angvec& facing);
   virtual ~cTeleportManeuver() {}

   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);
   virtual void Execute();
private:
   mxs_vector m_EndPos;
   mxs_angvec m_EndFac;
};

cTeleportManeuverFactory g_TeleportManeuverFactory;
EXTERN cManeuverFactory *g_pTeleportManeuverFactory=&g_TeleportManeuverFactory;


cMotionPlan *cTeleportManeuverFactory::CreatePlan(const tMSkillHandle skill,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cTeleportManeuver *pMnvr;

   if(params.mask&kMotParmFlag_Facing)
      if(params.mask&kMotParmFlag_Position)
         pMnvr = new cTeleportManeuver(pMotor, pCoord, params.position, params.facing);
      else
         pMnvr = new cTeleportManeuver(pMotor, pCoord, params.facing);
   else if(params.mask&kMotParmFlag_Facing)
      pMnvr = new cTeleportManeuver(pMotor, pCoord, params.position);
   else
      return NULL;

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// TELEPORT MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

cTeleportManeuver::cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_vector& position, const mxs_angvec& facing)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_EndPos=position;
   m_EndFac=facing;
}

cTeleportManeuver::cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_vector& position)
{
   mxs_vector opos;
   mxs_angvec ofac;

   pMotor->GetTransform(&opos,&ofac);

   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_EndPos=position;
   m_EndFac=ofac;
}

cTeleportManeuver::cTeleportManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_angvec& facing)
{
   mxs_vector opos;
   mxs_angvec ofac;

   pMotor->GetTransform(&opos,&ofac);

   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_EndPos=opos;
   m_EndFac=facing;
}

void cTeleportManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   moveState.position=m_EndPos;
   moveState.facing=m_EndFac;
   moveState.speed=0;
   moveState.direction=m_EndFac;
}

void cTeleportManeuver::Execute()
{
   sMcMoveState moveState;

   m_pMotor->SetTransform(&m_EndPos,&m_EndFac);
   GetExpectedEndMoveState(moveState);
   m_pCoord->NotifyAboutManeuverCompletion(this,moveState);
}
// $Header: r:/t2repos/thief2/src/motion/mvrutils.cpp,v 1.37 2000/03/06 09:42:29 adurant Exp $

#include <matrixs.h>
#include <portal.h>
#include <mvrutils.h>
#include <rand.h>
#include <stdlib.h>
#include <lg.h>
#include <motdmnge.h>
#include <wr.h> // for CellFromLoc
#include <motdesc.h>
#include <cfgdbg.h>
#include <motmngr.h>
#include <schema.h>
#include <property.h>
#include <propbase.h>
#include <textarch.h>
#include <prcniter.h>

#include <creature.h>
#include <creatext.h>

#include <phcore.h>
#include <phmods.h>
#include <phmod.h>
#include <phmodobb.h>
#include <phcontct.h>
#include <physcast.h>
#include <phoprop.h>
#include <aipthobb.h>
#include <aiground.h>

#include <mvrflags.h> // for footfall flags
#include <sndgen.h>   // for footfalls

// script stuff
#include <comtools.h>
#include <appagg.h>
#include <scrptapi.h> 
#include <scrptbas.h>
#include <scrptsrv.h>
#include <bodscrpt.h>
#include <puppet.h>

// must be last header
#include <dbmem.h>


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
/// PLAN BUILDING UTILITIES
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

inline BOOL MvrIsValidMotion(const int motionNum)
{
   return (motionNum>=0&&motionNum<mp_num_motions);
}

inline void MvrValidateMotion(const int motionNum)
{
   AssertMsg1(MvrIsValidMotion(motionNum),"motion num %d invalid",motionNum);
}

EXTERN mxs_ang MvrGetHeadingAngle(mxs_vector *v)
{
   mxs_ang angle;

   angle=mx_rad2ang(acos(v->x));
   if(angle>0)
   {
      if(v->y<0) // -pi/2 < actual angle < 0
         angle=-angle;
   } else if (v->y>0) // -pi < actual angle <= -pi/2 
      angle=-angle;
   return angle;   
}

////////////////////////////////////////////////////////////////////////

cDynArray<ObjID> standableObjectList;

void InitGroundHeightObjects()
{
   sPropertyObjIter iter;
   ObjID objID;
   int i;

   standableObjectList.SetSize(0);

   // standable objects include pressure plates
   g_pPhysPPlateProp->IterStart(&iter);
   while (g_pPhysPPlateProp->IterNext(&iter, &objID))
   {
      if (OBJ_IS_CONCRETE(objID))
         standableObjectList.Append(objID);
   }
   g_pPhysPPlateProp->IterStop(&iter);

   // and things marked as AI pathable
   cConcreteIter citer(g_pObjPathableProperty);

   citer.Start();
   while (citer.Next(&objID))
   {
      BOOL found = FALSE;

      for (i=0; i<standableObjectList.Size(); i++)
      {
         if (standableObjectList[i] == objID)
         {
            found = TRUE;
            break;
         }
      }
      if (!found)
         standableObjectList.Append(objID);
   }
   citer.Stop();
}

void TermGroundHeightObjects()
{
   standableObjectList.SetSize(0);
}

BOOL MvrFindGroundHeight(ObjID obj, Location *loc, mxs_real *pHeight, ObjID *pGroundObj)
{
   Location toLoc;
   Location hitLoc;
   ObjID    hitObj;
   BOOL     retval = TRUE;

   MakeLocation(&toLoc, loc->vec.x, loc->vec.y, loc->vec.z - 100.0);

   PhysRaycastSetObjlist(standableObjectList, standableObjectList.Size());

   int physcast_val;

   if ((physcast_val = PhysRaycast(*loc, toLoc, &hitLoc, &hitObj, 0.0, kCollideOBB | kCollideTerrain)) == kCollideNone)
   {
      toLoc.vec.z -= 100.0;

      if (PhysRaycast(*loc, toLoc, &hitLoc, &hitObj, 0.0, kCollideOBB | kCollideTerrain) == kCollideNone)
      {
         Warning(("Unable to find ground under %g %g %g\n", loc->vec.x, loc->vec.y, loc->vec.z));

         *pGroundObj = OBJ_NULL;
         *pHeight = 0;
         retval = FALSE;
      }
   }

   if (retval)
   {
      *pGroundObj = hitObj;
      *pHeight=hitLoc.vec.z;
      
      *pHeight = AIAdjustMvrGroundHeight(obj, loc, *pHeight, *pGroundObj);
   }

   PhysRaycastClearObjlist();

   return retval;
}

////////////////////////////////////////////////////////////////////////

void MvrSetStandingObj(ObjID standingObj, ObjID supportObj)
{
   cCreature *pCreature = CreatureFromObj(standingObj);

   // Create contact with our ground object
   if ((standingObj != OBJ_NULL) && (standingObj != supportObj) && !IsTextureObj(supportObj))
   {
      cPhysModel *pModel1 = g_PhysModels.Get(standingObj);
      cPhysModel *pModel2 = g_PhysModels.Get(supportObj);

      // Inform the creature we're standing on it
      pCreature->SetStandingObj(supportObj);

      if (pModel1 != NULL)
      {
         DestroyAllObjectContacts(standingObj, 0, pModel1);
         
         if (pModel2 != NULL)
         {
            int submod = 0;
            int i;

            if (pModel2->GetType(0) == kPMT_OBB)
            {
               mxs_vector normal_list[6];

               // Find the "top" surface of the OBB
               ((cPhysOBBModel *)pModel2)->GetNormals(normal_list);

               mxs_real best_z = -1.0;
               for (i=0; i<6; i++)
               {
                  if (normal_list[i].z > best_z)
                  {
                     submod = i;
                     best_z = normal_list[i].z;
                  }
               }
            }
            CreateObjectContact(standingObj, 0, pModel1, supportObj, submod, pModel2);
            pModel2->SetSleep(FALSE);
         }
      }
   }
   else
      pCreature->SetStandingObj(OBJ_NULL);
}

////////////////////////////////////////

void MvrSetStandingOffset(ObjID standingObj, ObjID supportObj, mxs_vector *pExpectedEndPos)
{
   if (supportObj == OBJ_NULL)
      return;

   cCreature *pCreature = CreatureFromObj(standingObj);

   mxs_vector offset;
   mx_sub_vec(&offset, pExpectedEndPos, &ObjPosGet(supportObj)->loc.vec);

   pCreature->SetStandingOffset(offset);
}

////////////////////////////////////////////////////////////////////////

void MvrSetTerrStandingOffset(ObjID standingObj, mxs_vector *pOffset)
{
   cCreature *pCreature = CreatureFromObj(standingObj);
   pCreature->SetStandingOffset(*pOffset);
}

////////////////////////////////////////////////////////////////////////

#ifdef OLD_WAY
int MvrRandomIntInRange(int low, int high)
{
   int r;

   r = low + (1 + high - low) * Rand() / (RAND_MAX+1);
   if (r > high) r = high;
   return r;
}
#endif
#define MvrRandomIntInRange RandRange

////////////////////////////////////////////////////////////////////////

// XXX TO DO: move this to multiped library
#define mp_motion_get_info(motionNum) &((mp_motion_list+(motionNum))->info)

EXTERN BOOL mp_get_component_id(int *compID, int motionNum, int jointID)
{
	mps_motion * m = mp_motion_list + motionNum;
	mps_comp_motion * cm = m->components;
   int i;

   AssertMsg(m->info.type==MT_CAPTURE,"mp_get_component_id only valid with captured motions");
   for(i=0;i<m->num_components;i++,cm++)
   {
      if(cm->type==CM_ROT&&cm->joint_id==jointID)
      {
         *compID=i;
         return TRUE;
      }
   } 
   return FALSE;
}

// XXX HACK HACK HACK HACK
EXTERN void MotCompRotCallback(mps_motion_info *mi,mps_comp_motion *cm,int frame, quat *data);


EXTERN void mp_get_rot_at_frame(quat *rot, int motionNum, int frame, int compID)
{
	mps_motion * m = mp_motion_list + motionNum;

   AssertMsg(m->info.type==MT_CAPTURE,"mp_get_rot_at_frame only valid with captured motions");
   AssertMsg((m->components+compID)->type==CM_ROT,"mp_get_rot_at_frame: component %d is not a rotation");

//   mp_capture_component_rot_func(&m->info,m->components+compID,frame,rot);
   MotCompRotCallback(&m->info,m->components+compID,frame,rot);
}

// this only works with valid motion-captured motions, not virtual ones.
// this takes into account how the motion will need to translate differently 
// depending on motor size vs that of the motion capture actor.
BOOL MvrGetRawMovement(const IMotor *pMotor, const int motionNum, sMotionPhys &phys)
{
   if(!MvrIsValidMotion(motionNum))
      return FALSE;

   AssertMsg(g_pMotionSet,"No motion set, cannot compute motion movement");

   phys.endDir=g_pMotionSet->GetEndHeading(motionNum);
   g_pMotionSet->GetTranslation(motionNum,&phys.xlat);
   // take into account motion scale -- Kate 1/99
   mx_scaleeq_vec(&phys.xlat,pMotor->GetMotionScale());
   phys.distance=mx_mag_vec(&phys.xlat);
   phys.duration=g_pMotionSet->GetDuration(motionNum);

   return MvrGetEndButtHeight(pMotor, motionNum, &phys.buttZOffset);
}

BOOL MvrGetEndButtHeight(const IMotor *pMotor, int motionNum, float *pHeight)
{
// @HACK: don't want this really.  Want end offset computed by motion processor
// and stored with motion

   *pHeight=pMotor->GetDefaultButtZOffset();
   
   return TRUE;
}

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
/// MOTOR RESOLVING UTILITIES
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

#define NUDGE_FAC 0.001
#define MAX_Z_NUDGE 0.1

// assume that first vector on ovel is main phys model.  nvel gets set to 
// what new velocity for this model should be.
void MvrCalcSlidingCollisionResponse(const mxs_vector *pForces, const int nForces, \
const mxs_vector *ovel, mxs_vector *nvel, ulong flags)
{
   float dot;
   int i;
   mxs_vector newdir, off;
   float len,mindot;

#if 0
   mprintf("Force List:\n");
   for (i=0; i<nForces; i++)
      mprintf(" [%d] %g %g %g\n", i, pForces[i].x, pForces[i].y, pForces[i].z);
   mprintf("Orig velocity: %g %g %g\n", ovel->x, ovel->y, ovel->z);
#endif

   // average wall normals affecting submodels 
   // hopefully just linear averaging will be okay
   mx_zero_vec(&newdir);
   for(i=0;i<nForces;i++)
      mx_addeq_vec(&newdir,(mxs_vector *)&pForces[i]);

   if(flags&kMvrUCF_MaintainSpeed)
   {
      if ((fabs(newdir.x) > 0.1) || (fabs(newdir.y) > 0.1))
         newdir.z = 0;
   }

   // this is slow but hopefully infrequent
   // set new facing
   len=mx_mag_vec(&newdir);
   // this is slow but hopefully infrequent
   // set new facing
   if(len>0.1)
      mx_scaleeq_vec(&newdir,1.0/len);
   else
      mx_zero_vec(&newdir);

#if 0
   mprintf("newdir (avg surf normal) = %g %g %g\n", newdir.x, newdir.y, newdir.z);
#endif

   // get rid of component of bip velocity perp to wall if heading towards wall,
   // want to find most negative dot product for velocities of all phys models,
   // since that model was moving furthest in bad direction.
   mindot=99999.0;
   for(i=0;i<nForces;i++)
   {
      dot=mx_dot_vec(&ovel[i],&newdir);
      if(dot<mindot)
         mindot=dot;
   }
   Assert_(mindot!=99999.0);
   ConfigSpew("BipedForceSpew",("terrain norm %g, %g, %g,  dot %g\n",newdir.x,newdir.y,newdir.z,dot));

   if(mindot<0)
   {
      mx_scale_vec(&off,&newdir,-mindot);
   } else
   {
      ConfigSpew("BipedForceSpew",("collided moving AWAY from wall\n"));
      mx_scale_vec(&off,&newdir,mindot);
   }

   // calc translation  
   mx_add_vec(nvel,(mxs_vector *)ovel,&off); // new vel vector

   if(flags&kMvrUCF_MaintainSpeed)
   {
      len=mx_mag_vec(nvel);

      // scale new velocity to match magnitude of old.
      // XXX NOTE: this caused wacky behavior previously when colliding with
      // sloped walls, and is not a physically correct solution.
      mxs_vector maybe_new_vel;

      if(len>0.05)
         mx_scale_vec(&maybe_new_vel,nvel,mx_mag_vec(ovel)/len);

      // Only accept the slide rescale if the z velocity doesn't increase dramatically
      if (fabs(maybe_new_vel.z) < (fabs(nvel->z) * 3))
         mx_copy_vec(nvel, &maybe_new_vel);
   }

#if 0
   mprintf("new velocity = %g %g %g\n", nvel->x, nvel->y, nvel->z);
#endif

   // add in nudge factor to nudge away from wall
   mx_scale_vec(&off,&newdir,NUDGE_FAC);
   // don't nudge up off floor, however, or not by much
   if(off.z>MAX_Z_NUDGE)
      off.z=MAX_Z_NUDGE;
   mx_addeq_vec(nvel,&off);
}

////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
/// EXTERNAL SYSTEM INTERACTION UTILITIES
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

EXTERN void FootfallCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
   const sMotorState *pState=pMotor->GetMotorState();

   if (flags&MF_LEFT_FOOTFALL)
   {
      mxs_vector pos;
      mxs_angvec rot;

      pMotor->GetTransform(&pos,&rot);

      pMotor->SetContact(pState->contactFlags|LEFT_FOOT);
      FootfallSound(pMotor->GetObjID(), &pos);
   }
   if (flags&MF_RIGHT_FOOTFALL)
   {
      mxs_vector pos;
      mxs_angvec rot;

      pMotor->GetTransform(&pos,&rot);

      pMotor->SetContact(pState->contactFlags|RIGHT_FOOT);
      FootfallSound(pMotor->GetObjID(), &pos);
   }
   if (flags&MF_LEFT_FOOTUP)
      pMotor->SetContact(pState->contactFlags&~LEFT_FOOT);
   if (flags&MF_RIGHT_FOOTUP)
      pMotor->SetContact(pState->contactFlags&~RIGHT_FOOT);
}

EXTERN void MvrInterruptCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
   if(!pCoord)
      return;
   if(flags&MF_CAN_INTERRUPT)
      pCoord->NotifyThatCanInterrupt();
}

EXTERN void MvrBodyCollapseCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
   Label collapse_schema = {"collapse_player"};

   SchemaPlayLoc(&collapse_schema, &ObjPosGet(objID)->loc.vec);
}

EXTERN void MvrHitCorpseCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
   Label collapse_schema = {"hit_corpse"};

   SchemaPlayLoc(&collapse_schema, &ObjPosGet(objID)->loc.vec);
}

EXTERN void MvrWeaponSwingCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
      mxs_vector pos;
      mxs_angvec rot;

      pMotor->GetTransform(&pos,&rot);
      WeaponSwingSound(pMotor->GetObjID(), &pos);
}

EXTERN void MvrWeaponChargeCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
      mxs_vector pos;
      mxs_angvec rot;

      pMotor->GetTransform(&pos,&rot);
      WeaponChargeSound(pMotor->GetObjID(), &pos);
}

EXTERN void MvrSearchCallback(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags)
{
      mxs_vector pos;
      mxs_angvec rot;

      pMotor->GetTransform(&pos,&rot);
      SearchSound(pMotor->GetObjID(), &pos);
}

///////////////////////////////////////////////////

EXTERN void MvrProcessStandardFlags(IMotor *pMotor,cMotionCoordinator *pCoord, const int flags)
{
   if(!pMotor)
      return;

   NotifyMotionFlags(pMotor->GetObjID(), flags, pMotor, pCoord);
}

// @TODO: get rid of this once puppet's go away, since start/end provided by
// ai script ability, and flag triggers will be installed as callbacks on obj
// by concerned party (though nobody looks at them yet).
EXTERN void MvrSendMotionMessage(ObjID obj, int motionNum, eMotionStatus whatHappened, ulong flags)
{
   if(!ObjIsPuppet(obj))
      return;

   sBodyMsg::eBodyAction actionType;

   switch(whatHappened)
   {
      case kMotionStart:
         actionType=sBodyMsg::kMotionStart;
         break;
      case kMotionEnd:
         actionType=sBodyMsg::kMotionEnd;
         break;
      case kMotionFlagReached:
         actionType=sBodyMsg::kMotionFlagReached;
         break;
      default:
         AssertMsg1(FALSE,"Unknown motion message type %d for script message\n",whatHappened);
         break;
   }
   AutoAppIPtr(ScriptMan);

   char *name;

   if(NULL!=(name=MotDescGetName(motionNum))) // scriptman can't handle NULL strings KJ 1/98
   {
      sBodyMsg bodyMessage(obj, actionType, name, flags);
      pScriptMan->SendMessage(&bodyMessage);
   }
}

void MvrUtilsRegisterDefaultObjFlags(ObjID obj)
{
   AddMotionFlagListener(obj, MF_FEET_FLAGS, FootfallCallback);
   AddMotionFlagListener(obj, MF_CAN_INTERRUPT, MvrInterruptCallback);

   // This might want to get set upon death throes trigger (E3 hack for now)
   AddMotionFlagListener(obj, MF_TRIGGER4, MvrBodyCollapseCallback);
   AddMotionFlagListener(obj, MF_TRIGGER5, MvrHitCorpseCallback);

   // For creature weapon powerup sounds
   AddMotionFlagListener(obj, MF_TRIGGER6, MvrWeaponChargeCallback);

   // For creature searching panning sounds (Thief 2 robots, for instance)
   AddMotionFlagListener(obj, MF_TRIGGER7, MvrSearchCallback);

   // For creature melee weapon swinging sounds
   AddMotionFlagListener(obj, MF_TRIGGER8, MvrWeaponSwingCallback);

}

void MvrUtilsUnRegisterDefaultObjFlags(ObjID obj)
{
   RemoveMotionFlagListener(obj, MF_FEET_FLAGS);
   RemoveMotionFlagListener(obj, MF_CAN_INTERRUPT);

   // This might want to get unset upon death throes trigger (E3 hack for now)
   RemoveMotionFlagListener(obj, MF_TRIGGER4);
   RemoveMotionFlagListener(obj, MF_TRIGGER5);
   
   RemoveMotionFlagListener(obj, MF_TRIGGER6);      
   RemoveMotionFlagListener(obj, MF_TRIGGER7);
   RemoveMotionFlagListener(obj, MF_TRIGGER8);

}
// $Header: r:/t2repos/thief2/src/motion/mvrutils.h,v 1.15 2000/01/31 09:49:56 adurant Exp $
#pragma once

#ifndef __MVRUTILS_H
#define __MVRUTILS_H

#include <matrixs.h>
#include <wrtype.h>
#include <math.h> // XXX for fabs

#ifdef __cplusplus
#include <mcoord.h>
#include <dynarray.h>

EXTERN cDynArray<ObjID> standableObjectList;

#endif

typedef struct sMotionPhys
{
   mxs_vector xlat;
   mxs_real distance; // magnitude of xlat vector
   mxs_real duration;
   mxs_real buttZOffset;
   mxs_ang endDir;
} sMotionPhys;

typedef enum eMotionStatus
{
   kMotionStart,
   kMotionEnd,
   kMotionFlagReached,
   kMotionStatusInvalid=0xFFFF,
} eMotionStatus;

#define kMvrUCF_MaintainSpeed 0x1

#ifdef __cplusplus
EXTERN BOOL MvrGetRawMovement(const IMotor *pMotor, const int motionNum, sMotionPhys &phys);

EXTERN void MvrCalcSlidingCollisionResponse(const mxs_vector *pForces, const int nForces, 
                                            const mxs_vector *ovel, mxs_vector *nvel, ulong flags=NULL);
#endif

EXTERN void InitGroundHeightObjects();
EXTERN void TermGroundHeightObjects();

EXTERN BOOL MvrFindGroundHeight(ObjID obj, Location *loc, mxs_real *pHeight, ObjID *pGroundObj);
EXTERN void MvrSetStandingObj(ObjID standingObj, ObjID supportObj);
EXTERN void MvrSetStandingOffset(ObjID standingObj, ObjID supportObj, mxs_vector *pExpectedEndPos);
EXTERN void MvrSetTerrStandingOffset(ObjID standingObj, mxs_vector *pOffset);

EXTERN int  MvrRandomIntInRange(int low, int high);

EXTERN BOOL MvrGetEndButtHeight(const IMotor *pMotor, int motionNum, float *pHeight);

EXTERN void MvrUtilsRegisterDefaultObjFlags(ObjID obj);
EXTERN void MvrUtilsUnRegisterDefaultObjFlags(ObjID obj);

EXTERN void MvrProcessStandardFlags(IMotor *pMotor, cMotionCoordinator *pCoord, const int flags);
EXTERN void MvrSendMotionMessage(ObjID obj, int motionNum, eMotionStatus whatHappened, ulong flags);

#endif





// $Header: r:/t2repos/thief2/src/motion/puppet.cpp,v 1.12 1998/07/27 13:12:21 CCAROLLO Exp $

#include <puppet.h>
#include <pupprop.h>
#include <propbase.h>
#include <property.h>
#include <mprintf.h>
#include <creatapi.h>
#include <osysbase.h>
#include <motdesc.h>

// script stuff
#include <comtools.h>
#include <appagg.h>
#include <scrptapi.h> 
#include <scrptbas.h>
#include <scrptsrv.h>
#include <bodscrpt.h>

// Include this last
#include <dbmem.h>


static IPuppetProperty *g_pPuppetProperty=NULL;	

void PuppetsInit()
{
   g_pPuppetProperty=PuppetPropertyInit();
   Assert_(g_pPuppetProperty);
}

BOOL ObjIsPuppet(ObjID obj)
{
   cPuppet* pPuppet;
   return g_pPuppetProperty->Get(obj,&pPuppet);
}

ICerebellum *PuppetGetCerebellum(ObjID obj)
{
   cPuppet* pPuppet;

   if(!g_pPuppetProperty)
      return NULL;
   if(g_pPuppetProperty->Get(obj,&pPuppet))
   {
      return pPuppet; 
   }
   return NULL;
}

EXTERN void LGAPI PuppetCreatureListener(sPropertyListenMsg* msg, PropListenerData data)
{
   cPuppet* pPuppet; 

   if(msg->type&(kListenPropSet|kListenPropUnset|kListenPropModify))
   {
      if(OBJ_IS_CONCRETE(msg->obj)&&g_pPuppetProperty->Get(msg->obj,&pPuppet))
         if(pPuppet)
         {
            pPuppet->ResetMotor();
         }
   }
}


cPuppet::cPuppet(ObjID objID)
{
   m_pMCoord = MotSysCreateMotionCoordinator();
   m_pMnvrRequest=NULL;
   SetOwner(objID);
}

cPuppet::cPuppet(const cPuppet& )
{
   m_pMCoord = MotSysCreateMotionCoordinator();
   m_pMnvrRequest=NULL;
   SetOwner(OBJ_NULL);
}

cPuppet::~cPuppet()
{
   if(m_pMCoord)
      delete m_pMCoord;
   if(m_pMnvrRequest)
      delete m_pMnvrRequest;
}

void cPuppet::SetOwner(ObjID objID)
{
   m_ObjID=objID;
   ResetMotor();
}

void cPuppet::ResetMotor()
{
   if(m_pMCoord)
      m_pMCoord->SetMotor(CreatureGetMotorInterface(m_ObjID));  // this is null if not a creature
}

void cPuppet::SetManeuverRequest(sPuppetMnvrRequest *pRequest)
{
   if(m_pMnvrRequest)
      delete m_pMnvrRequest;
   m_pMnvrRequest=pRequest;
}

// XXX puppets ignore priority for now @TODO: make them use it KJ 1/98
void cPuppet::PlayMotion(const char *name, eManeuverTransitionType trans, eManeuverPriority priority)
{
   static cTagSet SpecMotion("PlaySpecMotion");

   sPuppetMnvrRequest *pRequest= new sPuppetMnvrRequest;

   pRequest->trans=trans;
   pRequest->params.tags = SpecMotion;
   pRequest->params.motionNum=MotDescNameGetNum((char *)name);
   pRequest->params.mask=kMotParmFlag_MotNum;
   if(pRequest->params.motionNum>0) // motion is okay
   {
      SetManeuverRequest(pRequest);
   } else // tell script service motion is done
   {
      AutoAppIPtr(ScriptMan);
      sBodyMsg bodyMessage(m_ObjID,sBodyMsg::kMotionEnd,name,NULL);
      pScriptMan->SendMessage(&bodyMessage);
   }
}

void cPuppet::Update(ulong dt)
{
   AssertMsg1(m_pMCoord,"No motion coordinator for puppet %d\n",m_ObjID);

   sPuppetMnvrRequest *pRequest=GetManeuverRequest();

   if(!pRequest)
      return;

   const sMcMoveState *state=m_pMCoord->GetNextEndState();
   IMotionPlan *pPlan;

   if(pRequest->trans==kMnvrTrans_Immediate)
   {
      if(NULL!=(pPlan=m_pMCoord->BuildPlan(state,&pRequest->params)))
      {
         IManeuver *pManeuver = pPlan->PopFirstManeuver();
         m_pMCoord->SetCurrentManeuver(pManeuver);
         delete pPlan;
      } else
      {
         AssertMsg(FALSE,"Unable to build motion plan");
      }
      SetManeuverRequest(NULL);
   } else if(m_pMCoord->GetStatus()==kMCoord_Idle)
   {
      if(NULL!=(pPlan=m_pMCoord->BuildPlan(state,&pRequest->params)))
      {
         IManeuver *pManeuver = pPlan->PopFirstManeuver();
         m_pMCoord->SetNextManeuver(pManeuver);
         delete pPlan;
      } else
      {
         AssertMsg(FALSE,"Unable to build motion plan");
      }
      SetManeuverRequest(NULL);
   }
}
// $Header: r:/t2repos/thief2/src/motion/puppet.h,v 1.7 2000/01/31 09:49:57 adurant Exp $
#pragma once

#ifndef __PUPPET_H
#define __PUPPET_H

#include <objtype.h>
#include <property.h> // for listener structs

#ifdef __cplusplus

#include <mclntapi.h>
#include <cbllmapi.h>

typedef struct sPuppetMnvrRequest
{
   eManeuverTransitionType trans;
   sMcMoveParams params;
} sPuppetMnvrRequest;

typedef class cPuppet : public ICerebellum
{
public:
   cPuppet(ObjID objID=OBJ_NULL);
   cPuppet(const cPuppet& );
   ~cPuppet();

   virtual void SetOwner(ObjID obj);
   ObjID GetOwner() { return m_ObjID; };

   virtual void PlayMotion(const char *name, eManeuverTransitionType trans=kMnvrTrans_Immediate, eManeuverPriority=kMnvrPri_Script);
   virtual void Update(ulong deltaTime);

   void ResetMotor();

   void SetManeuverRequest(sPuppetMnvrRequest *pRequest);
   sPuppetMnvrRequest *GetManeuverRequest() { return m_pMnvrRequest; }

private:
   ObjID m_ObjID;
   sPuppetMnvrRequest *m_pMnvrRequest;
   IMotionCoordinator *m_pMCoord;
} cPuppet;


EXTERN ICerebellum *PuppetGetCerebellum(ObjID obj);

#endif // __cplusplus


EXTERN void PuppetsInit();
EXTERN void PuppetsUpdate(ulong dt);
EXTERN void LGAPI PuppetCreatureListener(sPropertyListenMsg* msg, PropListenerData data);

EXTERN BOOL ObjIsPuppet(ObjID obj);

#endif
// $Header: r:/t2repos/thief2/src/motion/pupprop.cpp,v 1.5 1998/04/12 16:49:02 mahk Exp $

#include <pupprop.h>

#include <property.h>
#include <propert_.h>
#include <dataops_.h>
#include <propval_.h>
#include <proplist.h>
#include <propbase.h>

#include <objtype.h>
#include <osysbase.h>

// Include this last
#include <dbmem.h>

//
// puppet value funcs 
//

class cPuppetOps : public cClassDataOps<cPuppet> 
{
public:
   // override default flags
   cPuppetOps() : cClassDataOps<cPuppet>(kNoFlags) { }; 

   STDMETHOD(Read)(sDatum* dat, IDataOpsFile* , int )
   {
      dat->value = new cPuppet; 
      return S_OK; 
   }

};

static sPropertyDesc g_PuppetDesc =
{
   PROP_PUPPET_NAME, // name
   kPropertyConcrete|kPropertyNoInherit|kPropertyInstantiate, // flags
};

//
// Property store class 
//
class cPuppetStore : public cListPropertyStore<cPuppetOps> 
{
}; 

//
// Property class.  Because it's kPropertyConcrete, I need to use cGenericProperty
//

class cPuppetProp : public cGenericProperty<IPuppetProperty,&IID_IPuppetProperty,cPuppet*>
{
   typedef cGenericProperty<IPuppetProperty,&IID_IPuppetProperty,cPuppet*> cParent; 

protected:
   cSimpleDataOps mAbstractOps; 

public:

   cPuppetProp(const sPropertyDesc* desc, cPuppetStore* store)
      : cParent(desc, store)
   {
      // Ok, I know that cPuppetStore's SetOps doesn't do anything.  
      // But, because I'm kPropertyConcrete, I know that the 
      // mpStore is a "mixed" store with a different implementation for abstract objects.
      // I want abstract objects to always have NULL values, so I use cSimpleDataOps instead 
      // of cPuppetOps
      mpStore->SetOps(&mAbstractOps); 
   }

   STANDARD_DESCRIBE_TYPE(cPuppet); 

   
   //
   // Hookup a puppet to its ObjID. 
   //

   void OnListenMsg(ePropertyListenMsg msg, ObjID obj, uPropListenerValue value)
   {
      
      if (msg & (kListenPropModify|kListenPropSet))
      {
         cPuppet* puppet = (cPuppet*)value.ptrval; 
         if (puppet && obj != puppet->GetOwner())
            puppet->SetOwner(obj); 
      }
      cParent::OnListenMsg(msg,obj,value); 
   }
   
}; 


cPuppetProp *g_pPuppetProp=NULL;
cPuppetStore* g_pPuppetStore = NULL; 

IPuppetProperty *PuppetPropertyInit(void)
{
   if(g_pPuppetProp!=NULL)
      return g_pPuppetProp;
   g_pPuppetStore = new cPuppetStore(); 
   g_pPuppetProp= new cPuppetProp(&g_PuppetDesc,g_pPuppetStore);
   return g_pPuppetProp;
}


//
// We use our special knowledge of the puppet property store to iterate across only concrete puppets
//

void PuppetsUpdate(ulong dt)
{
   sPropertyObjIter iter;
   cPuppet* puppet;
   ObjID objID;

   if(!g_pPuppetStore)
      return;
   g_pPuppetStore->IterStart(&iter);
   while(g_pPuppetStore->IterNext(&iter,&objID,(sDatum*)&puppet))
   {
      if (puppet)
         puppet->Update(dt);
   }
   g_pPuppetStore->IterStop(&iter); 
}



// $Header: r:/t2repos/thief2/src/motion/pupprop.h,v 1.3 2000/01/31 09:49:58 adurant Exp $
#pragma once

#ifndef __PUPPROP_H
#define __PUPPROP_H

#include <property.h>
#include <puppet.h>

////////////////////////////////////////////////////////////
// PUPPET PROPERTY
//

#undef INTERFACE
#define INTERFACE IPuppetProperty
DECLARE_PROPERTY_INTERFACE(IPuppetProperty)
{
   DECLARE_UNKNOWN_PURE(); 
   DECLARE_PROPERTY_PURE(); 
   DECLARE_PROPERTY_ACCESSORS(cPuppet*); 
}; 


#define PROP_PUPPET_NAME "Puppet"

//
// Instantiate the puppet property. 
//
EXTERN IPuppetProperty *PuppetPropertyInit(void);

#endif // __PUPPROP_H




// $Header: r:/t2repos/thief2/src/motion/skildtab.c,v 1.42 2000/02/19 13:17:40 toml Exp $
// This contains all the static data structures for the skill table, because
// Watcom doesn't compile if these are in a c++ file.

#include <skildtab.h>
#include <fix.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// MOTOR CONTROLLERS
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// DEFAULT MOTION DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////


EXTERN sDefaultFullDesc g_aDefaultDesc[] = { { kTeleportController } };



////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// SINGLEPLAY DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

EXTERN sSinglePlayFullDesc g_aSinglePlayDesc[] = { {kMultipedPlayController} };

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// COMBAT DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

EXTERN sCombatFullDesc g_aCombatDesc[] = { {kCombatController} };

////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// LOCOMOTION DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////

EXTERN sLocoFullDesc g_aLocoDesc[] = { \
// Walk
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Normal,kMS_LocoKind_Normal,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_WALK_LEFT_GUARD_READY, MDT_WALK_RIGHT_GUARD_READY, 1.5, -1.5, 1.0, 1.0, 180, 15, 0.5, 5.0, 0 } // gait data
   },
// Stand Normal
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Stationary,kMS_LocoKind_Normal,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_STAND_GUARD_CASUAL, MDT_STAND_GUARD_CASUAL, 1.5, -1.5, 1.0, 1.0, 180, 15, 0,0, 0 } // gait data
   },
// Stand Searching
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Stationary,kMS_LocoKind_Searching,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_STAND_GUARD_READY, MDT_STAND_GUARD_READY, 1.5, -1.5, 1.0, 1.0, 180, 15, 0,0, 0 } // gait data
   },
// Stand Combat
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Stationary,kMS_LocoKind_SwordCombat,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_STAND_GUARD_READY, MDT_STAND_GUARD_READY, 1.5, -1.5, 1.0, 1.0, 180, 15, 0,0, 0 } // gait data
   },
// Walk Searching
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Normal,kMS_LocoKind_Searching,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_WALK_SEARCH_CYCLE_GUARD_READY, MDT_WALK_SEARCH_CYCLE_GUARD_READY, 1.5, -1.5, 1.0, 1.0, 180, 15, 0.5, 5.0, 0 }
   },
// Run
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Fast,kMS_LocoKind_Normal,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_RUN_LEFT_SERVANT, MDT_RUN_RIGHT_SERVANT, 1.5, -1.5, 1.0, 1.0, 180, 15, 0.5, 5.0, 1, { {180, MDT_RUN_TURN_180 } } } // gait data
   },
// Sword Combat Advance
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Forwards,kMS_Speed_Normal,kMS_LocoKind_SwordCombat,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_ADVANCE_GUARD, MDT_ADVANCE_GUARD, 1.5, -1.5, 0.8, 1.0, 90, 15, 0.5, 5.0, 0 }
   },
// Sword Combat Backup
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Backwards,kMS_Speed_Normal,kMS_LocoKind_SwordCombat,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_RETREAT_GUARD, MDT_RETREAT_GUARD, 1.5, -1.5, 0.8, 1.0, 90, 15, 0.5, 5.0, 0 }
   },
// Sword Combat Sidestep Left
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Right,kMS_Speed_Normal,kMS_LocoKind_SwordCombat,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_SIDESTEP_LEFT_GUARD, MDT_SIDESTEP_LEFT_GUARD, 1.5, -1.5, 0.8, 1.0, 180, 15, 0.5, 5.0, 0 }
   },
// Sword Combat Sidestep Right
   {
      kMultipedGroundLocoController, // controller id
      {kMS_Mode_OnGround,kMS_Fac_Left,kMS_Speed_Normal,kMS_LocoKind_SwordCombat,kMS_PhysCon_Normal}, // skill selection desc
      { MDT_SIDESTEP_RIGHT_GUARD, MDT_SIDESTEP_RIGHT_GUARD, 1.5, -1.5, 0.8, 1.0, 180, 15, 0.5, 5.0, 0 }
   },
};


////////////////////////////////////////////////////
////////////////////////////////////////////////////
///
/// PLAYER SKILLS DATA 
///
////////////////////////////////////////////////////
////////////////////////////////////////////////////


EXTERN sPlayerSkillFullDesc g_aPlayerSkillDesc[] = { \
// Sword Ready
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {                // maneuver skill data
         "ph212203",
//         "GSW031C",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         4.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "armsw2",               // model name
      NULL,                   // schema name
      0,         // time to max
      0,         // shoot
      0,         // mouse speed
      0,         // mouse zone
      0,         // slewSpeedScale
      0,         // rotateSpeedScale
      TRUE,      // IsIdleMotion
   },
// Sword Block
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordAtBlock", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
//         "GA213086", 
         "AH213211",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.9, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      "sword_swing",                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword At Block
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
         NULL,
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Windup Short
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordAtWoundShort", "PlayerSwordSwingMedium", "PlayerSwordSwingShort", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "sh213003",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword At Wound Short
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordSwingShort", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
         NULL,
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Swing Short
   {
      kPlayerStandardController, // controller id
      kTrans_AtEnd,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "mh213003",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.67, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      "sword_swing",                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Windup Medium
   {
      kPlayerStandardController, // controller id
      kTrans_AtEnd,
      { "PlayerSwordAtWoundMedium", "PlayerSwordSwingMedium", "PlayerSwordSwingMedium", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "sh213056",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword At Wound Medium
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordSwingMedium", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
         NULL,
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Swing Medium
   {
      kPlayerStandardController, // controller id
      kTrans_AtEnd,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "mh213056",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.7, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      "sword_swing",                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Windup Long
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordAtWoundLong", "PlayerSwordSwingMedium", "PlayerSwordSwingLong", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "GA213070",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         3.0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword At Wound Long
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordSwingLong", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
         NULL,
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Swing Long
   {
      kPlayerStandardController, // controller id
      kTrans_AtEnd,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {   // maneuver skill data
           "GA213030",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.8, // time scale (0 means not specified)
      },              
      "armsw2",               // model name
      "sword_swing",                   // schema name
      0, // time to max
      0, // shoot
   },
// Sword Begin
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerSwordReady", "PlayerSwordSwingMedium", "PlayerSwordReady", "PlayerSwordEnd" }, // connecting skills
      {                // maneuver skill data
//         "GSW031A",
         "ph212202",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.6, // time scale (0 means not specified)
      }, 
      "armsw2",               // model name
      "sword_begin",                   // schema name
   },
// Sword End
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { NULL, NULL, NULL, NULL}, // connecting skills
      {                // maneuver skill data
//         "GSW031B",
         "ph212205",
         {1.57,-0.267,-3.077}, {0,0,0},
         {1.57,-0.267,-3.077}, {0,0,0},
         0, // duration (0 means not specified)
         0.6, // time scale (0 means not specified)
      }, 
      "armsw2",               // model name
      "sword_end",                   // schema name
   },
// Empty-Handed Idle
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerEmptyIdle", "PlayerEmptyIdle", "PlayerEmptyIdle", NULL }, // connecting skills
      {                // maneuver skill data
         NULL, 
         {0,-1.0,-2.0}, {0,0,0},
         {0,-1.0,-2.0}, {0,0,0}, 
         4.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      NULL,               // model name
      NULL,                   // schema name
      0, // time to max
      0, // shoot
      0,         // mouse speed
      0,         // mouse zone
      0,         // slewSpeedScale
      0,         // rotateSpeedScale
      TRUE,      // IsIdleMotion
   },
// Lockpick Idle
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerLockPickIdle","PlayerLockPickRaise", "PlayerLockPickIdle", NULL}, // connecting skills
      {                // maneuver skill data
         NULL, 
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         4.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "armtrl4",               // model name
      NULL,                   // schema name
   },
// Lockpick Raise
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerLockPickFrob","PlayerLockPickFrob", "PlayerLockPickLower", "PlayerLockPickLower"}, // connecting skills
      {                // maneuver skill data
         "GA114322", 
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "armtrl4",               // model name
      NULL,                   // schema name
   },
// Lockpick Frob
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerLockPickFrob","PlayerLockPickFrob", "PlayerLockPickLower", "PlayerLockPickLower"}, // connecting skills
      {                // maneuver skill data
         "GA114323", 
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "armtrl4",               // model name
      NULL,                   // schema name
   },
// Lockpick Lower
   {
      kPlayerStandardController, // controller id
      kTrans_Immediate,
      { "PlayerLockPickIdle","PlayerLockPickRaise", "PlayerLockPickIdle", "PlayerLockPickEnd"}, // connecting skills
      {                // maneuver skill data
         "GA114324", 
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         {0.447,0.2485,-2.517}, {degrees_to_fixang(356),degrees_to_fixang(350),degrees_to_fixang(19)},
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "armtrl4",               // model name
      NULL,                   // schema name
   },
// FlexBow idle
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowIdle","FlexBowAim", "FlexBowIdle", "FlexBowEnd" }, // connecting skills
      {                // maneuver skill data
         "d99bdown",
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         4.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "bowempt9",               // model name
      NULL,                   // schema name
   },
// FlexBow aim
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowDraw", "FlexBowDraw", "FlexBowIdle", "FlexBowRelax" }, // connecting skills
      {                // maneuver skill data
         "GABaim", 
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         0, // duration (0 means not specified)
         0.5, // time scale (0 means not specified)
      }, 
      "bowempt9",               // model name
      NULL,                   // schema name
   },
// FlexBow draw
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowDraw", "FlexBowDraw", "FlexBowFire", "FlexBowRelax" }, // connecting skills
      {                // maneuver skill data
         NULL, 
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
         1.0, // flexing duration
         30, // maximum flex, in degrees
      }, 
      "bowempt9",               // model name
      "bowpull",                   // schema name
      1.0, // time to max, for powering reasons
      0, // shoot
      0x1800, // mouse speed
      0, // mouse zone
      0.5,  // player slew speed scale
      0.7,  // player rotate speed scale
   },
// FlexBow fire
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowRelax", "FlexBowDraw", "FlexBowRelax", "FlexBowRelax" }, // connecting skills
      { // maneuver skill data 
         NULL,
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         0.8,  // duration
         0, // time scale (0 means not specified)
         0, // flexing duration
         0, // maximum flex, in degrees
      },
      "bowempt9",              // model name
      "bowtwang_player",       // schema name
      0, // time to max
      TRUE, // shoot!
   },
// FlexBow relax
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowIdle", "FlexBowAim", "FlexBowIdle", "FlexBowEnd" }, // connecting skills
      {                // maneuver skill data
         "d99brelx", 
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         0, // duration (0 means not specified)
         0.5, // time scale (0 means not specified)
      }, 
      "bowempt9",               // model name
      NULL,                   // schema name
   },
// FlexBow begin
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { "FlexBowIdle","FlexBowAim", "FlexBowIdle", "FlexBowEnd"}, // connecting skills
      {                // maneuver skill data
         "d99bbegn", 
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         1.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "bowempt9",               // model name
      "bow_begin",                   // schema name
   },
// FlexBow end
   {
      kPlayerFlexBowController, // controller id
      kTrans_Immediate,
      { NULL, NULL, NULL, NULL}, // connecting skills
      {                // maneuver skill data
         NULL, 
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         { -0.87,0.8,-2.59}, {degrees_to_fixang(11), degrees_to_fixang(14), degrees_to_fixang(284) },
         1.0, // duration (0 means not specified)
         0, // time scale (0 means not specified)
      }, 
      "bowempt9",               // model name
      "bow_end",                   // schema name
   },
};
// $Header: r:/t2repos/thief2/src/motion/skildtab.h,v 1.10 2000/01/31 09:49:59 adurant Exp $
#pragma once

#ifndef __SKILDTAB_H
#define __SKILDTAB_H

#include <mskilset.h>
#include <motdesc.h>
#include <skilltab.h>
#include <mseltype.h>

typedef enum eMControllerType
{
   kTeleportController,
   kMultipedPlayController,
   kGlideGroundLocoController,
   kMultipedGroundLocoController,
   kPlayerStandardController,
   kPlayerFlexBowController,
   kCombatController,
   kControllerInvalid=0xff,
} eMControllerType;


typedef struct sDefaultFullDesc
{
   int controllerID;
} sDefaultFullDesc;


typedef struct sSinglePlayFullDesc
{
   int controllerID;
} sSinglePlayFullDesc;

typedef struct sCombatFullDesc
{
   int controllerID;
} sCombatFullDesc;

typedef struct sLocoFullDesc
{
   int controllerID;
   sMLocoSelectDesc selDesc;
   sMGaitSkillData skillData;
} sLocoFullDesc;

typedef struct sPlayerSkillFullDesc
{
   int controllerID;
   ePlayerTransition trans;
   sSkillConnectDesc connect;
   sMPlayerSkillData skillData;
   char *modelName;
   char *schemaName;
   float timeToMax; 
   BOOL shoot;
   int mouseSpeed;
   int mouseZone;
   float slewSpeedScale;
   float rotateSpeedScale;
   BOOL IsIdleMotion;
} sPlayerSkillFullDesc;


EXTERN sLocoFullDesc g_aLocoDesc[];
EXTERN sPlayerSkillFullDesc g_aPlayerSkillDesc[];
EXTERN sDefaultFullDesc g_aDefaultDesc[];
EXTERN sSinglePlayFullDesc g_aSinglePlayDesc[];
EXTERN sCombatFullDesc g_aCombatDesc[];

#endif
// $Header: r:/t2repos/thief2/src/motion/skillset.cpp,v 1.5 1998/10/05 17:27:57 mahk Exp $
//
// XXX THIS IS TEMPORARY AND SLOW
// real implentation will involve properties and links and designer input and stuff

#include <skillset.h>

// Must be last header 
#include <dbmem.h>


static tSkillID g_DummySkills[]= \
{ 
   "Teleport",
   "SinglePlay",
   "Glide",
   "StandNormal",
   "StandSearching",
   "StandCombat",
   "SwordSwing",
   "Walk",
   "WalkSearching",
   "Run",
   "CombatAdvance",
   "CombatBackup",
   "CombatSSLeft",
   "CombatSSRight",
};

BOOL SkillSetGetForObj(const ObjID objID, int *nSkills, tSkillID **ppSkills)
{
   *ppSkills=g_DummySkills;
   *nSkills=sizeof(g_DummySkills)/sizeof(tSkillID);
   return TRUE;
}

// $Header: r:/t2repos/thief2/src/motion/mclntapi.h,v 1.22 2000/01/29 13:22:12 adurant Exp $
#pragma once

// This file declares the interface to the motion system to be used by
// higher-level systems.  The basic idea is that a client uses the
// MotionCoordinator to build plans to accomplish goals, and then
// feeds maneuvers from that plan to the MotionCoordinator when the coordinator
// needs them.  The motion system is a passive server from the perspective of
// the client.  The client can look at the plan built by the MotionCoordinator
// to decide if it likes it, and make adjustments to the plan as necessary.
//
// The client of the motion system is the AI cerebellum (see aicbllm.cpp)

#ifndef __MCLNTAPI_H
#define __MCLNTAPI_H

#include <mctype.h>
#include <matrixs.h>
#include <motrtype.h>
#include <label.h>
#include <tagdbt.h>
#include <ctagset.h>
#include <objtype.h> // for focus obj
#include <tagfile.h>
#include <fix.h>

// Maneuvers are the atomic units of action.
//
class IManeuver
{
public:
//// destructor
   virtual ~IManeuver() {}

////////
// Motion System Client Functions
////////
   virtual IManeuver *GetPrevManeuver()=0;
   virtual IManeuver *GetNextManeuver()=0;
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState)=0;
   virtual void SetAppData(ulong data)=0;
   virtual ulong GetAppData()=0;

////////
// Motion Coordinator Functions
////////
   virtual void Execute()=0;
   virtual void Finish()=0;
   virtual void SetMotor(IMotor *pMotor)=0;
   virtual void Save(ITagFile *pTagFile)=0;

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect()=0;
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel)=0;
   virtual void NotifyAboutBeingStuck()=0;
   virtual void NotifyAboutMotionAbortRequest()=0;
   virtual void NotifyAboutFrameFlags(const int)=0;
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)=0;
};

// A plan is composed of a sequence of maneuvers.
//
class IMotionPlan
{
public:
   virtual IManeuver *GetFirstManeuver()=0;
   virtual IManeuver *GetLastManeuver()=0;
   virtual IManeuver *PopFirstManeuver()=0;
};

// The is the motion system, as far as the client is concerned.
// There should be exactly one MotionCoordinator per entity to be controlled.
//

//
// Status of motion coordinator.  Returned by GetStatus
//
enum eMCoordStatus
{
   kMCoord_Idle,
   kMCoord_ActiveInterrupt,
   kMCoord_ActiveBusy,
   kMCoord_Error,
   kMCoord_IntMax=0xffffffff,
};

// XXX are two maneuvers - next and current - really necessary?

class IMotionCoordinator
{
public:
//// destructor
   virtual ~IMotionCoordinator() {}

   virtual void Load(ITagFile *pTagFile)=0;
   virtual void Save(ITagFile *pTagFile)=0;

   virtual void SetMotor(IMotor *pMotor)=0;

   // these are tags to be applied to every motion request
   virtual void SetPersistentTags(const cTagSet *pTags)=0;

   virtual IMotionPlan *BuildPlan(const sMcMoveState *pStartState, const sMcMoveParams *pParams)=0;

// this happens instantaneously, without blending or interrupting any
// currently executing maneuvers.  Coordinator chooses a motion
// (always that same one) that matches the tags, and poses the motor
// at the given fraction of the way through the motion.
   virtual void Pose(const cTagSet *pTags, float frac)=0;

//
   virtual eMCoordStatus GetStatus() const=0;

// Used to set the maneuver to be executed when the currently executing one is
// completed.  This is necessary because maneuver completion may occur between
// client GetStatus calls.  If no next maneuver is set, the coordinator will
// do nothing once te current one is completed until a maneuver is set.
//
   virtual void SetNextManeuver(IManeuver *pMnvr)=0;

// Used when the client wants to interrupt the currently executing maneuver with
// a new one, instead of making the new maneuver get executed when the current
// one is done.
//
   virtual void SetCurrentManeuver(IManeuver *pMnvr)=0;

// Used to get expected client state at the end of the currently executing
// maneuver.  This state should be used for new plan building.
//
   virtual const sMcMoveState *GetNextEndState() const=0;

// Set callback for coordinator to use when motor it is controlling gets
// moved around by other systems (editor, scripts etc).
   virtual void SetMotorStateChangeCallback(fMcMotorStateChangeCallback callback, void *context)=0;

// Set callback for coordinator to use when it completes a maneuver
   virtual void SetManeuverCompletionCallback(fMcManeuverCompletionCallback callback, void *context)=0;

   // this only lasts for one frame, so "instantaneously interruptable"
   virtual void NotifyThatCanInterrupt()=0;
};


struct sMcMoveState
{
   mxs_vector  position;
   mxs_real    speed;
   mxs_angvec  facing;
   mxs_angvec  direction;
};

#define kMotParmFlag_Direction 0x4
#define kMotParmFlag_ExactSpeed 0x10
#define kMotParmFlag_Facing 0x20
#define kMotParmFlag_Duration 0x40
#define kMotParmFlag_Position 0x80
#define kMotParmFlag_Name     0x100
#define kMotParmFlag_MotNum   0x400
#define kMotParmFlag_Distance 0x1000
#define kMotParmFlag_FocusObj 0x2000

struct sMcMoveParams
{
   sMcMoveParams()
    : mask(0)
   {
	  turnspeed = 0x3800;
   }

   cTagSet     tags;
   ulong       mask;    // says which remaining fields to use and which to ignore
// locomotion fields
   mxs_angvec  direction;
   mxs_real    distance; // used to modify when stride length when length>distance
   mxs_real    exactSpeed; // quantitative speed value
   mxs_angvec  facing;
   ulong       duration;
   mxs_vector  position;
// single action fields
   char *   name;
   int      motionNum;
   ObjID    focus;
   fix		   turnspeed; // The maximum angle speed to turn the body.
};

IMotionCoordinator *MotSysCreateMotionCoordinator();

#endif
////////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/crjoint.cpp,v 1.3 1999/12/09 20:16:43 BODISAFA Exp $
//
// Creature joint accessor 
//

#include <matrix.h>

#include <creatur_.h>
#include <creature.h>
#include <crjoint.h>

#include <objedit.h> // for nice naming in Assert messages

// Must be last header
#include <dbmem.h>

////////////////////////////////////////

// For sdescs and stuff that want string names of joints
char *g_pJointNames[kCJ_NumCreatureJoints + 1] = 
{
   "N/A",
   "Head",
   "Neck",
   "Abdomen",
   "Butt",
   "Left Shoulder",
   "Right Shoulder",
   "Left Elbow",
   "Right Elbow",
   "Left Wrist",
   "Right Wrist",
   "Left Fingers",
   "Right Fingers",
   "Left Hip",
   "Right Hip",
   "Left Knee",
   "Right Knee",
   "Left Ankle",
   "Right Ankle",
   "Left Toe",
   "Right Toe",
   "Tail",
};

////////////////////////////////////////

int GetCreatureJointID(ObjID creature, int joint)
{
   cCreature *pCreature = CreatureFromObj(creature);
   AssertMsg2(pCreature,"GetCreatureJointId: pCreature NULL for %s joint %d\n",ObjEditName(creature),joint);
   AssertMsg1((joint >= 0 && joint < kCJ_NumCreatureJoints), "GetCreatureJointID: invalid joint index %d\n", joint);

   const sCreatureDesc *pCDesc = pCreature->GetCreatureDesc();

   return pCDesc->pJointMap[joint];
}

////////////////////////////////////////

const mxs_vector &GetCreatureJointPos(ObjID creature, int joint)
{
   cCreature *pCreature = CreatureFromObj(creature);
   AssertMsg2(pCreature,"GetCreatureJointPos: pCreature NULL for %s joint %d\n",ObjEditName(creature),joint);
   AssertMsg1((joint >= 0 && joint < kCJ_NumCreatureJoints), "GetCreatureJointPos: invalid joint index %d\n", joint);
   const sCreatureDesc *pCDesc = pCreature->GetCreatureDesc();

   if (pCDesc->pJointMap[joint] == -1)
   {
      Warning(("Invalid joint %d for creature %s\n", joint, ObjWarnName(creature)));
      return pCreature->GetJoint(0);
   }
       
   return pCreature->GetJoint(pCDesc->pJointMap[joint]);
}

////////////////////////////////////////

const mxs_matrix &GetCreatureJointOrient(ObjID creature, int joint)
{
   cCreature *pCreature = CreatureFromObj(creature);
   AssertMsg2(pCreature,"GetCreatureJointOrient: pCreature NULL for %s joint %d\n",ObjEditName(creature),joint);
   AssertMsg1((joint >= 0 && joint < kCJ_NumCreatureJoints), "GetCreatureJointOrient: invalid joint index %d\n", joint);

   const sCreatureDesc *pCDesc = pCreature->GetCreatureDesc();
   Assert_(pCDesc);
   if ((joint == kCJ_Head) && pCDesc->canHeadTrack)
      return pCreature->GetHeadOrient();
   else
   {
      if (pCDesc->pJointMap[joint] == -1)
      {
         Warning(("Invalid joint %d for creature %s\n", joint, ObjWarnName(creature)));
         return pCreature->GetJointOrient(0);
      }
               
      return pCreature->GetJointOrient(pCDesc->pJointMap[joint]);
   }
}

////////////////////////////////////////

void GetCreatureJointPosC(ObjID creature, int joint, mxs_vector *vec)
{
   *vec = GetCreatureJointPos(creature, joint);
}

////////////////////////////////////////

void  GetCreatureJointOrientC(ObjID creature, int joint, mxs_matrix *mat)
{
   *mat = GetCreatureJointOrient(creature, joint);
}

////////////////////////////////////////



// $Header: r:/t2repos/thief2/src/motion/motdb.h,v 1.6 2000/01/29 13:22:13 adurant Exp $
#pragma once

#ifndef __MOTDB_H
#define __MOTDB_H

#include <tagfile.h>
#include <motschem.h>
#include <namemap.h>
#include <dynarray.h>
#include <fcytagdb.h>
#include <tagdbout.h>
#include <motdbtyp.h>
#include <tagremap.h>

#ifdef __cplusplus

typedef enum eMotDBMatchType
{
   kMMT_AbsoluteBest,
   kMMT_WeightedDither,
} eMotDBMatchType;

class cMotionDatabase
{
public:
   cMotionDatabase();
   virtual ~cMotionDatabase();

   // database query
   virtual BOOL GetBestMatch(int actor, cTagDBInput *pInput, cMotionSchema **ppSchema,eMotDBMatchType matchType=kMMT_AbsoluteBest);
   virtual BOOL GetTagKeyID(const Label *pName, int *pID);

   // get schema by index
   virtual BOOL GetSchema(int index, cMotionSchema **ppSchema);

   void Clear();

   // save/load
   virtual BOOL Load(ITagFile *pFile);
#ifdef EDITOR
   virtual BOOL BuildFromAscii();
   virtual BOOL Save(ITagFile *pFile);
#endif

   // build utilities
   virtual void CreateTagDatabase(int nActors);
   virtual void RegisterTag(const Label *pName, const sTagInfo *pInfo);
   virtual void AddSchema(const sMotSchemaDesc *pSchema);

   // retokenization--these are passed into cTagDBDatabases
   void TokenGlobalToLocal(cTagDBKey *pKey);
   void TokenLocalToGlobal(cTagDBKey *pKey);

private:
   cNameMap m_NameMap;
   cNameMap m_TagNameMap;
   cTagRemapper m_Remap;
   cMotionSchemaSet m_SchemaSet;
   int m_nActors;
   IFancyTagDatabase *m_pDatabase;
   cTagDBOutput m_RawResult;
};

inline BOOL cMotionDatabase::GetTagKeyID(const Label *pName, int *pID)
{
   int index=m_TagNameMap.IDFromName(pName);

   if(index==kNameMapIndexNotFound)
      return FALSE;
   *pID=index;
   return TRUE;
}

#endif // cplusplus

#endif // motdb.h

// $Header: r:/t2repos/thief2/src/motion/crwpnapi.cpp,v 1.2 2000/01/07 14:33:15 BODISAFA Exp $

// until this is propertized, this is completely shock/gamesys specific, sadly
// if it were propertized, that would be way less true

// in particular, we would want a nethandweapon property, or something
// which had all the data for a weapon converting from world to handheld
// then at init time, we would scan that property and build our table
// (which would just be obj->obj)

// at that point, we could pass that across, and the actual table data would
// be in the property.

// if we did that, we could probably make this truly ghost, and not have the
// shock dependancy we currently obviously have

#include <lg.h>
#include <comtools.h>
#include <appagg.h>

#include <crattach.h>
#include <crwpnlst.h>
#include <crwpnapi.h>
#include <linkman.h>
#include <linktype.h>
#include <relation.h>
#include <appagg.h>
#include <linkbase.h>
#include <matrix.h>
#include <mxmat.h>
#include <objsys.h>
#include <objdef.h>
#include <iobjsys.h>

#include <cretprop.h>
#include <weapon.h>
#include <objedit.h>
#include <mprintf.h>

#include <refsys.h>

#include <crjoint.h> // Range checking on joints.

#include <creature.h>   // CreatureFromObj

// Drop object
#include <physapi.h>
#include <prjctile.h>
#include <phnet.h>
#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>
#include <aiapi.h>

#include <dbmem.h>

// for weapon object solving
int  (*CreatureWeaponObjSwizzle) (ObjID weapon, int mode) = NULL;
BOOL (*CreatureWeaponObjCreate)  (ObjID id, int mode)     = NULL;
void (*CreatureWeaponObjDestroy) (ObjID id)               = NULL;
void (*CreatureWeaponObjDrop)    (ObjID id)               = NULL;

// @TODO:  Bodisafa 12/9/1999
// This needs to be in Dark & DeepC.
BOOL CreatureWeaponCreate(ObjID id, int mode);
void CreatureWeaponDestroy(ObjID id);
int  CreatureWeaponSwizzle(ObjID id, int mode);
void CreatureWeaponDrop(ObjID id);

// Init/Term
void CreatureWeaponInit(void)
{
   // @TODO:  Bodisafa 11/30/1999
   // This needs to be in Dark & DeepC.
   CreatureWeaponObjCreate  = CreatureWeaponCreate;
   CreatureWeaponObjDestroy = CreatureWeaponDestroy;
   CreatureWeaponObjSwizzle = CreatureWeaponSwizzle;
   CreatureWeaponObjDrop    = CreatureWeaponDrop;
   
   CreatureWeaponListInit();
}

void CreatureWeaponTerm(void)
{
   CreatureWeaponListTerm();
}

// @TODO:  Bodisafa 11/30/1999
// ObjHasWeaponOffset checks should be reduced to the correct code flow.
// Otherwise, we're doing too many redundant checks.
// Assert in the other cases.

// Creature Weapon List

// GetWeaponIdForMode:  Returns the appropriate ObjID for the current mode.
ObjID GetWeaponIdForMode(ObjID id, int mode)
{
   if (id != OBJ_NULL && (ObjHasWeaponOffset(id)))
   {
      if (WeaponOffsetSetActive(id, mode))
      {
         int referenceID =  WeaponOffsetGetDest(id);
         if (referenceID != OBJ_NULL)
         {
            return referenceID;
         }
      }
   }
//   Warning(("GetWeaponIdForMode: No weapon for object '%d' in mode '%d'\n", id, mode));
   return OBJ_NULL;
}

// CreatureWeaponAttachWeapon: Hooks up creatures weapon for a given mode.
// Input:
// ppCreat     - Creature weapon information.
// referenceID - Uses this ID to construct a new weapon.
// mode        - What mode is the creature in?
void CreatureWeaponAttachWeapon(sCreatureWeapon **ppCreat, int referenceID, int mode)
{
   const sCreatureWeapon* pCW = *ppCreat;

   if (!ObjHasWeaponOffset(pCW->obj))
   {
      mprintf("CreatureWeaponAttachWeapon:  returning - !WeaponOffsetProp\n");
      return;
   }

   // Same weapon or we have this weapon attached.
   if (pCW->nWeapon == referenceID || (pCW->weaponObj == referenceID))
   {
//      Warning(("CreatureWeaponAttachWeapon:  returning - nothing to do\n"));
      return;
   }
   
   AutoAppIPtr_(ObjectSystem, pObjSys);

   // If we currently holding a weapon, destroy it.
   if (pCW->weaponObj != OBJ_NULL)
   {
      mprintf("CreatureWeaponAttachWeapon:  destroying (%d,%d)\n", (*ppCreat)->nWeapon, referenceID);
      pObjSys->Destroy(pCW->weaponObj);
      (*ppCreat)->weaponObj = OBJ_NULL;
   }
   
   (*ppCreat)->nWeapon = referenceID;
   (*ppCreat)->weaponObj = BeginObjectCreate(referenceID, kObjectConcrete);
   if ((*ppCreat)->weaponObj == OBJ_NULL)
   {
      Warning(("CreatureWeaponAttachWeapon: Failed to create weapon no object id %d\n", referenceID));
      return;
   }

   EndObjectCreate(pCW->weaponObj);

   sCreatureAttachInfo Info;
   memset(&Info,0,sizeof(Info));

   if (WeaponOffsetSetActive(pCW->obj, mode))
   {
      Info.joint = WeaponOffsetGetJoint(pCW->obj);
      if (Info.joint >= 0 && Info.joint < kCJ_NumCreatureJoints)
      {
         mxs_vector* pTransform = WeaponOffsetGetTransform(pCW->obj);

         Assert_(pTransform != NULL);
         mxs_trans trans = {pTransform[0].x, pTransform[0].y, pTransform[0].z,
                            pTransform[1].x, pTransform[1].y, pTransform[1].z,
                            pTransform[2].x, pTransform[2].y, pTransform[2].z,
                            pTransform[3].x, pTransform[3].y, pTransform[3].z};
   
         mx_copy_trans(&Info.relTrans, &trans);

         CreatureAttachItem(pCW->obj, pCW->weaponObj, &Info);

         // Creatures don't support weapons with physics.
         CreatureMakeWeaponNonPhysical(pCW->obj, pCW->weaponObj);
   
         // mprintf("Attach %s to %s\n",ObjWarnName(pCW->weaponObj),ObjWarnName(pCW->obj));
      }
   }
}

inline BOOL WeaponSwizzle(ObjID id, ObjID referenceID, int mode)
{
   // Nothing to do.
   if (!ObjHasWeaponOffset(id) || (referenceID == OBJ_NULL))
   {
      return FALSE;
   }
   
   // We're on the way to the deathbed...or at least we're not feeling better yet.
   cCreature* pCreat = CreatureFromObj(id);
   if (pCreat == NULL)
   {
      return FALSE;
   }

   IAI* pAI = AppGetObj(IAIManager)->GetAI(id);
   if (!pCreat->IsPhysical() || !PhysObjHasPhysics(id) || (pAI && pAI->IsDying()))
   {
      pAI->Release();
      return FALSE;
   }
   
   if (pAI)
   {
      pAI->Release();
   }

   sCreatureWeapon *pCW = CreatureWeaponGet(id);
   
   // Verify referenceID is valid and creature weapon is in the list.
   if (pCW != NULL)
   {
      CreatureWeaponAttachWeapon(&pCW, referenceID, mode);
   }
   else if (CreatureWeaponObjCreate)
   {
      (*CreatureWeaponObjCreate)(id, mode);
   }
   return TRUE;
}

int CreatureWeaponSwizzle(ObjID id, int mode)
{
   // Get creature's reference ID for this mode.
   ObjID referenceID = GetWeaponIdForMode(id, mode);
   if (referenceID)
   {
      return WeaponSwizzle(id, referenceID, mode);
   }
   return FALSE;
}

BOOL CreatureWeaponCreate(ObjID id, int mode)
{
   if (!ObjHasWeaponOffset(id))
   {
      return FALSE;
   }

   CreatureWeaponAdd(id);
   // Find and swizzle to this weapon.
   int referenceID = GetWeaponIdForMode(id, mode);
   if (referenceID == OBJ_NULL)
   {
      Warning(("CreatureWeaponCreate: Invalid referenceID for Object '%d'\n", id));
      return FALSE;
   }
   return WeaponSwizzle(id, referenceID, mode);
}

void CreatureWeaponDestroy(ObjID id)
{
   if (!ObjHasWeaponOffset(id))
   {
      return;
   }
   
   sCreatureWeapon *pCW = CreatureWeaponGet(id);
   if (pCW)
   {
      LinkID linkID = (g_pCreatureAttachRelation->GetSingleLink(id, pCW->weaponObj));
      if (linkID)
      {
         g_pCreatureAttachRelation->Remove(linkID);
      }

	   CreatureDetachItem(id, pCW->weaponObj);
	   DestroyObject(pCW->weaponObj);
	   pCW->weaponObj = NULL;
      CreatureWeaponRem(id);
   }
   
   // Totally safety - yes it is crude.
   ClearWeaponOffsetCache();
}

#ifdef DEEPC
// EXTERN void ThrowObj(ObjID o, ObjID src);
static BOOL DoThrowObj(ObjID thrower, ObjID obj, float power)
{
   if (CreatureExists(obj))
   {
      mxs_matrix orien;
      mxs_vector launch_pos;
      mxs_vector launch_dir;
      mxs_angvec launch_fac;

      launch_fac = ObjPosGet(thrower)->fac;
      launch_fac.tx = 0;
      launch_fac.ty = 0;
      mx_ang2mat(&orien, &launch_fac);

      mx_copy_vec(&launch_dir, &orien.vec[0]);

      mx_scale_add_vec(&launch_pos, &ObjPosGet(thrower)->loc.vec, &launch_dir, 1.0);

      launch_dir.z = 2.0;

      ObjPosUpdate(obj, &launch_pos, &launch_fac);

      VALIDATE_CREATURE_POS(FALSE);

      CreatureMakeBallistic(obj, kCMB_Compressed);

      if (!PhysObjValidPos(obj, NULL))
      {
         CreatureMakeNonBallistic(obj);
         CreatureMakeNonPhysical(obj);

         VALIDATE_CREATURE_POS(TRUE);

         return FALSE;
      }

      VALIDATE_CREATURE_POS(TRUE);

      // Set the make-non-physical-on-sleep flag
      //#define REMOVE_ON_SLEEP
#ifdef REMOVE_ON_SLEEP
      cPhysTypeProp *pTypeProp;
      g_pPhysTypeProp->Get(obj, &pTypeProp);
      pTypeProp->remove_on_sleep = TRUE;
      g_pPhysTypeProp->Set(obj, pTypeProp);
#endif

      launchProjectile(thrower, obj, power / 6,PRJ_FLG_MASSIVE | PRJ_FLG_FROMPOS, NULL, &launch_dir, NULL);

      return TRUE;
   }
   else
   {
#ifdef NEW_NETWORK_ENABLED
      // @HACK: This really ought to wait until we see whether we have
      // successfully launched the thing before doing this. But the timing
      // of networking currently requires us to tell everyone that we're
      // physicalizing before we launch. We also need to super-hack this
      // with ForceContained, because otherwise the physicalize message
      // won't go through:
      PhysNetForceContainedMsgs(TRUE);
//      PhysRegisterSphereDefault(obj);
#endif

      BOOL launched = (launchProjectile(thrower,obj,power,PRJ_FLG_PUSHOUT|PRJ_FLG_MASSIVE,NULL,NULL,NULL) != OBJ_NULL);

#ifdef NEW_NETWORK_ENABLED
      PhysNetBroadcastObjPosByObj(obj);
      PhysNetForceContainedMsgs(FALSE);
#endif

      return launched;
   }
}

#endif // DEEPC

void CreatureWeaponDrop(ObjID id)
{
   if (ObjHasWeaponOffset(id))
   {
      sCreatureWeapon *pCW = CreatureWeaponGet(id);
      Assert_(pCW != NULL);

   // @TODO:  Bodisafa 12/7/1999
   // Game callback setup.

#ifdef DEEPC

      // Using Old & New for old & new weapon.
      IObjectQuery* query = AppGetObj(ITraitManager)->Query(pCW->weaponObj, kTraitQueryAllArchetypes);
      if (query && !query->Done())
      {
         // Grab Old's parent.
         query->Next();

         // We're at the top of the tree.  This should never happen.
         Assert_(!query->Done());

         // Grab the Old's parent object id.
         ObjID parentWeaponId = query->Object();
         
         // Create New as using Old's parent id.
         ObjID newWeaponId = BeginObjectCreate(parentWeaponId, kObjectConcrete);
         if (newWeaponId == OBJ_NULL)
         {
            Warning(("CreatureWeaponDrop: Failed to create throwing weapon object '%d'\n", newWeaponId));
            return;
         }
         EndObjectCreate(newWeaponId);
         
         // Throw New.
         DoThrowObj(id, newWeaponId, 0.5);
      }
      
      else
      {
         Warning(("CreatureWeaponDrop: No parent for weapon object '%d' \n", pCW->weaponObj));
      }

      // Get rid of Old.
      if (CreatureWeaponObjDestroy)
      {
         (*CreatureWeaponObjDestroy)(id);
      }

#else
      CreatureDetachItem(id, pCW->weaponObj);
      // throw_obj()
#endif // DEEPC
   }
}

///////////////////////
// warning
//   this has all essentially been desupported
//   in that the code above has changed to work in the real code
//   but none of this was changed for new calling conventions, names, etc...
// 
// Bodisafa 12/3/1999: This should be happy now.

#if 0

static void CreatureWeaponOutput(sCreatureAttachInfo *pInfo)
{
   mprintf("%g,%g,%g\n",pInfo->relTrans.mat.vec[0].x,pInfo->relTrans.mat.vec[0].y,pInfo->relTrans.mat.vec[0].z);
   mprintf("%g,%g,%g\n",pInfo->relTrans.mat.vec[1].x,pInfo->relTrans.mat.vec[1].y,pInfo->relTrans.mat.vec[1].z);
   mprintf("%g,%g,%g\n",pInfo->relTrans.mat.vec[2].x,pInfo->relTrans.mat.vec[2].y,pInfo->relTrans.mat.vec[2].z);
}

static int nWeaponObjId;

static sCreatureWeapon CreatureWeapon;

void CreatureWeaponSetObj(int nObjid)
{
   nWeaponObjId    = nObjid;
   CreatureWeapon.obj = nObjid;
}

void 
CreatureWeaponRotX(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Rotate X by %g\n",vD);
   sMxMatrix matrix;

   mx_copy_mat(&matrix,&(pInfo->relTrans.mat));
   mx_rot_x_mat_rad(&(pInfo->relTrans.mat),&matrix,(vD/180.0)*MX_REAL_PI);
   
   CreatureWeaponOutput(pInfo);   
}


void 
CreatureWeaponRotY(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Rotate Y by %g\n",vD);
   sMxMatrix matrix;

   mx_copy_mat(&matrix,&(pInfo->relTrans.mat));
   mx_rot_y_mat_rad(&(pInfo->relTrans.mat),&matrix,(vD/180.0)*MX_REAL_PI);
   
   CreatureWeaponOutput(pInfo);
}

void CreatureWeaponRotZ(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Rotate Z by %g\n",vD);
   sMxMatrix matrix;

   mx_copy_mat(&matrix,&(pInfo->relTrans.mat));
   mx_rot_z_mat_rad(&(pInfo->relTrans.mat),&matrix,(vD/180.0)*MX_REAL_PI);

   CreatureWeaponOutput(pInfo);
}

void CreatureWeaponTransX(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Translate X by %g\n",vD);
   pInfo->relTrans.vec.x += vD;
}

void CreatureWeaponTransY(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Translate Y by %g\n",vD);
   pInfo->relTrans.vec.y += vD;
}

void CreatureWeaponTransZ(float vD)
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   mprintf("Translate Z by %g\n",vD);
   pInfo->relTrans.vec.z += vD;
}

void
CreatureWeaponDump()
{
   sCreatureAttachInfo *pInfo = CreatureAttachmentGet(CreatureWeapon.obj, nWeaponObjId, 0);
   if (pInfo == NULL)
   {
      mprintf("No info\n");      
      return;

   }
   
   FILE *pFile = fopen("weapon.txt","a+");
   fprintf(pFile,"************************\n");
   fprintf(pFile,"%g,%g,%g\n",pInfo->relTrans.mat.vec[0].x,pInfo->relTrans.mat.vec[0].y,pInfo->relTrans.mat.vec[0].z);
   fprintf(pFile,"%g,%g,%g\n",pInfo->relTrans.mat.vec[1].x,pInfo->relTrans.mat.vec[1].y,pInfo->relTrans.mat.vec[1].z);
   fprintf(pFile,"%g,%g,%g\n",pInfo->relTrans.mat.vec[2].x,pInfo->relTrans.mat.vec[2].y,pInfo->relTrans.mat.vec[2].z);
   fprintf(pFile,"%g,%g,%g\n",pInfo->relTrans.vec.x,pInfo->relTrans.vec.y,pInfo->relTrans.vec.z);
   fclose(pFile);
}

#endif


// $Header: r:/t2repos/thief2/src/motion/motdmng_.h,v 1.3 2000/01/29 13:22:15 adurant Exp $
#pragma once

#ifndef __MOTDMNG__H
#define __MOTDMNG__H

#include <resapi.h>

typedef struct 
{
   int numEntries;
   ulong offset[1];
} MotDataCTable;

typedef IRes *MotDataHandle;

EXTERN MotDataHandle *motDataHandles;

#define MotDmngeIsLocked(mot_num) (motDataHandles[mot_num]!=NULL)
#define MotDmngeHandle(mot_num) (motDataHandles[mot_num])


#endif
#include <string.h>    // memset, apparently

#include <appagg.h>
#include <physapi.h>

#include <simtime.h>

#include <aiapi.h>     // ObjIsAI()

#include <objedit.h>
#include <hashset.h>
#include <hshsttem.h>
#include <crwpnlst.h>

#include <linkbase.h>
#include <lnkquery.h>
#include <crattach.h>
#include <objsys.h>

#include <dbmem.h>

#ifdef _MSC_VER
template cCreatureWeaponTableBase;
#endif

// core data structures
static cCreatureWeaponHash  gCreatureWeapons;

////////////////////////
// List Control

static BOOL _CreatureWeaponRecentlyExisted(ObjID obj)
{
   // will want to store off recently killed objs
   // and return whether this object is in the list
   return FALSE;
}

// core setup for creature weapons.
void CreatureWeaponInitStruct(sCreatureWeapon *pCW)
{
   memset(pCW, 0, sizeof(sCreatureWeapon));
}

////////////////////////////////
// internal api to rest of CreatureWeapon.

sCreatureWeapon *CreatureWeaponGet(ObjID obj)
{
   return gCreatureWeapons.Search(obj);
}

// actual add/remove of creatures from the creature weapon hash.
void CreatureWeaponAdd(ObjID obj)
{
   if (obj < 0)
   {
      Warning(("CreatureWeaponAdd: got a negative object %s?\n", ObjWarnName(obj)));
      return;
   }
   
   if (CreatureWeaponGet(obj))
   {
      return;
   }
   sCreatureWeapon  *pCW = new sCreatureWeapon;
   CreatureWeaponInitStruct(pCW);
   pCW->obj        = obj;
   gCreatureWeapons.Insert(pCW);
}

extern IRelation *g_pWeaponOffsetRelation;
void CreatureWeaponRem(ObjID obj)
{
   sCreatureWeapon *pCW=gCreatureWeapons.RemoveByKey(obj);
   
   if (pCW)
   {
      delete pCW;
   }
   else
   {
      if (!_CreatureWeaponRecentlyExisted(obj))
      {
         Warning(("CreatureWeaponRem: %s not found in hash\n",ObjWarnName(obj)));
      }
   }
      // in debug full spew, might want to warn here anyway
}

// remove all weapons for all creatures.
void CreatureWeaponRemoveWeapons(void)
{
   if (CreatureWeaponObjCreate == NULL)
   {
      return;  // cause if we cant create, this is all pretty silly
   }

   tHashSetHandle cwIter;
   sCreatureWeapon *pGR=gCreatureWeapons.GetFirst(cwIter);
   while (pGR)
   {
      if (pGR->nWeapon != -1)
      {
         (*CreatureWeaponObjDestroy)(pGR->obj);
      }
      pGR=gCreatureWeapons.GetNext(cwIter);
   }
}

////////////////////////////////
// dumb code to memory clean up on destroy

void CreatureWeaponListEmptyAndFree(void)
{
#ifdef WARN_ON
   int count = gCreatureWeapons.GetCount();
   if (count)
   {
      Warning(("CreatureWeapons still has %d members\n", count));
   }
#endif

   tHashSetHandle cwIter;
   sCreatureWeapon *pCW=gCreatureWeapons.GetFirst(cwIter);
   while (pCW)
   {
      CreatureWeaponRem(pCW->obj);
      pCW=gCreatureWeapons.GetNext(cwIter);
   }
}

////////////////
// init/term/reset

void CreatureWeaponListInit(void)
{
}

void CreatureWeaponListTerm(void)
{
   CreatureWeaponListEmptyAndFree();

#ifdef WARN_ON
   int count =gCreatureWeapons.GetCount();
   if (count)
   {
      Warning(("CreatureWeaponHash post empty has %d members\n",count));
   }
#endif

   gCreatureWeapons.DestroyAll();
}

void CreatureWeaponListReset(void)
{
   CreatureWeaponListTerm();  // for now, cause this is easy...
}

// $Header: r:/t2repos/thief2/src/motion/motmngr.h,v 1.3 2000/01/29 13:22:16 adurant Exp $
#pragma once

#ifndef __MOTMNGR_H
#define __MOTMNGR_H

/////////
//
// This is the motion manager module.  
// It's just a little game-independent module
// responsible for instantiating the motion set, providing commands for
// rebuilding the motion database etc.
//
// Basically, all non-object-specific, non-maneuver-specific,
// non-game-specific motion stuff goes in here.
//

EXTERN void MotionManagerInit();
EXTERN void MotionManagerClose();
EXTERN void MotionManagerReset();
EXTERN void MotionManagerLoad();

#ifdef __cplusplus

#include <motset.h>
#include <dynarray.h>
#include <motdb.h>

EXTERN IMotionSet *g_pMotionSet;

EXTERN cMotionDatabase *g_pMotionDatabase;

// include maneuver factory set in here, too, since why not.
// doesn't seem worthy of its own module
//
typedef class cManeuverFactory cManeuverFactory;
typedef cDynArray<cManeuverFactory *> cManeuverFactoryList;

EXTERN cManeuverFactoryList g_ManeuverFactoryList;


#endif // CPLUSPLUS


#endif // MOTMNGR
// Creature Weapon loop client, including save/load
//

#include <mprintf.h>
#include <config.h>
#include <appagg.h>
#include <loopmsg.h>
#include <loopapi.h>  // for CreateSimpleLoopClient
#include <netloop.h>
#include <dbasemsg.h>
#include <dispatch.h>
#include <dispbase.h>
#include <objremap.h>
#include <vernum.h>
#include <objedit.h>  // for ObjEditName()
#include <iobjsys.h>
#include <physloop.h> // for LOOPID_Physics
#include <simtime.h>  // for GetSimTimeFrame()
#include <netman.h>   // INetMan

#include <crwpnapi.h>
#include <crwpnlst.h>

#include <initguid.h>
#include <crwpnlup.h>

#include <dbmem.h>

//////////
//
// LOOP CLIENT
//

// State record for use by the ghost loop client
// Currently unused, but since it was in the boilerplate, I decided to
// keep it in case we want it later:
typedef struct _StateRecord
{
   int dummy;  // placeholder
} StateRecord;

static void CreatureWeapon_db_message(DispatchData *msg)
{
   msgDatabaseData data;
   data.raw = msg->data;

   switch (DB_MSG(msg->subtype))
   {
      case kDatabaseReset:
      {
         CreatureWeaponListTerm();
         break;
      }
      
      case kDatabaseLoad:
      case kDatabasePostLoad:
      case kDatabaseSave:
      {
         break;
      }
   }
}

static eLoopMessageResult LGAPI _LoopFunc(void* data, 
                                          eLoopMessage msg, 
                                          tLoopMessageData hdata)
{
   // useful stuff for most clients
   eLoopMessageResult result = kLoopDispatchContinue; 
   StateRecord* state = (StateRecord*)data;
   LoopMsg info;
   info.raw = hdata;

   switch(msg)
   {
      case kMsgAppInit:
      {
         CreatureWeaponInit();
         break;
      }
      case kMsgAppTerm:
      {
         CreatureWeaponTerm();
         break;
      }
      case kMsgNormalFrame:
      {
         break;
      }
      case kMsgDatabase:
      {
         CreatureWeapon_db_message(info.dispatch);
         break;
      }
      case kMsgEnd:
      {
         delete state;
         break;   
      }
   }
   return result;
}

// Factory function for our loop client.
static ILoopClient* LGAPI _CreateClient(sLoopClientDesc * pDesc,
                                        tLoopClientData data)
{
   // allocate space for our state, and fill out the fields
   StateRecord* state = new StateRecord;

   return CreateSimpleLoopClient(_LoopFunc,state,&CreatureWeaponLoopClientDesc);
}

// The public loop client descriptor
// used by loopapp.c
sLoopClientDesc CreatureWeaponLoopClientDesc =
{
   &LOOPID_CreatureWeapon,
   "CreatureWeapon Client",
   kPriorityNormal,              
   kMsgDatabase | kMsgsMode | kMsgsAppOuter | kMsgsFrameMid | kMsgEnd, // interests 

   kLCF_Callback,
   _CreateClient,
   
   NO_LC_DATA,

   {
//      {kConstrainAfter,  &LOOPID_Physics, kMsgsAppOuter },
//      {kConstrainBefore, &LOOPID_Physics, kMsgsFrame },
//      {kConstrainAfter,  &LOOPID_Network, kMsgsFrame },
      {kNullConstraint}
   }
};
// $Header: r:/t2repos/thief2/src/motion/motprop.h,v 1.8 2000/01/29 13:22:17 adurant Exp $
#pragma once

#ifndef __MOTPROP_H
#define __MOTPROP_H

#include <property.h>
#include <mschtype.h>
#include <label.h>
#include <mclntapi.h>

// This defines all of the motion system properties - actor, motor controller,
// phys characteristics etc.

// actor taglist

#define PROP_ACTOR_TAG_LIST_NAME "MotActorTagList"

#define kActorTagStringSize 800

struct sMotActorTagList
{
   char m_TagStrings[kActorTagStringSize];
};


F_DECLARE_INTERFACE(IMotActorTagListProperty);
#undef INTERFACE
#define INTERFACE IMotActorTagListProperty

DECLARE_PROPERTY_INTERFACE(IMotActorTagListProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sMotActorTagList*);
};


// 
// 'Motor Controller' Property
//

#define PROP_MOTOR_CONTROLLER_NAME "MotorController"

typedef int eMotorControllerType; // actual enum is app-specific

//
//  TimeWarp property
//

#define PROP_TIMEWARP_NAME "TimeWarp"

//
//   SwordAction property 
//

#define PROP_SWORD_ACTION_NAME "SwordActionType"

//
// Player Limbs Position Offsets Property
//

#define PROP_PLAYER_LIMB_OFFSETS_NAME "MotPlyrLimbOff"

typedef struct {
   mxs_vector armPosOff;
   mxs_vector armAngDegrees;
} sMPlayerLimbOffsets;

F_DECLARE_INTERFACE(IMotPlayerLimbOffsetsProperty);
#undef INTERFACE
#define INTERFACE IMotPlayerLimbOffsetsProperty

DECLARE_PROPERTY_INTERFACE(IMotPlayerLimbOffsetsProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sMPlayerLimbOffsets*);
};


// 
// 'Phys Limitations' Property
//

#define PROP_MOT_PHYS_LIMITS_NAME "MotPhysLimits"

// XXX TO DO: make this use something more real
typedef struct {
   int foo[2];
} sMotPhysLimits;

F_DECLARE_INTERFACE(IMotPhysLimitsProperty);
#undef INTERFACE
#define INTERFACE IMotPhysLimitsProperty

DECLARE_PROPERTY_INTERFACE(IMotPhysLimitsProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sMotPhysLimits*);
};



//
// 'Gait Description' Property
//

#define PROP_MOT_GAIT_DESC_NAME "MotGaitDesc"

F_DECLARE_INTERFACE(IMotGaitDescProperty);
#undef INTERFACE
#define INTERFACE IMotGaitDescProperty

DECLARE_PROPERTY_INTERFACE(IMotGaitDescProperty)
{
   DECLARE_UNKNOWN_PURE();
   DECLARE_PROPERTY_PURE();
   DECLARE_PROPERTY_ACCESSORS(sMGaitSkillData*);
};


//
// Functions
//

EXTERN void CoreMotionPropsInit();

EXTERN void CoreMotionPropsShutdown();

EXTERN void MotorControllerPropInit(char **motControllerNames,int nMotControllers);

EXTERN BOOL ObjGetMotControllerID(ObjID obj, int *pID);

EXTERN BOOL ObjGetTimeWarp(ObjID obj, float *pWarp);

EXTERN BOOL ObjGetSwordActionType(ObjID obj, int *pType);

EXTERN BOOL ObjGetGaitData(ObjID obj, sMGaitSkillData **pData);

EXTERN BOOL ObjGetActorTagList(ObjID obj, sMotActorTagList **pData);

EXTERN BOOL ObjGetPlayerPosOffsets(ObjID obj, mxs_vector *pPosOff, mxs_angvec *pAngOff);

#endif
// $Header: r:/t2repos/thief2/src/motion/mschutil.h,v 1.6 2000/01/29 13:22:18 adurant Exp $
#pragma once

#ifndef __MSCHUTIL_H
#define __MSCHUTIL_H

#ifdef __cplusplus

#include <motdbtyp.h>
#include <mschtype.h>

// motion schema utilities for getting data associated with schemas and their
// archetypes, including game-assigned data.  This is a "glue" file, and different
// apps may want to have different versions.

EXTERN BOOL MSchUGetGaitData(const cMotionSchema *pSchema,sMGaitSkillData **pData);

EXTERN BOOL MSchUGetSwordActionType(const cMotionSchema *pSchema, int *pType);

EXTERN BOOL MSchUGetMotControllerID(const cMotionSchema *pSchema, int *pID);

EXTERN BOOL MSchUGetPlayerSkillData(const cMotionSchema *pSchema, sMPlayerSkillData *pSkillData);

EXTERN BOOL MSchUGetPlayerPosOffset(const cMotionSchema *pSchema, mxs_vector *pPosOff, mxs_angvec *pAngOff);

#endif // cplusplus

#endif
// $Header: r:/t2repos/thief2/src/motion/mschyacc.h,v 1.2 2000/01/29 13:22:19 adurant Exp $
#pragma once

#ifndef __MSCHYACC_H
#define __MSCHYACC_H

EXTERN void MotSchemaYaccParse(char *schemaFile);
EXTERN void MotSchemaYaccCount(char *schemaFile, int *schemaCount, 
                            int *sampleCount, int *sampleCharCount);
#endif


// $Header: r:/t2repos/thief2/src/motion/mskilset.h,v 1.14 2000/01/29 13:22:20 adurant Exp $
#pragma once

#ifndef __MSKILSET_H
#define __MSKILSET_H

#ifdef __cplusplus ///////////////

#include <mctype.h>
#include <mctype_.h>
#include <motschem.h>
#include <tagdbin.h>
#include <motrtype.h>


class cMSkillSet
{
public:
   cMSkillSet() { m_ActorType=-1; }
   virtual ~cMSkillSet() {}

   void SetActorType(int type);

   // these are tags to be applied to every motion request
   void SetPersistentTags(const cTagSet *pTags);

   cMotionPlan *BuildPlanFromParams(const sMcMoveParams *pParams, \
      const sMcMotorState *pMotorState, const sMcMoveState *pMoveState, \
      IMotor *pMotor, cMotionCoordinator *pCoord);

   void Pose(const cTagSet *pTags, float frac, IMotor *pMotor);

private:
   int                  m_ActorType;
   cTagSet              m_PersistTags;
};

#endif // cplusplus

#endif
// $Header: r:/t2repos/thief2/src/motion/mskltree.h,v 1.2 2000/01/29 13:22:21 adurant Exp $
#pragma once

#ifndef __MSKLTREE_H
#define __MSKLTREE_H

typedef class cMSkillTree cMSkillTree;
typedef class cMSkillTreeNode cMSkillTreeNode;

// XXX can add different node type if want bigger key

typedef ulong tMSkillKey;
typedef struct sMSkillKeyDesc sMSkillKeyDesc;

struct sMSkillKeyDesc
{
   int nValues;
   uchar *pValues;
};

class cMSkillTree
{
public:

   cMSkillTree(const int bitsPerLevel, const int maxDepth); // XXX Assert if > sizeof(long)
   cMSkillTree(const cMSkillTree& atree); // copy constructor
   ~cMSkillTree();

   tMSkillKey BuildKey(const sMSkillKeyDesc& keyDesc);
   void InsertData(const void *dataPtr, const tMSkillKey key);
   void *GetData(const tMSkillKey key);

   int GetWildValue() const { return m_MaxEntriesPerLevel; } // the value to pass in to
                                                    // keydesc when
                                                    // any value is fine.

private:

   const int m_BitShift;
   const int m_MaxEntriesPerLevel;
   const int m_MaxDepth;
   cMSkillTreeNode *m_pHead;

};

#endif
// $Header: r:/t2repos/thief2/src/motion/mcoord.cpp,v 1.24 1999/03/02 20:18:20 mwhite Exp $
////
// XXX need to deal reasonably with maneuvers getting aborted and still 
// getting accurate end move state (can't just have delete call notify about
// completion because in setmotor and setcurrent want to delete both current
// and next).  Should velocity be stored with motor after all?
//
// XXX should figure out whether to build skill set at motor setting or
// coordinator creation or somewhere completely different.  currently set
// when motor is set.

#include <mcoord.h>
#include <mmanuver.h>
#include <mskilset.h>
#include <cfgdbg.h>
#include <config.h>
#include <tagfile.h>
#include <motmngr.h>

// must be last header
#include <dbmem.h>


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//
//              GLOBAL FUNCTIONS
//
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


IMotionCoordinator *MotSysCreateMotionCoordinator()
{
   return new cMotionCoordinator;
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//
//              MOTION COORDINATOR CONSTRUCTOR/DESTRUCTOR
//
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

cMotionCoordinator::cMotionCoordinator() :
m_pMotor(NULL),
m_pCurrentManeuver(NULL),
m_pNextManeuver(NULL)
{
   ClearInterMnvrState();

   m_MotorStateChangeCallback=NULL;
   m_MotorStateChangeCallbackContext=NULL;
   m_ManeuverCompletionCallback=NULL;
   m_ManeuverCompletionCallbackContext=NULL;
   m_InMotorFrame=FALSE;
   m_ManeuverCompleted=FALSE;
   m_CanInterrupt=FALSE; 

   memset(&m_NextMoveState,0,sizeof(m_NextMoveState));
}

cMotionCoordinator::~cMotionCoordinator()
{
   if(m_pCurrentManeuver)
   {
      if(m_ManeuverCompletionCallback)
      {
         (*m_ManeuverCompletionCallback)(m_ManeuverCompletionCallbackContext,m_pCurrentManeuver,NULL);
      }
      delete m_pCurrentManeuver;
      m_pCurrentManeuver=NULL;
   }
   if(m_pNextManeuver)
   {
      delete m_pNextManeuver;
      m_pNextManeuver=NULL;
   }
   if(m_pMotor)
   {
      m_pMotor->SetMotorResolver(NULL);
   }
}


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//
//              MOTION COORDINATOR INTERFACE FUNCTIONS
//
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

// detatch from old motor
void cMotionCoordinator::EndMotor(IMotor *pMotor)
{
   if(m_pMotor)
   {
      m_pMotor->SetMotorResolver(NULL);
      m_pMotor=NULL;
   }
}

void cMotionCoordinator::StartMotor(IMotor *pMotor)
{
   m_pMotor=pMotor;

   ClearInterMnvrState();
   if(pMotor)
   {
      pMotor->SetMotorResolver((IMotorResolver *)this);
      m_SkillSet.SetActorType(pMotor->GetActorType());

      pMotor->GetTransform(&m_NextMoveState.position,&m_NextMoveState.facing);
      m_NextMoveState.speed=0;
      m_NextMoveState.direction=m_NextMoveState.facing;
   }

   // get rid of existing maneuvers, since they have wrong pMotor
   if(m_pCurrentManeuver)
   {
      m_pCurrentManeuver->SetMotor(NULL);
      if(m_ManeuverCompletionCallback)
      {
         (*m_ManeuverCompletionCallback)(m_ManeuverCompletionCallbackContext,m_pCurrentManeuver,NULL);
      }
      delete m_pCurrentManeuver;
      m_pCurrentManeuver=NULL;
   }
   if(m_pNextManeuver)
   {
      m_pNextManeuver->SetMotor(NULL);
      delete m_pNextManeuver;
      m_pNextManeuver=NULL;
   }
}

void cMotionCoordinator::SetPersistentTags(const cTagSet *pTags)
{
   if(!pTags)
   {
      m_SkillSet.SetPersistentTags(NULL);
      return;
   }
   m_SkillSet.SetPersistentTags(pTags);
}

IMotionPlan *cMotionCoordinator::BuildPlan(const sMcMoveState *pStartState, const sMcMoveParams *pParams)
{
   Assert_(m_pMotor);

#ifndef SHIP
   if(config_is_defined("MCoordTrace"))
   {
      mprintf("%d: ",m_pMotor->GetObjID()); // rest of spew done by mskilset
   }
#endif

   return m_SkillSet.BuildPlanFromParams(pParams,&m_MotorState,pStartState,m_pMotor,this);
}

void cMotionCoordinator::Pose(const cTagSet *pTags, float frac)
{
   m_SkillSet.Pose(pTags,frac,m_pMotor);
}

// 
eMCoordStatus cMotionCoordinator::GetStatus() const
{
   eMCoordStatus status;

   if(!m_pCurrentManeuver)
      status=kMCoord_Idle;
   else if(m_CanInterrupt)
      status=kMCoord_ActiveInterrupt;
   else
      status=kMCoord_ActiveBusy;
#ifndef SHIP
   if(status!=kMCoord_ActiveBusy && m_pMotor)
   {
      ConfigSpew("MnvrTrace",("%d Telling Client that Coord is interruptable\n",m_pMotor->GetObjID()));
   }
#endif
   return status;
}

void cMotionCoordinator::NotifyAboutManeuverCompletion(IManeuver *pMnvr, sMcMoveState& endState)
{
   AssertMsg(pMnvr==m_pCurrentManeuver,"weird coordinator maneuver");

   m_CanInterrupt=FALSE; // reset, since this is what old maneuver told us
   if(InMotorFrame())
   {
      m_ManeuverCompleted=TRUE;
      m_NextMoveState=endState;
   } else
   {
      StartNextManeuver();
   }
}

void cMotionCoordinator::StartNextManeuver()
{
   if(m_ManeuverCompletionCallback)
   {
      (*m_ManeuverCompletionCallback)(m_ManeuverCompletionCallbackContext,m_pCurrentManeuver,m_pNextManeuver);
   }

   delete m_pCurrentManeuver;

   if(m_pNextManeuver)
   {
      m_pCurrentManeuver=m_pNextManeuver;
      m_pNextManeuver=NULL;

// XXX need to figure out how this should work for real
//      m_pCurrentManeuver->GetExpectedEndMoveState(m_NextMoveState);
      m_pCurrentManeuver->Execute();
   } else
   {
      m_pCurrentManeuver=NULL;
   }
}

// Get rid of stored up maneuvers, since they were built under false pretenses
void cMotionCoordinator::NotifyAboutMotorStateChange()
{
   // this interrupts saveload.  hmm.  Not really important for already-executing
   // maneuver.  Just get rid of next one.  KJ 10/98
#if 0
   if(m_pCurrentManeuver)
   {
      if(m_ManeuverCompletionCallback)
      {
         (*m_ManeuverCompletionCallback)(m_ManeuverCompletionCallbackContext,m_pCurrentManeuver,NULL);
      }
      delete m_pCurrentManeuver;
      m_pCurrentManeuver=NULL;
   }
#endif
   if(m_pNextManeuver)
   {
      delete m_pNextManeuver;
      m_pNextManeuver=NULL;
   }
   // notify client, if callback was provided
   if(m_MotorStateChangeCallback)
      m_MotorStateChangeCallback(m_MotorStateChangeCallbackContext);
}

void cMotionCoordinator::NotifyAboutMotorDestruction()
{
   // don't want to end current motor, since invalid.  just
   // start the NULL one directly instead of calling SetMotor(NULL)
   StartMotor(NULL);
}

// Used to set the maneuver to be executed when the currently executing one is
// completed.  This is necessary because maneuver completion may occur between
// client NeedManeuver calls.  If no next maneuver is set, the coordinator will
// do nothing once te current one is completed until a maneuver is set.
//
void cMotionCoordinator::SetNextManeuver(IManeuver *pMnvr)
{
   if(!m_pCurrentManeuver)
   {
      m_pCurrentManeuver=pMnvr;
      if(!pMnvr)
         return;
//      m_pCurrentManeuver->GetExpectedEndMoveState(m_NextMoveState);
      AssertMsg(m_pMotor,"Cannot do maneuver without a motor");
      ConfigSpew("MnvrTrace",("Starting Maneuver\n"));
      m_pCurrentManeuver->Execute();
   } else
   {
      if(m_pNextManeuver)
         delete m_pNextManeuver;
      m_pNextManeuver=pMnvr;
   }
}

// Used when the client wants to interrupt the currently executing maneuver with
// a new one, instead of making the new maneuver get executed when the current
// one is done.   
//
void cMotionCoordinator::SetCurrentManeuver(IManeuver *pMnvr)
{
   if(m_pCurrentManeuver)
   {
      // tell current maneuver to finish executing, so it can do whatever
      // cleanup it needs to, and can store off state for next maneuver.
      // @NOTE: many maneuvers to motion stopping, defocusing etc in
      // destructor, not on finish, though Finish really is the right place
      // for them.

      m_pCurrentManeuver->Finish();

      if(m_ManeuverCompletionCallback)
      {
         (*m_ManeuverCompletionCallback)(m_ManeuverCompletionCallbackContext,m_pCurrentManeuver,pMnvr);
      }
      delete m_pCurrentManeuver;
   }

   m_pCurrentManeuver=pMnvr;

   if(m_pNextManeuver)
   {
      delete m_pNextManeuver;
      m_pNextManeuver = NULL;
   }
//   m_pCurrentManeuver->GetExpectedEndMoveState(m_NextMoveState);
   if(m_pCurrentManeuver)
   {
      AssertMsg(m_pMotor,"Cannot do maneuver without a motor");
      ConfigSpew("MnvrTrace",("Starting Maneuver\n"));
      m_pCurrentManeuver->Execute();
   }
}

// Used to get expected client state at the end of the currently executing 
// maneuver.  This state should be used for new plan building.
//
const sMcMoveState *cMotionCoordinator::GetNextEndState() const
{
   return &m_NextMoveState;
}

// NOTE: if controller ids change, some person should invalidate save games
void cMotionCoordinator::Load(ITagFile *pTagFile)
{
   // should only be called on pristine motion coordinator
   AssertMsg(!m_pCurrentManeuver&&!m_pNextManeuver,"loading game over busy motion coordinator!");

   // read inter-maneuver state
   ITagFile_Move(pTagFile,(char *)&m_MotorState,sizeof(m_MotorState));
   // @TODO: swizzle schema id

   // read controller id for currently executing maneuver.
   // if -1, then not doing maneuver currently
   int cid;
   ITagFile_Move(pTagFile,(char *)&cid,sizeof(cid));
   if(cid>=0)
   {
      IManeuver *pCurMan=g_ManeuverFactoryList[cid]->LoadManeuver(m_pMotor,this,pTagFile);
      m_pCurrentManeuver=pCurMan;
   }
   // @NOTE: next maneuver info not saved.  currently never used KJ 10/98
}

// @NOTE: this doesn't save nextmaneuver info.  Could add if we need it. KJ 
void cMotionCoordinator::Save(ITagFile *pTagFile)
{
   // write out inter-maneuver state
   ITagFile_Move(pTagFile,(char *)&m_MotorState,sizeof(m_MotorState));

   // write out controllers for maneuvers
   int cid=-1;
   if(m_pCurrentManeuver)
   {
      cid=m_pCurrentManeuver->GetAppData();      
      ITagFile_Move(pTagFile,(char *)&cid,sizeof(cid));
      m_pCurrentManeuver->Save(pTagFile);
   } else
   {
      ITagFile_Move(pTagFile,(char *)&cid,sizeof(cid));
   }
}


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
//
//              MOTOR RESOLVER FUNCTIONS
//
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////

void cMotionCoordinator::CalcEnvironmentEffect()
{
}

void cMotionCoordinator::CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel)
{
   if(m_pCurrentManeuver)
   {
      m_pCurrentManeuver->CalcCollisionResponse(pForces,nForces,pCurrentVel,pNewVel);
   } else
   {
      AssertMsg(FALSE,"Collision but no maneuver!");
      *pNewVel=*pCurrentVel;
   }
}

void cMotionCoordinator::NotifyAboutBeingStuck()
{
   AssertMsg(m_pCurrentManeuver,"no maneuver but got stuck!");

   if(m_pCurrentManeuver)
      m_pCurrentManeuver->NotifyAboutBeingStuck();
}

void cMotionCoordinator::NotifyAboutMotionAbortRequest()
{
   if(m_pCurrentManeuver)
      m_pCurrentManeuver->NotifyAboutMotionAbortRequest();
   else
      Warning(("MCoord: no current maneuver but told to abort!\n"));
}

void cMotionCoordinator::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   AssertMsg(m_pCurrentManeuver,"no maneuver but motion was playing!");

   if(m_pCurrentManeuver)
   {
      m_pCurrentManeuver->NotifyAboutMotionEnd(motionNum, frame, flags);
   }
}

//
// Motion status notification functions
//
void cMotionCoordinator::NotifyAboutFrameUpdateBegin()
{
   m_CanInterrupt=FALSE; // reset, since is instant

   m_InMotorFrame=TRUE;
}

void cMotionCoordinator::NotifyAboutFrameUpdateEnd()
{
   m_InMotorFrame=FALSE;
   if(m_ManeuverCompleted)
   {
      StartNextManeuver();
      m_ManeuverCompleted=FALSE;
   }
}

void cMotionCoordinator::NotifyAboutFrameFlags(const int flags)
{
   if(m_pCurrentManeuver)
      m_pCurrentManeuver->NotifyAboutFrameFlags(flags);
}

// this only lasts for one frame, so "instantaneously interruptable"
void cMotionCoordinator::NotifyThatCanInterrupt()
{
   ConfigSpew("MnvrTrace",("%d Coord is interruptable\n",m_pMotor->GetObjID()));
   m_CanInterrupt=TRUE;
}
// $Header: r:/t2repos/thief2/src/motion/motdb.cpp,v 1.14 1999/12/27 15:24:35 BODISAFA Exp $

#include <motdb.h>
#include <osystype.h>
#include <tagdbkey.h>
#include <tagdbkst.h>
#include <motmngr.h>
#include <mschyacc.h>
#include <cfgdbg.h>
#include <config.h>
#include <schfile.h>
#include <motdb_.h>
#include <motdbase.h>

#include <dbmem.h> // must be last included header


///////////////////////////////////////////////////////
//
// cMotionDatabase implementation
//
///////////////////////////////////////////////////////

cMotionDatabase::cMotionDatabase()
   : m_Remap(&m_TagNameMap, NULL)
{
   m_nActors=0;
   m_pDatabase=NULL;
}

cMotionDatabase::~cMotionDatabase()
{
   if(m_pDatabase)
      delete m_pDatabase;
}

void cMotionDatabase::Clear()
{
   if(m_pDatabase)
   {
      delete m_pDatabase;
      m_pDatabase=NULL;
   }
   m_nActors=0;
   m_RawResult.Clear();
   m_NameMap.Clear();
   m_TagNameMap.Clear();
   m_Remap.Clear();
   m_SchemaSet.SetSize(0);
}


void cMotionDatabase::TokenLocalToGlobal(cTagDBKey *pKey)
{
   sTagRemap Remap(pKey->m_KeyType, 0, 0, 0);
   m_Remap.LocalToGlobal(&Remap, TRUE);
   pKey->m_KeyType = Remap.m_GlobalType;
}


void cMotionDatabase::TokenGlobalToLocal(cTagDBKey *pKey)
{
   sTagRemap Remap(0, 0, pKey->m_KeyType, 0);
   m_Remap.GlobalToLocal(&Remap, TRUE);
   pKey->m_KeyType = Remap.m_LocalType;
}

BOOL cMotionDatabase::GetSchema(int index, cMotionSchema **ppSchema)
{
   if ((index < 0) || (index >= m_SchemaSet.Size()))
   {
      *ppSchema = NULL;
      return FALSE;
   }

   *ppSchema = &m_SchemaSet[index];
   return TRUE;
}

// database query
BOOL cMotionDatabase::GetBestMatch(int actor, cTagDBInput *pInput, cMotionSchema **ppSchema, eMotDBMatchType matchType)
{
   cMotionSchema *pSchema=NULL;
   int size;

   if(!m_pDatabase)
      return FALSE;

   m_RawResult.Clear();
   if(!m_pDatabase->GetMatches(actor,pInput,&m_RawResult)) // this not ordered
      return FALSE;

   if((size=m_RawResult.Size())==0)
      return FALSE;

   if(size==1) // return the only match
   {
      *ppSchema=&m_SchemaSet[m_RawResult[0].m_iData];
      return TRUE;
   }

   // choose schema depending on match type
   switch(matchType)
   {
      case kMMT_AbsoluteBest:
      {
         // select schema with highest weight
         // @TODO: figure out what is best thing to do with
         // equally weighted results.  Do we always want to choose
         // same one?  It's weird to have which one gets chosen depend
         // on vagaries of tagdb implementation
         int i,best=-1,count=0;
         float bestWeight=-1.0;

         for(i=0;i<size;i++)
         {
#ifdef DBG_ON
            if(m_RawResult[i].m_fWeight==bestWeight)
            {
               count++;
            }
#endif
            if(m_RawResult[i].m_fWeight<=bestWeight)
               continue;
            best=i;
            count=1;
            bestWeight=m_RawResult[i].m_fWeight;
         }
         Assert_(best>=0);
#ifdef DBG_ON
         if(count!=1)
            ConfigSpew("MotDBTrace",("GetBestMatch: No absolute best - %d schemas have same weight\n",count));
#endif
         pSchema=&m_SchemaSet[m_RawResult[best].m_iData];
         break;
      }
      case kMMT_WeightedDither:
      {
         // sort output by weight, choose a random number between 
         // zero and sum of weights of all output, 
         // and iterate over sorted output
         // until sum of weights = chosen number
         // @TODO: implement this if it's really what we want
         // NOTE: this implementation chooses equally between
         // equally weighted schemas.
         AssertMsg(FALSE,"Motion Database weighted dither match not implemented yet");
         return FALSE;
      }
   }

   // convert raw result to schemas
   *ppSchema=pSchema;
   return TRUE;
}

// These ridiculous wrappers are the entry point for our swizzling,
// since we can't get at our 
static cMotionDatabase *g_pSwizzleDatabase;

static void GlobalToLocal(cTagDBKey *pKey)
{
   g_pSwizzleDatabase->TokenGlobalToLocal(pKey);
}

static void LocalToGlobal(cTagDBKey *pKey)
{
   g_pSwizzleDatabase->TokenLocalToGlobal(pKey);
}

////////////////////////////////////////////////////////////

#ifdef EDITOR
// construct database
BOOL cMotionDatabase::BuildFromAscii()
{
   Clear();

   // need to setup motionset for build
   g_pMotionSet->StartBuild();

   SchemaFilesLoadFromDir("mschema","*.def",MotSchemaYaccParse);   
   SchemaFilesLoadFromDir("mschema","*.mtg",MotSchemaYaccParse);   

   // retokenize w/global mapping
   g_pSwizzleDatabase = this;
   m_pDatabase->Swizzle(LocalToGlobal);
   m_pDatabase->SwizzleRequiredFlags(&m_Remap);

   // let motion set know we are done building
   g_pMotionSet->EndBuild();

   // setup runtime data now that motion set is built
   int nSchemas=m_SchemaSet.Size(),i;
   cMotionSchema *pSch;

   for(i=0;i<nSchemas;i++)
   {
      pSch=&m_SchemaSet[i];
      Assert_(pSch);
      pSch->SetupRunTimeData(&m_NameMap);
   }

   return FALSE;
}
#endif

BOOL cMotionDatabase::Load(ITagFile *pFile)
{
   ulong num;
   int i;

   // load name maps
   m_NameMap.Load(pFile);
   m_TagNameMap.Load(pFile);

   // load tag database
   ITagFile_Read(pFile, (char *)&num, sizeof(num));
   m_nActors=num;
   m_pDatabase=NewIFancyTagDatabase(m_nActors);
   m_pDatabase->Load(pFile);
   g_pSwizzleDatabase = this;
   m_pDatabase->Swizzle(LocalToGlobal);
   m_pDatabase->SwizzleRequiredFlags(&m_Remap);

   // load schemas
   ITagFile_Read(pFile, (char *)&num, sizeof(num));
   m_SchemaSet.SetSize(num);
   for(i=0;i<num;i++)
   {
      m_SchemaSet[i].Load(pFile,&m_NameMap);      
   }

   return TRUE;
}

#ifdef EDITOR
BOOL cMotionDatabase::Save(ITagFile *pFile)
{
   ulong num;
   int i;

   // Save name maps
   m_NameMap.Save(pFile);
   m_TagNameMap.Save(pFile);

   // Save tag database
   num=m_nActors;
   ITagFile_Write(pFile, (char *)&num, sizeof(num));
   g_pSwizzleDatabase = this;
   m_pDatabase->Swizzle(GlobalToLocal);
   m_pDatabase->Save(pFile);
   m_pDatabase->Swizzle(LocalToGlobal);

   // Save schemas
   num=m_SchemaSet.Size();
   ITagFile_Write(pFile, (char *)&num, sizeof(num));
   for(i=0;i<num;i++)
   {
      m_SchemaSet[i].Save(pFile);      
   }

   return TRUE;
}
#endif

//////////////////////////////////////////////////////////////////
//
// DATABASE BUILDING UTILITIES
//
//////////////////////////////////////////////////////////////////

void cMotionDatabase::CreateTagDatabase(int nActors)
{
   m_nActors=nActors;
   if(m_pDatabase)
      delete m_pDatabase;
   m_pDatabase=NewIFancyTagDatabase(m_nActors);
   Assert_(m_pDatabase);
}

void cMotionDatabase::RegisterTag(const Label *pName, const sTagInfo *pInfo)
{
   // check that tag not already registered. 
   int index=m_TagNameMap.IDFromName(pName);
   if(index==kNameMapIndexNotFound)
   {
      // register tag
      Assert_(m_pDatabase);
      int h=m_pDatabase->RegisterTag(pInfo);
      m_TagNameMap.AddNameAtIndex(pName,h);
   }
   else
   {
      // check for conflict.
      const sTagInfo *pOldInfo=m_pDatabase->GetTagInfo(index);
      Assert_(pOldInfo&&pInfo);
      if(pOldInfo->isMandatory!=pInfo->isMandatory || pOldInfo->weight!=pInfo->weight)
      {
         Warning(("tag %s already registered with conficting info\n",pName->text));
      }
   }
}

void cMotionDatabase::AddSchema(const sMotSchemaDesc *pDesc)
{
   ITagDBKeySet *pKeySet=NewITagDBKeySet();
   cMotionSchema sch;
   int index,j;

   Assert_(pDesc);

   int actor=pDesc->actor;
   
   if(actor<0||actor>=m_nActors)
   {
      Warning(("Actor %d out of bounds\n",pDesc->actor));
      return;
   }

   if(pDesc->archIsString)
   {
      index=m_NameMap.IDFromName(&pDesc->archName);
      if(index==kNameMapIndexNotFound)
      {
         index=m_NameMap.AddName(&pDesc->archName);
      }
      sch.SetArchetype(index);
      ulong flags=sch.GetFlags();
      flags|=kMSchFlag_ArchObjSwizzle;
      sch.SetFlags(flags);
   } else
   {
      sch.SetArchetype(pDesc->archInt);
   }

   // set duration/timewarp stuff
   if(pDesc->duration)
   {
      sch.SetDuration(pDesc->duration);
   } else if(pDesc->timeWarp)
   {
      sch.SetTimeWarp(pDesc->timeWarp);
   }
   // set distance/stretch stuff
   if(pDesc->distance)
   {
      sch.SetDistance(pDesc->distance);
   } else if(pDesc->stretch)
   {
      sch.SetStretch(pDesc->stretch);
   }

   for(j=0;j<pDesc->nMots;j++)
   {
      sch.AddMotion(&pDesc->pMots[j].name,&pDesc->pMots[j].stuff);
   }

   index=m_SchemaSet.Size();
   sch.SetSchemaID(index);

   ConfigSpew("yakspew",("SchemaID %d: %s\n",index,pDesc->name.text));

   m_SchemaSet.SetSize(index+1);
   m_SchemaSet.SetItem(&sch,index);

   // add to tag database
   int type;

   sTagDBData data;
   data.m_iData=index;
   data.m_fWeight=0;
   pKeySet->Clear();
   for(j=0;j<pDesc->nTags;j++)
   {
      type=m_TagNameMap.IDFromName(&pDesc->pTags[j].type);

      if(type==kNameMapIndexNotFound)
      {
         Warning(("tag %s not registered! cannot add to schema\n",pDesc->pTags[j].type.text));
         continue;
      }

      // NOTE: could add support for ranged tags if needed
      cTagDBKey key(type,pDesc->pTags[j].value,pDesc->pTags[j].value); 
      pKeySet->AddKey(&key);
   }
   m_pDatabase->InsertData(actor,pKeySet,data);

   delete pKeySet;
}

void MotDBCreate(int nActors)
{
   g_pMotionDatabase->CreateTagDatabase(nActors);
}

void MotDBRegisterTag(Label *pName, sTagInfo *pInfo)
{
   g_pMotionDatabase->RegisterTag(pName,pInfo);
}

void MotDBAddSchema(sMotSchemaDesc *pSchema)
{
   g_pMotionDatabase->AddSchema(pSchema);
}
// $Header: r:/t2repos/thief2/src/motion/mskltype.h,v 1.5 2000/01/31 09:49:53 adurant Exp $
#pragma once

#ifndef __MSKLTYPE_H
#define __MSKLTYPE_H

#ifdef __cplusplus

// forward declarations of mskill data

//typedef struct sMSkill sMSkill;
typedef class cMSkill cMSkill;

typedef char *tMSkillIdentifier;
typedef cMSkill *tMSkillHandle;

#endif // cplusplus


typedef struct sMSkillDesc sMSkillDesc;
typedef struct sMSkillPhysDesc sMSkillPhysDesc;
typedef struct sMGaitSkillData sMGaitSkillData;

#endif
// $Header: r:/t2repos/thief2/src/motion/motdmnge.c,v 1.11 2000/02/19 12:29:52 toml Exp $

#include <lg.h>
#include <appagg.h>
#include <string.h>
#include <motdmng_.h>
#include <motdmnge.h>
#include <motdesc.h>

#include <resapi.h>
#include <binrstyp.h>

#include <mprintf.h>
#include <multiped.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

MotDataHandle *motDataHandles=NULL;
static int    *motDataLockCnt=NULL;
static int g_nMotHandles=0;

void MotDmngeInit(int num_motions)
{
   int i;
   MotDataHandle *md;

   motDataHandles=(MotDataHandle *)Malloc(num_motions*sizeof(MotDataHandle));
   motDataLockCnt=(int *)Malloc(num_motions*sizeof(int));
   memset(motDataLockCnt,0,sizeof(int)*num_motions);
   
   md=motDataHandles;
   for(i=0;i<num_motions;i++,md++)
   {
      *md=NULL;
   }
   g_nMotHandles=num_motions;
}

void MotDmngeClose()
{
   if (motDataHandles)
   {
      // free any data that is currently locked
      int i;
      MotDataHandle *md=motDataHandles;

      for(i=0;i<g_nMotHandles;i++,md++)
      {
         if (*md) {
            IRes_Unlock(*md);
            SafeRelease(*md);
            *md=NULL;
         }
      }
      Free(motDataHandles);
      Free(motDataLockCnt);
      motDataHandles=NULL;
      motDataLockCnt=NULL;
   }
   g_nMotHandles=0;
}

// assumes mot_num is valid
// only use for non-virtual motions
void MotDmngeLock(int mot_num)
{
   if( ((mps_motion *)mp_motion_list+mot_num)->info.type!=MT_CAPTURE)
      return;
   if (motDataLockCnt[mot_num]==0)
   {
      IResMan *pResMan = AppGetObj(IResMan);
      char name[30];
      strcpy(name,MotDescGetName(mot_num));
      strcat(name,"_.mc");
      motDataHandles[mot_num]=IResMan_Bind(pResMan,
                                           name,
                                           RESTYPE_BINARY,
                                           NULL,
                                           "motions\\",
                                           0);
      // @TBD (justin 6-26-98): For now, we're maintaining a global lock, for
      // safety. This should get replaced by more concise locks, by someone
      // who groks motset better...
      SafeRelease(pResMan);
      if (motDataHandles[mot_num]) {
         IRes_Lock(motDataHandles[mot_num]);
      } else {
         Warning(("MotDmngeLock: no such resource %s.\n", name));
         return;
      }
   }
   motDataLockCnt[mot_num]++;
   // mprintf("loading %d\n",mot_num);
}

void MotDmngeUnlock(int mot_num)
{
   if( ((mps_motion *)mp_motion_list+mot_num)->info.type!=MT_CAPTURE)
      return;

   // I'd like to make this an assert, but it seems that we are not guaranteed that this
   // case won't occur. In fact, it definitely does occur when an attempt is made to lock
   // a motion that doesn't exist.
   if (motDataLockCnt[mot_num]<=0)
   {
      Warning(("MotDmngeUnlock: Ref count for motion %d already zero\n", mot_num));
      return;
   }
   motDataLockCnt[mot_num]--;
   if (motDataLockCnt[mot_num]==0)
   {
      MotDataHandle *md=&motDataHandles[mot_num];
      if (*md) {
         IRes_Unlock(*md);
         SafeRelease(*md);
         *md=NULL;
      }
   }
   // mprintf("freeing %d\n",mot_num);
}
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/mvrflags.h,v 1.6 2000/01/31 09:49:54 adurant Exp $
//
#pragma once

#ifndef __MVRFLAGS_H
#define __MVRFLAGS_H

#include <objtype.h>

#ifdef __cplusplus
class IMotor;
class cMotionCoordinator;
#else
typedef void IMotor;
typedef void cMotionCoordinator;
#endif

////////////////////////////////////////////////////////////////////////////////

// Common flags
#define MF_STANDING        0x00000001
#define MF_LEFT_FOOTFALL   0x00000002
#define MF_RIGHT_FOOTFALL  0x00000004
#define MF_LEFT_FOOTUP     0x00000008
#define MF_RIGHT_FOOTUP    0x00000010
#define MF_FIRE_RELEASE    0x00000020
#define MF_CAN_INTERRUPT   0x00000040
#define MF_START_MOT       0x00000080
#define MF_END_MOT         0x00000100

// Flags subject to game-specific interpretation
#define MF_TRIGGER1        0x00001000
#define MF_TRIGGER2        0x00002000
#define MF_TRIGGER3        0x00004000
#define MF_TRIGGER4        0x00008000

#define MF_TRIGGER5        0x00010000
#define MF_TRIGGER6        0x00020000
#define MF_TRIGGER7        0x00040000
#define MF_TRIGGER8        0x00080000


#define MF_FEET_FLAGS (MF_LEFT_FOOTFALL | MF_RIGHT_FOOTFALL | MF_LEFT_FOOTUP | MF_RIGHT_FOOTUP)

#define NEITHER_FOOT  0
#define LEFT_FOOT     1
#define RIGHT_FOOT    2

#define MF_MAX_BITS  32

////////////////////////////////////////////////////////////////////////////////

typedef void (*tFlagListenFunc)(ObjID objID, IMotor *pMotor, cMotionCoordinator *pCoord, const int flags);

struct sFlagListen
{
   ObjID objID;
   ulong interestedFlags;
   ulong triggeredFlags;
   tFlagListenFunc fnFlagListeners[32];
};

////////////////////////////////////////////////////////////////////////////////

EXTERN void  MotionFlagsInit();
EXTERN void  MotionFlagsTerm();

EXTERN void  ClearMotionFlagListeners(ObjID obj);
EXTERN void  AddMotionFlagListener(ObjID objID, ulong flags, tFlagListenFunc ListenerFunc);
EXTERN void  RemoveMotionFlagListener(ObjID objID, ulong flags);

EXTERN void  NotifyMotionFlags(ObjID objID, ulong flags, IMotor *pMotor, cMotionCoordinator *pCoord);
EXTERN ulong PollMotionFlags(ObjID objID, ulong flags);

////////////////////////////////////////////////////////////////////////////////

#endif // __MVRFLAGS_H






// $Header: r:/t2repos/thief2/src/motion/motmngr.cpp,v 1.20 1999/05/27 13:59:23 JON Exp $

#ifndef SHIP
//#define PROFILE_ON
#endif

#include <motmngr.h>
#include <motset.h>
#include <motdb.h>
#include <command.h>
#include <aiapi.h>
#include <motprop.h>
#include <appagg.h>
#include <propbase.h>
#include <propman.h>
#include <traitman.h>
#include <traitbas.h>
#include <objquery.h>
#include <cfgtool.h>
#include <timings.h>

#include <dbmem.h> // must be last included header

DECLARE_TIMER(MOTMNGR_PF_LOAD, Average);

IMotionSet *g_pMotionSet=NULL;

cMotionDatabase *g_pMotionDatabase=NULL;

/// GLOBALS
cManeuverFactoryList g_ManeuverFactoryList;

static TagFileTag g_MotDBTag = { "MotDBase" };
static VersionNum g_MotDBVersion={1,8};

#ifdef EDITOR
static void BuildMotionDatabase()
{
   AutoAppIPtr(AIManager);
   Assert_(g_pMotionDatabase);
   Assert_(g_pMotionSet);
   g_pMotionSet->Clear();
   g_pMotionDatabase->BuildFromAscii();

   if (!!pAIManager)
      pAIManager->ResetMotionTags();
}

static void SaveMotionDatabase()
{
   ITagFile *pFile=TagFileOpen("motiondb.bin",kTagOpenWrite);

   ITagFile_OpenBlock(pFile,&g_MotDBTag,&g_MotDBVersion);
   g_pMotionSet->Save(pFile);
   g_pMotionDatabase->Save(pFile);
   ITagFile_CloseBlock(pFile);

   SafeRelease(pFile);
}

Command MotMngrCommands[] =
{
   { "build_motion_database", FUNC_VOID, BuildMotionDatabase, "read in motion schemas as build database" },
   { "save_motion_database", FUNC_VOID, SaveMotionDatabase, "save out current built motion database" },
};
#endif

void MotionManagerInit()
{
   g_pMotionSet=NewMotionSet();
   g_pMotionDatabase = new cMotionDatabase;
#ifdef EDITOR
   COMMANDS(MotMngrCommands,HK_EDITOR);
#endif
   CoreMotionPropsInit();
}

void MotionManagerClose()
{
   delete g_pMotionSet;
   g_pMotionSet=NULL;

   delete g_pMotionDatabase;
   g_pMotionDatabase=NULL;

   CoreMotionPropsShutdown();
}

void MotionManagerReset()
{
   g_pMotionSet->Clear();
   g_pMotionDatabase->Clear();
}

void MotionManagerLoad()
{
   AUTO_TIMER(MOTMNGR_PF_LOAD);
   AutoAppIPtr(AIManager);

   // first check current directory
   ITagFile *pFile=TagFileOpen("motiondb.bin",kTagOpenRead);

   if(!pFile) // try resname path
   {
      char fullname[80];

      if(!find_file_in_config_path(fullname,"mschema/motiondb.bin","resname_base"))
      {
         Warning(("Unable to load motion database\n"));
         return;
      }
      pFile=TagFileOpen(fullname,kTagOpenRead);
      if(!pFile)
      {
         Warning(("Unable to load motion database\n"));
         return;
      }
   }

   TagVersion FoundVersion = g_MotDBVersion;
   HRESULT result = ITagFile_OpenBlock(pFile,&g_MotDBTag,&FoundVersion);

   if (result == S_OK
    && FoundVersion.major == g_MotDBVersion.major
    && FoundVersion.minor == g_MotDBVersion.minor) {
      g_pMotionSet->Load(pFile);
      g_pMotionDatabase->Load(pFile);
      ITagFile_CloseBlock(pFile);
      SafeRelease(pFile);
   }

   if (!!pAIManager)
      pAIManager->ResetMotionTags();
}
/* n:\bin\yacc -p msch -l -D mschtok.h -o mschyacc.c c:\b\cam\src\mschema.y */

#ifdef MSCHTRACE
#define MSCHDEBUG 1
#else
#ifndef MSCHDEBUG
#define MSCHDEBUG 0
#endif
#endif

/*
 * Portable way of defining ANSI C prototypes
 */
#ifndef MSCH_ARGS
#if __STDC__
#define MSCH_ARGS(x)	x
#else
#define MSCH_ARGS(x)	()
#endif
#endif


#if MSCHDEBUG
typedef struct mschNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} mschNamedType;
typedef struct mschTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} mschTypedRules;

#endif

typedef union {
   char *strval;
   int  ival;
   float fval;
   BOOL  bval;
} MSCHSTYPE;
#define IDENT	257
#define STRING	258
#define INT	259
#define FLOAT	260
#define BOOLEAN	261
#define INCLUDE	262
#define DEFINE	263
#define LPAREN	264
#define RPAREN	265
#define EQUAL	266
#define COLON	267
#define SCHEMA	268
#define TAG	269
#define TAG_OPT	270
#define ACTOR	271
#define ACTORS_DECLARE	272
#define ARCHETYPE	273
#define MOTION	274
#define TAGLIST_HEADER	275
#define MOTLIST_HEADER	276
#define STRETCH	277
#define TIMEWARP	278
#define DURATION	279
#define DISTANCE	280
#define MOT_NECK_FIXED	281
#define MOT_NECK_NOT_FIXED	282
#define MOT_BLEND_NONE	283
#define MOT_BLEND_DEFAULT	284
#define MOT_IS_TURN	285
#define MOT_BLEND_LENGTH	286
#define MOT_IN_PLACE	287
#define MOT_IS_LOCO	288

#include <stdio.h>
#include <string.h>
#include <mprintf.h>
#include <inctab.h>
#include <cfgdbg.h>
#include <config.h>
#include <label.h>
#include <motdb_.h>
#include <motdbase.h>


#define FILE_NAME_LEN 100

/*
  Include file stuff
*/
extern void IncParseFile(char *fileName);
extern void SchemaParseFile(char *fileName, int (*parseFn)());

#define mscherror mprintf

#define kDefaultBlendLength 500 // msec

#define FreeString(ident) { free(ident); ident = NULL; }

/* globals */
#define kMaxTagsPerSchema       16
#define kMaxMotionsPerSchema    128

static sTagDesc g_aSchemaTags[kMaxTagsPerSchema];
static sMotDesc g_aSchemaMotions[kMaxMotionsPerSchema];

static int g_nSchemaTags=0;
static int g_nSchemaMotions=0;

static float g_TimeWarp=0;
static float g_Stretch=0;
static float g_Duration=0;
static float g_Distance=0;

static BOOL g_TagIsMandatory=TRUE;
static float g_TagWeight=0;

static int g_TagVal=0;

static BOOL g_ArchIsString=FALSE;
static int g_ArchInt=0;
static Label g_ArchName;

static BOOL g_NeckIsFixed=FALSE;
static int  g_BlendLength=kDefaultBlendLength;
static BOOL g_IsTurn=FALSE;
static BOOL g_IsLoco=FALSE;
static BOOL g_InPlace=FALSE;


extern int mschchar, mscherrflag;
extern MSCHSTYPE mschlval;
#if MSCHDEBUG
enum MSCH_Types { MSCH_t_NoneDefined, MSCH_t_strval, MSCH_t_ival, MSCH_t_fval, MSCH_t_bval
};
#endif
#if MSCHDEBUG
mschTypedRules mschRules[] = {
	{ "&00: %01 &00",  0},
	{ "%01: %02",  0},
	{ "%02: %03",  0},
	{ "%02: %03 %02",  0},
	{ "%03: %04",  0},
	{ "%03: %05",  0},
	{ "%03: %06",  0},
	{ "%03: %07",  0},
	{ "%04: &07 &03",  0},
	{ "%08: %09",  0},
	{ "%08: %10",  0},
	{ "%09: &15 &05",  0},
	{ "%06: &14 &02 %08",  0},
	{ "%07: &17 &04",  0},
	{ "%11: %12",  0},
	{ "%11: %13",  0},
	{ "%12: &18 &02",  0},
	{ "%13: &18 &04",  0},
	{ "%05: &13 &02 &16 &04 %11 %14 %15 %16",  0},
	{ "%14: %17",  0},
	{ "%14: %10",  0},
	{ "%17: %17 %18",  0},
	{ "%17: %18",  0},
	{ "%18: %19",  0},
	{ "%18: %20",  0},
	{ "%18: %21",  0},
	{ "%18: %22",  0},
	{ "%19: &23 &05",  0},
	{ "%20: &24 &05",  0},
	{ "%21: &22 &05",  0},
	{ "%22: &25 &05",  0},
	{ "%15: &20 %23",  0},
	{ "%23: %24",  0},
	{ "%23: %10",  0},
	{ "%24: %24 %25",  0},
	{ "%24: %25",  0},
	{ "%26: %27",  0},
	{ "%26: %10",  0},
	{ "%27: &04",  0},
	{ "%25: &02 %26",  0},
	{ "%16: &21 %28",  0},
	{ "%28: %29",  0},
	{ "%28: %10",  0},
	{ "%29: %29 %30",  0},
	{ "%29: %30",  0},
	{ "%31: %32",  0},
	{ "%31: %10",  0},
	{ "%32: %33 %32",  0},
	{ "%32: %33",  0},
	{ "%33: %34",  0},
	{ "%33: %35",  0},
	{ "%33: %36",  0},
	{ "%33: &27",  0},
	{ "%33: &29",  0},
	{ "%33: %37",  0},
	{ "%33: %38",  0},
	{ "%33: %39",  0},
	{ "%34: &26",  0},
	{ "%37: &28",  0},
	{ "%35: &31 &04",  0},
	{ "%39: &32",  0},
	{ "%38: &33",  0},
	{ "%36: &30",  0},
	{ "%30: &02 %31",  0},
	{ "%10:",  0},
	{ "%16:",  0},
{ "$accept",  0},{ "error",  0}
};
mschNamedType mschTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "IDENT",  257,  1},
	{ "STRING",  258,  1},
	{ "INT",  259,  2},
	{ "FLOAT",  260,  3},
	{ "BOOLEAN",  261,  4},
	{ "INCLUDE",  262,  0},
	{ "DEFINE",  263,  0},
	{ "LPAREN",  264,  0},
	{ "RPAREN",  265,  0},
	{ "EQUAL",  266,  0},
	{ "COLON",  267,  0},
	{ "SCHEMA",  268,  0},
	{ "TAG",  269,  0},
	{ "TAG_OPT",  270,  0},
	{ "ACTOR",  271,  0},
	{ "ACTORS_DECLARE",  272,  0},
	{ "ARCHETYPE",  273,  0},
	{ "MOTION",  274,  0},
	{ "TAGLIST_HEADER",  275,  0},
	{ "MOTLIST_HEADER",  276,  0},
	{ "STRETCH",  277,  0},
	{ "TIMEWARP",  278,  0},
	{ "DURATION",  279,  0},
	{ "DISTANCE",  280,  0},
	{ "MOT_NECK_FIXED",  281,  0},
	{ "MOT_NECK_NOT_FIXED",  282,  0},
	{ "MOT_BLEND_NONE",  283,  0},
	{ "MOT_BLEND_DEFAULT",  284,  0},
	{ "MOT_IS_TURN",  285,  0},
	{ "MOT_BLEND_LENGTH",  286,  0},
	{ "MOT_IN_PLACE",  287,  0},
	{ "MOT_IS_LOCO",  288,  0}

};
#endif
static short mschdef[] = {

	  67,   -1,   62,   -5,   66,   62,    3,   62,   65,   62, 
	  62,   64,   63
};
static short mschex[] = {

	   0,    0,   -1,    1,  275,   62,   -1,    1
};
static short mschact[] = {

	 -25,  -28,  -26,  -27,  272,  269,  268,  262,  -24,  257, 
	 -46,  259,   -3,  257,  -49,  258,  -23,  271,  -22,  270, 
	 -21,  259,  -48,  260,  -20,  273,  -18,  -16,  -17,  -19, 
	 280,  279,  278,  277,  -45,  -44,  259,  257,  -39,  260, 
	 -40,  260,  -41,  260,  -42,  260,   -6,  275,   -8,  257, 
	 -10,  276,  -38,  259,  -11,  257,  -36,  -83,  -35,  -84, 
	 -31,  -14,  -33,  -32,  288,  287,  286,  285,  284,  283, 
	 282,  281,  -34,  259,   -1
};
static short mschpact[] = {

	   4,   16,   19,   30,   30,   49,   51,   53,   49,   55, 
	  64,   55,   64,   73,   47,   45,   43,   41,   39,   36, 
	  25,   23,   21,   17,   15,   13,   11,    9,    4
};
static short mschgo[] = {

	  -2,  -51,  -50,    0,   -1,  -52,  -53,  -54,  -55,  -47, 
	 -56,  -60,  -68,  -72,  -74,  -78,  -57,   10,    9,    7, 
	   5,    3,   -4,  -58,  -59,  -15,   -7,  -43,   -5,  -61, 
	 -62,    4,  -63,  -64,  -65,  -66,  -67,   -9,  -69,  -70, 
	   8,  -37,  -71,  -73,  -12,  -75,  -76,   11,  -30,  -79, 
	 -77,   12,  -13,  -80,  -81,  -82,  -85,  -86,  -87,   -1
};
static short mschpgo[] = {

	   0,    0,    0,   27,   46,   55,   57,   58,   54,   56, 
	  53,   39,   42,   35,   34,   33,   32,    6,   24,   23, 
	   8,    7,   10,    5,    0,    2,    4,    4,    4,    4, 
	   9,    9,   22,   22,   25,   28,   28,   30,   30,   30, 
	  30,   26,   36,   37,   37,   41,   41,   27,   43,   44, 
	  44,   48,   48,   50,   52,   52,   52,   52,   52,   52, 
	  52,   52,   16,   50,   43,   36,   25,    2,    0
};
static short mschrlen[] = {

	   0,    0,    0,    0,    2,    1,    1,    1,    2,    1, 
	   1,    2,    1,    2,    2,    2,    2,    8,    2,    2, 
	   2,    3,    2,    2,    1,    2,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    2,    1,    1,    1,    1, 
	   1,    2,    1,    2,    1,    1,    1,    2,    1,    2, 
	   1,    1,    1,    2,    1,    1,    1,    1,    1,    1, 
	   1,    1,    0,    1,    1,    1,    1,    1,    2
};
#define MSCHS0	28
#define MSCHDELTA	25
#define MSCHNPACT	29
#define MSCHNDEF	13

#define MSCHr66	0
#define MSCHr67	1
#define MSCHr68	2
#define MSCHr65	3
#define MSCHr63	4
#define MSCHr62	5
#define MSCHr61	6
#define MSCHr60	7
#define MSCHr59	8
#define MSCHr58	9
#define MSCHr57	10
#define MSCHr39	11
#define MSCHr38	12
#define MSCHr30	13
#define MSCHr29	14
#define MSCHr28	15
#define MSCHr27	16
#define MSCHr18	17
#define MSCHr17	18
#define MSCHr16	19
#define MSCHr13	20
#define MSCHr12	21
#define MSCHr11	22
#define MSCHr8	23
#define MSCHrACCEPT	MSCHr66
#define MSCHrERROR	MSCHr67
#define MSCHrLR2	MSCHr68
#if MSCHDEBUG
char * mschsvar[] = {
	"$accept",
	"file",
	"statements",
	"statement",
	"include",
	"schema",
	"tag",
	"actors_declare",
	"opt_tag_spec",
	"tag_spec",
	"null",
	"archetype",
	"arch_string",
	"arch_int",
	"optparams",
	"taglist",
	"motlist",
	"paraminsts",
	"paraminst",
	"timewarp",
	"duration",
	"stretch",
	"distance",
	"opttaginsts",
	"taginsts",
	"taginst",
	"opt_tag_val",
	"tag_val",
	"optmotions",
	"motinsts",
	"motinst",
	"optmotparamlist",
	"motparamlist",
	"motparam",
	"neck_fixed",
	"blend_length",
	"is_turn",
	"blend_none",
	"is_loco",
	"in_place",
	0
};
short mschrmap[] = {

	  66,   67,   68,   65,   63,   62,   61,   60,   59,   58, 
	  57,   39,   38,   30,   29,   28,   27,   18,   17,   16, 
	  13,   12,   11,    8,    1,    3,    4,    5,    6,    7, 
	   9,   10,   14,   15,   20,   21,   22,   23,   24,   25, 
	  26,   31,   33,   34,   35,   36,   37,   40,   42,   43, 
	  44,   45,   46,   47,   49,   50,   51,   52,   53,   54, 
	  55,   56,   64,   48,   41,   32,   19,    2,    0
};
short mschsmap[] = {

	   9,   11,   14,   24,   38,   47,   48,   49,   52,   54, 
	  61,   64,   81,   70,   39,   31,   30,   29,   28,   25, 
	  22,   19,   17,   12,    4,    3,    2,    1,    0,   66, 
	  67,   68,   69,   85,   71,   72,   56,   57,   42,   43, 
	  44,   45,   55,   40,   41,   13,   18,   23,   15,   10, 
	  16,    8,    7,    6,    5,   21,   20,   27,   26,   37, 
	  46,   36,   35,   34,   33,   32,   53,   51,   60,   50, 
	  59,   58,   65,   63,   84,   62,   83,   82,   86,   80, 
	  79,   78,   77,   76,   75,   74,   73
};
int mschntoken = 34;
int mschnvar = 40;
int mschnstate = 87;
int mschnrule = 69;
#endif

#if MSCHDEBUG
/*
 * Package up YACC context for tracing
 */
typedef struct mschTraceItems_tag {
	int	state, lookahead, errflag, done;
	int	rule, npop;
	short	* states;
	int	nstates;
	MSCHSTYPE * values;
	int	nvalues;
	short	* types;
} mschTraceItems;
#endif


/*
 * Copyright 1985, 1990 by Mortice Kern Systems Inc.  All rights reserved.
 * 
 * Automaton to interpret LALR(1) tables.
 *
 * Macros:
 *	mschclearin - clear the lookahead token.
 *	mscherrok - forgive a pending error
 *	MSCHERROR - simulate an error
 *	MSCHACCEPT - halt and return 0
 *	MSCHABORT - halt and return 1
 *	MSCHRETURN(value) - halt and return value.  You should use this
 *		instead of return(value).
 *	MSCHREAD - ensure mschchar contains a lookahead token by reading
 *		one if it does not.  See also MSCHSYNC.
 *	MSCHRECOVERING - 1 if syntax error detected and not recovered
 *		yet; otherwise, 0.
 *
 * Preprocessor flags:
 *	MSCHDEBUG - includes debug code if 1.  The parser will print
 *		 a travelogue of the parse if this is defined as 1
 *		 and mschdebug is non-zero.
 *		yacc -t sets MSCHDEBUG to 1, but not mschdebug.
 *	MSCHTRACE - turn on MSCHDEBUG, and undefine default trace functions
 *		so that the interactive functions in 'ytrack.c' will
 *		be used.
 *	MSCHSSIZE - size of state and value stacks (default 150).
 *	MSCHSTATIC - By default, the state stack is an automatic array.
 *		If this is defined, the stack will be static.
 *		In either case, the value stack is static.
 *	MSCHALLOC - Dynamically allocate both the state and value stacks
 *		by calling malloc() and free().
 *	MSCHSYNC - if defined, yacc guarantees to fetch a lookahead token
 *		before any action, even if it doesnt need it for a decision.
 *		If MSCHSYNC is defined, MSCHREAD will never be necessary unless
 *		the user explicitly sets mschchar = -1
 *
 * Copyright (c) 1983, by the University of Waterloo
 */
/*
 * Prototypes
 */

extern int mschlex MSCH_ARGS((void));

#if MSCHDEBUG

#include <stdlib.h>		/* common prototypes */
#include <string.h>
#include <memall.h>
#include <dbmem.h>   // must be last header! 

extern char *	mschValue MSCH_ARGS((MSCHSTYPE, int));	/* print mschlval */
extern void mschShowState MSCH_ARGS((mschTraceItems *));
extern void mschShowReduce MSCH_ARGS((mschTraceItems *));
extern void mschShowGoto MSCH_ARGS((mschTraceItems *));
extern void mschShowShift MSCH_ARGS((mschTraceItems *));
extern void mschShowErrRecovery MSCH_ARGS((mschTraceItems *));
extern void mschShowErrDiscard MSCH_ARGS((mschTraceItems *));

extern void mschShowRead MSCH_ARGS((int));
#endif

/*
 * If MSCHDEBUG defined and mschdebug set,
 * tracing functions will be called at appropriate times in mschparse()
 * Pass state of YACC parse, as filled into mschTraceItems mschx
 * If mschx.done is set by the tracing function, mschparse() will terminate
 * with a return value of -1
 */
#define MSCH_TRACE(fn) { \
	mschx.state = mschstate; mschx.lookahead = mschchar; mschx.errflag =mscherrflag; \
	mschx.states = mschs+1; mschx.nstates = mschps-mschs; \
	mschx.values = mschv+1; mschx.nvalues = mschpv-mschv; \
	mschx.types = mschtypev+1; mschx.done = 0; \
	mschx.rule = mschi; mschx.npop = mschj; \
	fn(&mschx); \
	if (mschx.done) MSCHRETURN(-1); }

#ifndef I18N
#define	gettext(x)	x
#endif

#ifndef MSCHSSIZE
# define MSCHSSIZE	150
#endif

#define MSCHERROR		goto mscherrlabel
#define mscherrok		mscherrflag = 0
#if MSCHDEBUG
#define mschclearin	{ if (mschdebug) mschShowRead(-1); mschchar = -1; }
#else
#define mschclearin	mschchar = -1
#endif
#define MSCHACCEPT	MSCHRETURN(0)
#define MSCHABORT		MSCHRETURN(1)
#define MSCHRECOVERING()	(mscherrflag != 0)
#ifdef MSCHALLOC
# define MSCHRETURN(val)	{ retval = (val); goto mschReturn; }
#else
# define MSCHRETURN(val)	return(val)
#endif
#if MSCHDEBUG
/* The if..else makes this macro behave exactly like a statement */
# define MSCHREAD	if (mschchar < 0) {					\
			if ((mschchar = mschlex()) < 0)			\
				mschchar = 0;				\
			if (mschdebug)					\
				mschShowRead(mschchar);			\
		} else
#else
# define MSCHREAD	if (mschchar < 0) {					\
			if ((mschchar = mschlex()) < 0)			\
				mschchar = 0;				\
		} else
#endif

#define MSCHERRCODE	256		/* value of `error' */
#define	MSCHQMSCHP	mschq[mschq-mschp]

MSCHSTYPE	mschval;				/* $ */
MSCHSTYPE	*mschpvt;				/* $n */
MSCHSTYPE	mschlval;				/* mschlex() sets this */

int	mschchar,				/* current token */
	mscherrflag,			/* error flag */
	mschnerrs;			/* error count */

#if MSCHDEBUG
int mschdebug = 0;		/* debug if this flag is set */
extern char	*mschsvar[];	/* table of non-terminals (aka 'variables') */
extern mschNamedType mschTokenTypes[];	/* table of terminals & their types */
extern short	mschrmap[], mschsmap[];	/* map internal rule/states */
extern int	mschnstate, mschnvar, mschntoken, mschnrule;

extern int	mschGetType MSCH_ARGS((int));	/* token type */
extern char	*mschptok MSCH_ARGS((int));	/* printable token string */
extern int	mschExpandName MSCH_ARGS((int, int, char *, int));
				  /* expand mschRules[] or mschStates[] */
static char *	mschgetState MSCH_ARGS((int));

#define mschassert(condition, msg, arg) \
	if (!(condition)) { \
		printf(gettext("\nyacc bug: ")); \
		printf(msg, arg); \
		MSCHABORT; }
#else /* !MSCHDEBUG */
#define mschassert(condition, msg, arg)
#endif

void MotSchemaYaccParse(char *schemaFile)
{
   // init globals
        
   IncTabsInit();

   mprintf("parsing file %s!\n",schemaFile);
   MschParseFile(schemaFile);

   IncTabsShutdown();

}



mschparse()
{
	register short		mschi, *mschp;	/* for table lookup */
	register short		*mschps;		/* top of state stack */
	register short		mschstate;	/* current state */
	register MSCHSTYPE	*mschpv;		/* top of value stack */
	register short		*mschq;
	register int		mschj;
#if MSCHDEBUG
	mschTraceItems	mschx;			/* trace block */
	short	* mschtp;
	int	mschruletype = 0;
#endif
#ifdef MSCHSTATIC
	static short	mschs[MSCHSSIZE + 1];
	static MSCHSTYPE	mschv[MSCHSSIZE + 1];
#if MSCHDEBUG
	static short	mschtypev[MSCHSSIZE+1];	/* type assignments */
#endif
#else /* ! MSCHSTATIC */
#ifdef MSCHALLOC
	MSCHSTYPE *mschv;
	short	*mschs;
#if MSCHDEBUG
	short	*mschtypev;
#endif
	MSCHSTYPE save_mschlval;
	MSCHSTYPE save_mschval;
	MSCHSTYPE *save_mschpvt;
	int save_mschchar, save_mscherrflag, save_mschnerrs;
	int retval;
#else
	short		mschs[MSCHSSIZE + 1];
	static MSCHSTYPE	mschv[MSCHSSIZE + 1];	/* historically static */
#if MSCHDEBUG
	short	mschtypev[MSCHSSIZE+1];		/* mirror type table */
#endif
#endif /* ! MSCHALLOC */
#endif /* ! MSCHSTATIC */


#ifdef MSCHALLOC
	mschs = (short *) malloc((MSCHSSIZE + 1) * sizeof(short));
	mschv = (MSCHSTYPE *) malloc((MSCHSSIZE + 1) * sizeof(MSCHSTYPE));
#if MSCHDEBUG
	mschtypev = (short *) malloc((MSCHSSIZE+1) * sizeof(short));
#endif
	if (mschs == (short *)0 || mschv == (MSCHSTYPE *)0
#if MSCHDEBUG
		|| mschtypev == (short *) 0
#endif
	) {
		mscherror("Not enough space for parser stacks");
		return 1;
	}
	save_mschlval = mschlval;
	save_mschval = mschval;
	save_mschpvt = mschpvt;
	save_mschchar = mschchar;
	save_mscherrflag = mscherrflag;
	save_mschnerrs = mschnerrs;
#endif

	mschnerrs = 0;
	mscherrflag = 0;
	mschclearin;
	mschps = mschs;
	mschpv = mschv;
	*mschps = mschstate = MSCHS0;		/* start state */
#if MSCHDEBUG
	mschtp = mschtypev;
	mschi = mschj = 0;			/* silence compiler warnings */
#endif

mschStack:
	mschassert((unsigned)mschstate < mschnstate, gettext("state %d\n"), mschstate);
	if (++mschps > &mschs[MSCHSSIZE]) {
		mscherror("Parser stack overflow");
		MSCHABORT;
	}
	*mschps = mschstate;	/* stack current state */
	*++mschpv = mschval;	/* ... and value */
#if MSCHDEBUG
	*++mschtp = mschruletype;	/* ... and type */

	if (mschdebug)
		MSCH_TRACE(mschShowState)
#endif

	/*
	 *	Look up next action in action table.
	 */
mschEncore:
#ifdef MSCHSYNC
	MSCHREAD;
#endif
	if (mschstate >= sizeof mschpact/sizeof mschpact[0]) 	/* simple state */
		mschi = mschstate - MSCHDELTA;	/* reduce in any case */
	else {
		if(*(mschp = &mschact[mschpact[mschstate]]) >= 0) {
			/* Look for a shift on mschchar */
#ifndef MSCHSYNC
			MSCHREAD;
#endif
			mschq = mschp;
			mschi = mschchar;
			while (mschi < *mschp++)
				;
			if (mschi == mschp[-1]) {
				mschstate = ~MSCHQMSCHP;
#if MSCHDEBUG
				if (mschdebug) {
					mschruletype = mschGetType(mschchar);
					MSCH_TRACE(mschShowShift)
				}
#endif
				mschval = mschlval;	/* stack what mschlex() set */
				mschclearin;		/* clear token */
				if (mscherrflag)
					mscherrflag--;	/* successful shift */
				goto mschStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

		if (mschstate >= sizeof mschdef /sizeof mschdef[0])
      {
//         mscherror("mshyacc.c:  (%s) Unknown state transition %d out of possible %d\n", mschpv->strval, mschstate, sizeof mschdef /sizeof mschdef[0]);
         mscherror("mshyacc.c:  Unknown state transition %d out of possible %d\n", mschstate, sizeof mschdef /sizeof mschdef[0]);
         goto mschError;
      }
			
		if ((mschi = mschdef[mschstate]) < 0)	 { /* default == reduce? */
			/* Search exception table */
			mschassert((unsigned)~mschi < sizeof mschex/sizeof mschex[0],
				gettext("exception %d\n"), mschstate);
			mschp = &mschex[~mschi];
#ifndef MSCHSYNC
			MSCHREAD;
#endif
			while((mschi = *mschp) >= 0 && mschi != mschchar)
				mschp += 2;
			mschi = mschp[1];
			mschassert(mschi >= 0,
				 gettext("Ex table not reduce %d\n"), mschi);
		}
	}

	mschassert((unsigned)mschi < mschnrule, gettext("reduce %d\n"), mschi);
	mschj = mschrlen[mschi];
#if MSCHDEBUG
	if (mschdebug)
		MSCH_TRACE(mschShowReduce)
	mschtp -= mschj;
#endif
	mschps -= mschj;		/* pop stacks */
	mschpvt = mschpv;		/* save top */
	mschpv -= mschj;
	mschval = mschpv[1];	/* default action $ = $1 */
#if MSCHDEBUG
	mschruletype = mschRules[mschrmap[mschi]].type;
#endif

	switch (mschi) {		/* perform semantic action */
		
case MSCHr8: {	/* include :  INCLUDE STRING */

   ConfigSpew("yakspew",("include %s\n",mschpvt[0].strval));       

   IncParseFile(mschpvt[0].strval);
   FreeString(mschpvt[0].strval);

} break;

case MSCHr11: {	/* tag_spec :  TAG_OPT FLOAT */

   g_TagIsMandatory=FALSE;
   g_TagWeight=mschpvt[0].fval;

} break;

case MSCHr12: {	/* tag :  TAG IDENT opt_tag_spec */

   sTagInfo info;

   if(config_is_defined("yakspew"))
   {
      mprintf("tag %s mand %d",mschpvt[-1].strval,g_TagIsMandatory);
      if(g_TagIsMandatory)
      {
         mprintf("\n");
      } else
      {
         mprintf(" weight %g\n",g_TagWeight);
      }
   }
   info.isMandatory=g_TagIsMandatory;
   info.weight = g_TagWeight;
   MotDBRegisterTag((Label *)(mschpvt[-1].strval),&info); 
   // reset globals
   g_TagIsMandatory=TRUE;
   g_TagWeight=0;

   FreeString(mschpvt[-1].strval);

} break;

case MSCHr13: {	/* actors_declare :  ACTORS_DECLARE INT */

   MotDBCreate(mschpvt[0].ival);

} break;

case MSCHr16: {	/* arch_string :  ARCHETYPE IDENT */

   g_ArchIsString=TRUE;
   strncpy(g_ArchName.text,mschpvt[0].strval,sizeof(g_ArchName));
   FreeString(mschpvt[0].strval);

} break;

case MSCHr17: {	/* arch_int :  ARCHETYPE INT */

   g_ArchIsString=FALSE;
   g_ArchInt=mschpvt[0].ival;

} break;

case MSCHr18: {	/* schema :  SCHEMA IDENT ACTOR INT archetype optparams taglist motlist */

   int i;
   sMotDesc *pMotDesc;
   sTagDesc *pTagDesc;
   sMotSchemaDesc schema;

   if(config_is_defined("yakspew"))     
   {
      if(g_ArchIsString)
         mprintf("schema %s\n  with actor %d\n  with archetype %s\n",mschpvt[-6].strval,mschpvt[-4].ival,g_ArchName.text);       
      else
         mprintf("schema %s\n  with actor %d\n  with archetype %d\n",mschpvt[-6].strval,mschpvt[-4].ival,g_ArchInt);       

      // look at params
      if(g_Duration)
      {
         mprintf("  duration %g\n",g_Duration);
      }
      if(g_Distance)
      {
         mprintf("  distance %g\n",g_Distance);
      }
      if(g_TimeWarp)
      {
         mprintf("  timewarp %g\n",g_TimeWarp);
      }
      if(g_Stretch)
      {
         mprintf("  stretch %g\n",g_Stretch);
      }

      // look at tag globals
      pTagDesc=g_aSchemaTags;
      for(i=0;i<g_nSchemaTags;i++,pTagDesc++)
      {
         mprintf("  with tag %s value %d\n",pTagDesc->type.text,pTagDesc->value);
      }
        
      // look at motion globals     
      pMotDesc=g_aSchemaMotions;
      for(i=0;i<g_nSchemaMotions;i++,pMotDesc++)
      {
         mprintf("  with motion %s,",pMotDesc->name.text);
         if(pMotDesc->stuff.flags&kMSF_NECK_IS_FIXED)
         {
            mprintf(" neck_fixed");
         }
         if(pMotDesc->stuff.blendLength!=kDefaultBlendLength)
         {
            mprintf(" blend %d",pMotDesc->stuff.blendLength);
         }
         if(pMotDesc->stuff.flags&kMSF_IS_TURN)
         {
            mprintf(" is_turn");
         }
         if(pMotDesc->stuff.flags&kMSF_IS_LOCO)
         {
            mprintf(" is_loco");
         }
         if(pMotDesc->stuff.flags&kMSF_WANT_NO_XLAT)
         {
            mprintf(" in_place");
         }
         mprintf("\n");
      }
   }

   schema.nTags=g_nSchemaTags;
   schema.pTags=g_aSchemaTags;
   schema.nMots=g_nSchemaMotions;
   schema.pMots=g_aSchemaMotions;
   schema.duration=g_Duration;
   schema.distance=g_Distance;
   schema.timeWarp=g_TimeWarp;
   schema.stretch=g_Stretch;
   schema.actor=mschpvt[-4].ival;
   strncpy(schema.name.text,mschpvt[-6].strval,15);

   if(g_ArchIsString)
   {
      strncpy(schema.archName.text,g_ArchName.text,sizeof(schema.archName));
      schema.archIsString=TRUE;
   } else
   {
      schema.archInt=g_ArchInt;  
      schema.archIsString=FALSE;
   }
   MotDBAddSchema(&schema);

   // reset globals
   g_nSchemaTags=0;
   g_nSchemaMotions=0;
   g_TimeWarp=0;
   g_Stretch=0;
   g_Duration=0;
   g_Distance=0;

   FreeString(mschpvt[-6].strval);

} break;

case MSCHr27: {	/* timewarp :  TIMEWARP FLOAT */

   g_TimeWarp=mschpvt[0].fval;

} break;

case MSCHr28: {	/* duration :  DURATION FLOAT */

   g_Duration=mschpvt[0].fval;

} break;

case MSCHr29: {	/* stretch :  STRETCH FLOAT */

   g_Stretch=mschpvt[0].fval;

} break;

case MSCHr30: {	/* distance :  DISTANCE FLOAT */

   g_Distance=mschpvt[0].fval;

} break;

case MSCHr38: {	/* tag_val :  INT */

   g_TagVal=mschpvt[0].ival;

} break;

case MSCHr39: {	/* taginst :  IDENT opt_tag_val */

   int size;

   if(g_nSchemaTags<kMaxTagsPerSchema)
   {
      size=sizeof(g_aSchemaTags[0].type);     
      strncpy(g_aSchemaTags[g_nSchemaTags].type.text,mschpvt[-1].strval,size);
      g_aSchemaTags[g_nSchemaTags].value=g_TagVal;
      g_nSchemaTags++;  
   } else
   {
      Warning(("Cannot add tag %s to schema - too many tags\n",mschpvt[-1].strval));
   }
   // reset globals 
   g_TagVal=0;
   FreeString(mschpvt[-1].strval);

} break;

case MSCHr57: {	/* neck_fixed :  MOT_NECK_FIXED */

   g_NeckIsFixed=TRUE;

} break;

case MSCHr58: {	/* blend_none :  MOT_BLEND_NONE */

   g_BlendLength=0;             

} break;

case MSCHr59: {	/* blend_length :  MOT_BLEND_LENGTH INT */

   g_BlendLength=mschpvt[0].ival;             

} break;

case MSCHr60: {	/* in_place :  MOT_IN_PLACE */

   g_InPlace=TRUE;        

} break;

case MSCHr61: {	/* is_loco :  MOT_IS_LOCO */

   g_IsLoco=TRUE;        

} break;

case MSCHr62: {	/* is_turn :  MOT_IS_TURN */

   g_IsTurn=TRUE;

} break;

case MSCHr63: {	/* motinst :  IDENT optmotparamlist */

   int size;
     
   if(g_nSchemaMotions<kMaxMotionsPerSchema)
   {
      size=sizeof(g_aSchemaMotions[0].name);     
      strncpy(g_aSchemaMotions[g_nSchemaMotions].name.text,mschpvt[-1].strval,size);
      g_aSchemaMotions[g_nSchemaMotions].stuff.flags=NULL;
      if(g_NeckIsFixed)
         g_aSchemaMotions[g_nSchemaMotions].stuff.flags|=kMSF_NECK_IS_FIXED;
      g_aSchemaMotions[g_nSchemaMotions].stuff.blendLength=g_BlendLength;
      if(g_IsTurn)
         g_aSchemaMotions[g_nSchemaMotions].stuff.flags|=kMSF_IS_TURN;
      if(g_IsLoco)
         g_aSchemaMotions[g_nSchemaMotions].stuff.flags|=kMSF_IS_LOCO;
      if(g_InPlace)
         g_aSchemaMotions[g_nSchemaMotions].stuff.flags|=kMSF_WANT_NO_XLAT;
      g_nSchemaMotions++;  
   } else
   {
      Warning(("Cannot add motion %s to schema - too many motions\n",mschpvt[-1].strval));
   }

   // reset motion params
   g_NeckIsFixed=FALSE;
   g_BlendLength=kDefaultBlendLength;
   g_IsTurn=FALSE;
   g_IsLoco=FALSE;
   g_InPlace=FALSE;

   FreeString(mschpvt[-1].strval);

} break;

case MSCHr65: {	/* motlist :  */


} break;
	case MSCHrACCEPT:
		MSCHACCEPT;
	case MSCHrERROR:
		goto mschError;
	}

	/*
	 *	Look up next state in goto table.
	 */

	mschp = &mschgo[mschpgo[mschi]];
	mschq = mschp++;
	mschi = *mschps;
	while (mschi < *mschp++)
		;

	mschstate = ~(mschi == *--mschp? MSCHQMSCHP: *mschq);
#if MSCHDEBUG
	if (mschdebug)
		MSCH_TRACE(mschShowGoto)
#endif
	goto mschStack;

mscherrlabel:	;		/* come here from MSCHERROR	*/
/*
#pragma used mscherrlabel
 */
	mscherrflag = 1;
	if (mschi == MSCHrERROR) {
		mschps--;
		mschpv--;
#if MSCHDEBUG
		mschtp--;
#endif
	}

mschError:
	switch (mscherrflag) {

	case 0:		/* new error */
		mschnerrs++;
		mschi = mschchar;
// mschpvt		
// pMotDesc->name
      mscherror("mshyacc.c:  Syntax error on char '%c'\n", mschchar);
		if (mschi != mschchar) {
			/* user has changed the current token */
			/* try again */
			mscherrflag++;	/* avoid loops */
			goto mschEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		mscherrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; mschps > mschs; mschps--, mschpv--
#if MSCHDEBUG
					, mschtp--
#endif
		) {
			if (*mschps >= sizeof mschpact/sizeof mschpact[0])
				continue;
			mschp = &mschact[mschpact[*mschps]];
			mschq = mschp;
			do
				;
			while (MSCHERRCODE < *mschp++);

			if (MSCHERRCODE == mschp[-1]) {
				mschstate = ~MSCHQMSCHP;
				goto mschStack;
			}
				
			/* no shift in this state */
#if MSCHDEBUG
			if (mschdebug && mschps > mschs+1)
				MSCH_TRACE(mschShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (mschchar == 0)  /* but not EOF */
			break;
#if MSCHDEBUG
		if (mschdebug)
			MSCH_TRACE(mschShowErrDiscard)
#endif
		mschclearin;
		goto mschEncore;	/* try again in same state */
	}
	MSCHABORT;

#ifdef MSCHALLOC
mschReturn:
	mschlval = save_mschlval;
	mschval = save_mschval;
	mschpvt = save_mschpvt;
	mschchar = save_mschchar;
	mscherrflag = save_mscherrflag;
	mschnerrs = save_mschnerrs;
	free((char *)mschs);
	free((char *)mschv);
	return(retval);
#endif
}

		
#if MSCHDEBUG
/*
 * Return type of token
 */
int
mschGetType(tok)
int tok;
{
	mschNamedType * tp;
	for (tp = &mschTokenTypes[mschntoken-1]; tp > mschTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}
/*
 * Print a token legibly.
 */
char *
mschptok(tok)
int tok;
{
	mschNamedType * tp;
	for (tp = &mschTokenTypes[mschntoken-1]; tp > mschTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}

/*
 * Read state 'num' from mschStatesFile
 */
#ifdef MSCHTRACE
// Bodisafa:  Who knows what a good MSCHMAX_READ size is.
#define MSCHMAX_READ 256
static FILE *mschStatesFile = (FILE *) 0;
static char mschReadBuf[MSCHMAX_READ+1];

static char *
mschgetState(num)
int num;
{
	int	size;

	if (mschStatesFile == (FILE *) 0
	 && (mschStatesFile = fopen(mschStatesFile, "r")) == (FILE *) 0)
		return "mschExpandName: cannot open states file";

	if (num < mschnstate - 1)
		size = (int)(mschStates[num+1] - mschStates[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(mschStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(mschStatesFile) - mschStates[num]);
	}
	if (size < 0 || size > MSCHMAX_READ)
		return "mschExpandName: bad read size";
	if (fseek(mschStatesFile, mschStates[num], 0) < 0) {
	cannot_seek:
		return "mschExpandName: cannot seek in states file";
	}

	(void) fread(mschReadBuf, 1, size, mschStatesFile);
	mschReadBuf[size] = '\0';
	return mschReadBuf;
}
#endif /* MSCHTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode mschStates and mschRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
mschExpandName(num, isrule, buf, len)
int num, isrule;
char * buf;
int len;
{
	int	i, n, cnt, type;
	char	* endp, * cp;
	char	*s;

	if (isrule)
		s = mschRules[num].name;
	else
#ifdef MSCHTRACE
		s = mschgetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = mschnvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = mschntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= mschnvar)
					goto too_big;
				cp = mschsvar[n];
			} else if (n >= mschntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = mschTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef MSCHTRACE
/*
 * Show current state of mschparse
 */
void
mschShowState(tp)
mschTraceItems * tp;
{
	short * p;
	MSCHSTYPE * q;

	printf(
	    gettext("state %d (%d), char %s (%d)\n"),
	      mschsmap[tp->state], tp->state,
	      mschptok(tp->lookahead), tp->lookahead);
}
/*
 * show results of reduction
 */
void
mschShowReduce(tp)
mschTraceItems * tp;
{
	printf("reduce %d (%d), pops %d (%d)\n",
		mschrmap[tp->rule], tp->rule,
		tp->states[tp->nstates - tp->npop],
		mschsmap[tp->states[tp->nstates - tp->npop]]);
}
void
mschShowRead(val)
int val;
{
	printf(gettext("read %s (%d)\n"), mschptok(val), val);
}
void
mschShowGoto(tp)
mschTraceItems * tp;
{
	printf(gettext("goto %d (%d)\n"), mschsmap[tp->state], tp->state);
}
void
mschShowShift(tp)
mschTraceItems * tp;
{
	printf(gettext("shift %d (%d)\n"), mschsmap[tp->state], tp->state);
}
void
mschShowErrRecovery(tp)
mschTraceItems * tp;
{
	short	* top = tp->states + tp->nstates - 1;

	printf(
	gettext("Error recovery pops state %d (%d), uncovers %d (%d)\n"),
		mschsmap[*top], *top, mschsmap[*(top-1)], *(top-1));
}
void
mschShowErrDiscard(tp)
mschTraceItems * tp;
{
	printf(gettext("Error recovery discards %s (%d), "),
		mschptok(tp->lookahead), tp->lookahead);
}
#endif	/* ! MSCHTRACE */
#endif	/* MSCHDEBUG */
// $Header: r:/t2repos/thief2/src/motion/motprop.cpp,v 1.9 1999/01/13 13:57:20 KATE Exp $

#include <motprop.h>
#include <property.h>
#include <propbase.h>
#include <propface.h>
#include <propfac_.h>
#include <dataops_.h>
#include <propsprs.h>
#include <matrix.h>
#include <fix.h>

#include <mschbase.h>
#include <sdesbase.h>
#include <sdestool.h>

#include <dbmem.h> // must be last included header


static IMotActorTagListProperty* actorTagListProp = NULL;

static IMotPhysLimitsProperty* motPhysLimitsProp = NULL;

static IMotGaitDescProperty* motGaitDescProp = NULL;

static IIntProperty* motorControllerProp = NULL;

static IIntProperty* motSwordActionProp = NULL;

// @DIPPY, but hopefully functional
#if 0
static IBoolProperty* motBlockProp = NULL;
static IBoolProperty* motRecoverProp = NULL;
#endif

static IFloatProperty* timeWarpProp = NULL;

static IMotPlayerLimbOffsetsProperty* motPlayerLimbOffsetsProp = NULL;

////////////////////////////////////////////////
//
//    ACTOR TAG LIST PROPERTY CREATION
//

class cActorTagListOps : public cClassDataOps<sMotActorTagList>
{
}; 

class cActorTagListStore : public cSparseHashPropertyStore<cActorTagListOps>
{
}; 

class cMotActorTagListProperty : public cSpecificProperty<IMotActorTagListProperty,&IID_IMotActorTagListProperty,sMotActorTagList*,cActorTagListStore>
{
   typedef cSpecificProperty<IMotActorTagListProperty,&IID_IMotActorTagListProperty,sMotActorTagList*,cActorTagListStore> cParent; 

public: 
   cMotActorTagListProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      
   }

   STANDARD_DESCRIBE_TYPE(sMotActorTagList); 

}; 



static sPropertyDesc actorTagListPropDesc =
{
   PROP_ACTOR_TAG_LIST_NAME,
   0,
   NULL,
   0,1, // verison
   { "Motions", "ActorTagList" }, 
};

// structure descriptor fun
static sFieldDesc actorTagListFields [] =
{
   { "tags", kFieldTypeString, FieldLocation(sMotActorTagList, m_TagStrings) },
};

static sStructDesc actorTagListStruct = StructDescBuild(sMotActorTagList,kStructFlagNone,actorTagListFields);


////////////////////////////////////////////////
//
//    MOTOR CONTROLLER PROPERTY CREATION
//

static sPropertyDesc motControlPropDesc =
{
   PROP_MOTOR_CONTROLLER_NAME,
   0,  // flags
   NULL, // constraints
   0, 0, // Version
   { "Motions", "Motor Controller" }, // ui strings
};

#define MOTCONTROL_TYPENAME "tMotorControllerType"

static sFieldDesc motControllerField[] = 
{
   { "", kFieldTypeEnum, sizeof(int), 0, kFieldFlagUnsigned, 0, 0, 0, NULL },
}; 

static sStructDesc motControlSDesc = 
{
   MOTCONTROL_TYPENAME, 
   sizeof(int),
   kStructFlagNone,
   sizeof(motControllerField)/sizeof(motControllerField[0]),
   motControllerField,
}; 

static sPropertyTypeDesc motControlTDesc = 
{
   MOTCONTROL_TYPENAME,
   sizeof(int),
};

#define MOTCONTROLPROP_IMPL kPropertyImplSparseHash


////////////////////////////////////////////////
//
//    TIMEWARP PROPERTY
//

static sPropertyDesc timeWarpPropDesc = 
{
   PROP_TIMEWARP_NAME,
   0,  // flags
   NULL, // constraints
   0, 0, // Version
   { "Creature", "Time Warp" }, // ui strings
}; 

#define TIMEWARP_PROP_IMPL kPropertyImplSparseHash


////////////////////////////////////////////////
//
//    SWORD ACTION PROPERTY CREATION
//

static sPropertyDesc motSwordActionPropDesc =
{
   PROP_SWORD_ACTION_NAME,
   0,  // flags
   NULL, // constraints
   0, 0, // Version
   { "Motions", "Sword Action Type" }, // ui strings
};

#define SWORDACTION_TYPENAME "eMSwordActionType"

static char *motSwordActionNames[] = 
{
   "Swing",
   "General Block",
   "Directed Block",
};

static sFieldDesc motSwordActionField[] = 
{
   { "", kFieldTypeEnum, sizeof(int), 0, FullFieldNames(motSwordActionNames) },
}; 

static sStructDesc motSwordActionSDesc = 
{
   SWORDACTION_TYPENAME, 
   sizeof(int),
   kStructFlagNone,
   sizeof(motSwordActionField)/sizeof(motSwordActionField[0]),
   motSwordActionField,
}; 

static sPropertyTypeDesc motSwordActionTDesc = 
{
   SWORDACTION_TYPENAME,
   sizeof(int),
};

#define MOTSWORDACTIONPROP_IMPL kPropertyImplSparseHash




////////////////////////////////////////////////
//
//    PHYS LIMITS PROPERTY CREATION
//


class cMotPhysLimitsOps : public cClassDataOps<sMotPhysLimits>
{
}; 

class cMotPhysLimitsStore : public cSparseHashPropertyStore<cMotPhysLimitsOps>
{

}; 

class cMotPhysLimitsProperty : public cSpecificProperty<IMotPhysLimitsProperty,&IID_IMotPhysLimitsProperty,sMotPhysLimits*,cMotPhysLimitsStore>
{
   typedef cSpecificProperty<IMotPhysLimitsProperty,&IID_IMotPhysLimitsProperty,sMotPhysLimits*,cMotPhysLimitsStore> cParent; 

public: 
   cMotPhysLimitsProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      
   }

   STANDARD_DESCRIBE_TYPE(sMotPhysLimits); 

}; 

static sPropertyDesc motPhysLimitsPropDesc =
{
   PROP_MOT_PHYS_LIMITS_NAME,
   NULL,
   NULL, // constraints
   0,0, // version
   { "Motions", "Phys Limits" },
};

// structure descriptor fun
static sFieldDesc physLimitFields [] =
{
   { "Foo 1", kFieldTypeInt, FieldLocation(sMotPhysLimits,foo[0]) },
   { "Foo 2", kFieldTypeInt, FieldLocation(sMotPhysLimits,foo[1]) },
};

static sStructDesc physLimitsStruct = StructDescBuild(sMotPhysLimits,kStructFlagNone,physLimitFields);


////////////////////////////////////////////////
//
//    PLAYER LIMB OFFSETS PROPERTY CREATION
//


class cMotPlayerLimbOffsetsOps : public cClassDataOps<sMPlayerLimbOffsets>
{
}; 

class cMotPlayerLimbOffsetsStore : public cSparseHashPropertyStore<cMotPlayerLimbOffsetsOps>
{
}; 

class cMotPlayerLimbOffsetsProperty : public cSpecificProperty<IMotPlayerLimbOffsetsProperty,&IID_IMotPlayerLimbOffsetsProperty,sMPlayerLimbOffsets*,cMotPlayerLimbOffsetsStore>
{
   typedef cSpecificProperty<IMotPlayerLimbOffsetsProperty,&IID_IMotPlayerLimbOffsetsProperty,sMPlayerLimbOffsets*,cMotPlayerLimbOffsetsStore> cParent; 

public: 
   cMotPlayerLimbOffsetsProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      
   }

   STANDARD_DESCRIBE_TYPE(sMPlayerLimbOffsets); 

}; 

static sPropertyDesc motPlayerLimbOffsetsPropDesc =
{
   PROP_PLAYER_LIMB_OFFSETS_NAME,
   NULL,
   NULL, // constraints
   0,0, // version
   { "Motions", "Player Limb Offsets" },
};

// structure descriptor fun
static sFieldDesc limbOffsetsFields [] =
{
   { "Arm Pos Offset", kFieldTypeVector, FieldLocation(sMPlayerLimbOffsets,armPosOff) },
   { "Arm Ang Offset", kFieldTypeVector, FieldLocation(sMPlayerLimbOffsets,armAngDegrees) },
};

static sStructDesc playerLimbOffsetsStruct = StructDescBuild(sMPlayerLimbOffsets,kStructFlagNone,limbOffsetsFields);


////////////////////////////////////////////////
//
//    GAIT DESC PROPERTY CREATION
//

class cMotGaitDescOps : public cClassDataOps<sMGaitSkillData>
{
}; 

class cMotGaitDescStore : public cSparseHashPropertyStore<cMotGaitDescOps>
{

}; 

class cMotGaitDescProperty : public cSpecificProperty<IMotGaitDescProperty,&IID_IMotGaitDescProperty,sMGaitSkillData*,cMotGaitDescStore>
{
   typedef cSpecificProperty<IMotGaitDescProperty,&IID_IMotGaitDescProperty,sMGaitSkillData*,cMotGaitDescStore> cParent; 

public: 
   cMotGaitDescProperty(const sPropertyDesc* desc)
      : cParent(desc)
   {
      
   }

   STANDARD_DESCRIBE_TYPE(sMGaitSkillData); 

}; 

static sPropertyDesc motGaitPropDesc =
{
   PROP_MOT_GAIT_DESC_NAME,
   NULL,
   NULL, // constraints
   0,0, // version
   { "Motions", "Gait Desc" },
};

// structure descriptor fun
static sFieldDesc gaitDescFields[] =
{
   { "LeftMotOff", kFieldTypeInt, FieldLocation(sMGaitSkillData,leftStride) },
   { "RightMotOff", kFieldTypeInt, FieldLocation(sMGaitSkillData,rightStride) },
   { "MaxAscend", kFieldTypeFloat, FieldLocation(sMGaitSkillData,maxAscend) },
   { "MaxDescend", kFieldTypeFloat, FieldLocation(sMGaitSkillData,maxDescend) },
   { "TimeWarp", kFieldTypeFloat, FieldLocation(sMGaitSkillData,timeWarp) },
   { "Stretch", kFieldTypeFloat, FieldLocation(sMGaitSkillData,stretch) },
   { "MaxAngVel", kFieldTypeInt, FieldLocation(sMGaitSkillData,maxAngVel) },
   { "TurnTolerance", kFieldTypeInt, FieldLocation(sMGaitSkillData,turnTolerance) },
   { "MaxVel", kFieldTypeFloat, FieldLocation(sMGaitSkillData,maxVel) },
   { "MinVel", kFieldTypeFloat, FieldLocation(sMGaitSkillData,minVel) },
   { "NumTurns", kFieldTypeInt, FieldLocation(sMGaitSkillData,numTurns) },
   { "Turn 1 Angle", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[0].angle)},
   { "Turn 1 MotOff", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[0].mot)},
   { "Turn 2 Angle", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[1].angle)},
   { "Turn 2 MotOff", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[1].mot)},
   { "Turn 3 Angle", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[2].angle)},
   { "Turn 3 MotOff", kFieldTypeInt, FieldLocation(sMGaitSkillData,turns[2].mot)},
   { "Stride Duration Noise",kFieldTypeFloat,FieldLocation(sMGaitSkillData,noise)},
};

static sStructDesc gaitDescStruct = StructDescBuild(sMGaitSkillData,kStructFlagNone,gaitDescFields);


////////////////////////////////////////////////
//
//    INITIALIZATION
//

EXTERN void MotorControllerPropInit(char **motControllerNames,int nMotControllers);

void MotorControllerPropInit(char **motControllerNames,int nMotControllers)
{
   AutoAppIPtr_(StructDescTools,pTools);

   // motor controller property
   AssertMsg(motControlSDesc.fields,"Motor Controller SDesc not set up properly");
   AssertMsg(nMotControllers&&motControllerNames,"Motor Controller names not adequate");
   motControlSDesc.fields->max=nMotControllers;
   motControlSDesc.fields->datasize=nMotControllers;
   motControlSDesc.fields->data=(void *)motControllerNames;
}

void CoreMotionPropsInit()
{
   AutoAppIPtr_(StructDescTools,pTools);

   // actor property
   pTools->Register(&actorTagListStruct);
   actorTagListProp=new cMotActorTagListProperty(&actorTagListPropDesc);

   pTools->Register(&motControlSDesc);
   motorControllerProp = CreateIntegralProperty(&motControlPropDesc,&motControlTDesc,MOTCONTROLPROP_IMPL);

   timeWarpProp = CreateFloatProperty(&timeWarpPropDesc,TIMEWARP_PROP_IMPL);

   pTools->Register(&motSwordActionSDesc);
   motSwordActionProp = CreateIntegralProperty(&motSwordActionPropDesc,&motSwordActionTDesc,MOTSWORDACTIONPROP_IMPL);

   // phys limits property
   pTools->Register(&physLimitsStruct);
   motPhysLimitsProp=new cMotPhysLimitsProperty(&motPhysLimitsPropDesc);

   // gait desc property
   pTools->Register(&gaitDescStruct);
   motGaitDescProp=new cMotGaitDescProperty(&motGaitPropDesc);

   // player pos offsets property
   pTools->Register(&playerLimbOffsetsStruct);
   motPlayerLimbOffsetsProp=new cMotPlayerLimbOffsetsProperty(&motPlayerLimbOffsetsPropDesc);
}

void CoreMotionPropsShutdown()
{
   SafeRelease(actorTagListProp);
   SafeRelease(motorControllerProp);
   SafeRelease(timeWarpProp);
   SafeRelease(motSwordActionProp);
   SafeRelease(motPhysLimitsProp);
   SafeRelease(motGaitDescProp);
   SafeRelease(motPlayerLimbOffsetsProp);
}

/////////////////////////////////////////////////
//
//    Access functions
//

BOOL ObjGetMotControllerID(ObjID obj, int *pID)
{
   Assert_(motorControllerProp);
   return motorControllerProp->Get(obj,pID);
}

// this should not be put on motion schema archetypes. rather, it belongs
// on creatures who should have all their motion playback speeds modified.  KJ 8/98
BOOL ObjGetTimeWarp(ObjID obj, float *pWarp)
{
   Assert_(timeWarpProp);
   return timeWarpProp->Get(obj,pWarp);
}

BOOL ObjGetSwordActionType(ObjID obj, int *pType)
{
   Assert_(motSwordActionProp);
   return motSwordActionProp->Get(obj,pType);
}

BOOL ObjGetGaitData(ObjID obj, sMGaitSkillData **pData)
{
   Assert_(motGaitDescProp);
   return motGaitDescProp->Get(obj,pData);
}

// @TODO: move this to AI property category? KJ 8/98
BOOL ObjGetActorTagList(ObjID obj, sMotActorTagList **pData)
{
   Assert_(actorTagListProp);
   return actorTagListProp->Get(obj, pData);
}

BOOL ObjGetPlayerPosOffsets(ObjID obj, mxs_vector *pPosOff, mxs_angvec *pAngOff)
{
   BOOL success;
   sMPlayerLimbOffsets *pLimbOff;
   int d;

   Assert_(motPlayerLimbOffsetsProp);
   if(TRUE==(success=motPlayerLimbOffsetsProp->Get(obj,&pLimbOff)))
   {
      mx_copy_vec(pPosOff,&pLimbOff->armPosOff);
      d=pLimbOff->armAngDegrees.x;
      pAngOff->tx=degrees_to_fixang(d);
      d=pLimbOff->armAngDegrees.y;
      pAngOff->ty=degrees_to_fixang(d);
      d=pLimbOff->armAngDegrees.z;
      pAngOff->tz=degrees_to_fixang(d);
   }
   return success;
}
// $Header: r:/t2repos/thief2/src/motion/motschem.cpp,v 1.8 1999/10/25 15:54:30 BODISAFA Exp $

#include <motschem.h>
#include <objedit.h>
#include <stdlib.h>
#include <rand.h>
#include <motmngr.h>

#include <dbmem.h> // must be last included header


cMotionSchema::cMotionSchema()
{
   m_ArchObj=OBJ_NULL;
   m_ArchIndex=kNameMapIndexNotFound;
   m_Flags=NULL;
   m_TimeModifier=0;
   m_DistModifier=0;
}

cMotionSchema::~cMotionSchema()
{
}

BOOL cMotionSchema::GetRandomMotion(int *pMotID) const
{
   int size=m_MotRunHandleList.Size();
   if(size>0)
   {
      int id=RandRange(0,size-1);
#ifdef OLD_WAY
      int id= (size*Rand())/(RAND_MAX+1);
      if(id>=size)
         id=size-1;
#endif
      *pMotID = m_MotRunHandleList[id];
      return TRUE;
   }
   return FALSE;
}

BOOL cMotionSchema::GetRandomMotionInRange(int min, int max, int *pMotID) const
{
   int size=m_MotRunHandleList.Size();
   Assert_(max<=size);
   if(min>max)
      return FALSE;
   int id=RandRange(min,max);
#ifdef OLD_WAY
   int id= min + (((max-min+1)*Rand())/(RAND_MAX+1));
#endif
   Assert_(id<=max);
   *pMotID = m_MotRunHandleList[id];
   return TRUE;
}

// @TODO: how to deal when not all motions in loco schema get successfully loaded?
BOOL cMotionSchema::GetMotion(int offset, int *pMotID) const
{
   if(m_MotRunHandleList.Size()!=m_MotIndexList.Size())
   {
      Warning(("Not all motions in schema could be loaded\n"));
   }

   int size=m_MotRunHandleList.Size();
   if(size<=offset)
      return FALSE;

   *pMotID = m_MotRunHandleList[offset];
   return TRUE;
}

BOOL cMotionSchema::Save(ITagFile *pFile)
{
   // write out name
   ITagFile_Write(pFile,(char *)&m_ArchIndex,sizeof(m_ArchIndex));

   // write out schema index
   ITagFile_Write(pFile,(char *)&m_SchemaID,sizeof(m_ArchIndex));

   // write out flags
   ITagFile_Write(pFile,(char *)&m_Flags,sizeof(m_Flags));

   // write out params
   ITagFile_Write(pFile,(char *)&m_TimeModifier,sizeof(m_TimeModifier));
   ITagFile_Write(pFile,(char *)&m_DistModifier,sizeof(m_DistModifier));

   // write out index list
   ulong size=m_MotIndexList.Size();
   int i;
   ITagFile_Write(pFile,(char *)&size,sizeof(size));
   for(i=0;i<size;i++)
      ITagFile_Write(pFile,(char *)&m_MotIndexList[i],sizeof(m_MotIndexList[i]));

   return FALSE;
}

BOOL cMotionSchema::Load(ITagFile *pFile, cNameMap *pNameMap)
{
   // read in name
   ITagFile_Read(pFile,(char *)&m_ArchIndex,sizeof(m_ArchIndex));

   // read in schema index
   ITagFile_Read(pFile,(char *)&m_SchemaID,sizeof(m_ArchIndex));

   // read in flags
   ITagFile_Read(pFile,(char *)&m_Flags,sizeof(m_Flags));

   // read in params
   ITagFile_Read(pFile,(char *)&m_TimeModifier,sizeof(m_TimeModifier));
   ITagFile_Read(pFile,(char *)&m_DistModifier,sizeof(m_DistModifier));

   // read in index list
   ulong size,index;
   int i;
   ITagFile_Read(pFile,(char *)&size,sizeof(size));
   m_MotIndexList.SetSize(size);
   for(i=0;i<size;i++)
   {
      ITagFile_Read(pFile,(char *)&index,sizeof(index));
      m_MotIndexList.SetItem((int *)&index,i);
   }

   SetupRunTimeData(pNameMap);
   return TRUE;
}

void cMotionSchema::AddMotion(const Label *name, const sMotStuff *pStuff)
{
   int index;

   Assert_(g_pMotionSet);
   if(!g_pMotionSet->AddMotion(name,pStuff,&index))
      return;

   m_MotIndexList.Append(index);
}

void cMotionSchema::SetArchetype(int index)
{
   m_ArchIndex=index;
}

void cMotionSchema::SetupRunTimeData(cNameMap *pNameMap)
{
   int i,size,index,rh;

   // build run handle list
   m_MotRunHandleList.SetSize(0);
   size=m_MotIndexList.Size();
   for(i=0;i<size;i++)
   {
      index=m_MotIndexList[i];            
      if(g_pMotionSet->GetRunHandle(index,&rh))
         m_MotRunHandleList.Append(rh);
   }

   // set archetype objid
   if(m_Flags&kMSchFlag_ArchObjSwizzle)
   {
      Label *name=pNameMap->NameFromID(m_ArchIndex);
      Assert_(name);
      m_ArchObj=EditGetObjNamed(name->text);
      if(m_ArchObj==OBJ_NULL)
      {
         Warning(("SetupRunTimeData: archetype obj %s not found\n",name->text));
      }
   }
}


// $Header: r:/t2repos/thief2/src/motion/motset.cpp,v 1.19 1999/12/27 15:26:01 BODISAFA Exp $

#include <motset.h>
#include <motdbase.h>
extern "C" {
#include <mp.h>
}
#include <string.h>
#include <appagg.h>
#include <objpos.h>
#include <resapi.h>
#include <binrstyp.h>
#include <motdmnge.h>
#include <motdmng_.h>
#include <motdesc.h>
#include <motmngr.h>
#include <creature.h> // for callbacks
#include <mvrflags.h>

#include <dynarray.h>
#include <namemap.h>
#include <cfgdbg.h>     

#include <dbmem.h> // must be last included header


#define E398_HACK

EXTERN void MotCompRotCallback(mps_motion_info *mi,mps_comp_motion *cm,float frame, quat *data);
static void MotCompXlatCallback(multiped *mp, mps_motion_info *mi,mps_comp_motion *cm,float frame, mxs_vector *data);
static void MotRootRotCallback(multiped *mp, mps_motion_info *mi,float frame, quat *data);
static void MotFilterCallback(multiped*mp, mps_motion_info *mi,quat *rot, mxs_vector *xlat);

class cMpsMotion : public mps_motion
{
public:
   cMpsMotion(mps_motion *mot=NULL);

// NOTE: destructor does not free the flags or components, just as
// constructor doesn't alloc them.  This data gets freed on
// mp_close if and only if the motion has been mp_add_motion-ed,
// which happens during runtime setup.
   ~cMpsMotion() {}

   void Read(ITagFile *pFile);
   void Write(ITagFile *pFile);
};

cMpsMotion::cMpsMotion(mps_motion *mot)
{
   if(!mot)
   {
      num_components=0;
      components=NULL;
      num_flags=0;
      flags=NULL;
      info.type=MT_CAPTURE;
      info.num_frames=0;
      info.name[0]='\0';
      return;
   }
   info=mot->info;
   if(info.type==MT_CAPTURE)
   {
      num_components=mot->num_components;
      components=mot->components;
   } else
   {
      virtual_update=mot->virtual_update;
   }
   num_flags=mot->num_flags;
   flags=mot->flags;
}

void cMpsMotion::Read(ITagFile *pFile)
{
   mps_motion mot;

   // delete any existing alloced stuff
   if(flags)
   {
      mp_free(flags);
      flags=NULL;
   }
   if(components)
   {
      mp_free(components);
      components=NULL;
   }

   ITagFile_Read(pFile,(char *)&mot,sizeof(mot));
   info=mot.info;
   AssertMsg(info.type==MT_CAPTURE,"can't read virtual motions");
   num_components=mot.num_components;
   num_flags=mot.num_flags;

   if(mot.num_components)
   {
      components=(mps_comp_motion *) mp_alloc(sizeof(mps_comp_motion) * mot.num_components,__FILE__,__LINE__);
      ITagFile_Read(pFile,(char *)components,sizeof(*mot.components)*mot.num_components);
   } else
   {
      components=NULL;
   }

   // read flags
   if(mot.num_flags)
	{
	   flags=(mps_motion_flag *) mp_alloc(sizeof(mps_motion_flag) * mot.num_flags,__FILE__,__LINE__);
      ITagFile_Read(pFile,(char *)flags,sizeof(*mot.flags)*mot.num_flags);
	} else
	{
	   flags=NULL;
	}
}

void cMpsMotion::Write(ITagFile *pFile)
{
   mps_motion mot;

   AssertMsg(info.type==MT_CAPTURE,"cannot write virtual motion");
   mot.info=info;
   mot.num_components=num_components;
   mot.components=NULL;
   mot.num_flags=num_flags;
   mot.flags=NULL;
   
   ITagFile_Write(pFile,(char *)&mot,sizeof(mot));
   ITagFile_Write(pFile,(char *)components,sizeof(*components)*num_components);
   ITagFile_Write(pFile,(char *)flags,sizeof(*flags)*num_flags);
}


class cMotStuffList : public cDynArray<sMotStuff> {};
class cMotIndexList : public cDynArray<int> {};


// ids here are same as in mp_motion_list, so you can pass them into
// creature->PlayMotion
class cMotionSet : public IMotionSet
{
public:
   cMotionSet();
   ~cMotionSet();

// run-time functions
//
   virtual BOOL NeckIsFixed(int motHandle);
   virtual int  BlendLength(int motHandle);
   virtual void GetStartEndFrames(int motHandle, int *pStart, int *pEnd);
   virtual int GetNumFrames(int motHandle);
   virtual mxs_ang GetEndHeading(int motHandle);
   virtual void GetTranslation(int motHandle, mxs_vector *pXlat);
   virtual float GetDuration(int motHandle);
   virtual void GetSlidingVelocity(int motHandle, mxs_vector *pVel);
   virtual BOOL WantInPlace(int motHandle);

   virtual Label *GetName(int motHandle);
   virtual int  GetMotHandleFromName(const Label *name);

   //this is correct even if motions not all loaded successfully
   virtual int  NumMotions() { return m_RunHandle2Index.Size(); }

// load/save functions
//
   virtual BOOL Load(ITagFile *pFile);
   virtual BOOL Save(ITagFile *pFile);
   virtual BOOL GetRunHandle(int index, int *pRunHandle);

// set-building functions
//
   virtual void Clear();
   virtual void StartBuild() { Clear(); }
   virtual void EndBuild() { SetupRunTimeData(); DippyComputeAllMotPhys(); }
   virtual BOOL AddMotion(const Label *name, const sMotStuff *pStuff, int *pIndex);

// virtual motion dealing.  These need to be registered before "add motion" gets called.
   void RegisterVirtualMotion(const Label *name,const mps_motion *pMotion);

private:
   BOOL SetupMotion(const Label *name,int id,int *runHandle);
   void SetupRunTimeData();
   void DippyComputeAllMotPhys();
   void HackComputeMotPhys(int runHandle, int index);


   cMotStuffList m_MotStuffList; // mapping from mot index to stuff
   // note: if all motions are successfully loaded, these will be the identity mappings
   cMotIndexList m_Index2RunHandle; // mapping from mot index to mot run-time handle
   cMotIndexList m_RunHandle2Index; // mapping from mot run-time handle to mot index
   cNameMap m_NameMap;
#ifdef E398_HACK
   BOOL m_HackSuspendInPlace;
#endif

   // virtual motion stuff - this never gets cleared out
   cNameMap m_VMotNameMap; 
   cDynArray<mps_motion> m_VMotList;
   cDynClassArray<cMpsMotion> m_cMoCapList;
};



cMotionSet::cMotionSet()
{
   mp_init(1);
   MotDmngeInit(1);
   mp_set_motion_start_end_callbacks(MotDmngeLock,MotDmngeUnlock);
   mp_set_capture_callbacks(MotCompXlatCallback,MotCompRotCallback,MotRootRotCallback);
   mp_set_rot_filter_callback(MotFilterCallback);
#ifdef E398_HACK
   m_HackSuspendInPlace=FALSE;
#endif
}

cMotionSet::~cMotionSet()
{
   mp_close();
   MotDmngeClose();
}

BOOL cMotionSet::NeckIsFixed(int motHandle)
{
   if(motHandle<0)
      return FALSE;
   Assert_(motHandle<m_RunHandle2Index.Size());
   return m_MotStuffList[m_RunHandle2Index[motHandle]].flags&kMSF_NECK_IS_FIXED;
}

void cMotionSet::GetStartEndFrames(int motHandle, int *pStart, int *pEnd)
{
   *pStart=0;
   *pEnd=-1;
   if(motHandle<0 || motHandle>mp_num_motions)
   {
      return;
   }
   mps_motion *pMot;
   int i;
   mps_motion_flag *pF;

   pMot=mp_motion_list+motHandle;
   pF=pMot->flags;
   for(i=0;i<pMot->num_flags;i++,pF++)
   {
      if(pF->flags&MF_START_MOT)
      {
         *pStart=pF->frame;
      }
      if(pF->flags&MF_END_MOT)
      {
         *pEnd=pF->frame;
      }
   }
}

int cMotionSet::GetNumFrames(int motHandle)
{
   if(motHandle<0 || motHandle>=mp_num_motions)
      return 0;

   return ((mps_motion *)(mp_motion_list+motHandle))->info.num_frames;
}

#define kMotDefaultBlendLength 500 // in msec

int cMotionSet::BlendLength(int motHandle)
{
   if(motHandle<0)
      return 0;
   Assert_(motHandle<m_RunHandle2Index.Size());

   return m_MotStuffList[m_RunHandle2Index[motHandle]].blendLength;
}

mxs_ang cMotionSet::GetEndHeading(int motHandle)
{
   int id=m_RunHandle2Index[motHandle];

   Assert_(id>=0&&id<m_MotStuffList.Size());
   return m_MotStuffList[id].endDirAction;
}

float cMotionSet::GetDuration(int motHandle)
{
   int id=m_RunHandle2Index[motHandle];

   Assert_(id>=0&&id<m_MotStuffList.Size());
   return m_MotStuffList[id].duration;
}

void cMotionSet::GetTranslation(int motHandle, mxs_vector *pXlat)
{
   int id=m_RunHandle2Index[motHandle];

   Assert_(id>=0&&id<m_MotStuffList.Size());

   mx_copy_vec(pXlat,&m_MotStuffList[id].xlat);
}

void cMotionSet::GetSlidingVelocity(int motHandle, mxs_vector *pVel)
{
   int id=m_RunHandle2Index[motHandle];

   Assert_(id>=0&&id<m_MotStuffList.Size());

   sMotStuff *pStuff=&m_MotStuffList[id];

   if(pStuff->flags&kMSF_IS_LOCO)
   {
      mx_copy_vec(pVel,&pStuff->xlat);
      mx_scaleeq_vec(pVel,1.0/m_MotStuffList[id].duration);
   } else
   {
      mx_zero_vec(pVel);
   }
}

BOOL cMotionSet::WantInPlace(int motHandle)
{
   int id=m_RunHandle2Index[motHandle];

   Assert_(id>=0&&id<m_MotStuffList.Size());

#ifdef E398_HACK
   if(m_HackSuspendInPlace)
      return FALSE;
#endif

   return m_MotStuffList[id].flags&kMSF_WANT_NO_XLAT;
}

Label *cMotionSet::GetName(int motHandle)
{
   return m_NameMap.NameFromID(m_RunHandle2Index[motHandle]);
}

int cMotionSet::GetMotHandleFromName(const Label *name)
{
   int index=m_NameMap.IDFromName(name);

   if(index==kNameMapIndexNotFound)
      return -1;
   return m_Index2RunHandle[index];
}

// this is a hack because this data should really be calculated in 
// motion processor, not on load, and should probably be more
// sophisticated.   KJ 5/19/98
void cMotionSet::HackComputeMotPhys(int runHandle, int index)
{
   Assert_(runHandle>=0&&runHandle<mp_num_motions);

   sMotStuff *pStuff=&m_MotStuffList[index];
   mps_motion_info *pInfo=&((mp_motion_list+(runHandle))->info);

   Assert_(pInfo);

   pStuff->duration=pInfo->num_frames/pInfo->freq;

   if(pInfo->type!=MT_CAPTURE)
   {
      pStuff->endDirAction=0;
      mx_zero_vec(&pStuff->xlat);
      return;
   }

   Assert_(pInfo->num_frames>0);

   MotDmngeLock(runHandle);

   // compute endDirAction
   if(pStuff->flags&kMSF_IS_TURN)
   {
      // end dir action is end butt facing

      mps_motion *m=mp_motion_list+runHandle;
      quat q;
      mxs_matrix mat;
      mxs_angvec ang;

      // first check if motion is an overlay.  
      // Full body motions always have xlat component first
      if(m->components[0].type!=CM_TRANS)
      {
         // then overlay
         pStuff->endDirAction=0;
      }
      else
      {
         // butt joint is same as xlat joint
         int joint=m->components[0].joint_id;
         int i;
         mps_comp_motion *pComp=m->components+1;

         for(i=1;i<m->num_components;i++,pComp++)
         {
            if(pComp->joint_id==joint)
               break;
         }
         AssertMsg1(i < m->num_components, "HackComputeMotPhys: joint id %d match failed.", pComp->joint_id);
         Assert_(pComp->type==CM_ROT);
         MotCompRotCallback(pInfo,pComp,pInfo->num_frames-1,&q);
         quat_to_matrix(&mat,&q);
         mx_mat2ang(&ang,&mat);
         pStuff->endDirAction=ang.tz;

         // assumption is that start dir action is zero.  sanity
         // check this.
         MotCompRotCallback(pInfo,pComp,0,&q);
         quat_to_matrix(&mat,&q);
         mx_mat2ang(&ang,&mat);
         if(ang.tz>0x1000&&ang.tz<0xf000)
         {
            Warning(("HackComputeMotPhys: turn %s has starting orient of %x\n",pInfo->name,ang.tz));
         }
      }
   } else
   {
      pStuff->endDirAction=0;
   }

#ifdef E398_HACK
   m_HackSuspendInPlace=TRUE;
#endif
   // compute xlat and average speed
   mp_get_xlat_at_frame(&pStuff->xlat,runHandle,pInfo->num_frames-1);
#ifdef E398_HACK
   m_HackSuspendInPlace=FALSE;
#endif
   MotDmngeUnlock(runHandle);
}

void cMotionSet::SetupRunTimeData()
{
   // try loading motions, and build index<->runHandle mappings
   int i,size,rh,last;
   Label *name;

   size=m_NameMap.Size();

   // setup multiped library and res locking stuff
   mp_init(size);
   MotDmngeInit(size);
   mp_set_motion_start_end_callbacks(MotDmngeLock,MotDmngeUnlock);
   mp_set_capture_callbacks(MotCompXlatCallback,MotCompRotCallback,MotRootRotCallback);

   m_Index2RunHandle.SetSize(size);
   for(i=0;i<size;i++)
   {
      name=m_NameMap.NameFromID(i);
      if(SetupMotion(name,i,&rh))
      {
         last=m_RunHandle2Index.Append(i);
         AssertMsg(rh==last,"MotionSet run time data out of synch");
         m_Index2RunHandle.SetItem(&last,i);
      } else
      {
         Warning(("Could not load motion %s\n",name));
         rh=-1;
         m_Index2RunHandle.SetItem(&rh,i);
      }
   }
   
}

void cMotionSet::DippyComputeAllMotPhys()
{
   int i,size,rh;

   size=m_Index2RunHandle.Size();
   for(i=0;i<size;i++)
   {
      rh=m_Index2RunHandle[i];
      if(rh>=0)
         HackComputeMotPhys(rh,i);
   }
}

BOOL cMotionSet::Load(ITagFile *pFile)
{
   // load namemap
   m_NameMap.Load(pFile);
   
   // load motstuff
   int i;
   ulong size;
   sMotStuff stuff;

   ITagFile_Read(pFile,(char *)&size,sizeof(size));
   m_MotStuffList.SetSize(size);
   for(i=0;i<size;i++)
   {
      ITagFile_Read(pFile,(char *)&stuff,sizeof(stuff));
      m_MotStuffList.SetItem(&stuff,i);
   }

   ITagFile_Read(pFile,(char *)&size,sizeof(size));
   m_cMoCapList.SetSize(size);
   for(i=0;i<size;i++)
   {
      cMpsMotion m;

      m.Read(pFile);
      m_cMoCapList.SetItem(&m,i);
   }

   // setup run-time data
   SetupRunTimeData();

   return TRUE;
}

BOOL cMotionSet::Save(ITagFile *pFile)
{
   // save off name map 
   m_NameMap.Save(pFile);

   // save off motstuff
   ulong size=m_MotStuffList.Size();
   int i;

   ITagFile_Write(pFile,(char *)&size,sizeof(size));
   for(i=0;i<size;i++)
   {
      ITagFile_Write(pFile,(char *)&m_MotStuffList[i],sizeof(m_MotStuffList[i]));
   }
   size=m_cMoCapList.Size(); // this should always be same size as motstufflist.
   ITagFile_Write(pFile,(char *)&size,sizeof(size));
   for(i=0;i<size;i++)
   {
      m_cMoCapList[i].Write(pFile);
   }

   return TRUE;
}

BOOL cMotionSet::GetRunHandle(int index, int *pRunHandle)
{
   int rh=m_Index2RunHandle[index];

   if(rh>=0)
   {
      *pRunHandle=rh;
      return TRUE;
   } else
   {
      return FALSE;
   }
}

// set-building functions
void cMotionSet::Clear()
{
   m_Index2RunHandle.SetSize(0);
   m_RunHandle2Index.SetSize(0);
   m_MotStuffList.SetSize(0);
   m_cMoCapList.SetSize(0);
   m_NameMap.Clear();

   mp_close(); // this frees up mp_motion_list
   MotDmngeClose();
}

// needs to be called between startbuild and endbuild calls, since doesn't setup
// run time data.
BOOL cMotionSet::AddMotion(const Label *name, const sMotStuff *pStuff, int *pIndex)
{
   int index;

   // first check if motion already in set.
   index=m_NameMap.IDFromName(name);
   if(index!=kNameMapIndexNotFound) // motion already added
   {
      // motstuff must be identical, otherwise fail
      if(m_MotStuffList[index].flags!=pStuff->flags||
         m_MotStuffList[index].blendLength!=pStuff->blendLength)
      {
         AssertMsg1(FALSE,"Motion %s already added with different stuff\n",name->text);
		   return FALSE;
      }
      *pIndex=index;
      return TRUE;
   }

   index=m_MotStuffList.Append(*pStuff);
   m_NameMap.AddNameAtIndex(name,index); // know these will be consecutive

   AssertMsg(m_NameMap.Size()==m_MotStuffList.Size(),"motion set is out of synch");

   *pIndex=index;

   // try loading the mo-cap .mi file, so don't need to do so at run time
   AutoAppIPtr(ResMan);
   IRes *pRes;
   char fname[32];
   mps_motion *mot;
   mps_comp_motion *components;
   mps_motion_flag *flags;

   strcpy(fname,name->text);
   strcat(fname,".mi");
   pRes = pResMan->Bind(fname, RESTYPE_BINARY, NULL, "motions\\");
   if (!pRes) {
      cMpsMotion m;

      ConfigSpew("yakspew",("motion %s .mi file not found, is virtual?\n",name->text));
      SafeRelease(pRes);

      // add an empty motion
      m_cMoCapList.SetSize(index+1); // same as motstufflist index
      m_cMoCapList.SetItem(&m,index);
      return TRUE;
   }
   mot=(mps_motion *) pRes->Lock();

   // @TODO: get rid of name field in mps_motion_info, since not used.
   // (or start using it?).  Right now, name is likely to be out of synch,
   // since motion files get renamed fairly frequently.

   // mp_alloc-ed stuff gets freed on mp_close, as long as motion was
   // mp_add_motion-ed.
   components=(mps_comp_motion *) mp_alloc(sizeof(mps_comp_motion) * mot->num_components,__FILE__,__LINE__);
   memcpy(components,mot+1,sizeof(mps_comp_motion) * mot->num_components);

   // read flags
   if(mot->num_flags)
	{
	   flags=(mps_motion_flag *) mp_alloc(sizeof(mps_motion_flag) * mot->num_flags,__FILE__,__LINE__);
	   memcpy(flags,((char *)mot)+sizeof(mps_motion)+sizeof(mps_comp_motion)*mot->num_components,sizeof(mps_motion_flag) * mot->num_flags);
	} else
	{
	   flags=NULL;
	}
   mot->components=components;
   mot->flags=flags;
   cMpsMotion m(mot);

   m_cMoCapList.SetSize(index+1); // same as motstufflist index
   m_cMoCapList.SetItem(&m,index);

   // put mot somewhere
   pRes->Unlock();
   SafeRelease(pRes);

   return TRUE;
}

// NOTE: This does not check whether motion was previously loaded,
// however AddMotion prevents a motion from appearing in list twice.
BOOL cMotionSet::SetupMotion(const Label *name,int id,int *runHandle)
{
   // check if motion is a virtual motion
   int index;

   index=m_VMotNameMap.IDFromName(name);
   if(index!=kNameMapIndexNotFound)
   {
      // add the virtual motion to motion list
      *runHandle=mp_add_motion(&m_VMotList[index]);
      return TRUE;
   }

   // check that mot loaded mi file properly at db build time
   if(!m_cMoCapList[id].components) // then mi info never set
   {
      Warning(("cannot setup motion %s. is .mi file in motion database?\n",name->text));
      return FALSE;
   }   
   *runHandle=mp_add_motion(&m_cMoCapList[id]);

   return TRUE;
}

// virtual motion registering, so loading works
void cMotionSet::RegisterVirtualMotion(const Label *name,const mps_motion *pMotion)
{
   int index;

   Assert_(pMotion->info.type==MT_VIRTUAL);
   index=m_VMotList.Append(*pMotion);
   m_VMotNameMap.AddNameAtIndex(name,index);
}

IMotionSet *NewMotionSet()
{
   return new cMotionSet;
}


///////////////////////////////////////////////////
///////////////////////////////////////////////////
///// Global functions
/////
///////////////////////////////////////////////////

#define E398_HACK

static void MotCompXlatCallback(multiped *mp, mps_motion_info *mi,mps_comp_motion *cm,float frame, mxs_vector *data)
{
   mxs_vector *v;
   IRes *pRes;
   MotDataCTable *cTable=NULL;
   BOOL lockedHere=FALSE;
   int iframe=(int)frame;

   if(mp && mp->app_ptr && ((cCreature *)mp->app_ptr)->IsBallistic())
   {
      // OLD - x_copy_vec(data,&mp->global_pos);  // use global pos
#if 0 //! MTR - This set an absolute position when an offset is wanted.
      Position *pPos=ObjPosGet(((cCreature *)mp->app_ptr)->GetObjID());
      if(pPos)
         mx_copy_vec(data,&pPos->loc.vec);
      else
         mx_zero_vec(data);
#endif
      AssertMsg(mp->frame_of_reference != MFRT_REL_START, "Expected ballistic to have global frame");
      mx_zero_vec(data);
      return;
   } 

   if(mi->mot_num<0)
   {
      Warning(("MotCompXlatCallback: invalid motion passed\n"));
      mx_zero_vec(data);
      return;
   }
   if(!MotDmngeIsLocked(mi->mot_num))
   {
      ConfigSpew("MotLockTrack",("MotCompXlatCallback: locking motion %d\n",mi->mot_num));
      MotDmngeLock(mi->mot_num);
      lockedHere=TRUE;
   }
   pRes=MotDmngeHandle(mi->mot_num);
   if(!pRes)
   {
      Warning(("MotCompXlatCallback: cannot get data handle\n"));
      mx_zero_vec(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   // @TBD (justin 6-26-98): DataPeek is an evil hack, and should be
   // replaced by a proper Lock by someone who understands this code
   // well...
   cTable=(MotDataCTable *) pRes->DataPeek();
   if(!cTable)
   {
      Warning(("MotCompXlatCallback: cannot get data from handle\n"));
      mx_zero_vec(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   if(cm->handle>=cTable->numEntries)
   {
      mx_zero_vec(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   v=(mxs_vector *)(((uchar *)cTable)+cTable->offset[cm->handle]);
   if(iframe+1==mi->num_frames)
      mx_copy_vec(data,&v[iframe]);
   else
      mx_interpolate_vec(data,&v[iframe],&v[iframe+1],frame-iframe);
#ifdef E398_HACK
   // keep motion in place if don't want it to have moved at end but
   // want to keep butt free during motion
   Assert_(g_pMotionSet);
   if(g_pMotionSet->WantInPlace(mi->mot_num))
   {
      mxs_vector totXlat;
      float frac;

      g_pMotionSet->GetTranslation(mi->mot_num,&totXlat);
      frac=(frame+1)/mi->num_frames;
      mx_scaleeq_vec(&totXlat,-frac);
      mx_addeq_vec(data,&totXlat);
   }
#endif

   if(lockedHere)
   {
      MotDmngeUnlock(mi->mot_num);
   }
}

///////////////////////////////////////////////////

#define E398_HACK

#ifdef E398_HACK

EXTERN BOOL g_DoRootHack=FALSE;
EXTERN int  g_HackButtJointID=0; 

#endif

// XXX this is really a very bad thing to do, but might still be
// workable if every creature type we invent used the same id for the
// neck joint. hmm.  The real solution is to do away with this neck hack,
// which means solving the capture distortion problem for real.
#define NECK 9

EXTERN BOOL g_mot_quat_debug=FALSE;

// @TODO: GET RID OF NECK HACK!
void MotCompRotCallback(mps_motion_info *mi,mps_comp_motion *cm,float frame, quat *data)
{
   quat *q;
   IRes *pRes;
   MotDataCTable *cTable=NULL;
   BOOL lockedHere=FALSE;
   int iframe=(int)frame;

   if(mi->mot_num<0)
   {
      Warning(("MotCompRotCallback: invalid motion passed\n"));
      quat_identity(data);
      return;
   }
   if(!MotDmngeIsLocked(mi->mot_num))
   {
      ConfigSpew("MotLockTrack",("MotCompRotCallback: locking motion %d\n",mi->mot_num));
      MotDmngeLock(mi->mot_num);
      lockedHere=TRUE;
   }
   pRes=MotDmngeHandle(mi->mot_num);
   if (!pRes)
   {
      Warning(("MotCompRotCallback: cannot get data from handle\n"));
      quat_identity(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   // @TBD (justin 6-26-98): This DataPeek should be replaced by a proper
   // Lock...
   cTable=(MotDataCTable *) pRes->DataPeek();
   if(!cTable)
   {
      Warning(("MotCompRotCallback: cannot get data from handle\n"));
      quat_identity(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   if(cm->handle>=cTable->numEntries)
   {
      quat_identity(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   // XXX this is a hack for fixing the neck in messed up motions.
   // still want to figure out how to deal with motion distortion problems..
   if(cm->joint_id==NECK && (MotDescNeckFixed(mi->mot_num)))
   {
      quat_identity(data);
      if(lockedHere)
         MotDmngeUnlock(mi->mot_num);
      return;
   }
   q=(quat *)(((uchar *)cTable)+cTable->offset[cm->handle]);
   if(iframe+1==mi->num_frames)
      memcpy(data,&q[iframe],sizeof(quat));
   else
      quat_slerp(data,&q[iframe],&q[iframe+1],frame-iframe);

   if (g_mot_quat_debug &&
       ((quat_mag(data) > 1.001)||(quat_mag(data) < 0.999)))
       CriticalMsg3("MotCompRotCallback: Bad quaternion in joint %i, motion %s, frame %g", 
         cm->joint_id, g_pMotionSet->GetName(mi->mot_num), frame);


   if(lockedHere)
   {
      MotDmngeUnlock(mi->mot_num);
   }
#ifdef E398_HACK
   if(g_DoRootHack && g_HackButtJointID==cm->joint_id)
   {
      quat qtmp,foo;
      mxs_matrix mat;
 
      MotRootRotCallback(NULL,mi,frame,&qtmp);
      quat_to_matrix(&mat,&qtmp);
      mx_transeq_mat(&mat);
      quat_from_matrix(&qtmp,&mat);
      // multiply data by inverse of qtmp
      quat_copy(&foo,data);
      quat_mul(data,&foo,&qtmp);
   }
#endif
}

///////////////////////////////////////////////////

void MotRootRotCallback(multiped *mp, mps_motion_info *mi,float frame, quat *data)
{
   if(mp && mp->app_ptr && ((cCreature *)mp->app_ptr)->IsBallistic())
   {
//      quat_identity(data);  // mo-cap doesn't determine root orientation
      Position *pPos=ObjPosGet(((cCreature *)mp->app_ptr)->GetObjID());
      if(pPos)
      {
         mxs_matrix mat; 

         mx_ang2mat(&mat,&pPos->fac);
         quat_from_matrix(data,&mat);
      } else
      {
         quat_identity(data);
      }
   } else
   {
      mxs_ang totRot=g_pMotionSet->GetEndHeading(mi->mot_num);
      quat q,qs;
      mxs_vector zaxis;
      float frac; 
   
      mx_unit_vec(&zaxis,2);
      if(!totRot)
      {
         quat_identity(data);   
         return;
      } 
   //   quat_create(&q,&zaxis,totRot);
      mxs_matrix mat;
      mx_mk_rot_z_mat(&mat,totRot);
      quat_from_matrix(&q,&mat);

      // slerp rotation by how far through motion you are.
      quat_identity(&qs);   
      frac=frame/mi->num_frames;
      quat_slerp(data,&qs,&q,frac);
   }
}

///////////////////////////////////////////////////

void MotFilterCallback(multiped *mp, mps_motion_info *mi,quat *rot, mxs_vector *xlat)
{
   if(mp->app_ptr)
      ((cCreature*)mp->app_ptr)->FilterMotionFrameData(mi,rot,xlat);
}

///////////////////////////////////////////////////////////////////////////////
// $Source: r:/t2repos/thief2/src/motion/mputil.cpp,v $
// $Author: mahk $
// $Date: 1998/10/05 17:26:37 $
// $Revision: 1.4 $
//
// Multiped utilities

#include <lg.h>

#include <mputil.h>

// Must be last header 
#include <dbmem.h>


void MpWriteMotionNode(mps_motion_node *node, MpFileFunc write, 
                       MpFile *file)
{
   write(file, &node->time, sizeof(node->time));
   write(file, &node->handle, sizeof(node->handle));
   write(file, &node->start_frame, sizeof(node->start_frame));
   write(file, &node->frame, sizeof(node->frame));
   write(file, &node->params, sizeof(node->params));
   write(file, &node->base_pos, sizeof(node->base_pos));
   write(file, &node->base_orient, sizeof(node->base_orient));
   write(file, &node->offset, sizeof(node->offset));
   if (node->callback)
      Warning(("MpWriteMotionList: callback on motion %d can't be saved\n",
               node->handle));
   write(file, &node->callback_num, sizeof(node->callback_num));
   write(file, &node->callback_frame, sizeof(node->callback_frame));
   write(file, node->targets, sizeof(*(node->targets)));
   write(file, &node->flag_index, sizeof(node->flag_index));
}

void MpWriteTransitionNode(mps_transition_node *node, MpFileFunc write, 
                       MpFile *file)
{
   write(file, &node->time, sizeof(node->time));
   write(file, &node->duration, sizeof(node->duration));
}

void MpWriteStackNode(mps_stack_node *node, MpFileFunc write, 
                       MpFile *file)
{
   write(file, &node->type, sizeof(node->type));
   if (node->type == MN_MOTION)
      MpWriteMotionNode((mps_motion_node*)node, write, file);
   else
      MpWriteTransitionNode((mps_transition_node*)node, write, file);
}

void MpWriteMotionList(mps_motion_list *list, MpFileFunc write, 
                       MpFile *file)
{
   mps_stack_node *stack;
   int i;
   
   if (list == NULL)
      return;
   write(file, &list->signature, sizeof(list->signature));
   write(file, &list->count, sizeof(list->count));
   stack = list->head;
   for (i=0; i<list->count; i++)
   {
      if (stack == NULL)
      {
         Warning(("MpWriteMotionList: bad motion list\n"));
         return;
      }
      MpWriteStackNode(stack, write, file);
      stack = stack->next;
   }
   write(file, &list->flags, sizeof(list->flags));
}

void MpWriteOverlay(mps_overlay *overlay, MpFileFunc write,
                    MpFile *file)
{
   if (overlay == NULL)
      return;
   write(file, &overlay->sig, sizeof(overlay->sig));
   MpWriteMotionList(&overlay->list, write, file);
   write(file, &overlay->mode, sizeof(overlay->mode));
   write(file, &overlay->time, sizeof(overlay->time));
   write(file, &overlay->duration, sizeof(overlay->duration));
}

void MpWriteMultiped(multiped *mp, MpFileFunc write, MpFile *file)
{
   int i;

   write(file, &mp->app_ptr, sizeof(mp->app_ptr));
   write(file, &mp->num_joints, sizeof(mp->num_joints));
   write(file, &mp->root_joint, sizeof(mp->root_joint));
   write(file, mp->joint_map, mp->num_joints);
   write(file, mp->rel_orients, mp->num_joints*sizeof(quat));
   MpWriteMotionList(&mp->main_motion, write, file);
   write(file, &mp->num_overlays, sizeof(mp->num_overlays));
   for (i=0; i<mp->num_overlays; i++)
      MpWriteOverlay(&mp->overlays[i], write, file);
   write(file, &mp->global_pos, sizeof(mp->global_pos));
   write(file, &mp->global_orient, sizeof(mp->global_orient));
   write(file, &mp->target_heading, sizeof(mp->target_heading));
   write(file, &mp->th_time, sizeof(mp->th_time));
   write(file, &mp->th_duration, sizeof(mp->th_duration));
}

void MpReadMotionNode(mps_motion_node *node, MpFileFunc read,
                      MpFile *file)
{
   read(file, &node->time, sizeof(node->time));
   read(file, &node->handle, sizeof(node->handle));
   read(file, &node->start_frame, sizeof(node->start_frame));
   read(file, &node->frame, sizeof(node->frame));
   read(file, &node->params, sizeof(node->params));
   read(file, &node->base_pos, sizeof(node->base_pos));
   read(file, &node->base_orient, sizeof(node->base_orient));
   read(file, &node->offset, sizeof(node->offset));
   read(file, &node->callback_num, sizeof(node->callback_num));
   read(file, &node->callback_frame, sizeof(node->callback_frame));
   read(file, node->targets, sizeof(*(node->targets)));
   read(file, &node->flag_index, sizeof(node->flag_index));
}

void MpReadTransitionNode(mps_transition_node *node, MpFileFunc read, 
                       MpFile *file)
{
   read(file, &node->time, sizeof(node->time));
   read(file, &node->duration, sizeof(node->duration));
}

void MpReadStackNode(mps_stack_node *node, MpFileFunc read,
                     MpFile *file)
{
   read(file, &node->type, sizeof(node->type));
   if (node->type == MN_MOTION)
      MpReadMotionNode((mps_motion_node*)node, read, file);
   else
      MpReadTransitionNode((mps_transition_node*)node, read, file);
}

void MpReadMotionList(mps_motion_list *list, MpFileFunc read, 
                      MpFile *file)
{
   int i;
   int count;
   mps_motion_node temp;
   mps_stack_node *node;

   read(file, &list->signature, sizeof(list->signature));
   read(file, &count, sizeof(list->count));
   for (i=0; i<list->count; i++)
   {
      MpReadStackNode((mps_stack_node*)&temp, read, file);
      if (temp.type == MN_MOTION)
      {
         node = (mps_stack_node*)mp_alloc(sizeof(mps_motion_node), 
                                          __FILE__, __LINE__);
         memcpy(node, &temp, sizeof(mps_motion_node));
      }
      else
      {
         node = (mps_stack_node*)mp_alloc(sizeof(mps_transition_node),
                                              __FILE__, __LINE__);
         memcpy(node, &temp, sizeof(mps_transition_node));
      }
      mp_list_add(list, node);
   }
   read(file, &list->flags, sizeof(list->flags));
}

void MpReadOverlay(mps_overlay *overlay, MpFileFunc read, MpFile *file)
{
   read(file, &overlay->sig, sizeof(overlay->sig));
   MpReadMotionList(&overlay->list, read, file);
   read(file, &overlay->mode, sizeof(overlay->mode));
   read(file, &overlay->time, sizeof(overlay->time));
   read(file, &overlay->duration, sizeof(overlay->duration));
}

void MpReadMultiped(multiped *mp, MpFileFunc read, MpFile *file)
{
   int i;

   //   mp_free_multiped(mp);
   read(file, &mp->app_ptr, sizeof(mp->app_ptr));
   read(file, &mp->num_joints, sizeof(mp->num_joints));
   read(file, &mp->root_joint, sizeof(mp->root_joint));
   mp->joint_map = (uchar*)mp_alloc(mp->num_joints, 
                                    __FILE__, __LINE__);
   read(file, mp->joint_map, mp->num_joints);
   mp->rel_orients = (quat*)mp_alloc(mp->num_joints*sizeof(quat),
                                     __FILE__, __LINE__);
   read(file, mp->rel_orients, mp->num_joints*sizeof(quat));
   MpReadMotionList(&mp->main_motion, read, file);
   read(file, &mp->num_overlays, sizeof(mp->num_overlays));
   for (i=0; i<mp->num_overlays; i++)
      MpReadOverlay(&mp->overlays[i], read, file);
   read(file, &mp->global_pos, sizeof(mp->global_pos));
   read(file, &mp->global_orient, sizeof(mp->global_orient));
   read(file, &mp->target_heading, sizeof(mp->target_heading));
   read(file, &mp->th_time, sizeof(mp->th_time));
   read(file, &mp->th_duration, sizeof(mp->th_duration));
}
// $Header: r:/t2repos/thief2/src/motion/mschutil.cpp,v 1.5 1998/06/04 16:04:30 kate Exp $

#include <motprop.h>
#include <mschutil.h>
#include <mschbase.h>
#include <motschem.h>
#include <drkcret.h>
#include <plycbllm.h>

#include <dbmem.h> // must be last included header

BOOL MSchUGetGaitData(const cMotionSchema *pSchema, sMGaitSkillData **pData)
{
   ObjID obj;

   Assert_(pSchema);

   Assert_(pSchema->GetFlags()&kMSchFlag_ArchObjSwizzle);

   obj=pSchema->GetArchetype();
   return ObjGetGaitData(obj,pData);
}

BOOL MSchUGetSwordActionType(const cMotionSchema *pSchema, int *pType)
{
   ObjID obj;

   Assert_(pSchema);

   Assert_(pSchema->GetFlags()&kMSchFlag_ArchObjSwizzle);

   obj=pSchema->GetArchetype();
   return ObjGetSwordActionType(obj,pType);
}


BOOL MSchUGetMotControllerID(const cMotionSchema *pSchema, int *pID)
{
   ObjID obj;

   Assert_(pSchema);

   if(pSchema->GetFlags()&kMSchFlag_ArchObjSwizzle)
   {
      obj=pSchema->GetArchetype();
      return ObjGetMotControllerID(obj,pID);
   } else // is player schema
   {
      // @NOTE: this only works if schema is the currently set up one for
      // player cerebellum.  However, this is always the case currently.
      //                                              KJ 4/98
      return PlayerGetMotControllerID(pID);
   }
}

// @TODO: cache last used archetype, and then make a property listener or something,
// so that this doesn't need to check the property every time, since it almost never
// changes, and same archetype will likely get used over and over for same player ability
// (sword idling etc)
BOOL MSchUGetPlayerPosOffset(const cMotionSchema *pSchema, mxs_vector *pPosOff, mxs_angvec *pAngOff)
{
   ObjID obj;

   Assert_(pSchema);

   if(pSchema->GetFlags()&kMSchFlag_ArchObjSwizzle)
   {
      obj=pSchema->GetArchetype();
      return ObjGetPlayerPosOffsets(obj,pPosOff,pAngOff);
   } else
   {
      Warning(("Don't know how to get arm offset\n"));
      return FALSE;
   }
}

BOOL MSchUGetPlayerSkillData(const cMotionSchema *pSchema, sMPlayerSkillData *pSkillData)
{
   // @NOTE: this only works if schema is the currently set up one for
   // player cerebellum.  However, this is always the case currently.
   //                                              KJ 4/98
   return PlayerGetSkillData(pSkillData);
}

// $Header: r:/t2repos/thief2/src/motion/mskilset.cpp,v 1.23 1998/10/13 13:10:40 KATE Exp $

#include <mskilset.h>
#include <motdesc.h>
#include <fix.h>
#include <motdb.h>
#include <motschem.h>
#include <motmngr.h>
#include <mschutil.h>
#include <mclntapi.h>
#include <config.h>
#include <cfgdbg.h>
#include <mmanuver.h>
#include <motprop.h>

#include <dbmem.h>



//////////////////////////////////////////////
//
// Motion SkillSet Stuff
//
//////////////////////////////////////////////

void cMSkillSet::SetActorType(int type)
{
   m_ActorType=type;
}

// @TODO: Get rid of this function everywhere
void cMSkillSet::SetPersistentTags(const cTagSet *pTags)
{
   return;
}

static cTagDBInput g_Tags;

static void SetupTags(const IMotor *pMotor,const cTagSet *pTags,sMotActorTagList **ppActTags)
{
   sMotActorTagList *pActorTags=NULL;

   // add on persistent (actor) tags that always get associated with
   // motion request
   g_Tags.Clear();
   g_Tags.AppendTagSet(pTags); // cast away constness

   // get persistent tags
   if(pMotor && ObjGetActorTagList(pMotor->GetObjID(),&pActorTags))
   {
      cTagSet actorTagSet;

      actorTagSet.FromString(pActorTags->m_TagStrings);
      g_Tags.AppendTagSet(&actorTagSet);
      *ppActTags=pActorTags;
   } else
   {
      *ppActTags=NULL;
   }
}

cMotionPlan *cMSkillSet::BuildPlanFromParams(const sMcMoveParams *pParams,\
      const sMcMotorState *pMotorState, const sMcMoveState *pMoveState, \
      IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cMotionSchema *pSchema;
   sMotActorTagList *pActorTags=NULL;
   cStr spewString;  
   BOOL doSpew=FALSE;

#ifndef SHIP
   doSpew=config_is_defined("MCoordTrace");
#endif

   // NOTE: if specifying motion by name or number, still need schema
   // for archetype

   Assert_(pParams);

   SetupTags(pMotor,&pParams->tags,&pActorTags);

   if(doSpew)
   {
      pParams->tags.ToString(&spewString);
      if(pActorTags)
      {
         spewString.Append(2,", ");
         spewString.Append(strlen(pActorTags->m_TagStrings),pActorTags->m_TagStrings);
      }
      spewString.Append(4,"} : ");
   }

   if(!g_pMotionDatabase->GetBestMatch(m_ActorType,&g_Tags,&pSchema))
   {
      if(doSpew)
      {
         spewString.Append(8,"no match");
         mprintf("tag request {%s\n",spewString);
      }
      return NULL;
   }

   Assert_(pSchema);

   if(doSpew)
   {
      char buf[32];

      sprintf(buf,"match %d : %d mots",pSchema->GetSchemaID(),pSchema->NumMotions());
      buf[31]='\0';
      spewString.Append(strlen(buf),buf);
      mprintf("tag request {%s\n",spewString);
   }

   int id;

   if(!MSchUGetMotControllerID(pSchema,&id))
   {
      Warning(("No motor controller for schema\n"));
      return NULL;
   }
   cMotionPlan *pPlan=g_ManeuverFactoryList[id]->CreatePlan(pSchema,*pMotorState,*pMoveState,*pParams,pMotor,pCoord);
   // set app data to controller id.  secretly know only one maneuver in plan - KJ
   if(pPlan)
   {
      IManeuver *pMnvr=pPlan->GetFirstManeuver();
      pMnvr->SetAppData(id); // store this for load/save purposes KJ 10/98
   }
   return pPlan;
}


void cMSkillSet::Pose(const cTagSet *pTags, float frac,IMotor *pMotor)
{
   sMotActorTagList *pActTagNames;
   cMotionSchema *pSchema;
   int motNum;

   SetupTags(pMotor,pTags,&pActTagNames);

   if(g_pMotionDatabase->GetBestMatch(m_ActorType,&g_Tags,&pSchema))
   {
      if(pSchema->GetMotion(0,&motNum))
      {
         pMotor->PoseAtMotionFrame(motNum,frac*(g_pMotionSet->GetNumFrames(motNum)-1));
      }
   }
}
// $Header: r:/t2repos/thief2/src/motion/mskltree.cpp,v 1.3 1997/12/22 19:48:56 mahk Exp $

#include <mskltree.h>
#include <lg.h>

// Must be last header
#include <dbmem.h>

#define kValueAny 3 // XXX need to invent this for real

typedef tMSkillKey tMSkillMask;

class cMSkillMask
{
public:
   cMSkillMask(const tMSkillKey key=0, const int bitShift=0, const int nValues=0);
//   cMSkillMask(const cMSkillMask& mask);

   BOOL GetValue(tMSkillKey *pValue, const int index) const;

   // Builds a key with current mask's values and value at index set to value argument
//   tMSkillKey MakeChildKey(const int index, const int value);

private:
   const tMSkillKey m_Key;
   const ushort m_BitShift;
   ushort m_BitMask;
   const int m_nValues;
};

class cMSkillTreeNode
{
public:

   cMSkillTreeNode(const int depth, const int maxChildren, const cMSkillTree *pTree);
   ~cMSkillTreeNode();

   cMSkillTreeNode *InsertChild(const int iChild);

   cMSkillTreeNode *GetChild(const int iChild) { \
      AssertMsg1(iChild<m_MaxChildren,"cMSkillTreeNode::GetChild. index %d too big",iChild); \
      return m_ppChildren[iChild]; }

   void MakeLeaf(void *pData);

   BOOL IsLeaf() { return m_IsLeaf; }

   void *GetData(const cMSkillMask& mask) { return LinearGetData(mask); }

private:

   void *RecursiveGetData(const cMSkillMask &mask);
   void *LinearGetData(const cMSkillMask &mask);

   bool m_IsLeaf;
   uchar m_Depth;
   uchar m_nChildren;
   const uchar m_MaxChildren;
   void *m_pData;
   cMSkillTreeNode **m_ppChildren;
   const cMSkillTree *m_pTree; // the tree this node belongs to
};


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///
///  ATree implementation
///
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

cMSkillTree::cMSkillTree(const int bitsPerLevel, const int maxDepth)
 : m_BitShift(bitsPerLevel),
   m_MaxDepth(maxDepth),
   m_MaxEntriesPerLevel((1<<bitsPerLevel)-1)  // subtract off for wild value
{
   AssertMsg2((bitsPerLevel*maxDepth)/8 <= sizeof(tMSkillKey),\
      "ATree cannot support key size of %d*%d bits\n",bitsPerLevel,maxDepth);

   m_pHead=NULL;
}

////////////////////////////////////////////////////////////////////////////////

cMSkillTree::cMSkillTree(const cMSkillTree& atree)
 : m_BitShift(atree.m_BitShift),
   m_MaxEntriesPerLevel(atree.m_MaxEntriesPerLevel),
   m_MaxDepth(atree.m_MaxDepth)
{
   m_pHead=atree.m_pHead;
}

////////////////////////////////////////////////////////////////////////////////

cMSkillTree::~cMSkillTree()
{
   if(m_pHead)
      delete m_pHead;
}

////////////////////////////////////////////////////////////////////////////////

// XXX should make this inline, I think
tMSkillKey cMSkillTree::BuildKey(const sMSkillKeyDesc &keyDesc)
{
   int i;
   uchar *pVal=keyDesc.pValues;
   tMSkillKey key=0;

   AssertMsg1(keyDesc.nValues<=m_MaxDepth,"cMSkillTree::BuildKey. Request has %d values!",keyDesc.nValues);
   pVal=keyDesc.pValues;
   for(i=0;i<keyDesc.nValues;i++,pVal++)
   {
      if(*pVal>m_MaxEntriesPerLevel)
      {
         AssertMsg2(*pVal<=m_MaxEntriesPerLevel,"cMSkillTree::BuildKey. Value %d at entry %d is too large to use\n",*pVal, i);
      }
      key|=(*pVal)<<(m_BitShift*i);
   }
   return key;
}

////////////////////////////////////////////////////////////////////////////////

void cMSkillTree::InsertData(const void *pData, const tMSkillKey key)
{
   if(!m_pHead)
   {
      cMSkillMask mask(key, m_BitShift, m_MaxDepth);

      m_pHead=new cMSkillTreeNode(0, m_MaxEntriesPerLevel, this);

      if(!m_pHead)
      {
         AssertMsg(m_pHead,"Unable to create ATree node!\n");
         return;
      }
   }
   int depth=0;
   tMSkillKey val=0;
   cMSkillMask mask(key,m_BitShift,m_MaxDepth);
   cMSkillTreeNode *pNode=m_pHead;
   cMSkillTreeNode *pChild;

   while(mask.GetValue(&val,depth++))
   {
      AssertMsg(val!=GetWildValue(),"cMSkillTree::InsertData. key must be fully specified. 'Any' is not allowed\n");
      if(!(pChild=pNode->GetChild(val)))
      {
         pChild=pNode->InsertChild(val);
      }
      pNode=pChild;
   }
   // insert leaf
   pNode->MakeLeaf((void *)pData); // secretly know that we don't change it
}

////////////////////////////////////////////////////////////////////////////////

void *cMSkillTree::GetData(const tMSkillKey key)
{
   if(!m_pHead)
      return NULL;

   cMSkillMask mask(key,m_BitShift,m_MaxDepth);
   return m_pHead->GetData(mask);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///
///  cMSkillMask implementation
///
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

cMSkillMask::cMSkillMask(const tMSkillKey mask, const int bitShift, const int nValues)
 : m_BitShift(bitShift),
   m_nValues(nValues),
   m_Key(mask)
{
   int i=bitShift;
   ulong bit=0x1;

   m_BitMask=0;
   while(i--)
   {
      m_BitMask|=bit;
      bit=bit<<1;
   }
}

inline BOOL cMSkillMask::GetValue(tMSkillKey *pValue, const int index) const
{
   tMSkillKey val=m_Key;

   if(index>=m_nValues)
      return FALSE;

   val=val>>(m_BitShift*index);
   *pValue=val&m_BitMask;
   return TRUE;
}

#if 0
cMSkillMask::cMSkillMask(const cMSkillMask& mask)
 : m_Key(mask.m_Key),
   m_BitShift(mask.m_BitShift),
   m_BitMask(mask.m_BitMask),
   m_nValues(mask.m_nValues)
{
}

tMSkillKey cMSkillMask::MakeChildKey(const int index, const int value)
{
   tMSkillKey key=m_Key;
   int i=index;
   int val=value&m_BitMask;
   int mask=m_BitMask;

   val=val<<(m_BitShift*index);
   mask=mask<<(m_BitShift*index);

   tMSkillKey MakeChildKey(const int index, const int value);
   key=key&(~mask); // in case value at index was previously set, this will wipe it
   key=key|val;
   return key;
}
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///
///  cMSkillTreeNode implementation
///
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

cMSkillTreeNode::cMSkillTreeNode(const int depth, const int maxChildren, const cMSkillTree *pTree)
 : m_MaxChildren(maxChildren),
   m_pTree(pTree)
{
   m_IsLeaf=FALSE;
   m_Depth=depth;
   m_nChildren=0;
   m_pData=NULL;

   m_ppChildren=new cMSkillTreeNode *[m_MaxChildren];
   // NULL it out
   int i;
   for(i=0;i<m_MaxChildren;i++)
   {
      m_ppChildren[i]=NULL;
   }
}

cMSkillTreeNode::~cMSkillTreeNode()
{
   int i;
   cMSkillTreeNode **ppChild=m_ppChildren;

   for(i=0;i<m_nChildren;i++,ppChild++)
   {
      if(*ppChild)
         delete *ppChild;
   }
   delete [] m_ppChildren; 
}

cMSkillTreeNode *cMSkillTreeNode::InsertChild(const int iChild)
{
   cMSkillTreeNode *pChild;

   pChild=m_ppChildren[iChild];
   if(pChild)
   {
      AssertMsg1(FALSE,"cMSkillTreeNode::InsertChild.  Child already exists at %d\n",iChild);
      return pChild;
   }
   m_ppChildren[iChild]=new cMSkillTreeNode(m_Depth+1,m_MaxChildren,m_pTree);
   if(m_nChildren<=iChild)
   {
      m_nChildren=iChild+1;
   }
   return m_ppChildren[iChild];
}

void cMSkillTreeNode::MakeLeaf(void *pData)
{
   if(m_nChildren)
   {
      AssertMsg1(FALSE,"Cannot make node a leaf since already has %d children!\n",m_nChildren);
      return;
   }
   if(m_IsLeaf)
   {
      AssertMsg(FALSE,"Cannot make node a leaf since it already is one");
      return;
   }
   m_IsLeaf=TRUE;
   m_pData=pData;
}

// to depth-first recursion on tree
void *cMSkillTreeNode::RecursiveGetData(const cMSkillMask &mask)
{
   int i=0;
   void *pData;
   cMSkillTreeNode *pChild;
   tMSkillKey val;

   while(i<m_nChildren)
   {
      pChild=GetChild(i);
      if(!pChild) // dead end.  data not to be found here, so check other kids
         continue;
      if(pChild->IsLeaf()) // found the data.  get outta here.
         return pChild->m_pData;
      // sanity check
      AssertMsg1(mask.GetValue(&val,m_Depth+1),"No value for mask at depth %d",m_Depth+1);
      mask.GetValue(&val,m_Depth+1);

      if(val!=m_pTree->GetWildValue()) // revert to linear search
      {
         if(NULL!=(pData=pChild->LinearGetData(mask)))
         {
            // found the data.   get outta here
            return pData;
         }
      } else // continue with recursive search
      {
         if(NULL!=(pData=pChild->RecursiveGetData(mask)))
         {
            // found the data.   get outta here
            return pData;
         }
      }
      // haven't found the data yet, check next child
      i++;
   }
   // checked all children and failed to find data
   return NULL;
}

void *cMSkillTreeNode::LinearGetData(const cMSkillMask &mask)
{
   int depth=m_Depth;
   tMSkillKey val;
   cMSkillTreeNode *pNode=this;
   cMSkillTreeNode *pChild;

   while(mask.GetValue(&val,depth++))
   {
      if(val==m_pTree->GetWildValue()) // need to check recursively
      {
         return pNode->RecursiveGetData(mask);
      }
      AssertMsg(!pNode->IsLeaf(),"cMSkillTreeNode::LinearGetData. tree badly constructed");

      pChild=pNode->GetChild(val);
      if(!pChild) // no entry for key
         return NULL;

      pNode=pChild;
   }
   // if got this far, then node HAS to be leaf
   AssertMsg(pNode->IsLeaf(),"cMSkillTreeNode::LinearGetData. tree badly constructed");
   return pNode->m_pData;
}
// $Header: r:/t2repos/thief2/src/motion/mvrcmbat.cpp,v 1.31 1999/12/09 20:19:31 BODISAFA Exp $

#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <motdesc.h>
#include <mclntapi.h>
#include <mprintf.h>
#include <weapon.h>
#include <osystype.h>
#include <cfgdbg.h>
#include <mschutil.h>
#include <weaphalo.h>
#include <mvrflags.h>
#include <mschbase.h>
#include <appagg.h>
#include <iobjsys.h> // woo hoo comm-y stuff
#include <ghostmvr.h>
#include <textarch.h>
#include <crwpnapi.h>

      // must be last header
#include <dbmem.h>

// each motor controller that wants to look at inter-maneuver state should
// have unique value for lastControllerID field.
#define kMvrUID_Combat 0x1 

// inter-maneuver state flag
#define kMnvrState_HackBlockThing 0x1

class cCombatManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const cMotionSchema *schema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      

   virtual IManeuver *LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile);
};

typedef struct
{
   BOOL m_DoRotate;
   mxs_angvec m_Direction;
   int m_MotionNum;
   int m_RestMotion;
   ObjID m_WeaponObj;
   BOOL m_ReturningToRest;
   BOOL m_DoingSwing;
   int m_SchemaID;
   float m_TimeWarp;
   int m_ActionType;
   ObjID m_FocusObj;
   BOOL m_IsPhysical;
   fix m_TurnSpeed;
} sCombatData;

class cCombatManeuver: public cManeuver, private sCombatData
{
public:
   cCombatManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams *pParams, const mxs_angvec *pDirection=NULL,BOOL doDir=FALSE);
   cCombatManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success);
   ~cCombatManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();
   virtual void Finish();
   virtual void SetMotor(IMotor *pMotor);
   virtual void Save(ITagFile *pTagFile);
   virtual void DestroyWeapon();


////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel); }
   virtual void NotifyAboutBeingStuck() { m_pMotor->StopMotion(m_MotionNum); }
   virtual void NotifyAboutMotionAbortRequest();

//
// Motion status notification functions
//
   virtual void NotifyAboutFrameFlags(const int);
#if 0
   virtual void NotifyAboutFrameUpdateBegin(const ObjID);
   virtual void NotifyAboutFrameUpdateEnd(const ObjID);
#endif

   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);

private:
};

cCombatManeuverFactory g_CombatManeuverFactory;
EXTERN cManeuverFactory *g_pCombatManeuverFactory=&g_CombatManeuverFactory;

cMotionPlan *cCombatManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cCombatManeuver *pMnvr;

   if(params.mask&kMotParmFlag_Facing)
   {
      pMnvr = new cCombatManeuver(pMotor, pCoord, pSchema, &params,&params.facing,TRUE);
   } else
   {
      pMnvr = new cCombatManeuver(pMotor, pCoord, pSchema, &params);
   }
   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

IManeuver *cCombatManeuverFactory::LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile)
{
   BOOL success;
   cCombatManeuver *pMnvr=new cCombatManeuver(pMotor,pCoord,pTagFile,&success);

   if(!success)
   {
      delete pMnvr;
      return NULL;
   }
   return pMnvr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// Combat MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define MAX_INTERESTED_MOTIONS 10


cCombatManeuver::cCombatManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams *pParams, const mxs_angvec *pDirection, BOOL doDir)
{
   Assert_(pSchema);
   Assert_(pMotor);

   if(doDir)
   {
      m_DoRotate=TRUE;
      m_Direction=*pDirection;
   } else
   {
      m_DoRotate=FALSE;
   }
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_ReturningToRest=FALSE;
   m_DoingSwing=FALSE;
   m_WeaponObj=OBJ_NULL;
   m_SchemaID=pSchema->GetSchemaID();
   if(!MSchUGetSwordActionType(pSchema,&m_ActionType))
      m_ActionType=kMSAT_Swing; // default
   m_IsPhysical=FALSE;

   if(pParams->mask&kMotParmFlag_FocusObj)
      m_FocusObj=pParams->focus;
   else
      m_FocusObj=OBJ_NULL;
   m_TurnSpeed = pParams->turnspeed;
   
   int startMotOff;

   if (m_ActionType == kMSAT_Swing)
   {
      if (!pSchema->GetMotion(0,&m_RestMotion))
      {
         Warning(("CombatManeuver: no rest position\n"));
         m_RestMotion=-1;
      }
      startMotOff=1;
   } 
   else
   if (m_ActionType == kMSAT_GeneralBlock)
   {
      if (!pSchema->GetMotion(0,&m_RestMotion))
      {
         Warning(("CombatManeuver: no rest position\n"));
         m_RestMotion=-1;
      }
      startMotOff=0;
   }
   else
   {
      m_RestMotion=-1;
      startMotOff=0;
   } 

   m_MotionNum=-1;
   if (IsRemoteGhost(pMotor->GetObjID()))
   {
      m_MotionNum = GetGhostMotionNumber();
#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("rCmbat: Remote ghost %d playing schema %d, motion %d\n", pMotor->GetObjID(), m_SchemaID, m_MotionNum);
      }
#endif
   }
   if (m_MotionNum==-1)  // not a remoteghost, or remghost didnt want to deal 
   {
      if(!pSchema->GetRandomMotionInRange(startMotOff,pSchema->NumMotions()-1,&m_MotionNum))
      {
         Warning(("rCmbat: CombatManeuver(True!): unable to find motion\n"));
         m_MotionNum=-1;
      }
      
      if (IsLocalGhost(pMotor->GetObjID()))
      {
#ifndef SHIP
         if (config_is_defined("ghost_motion_spew"))
         {
            mprintf("rCmbat: Local ghost %d informing remote about schema %d, motion %d\n", 
                    pMotor->GetObjID(), m_SchemaID, m_MotionNum);
         }
#endif
         // @TODO: CAC: tell remote ghost that we're playing a motion
         GhostSendMoCap(pMotor->GetObjID(),m_SchemaID,m_MotionNum,FALSE);
      }
   }

   m_TimeWarp=1.0;
   pSchema->GetTimeWarp(&m_TimeWarp);
}

cCombatManeuver::cCombatManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success)
{
   *success=TRUE;
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sCombatData *)this),sizeof(*((sCombatData*)this)));
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   Assert_(m_pMotor);
   // swizzle motion number
   if(m_MotionNum!=-1)
   {
      m_MotionNum=m_pMotor->SwizzleMotion(m_MotionNum);   
      if(m_MotionNum==-1) // couldn't swizzle
         *success=FALSE;
   }
   // check that motor is in same state we think we are
   if(m_pMotor->GetCurrentMotion()!=m_MotionNum)   // out of synch!
   {
      Warning(("cGroundLocoManuever: cannot load maneuver because creature is out of synch\n"));
      m_MotionNum=-1;
      *success=FALSE;
   }
   // swizzle objects and other mots
   // @NOTE: not swizzling rest motion, because this wasn't 
   // necessarily playing when saved, so won't swizzle correctly.
   // swizzling only needed when motion db changes KJ 10/98
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   m_WeaponObj=pObjSys->RemapOnLoad(m_WeaponObj);
   m_FocusObj=pObjSys->RemapOnLoad(m_FocusObj);
}

void cCombatManeuver::Save(ITagFile *pTagFile)
{
   // write app_data from cmaneuver
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sCombatData*)this),sizeof(*((sCombatData*)this)));
}

cCombatManeuver::~cCombatManeuver()
{
   // Stop motion if one is playing

   if(m_pMotor)
   {
      if(m_MotionNum>=0)
         m_pMotor->StopMotion(m_MotionNum);
      m_pMotor->SetFocus(OBJ_NULL,m_TurnSpeed);
   }
   DestroyWeapon();
}

void cCombatManeuver::SetMotor(IMotor *pMotor) 
{ 
   DestroyWeapon();
   m_pMotor=pMotor;
}

void cCombatManeuver::DestroyWeapon()
{
   if(m_WeaponObj!=OBJ_NULL)
   {
      ObjID me;
      // detach weapon
      if(!m_pMotor)
      {
         Warning(("detaching weapon %d from non-existant creature!\n",m_WeaponObj));
         me=OBJ_NULL;
      } else
      {
         me=m_pMotor->GetObjID();
      }

      // in case never dephysicalized
      if(m_IsPhysical)
      {
         MakeAIWeaponNonPhysical(me,m_WeaponObj); // in case not already done
         if(m_ActionType==kMSAT_GeneralBlock)
            WeaponHaloDeflate(me,m_WeaponObj); // @NOTE: this may get called twice
         ConfigSpew("MnvrTrace",("%d: de-physicalizing\n",me));
      }
      ConfigSpew("MnvrTrace",("%d: unequip weapon\n",me));
      UnEquipAIWeapon(me,m_WeaponObj);
      m_WeaponObj=NULL;
   }
}


void cCombatManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for Combat maneuver");
}

static float g_HackTestPercent = 0.1;

void cCombatManeuver::Execute()
{
// calculate end height of motion
   mxs_real height;
   ObjID    standing_obj;
   int startFrame=0;
   ulong motFlags=NULL;
   BOOL doingBlockContinue=FALSE;

   AssertMsg(m_pMotor,"no motor for combat maneuver\n");
   Assert_(m_pCoord);   

   sMcMotorState *pS=m_pCoord->GetInterMnvrState();
   // check if last maneuver said to do block thing  
   if(m_ActionType==kMSAT_DirectedBlock && pS->lastControllerID==kMvrUID_Combat && pS->flags&kMnvrState_HackBlockThing)
   {
      doingBlockContinue=TRUE;
      // @TODO: find out how far through to start motion.
      // @DIPPY: this should be a "getmotioninfo" function elsewhere
      if(m_MotionNum>=0)
      {
         startFrame=mp_motion_list[m_MotionNum].info.num_frames*pS->lastMotPercentCompleted;
         ConfigSpew("MnvrTrace",("doing continue mot %d\n",m_MotionNum));
         motFlags=kMotStartFlag_SetStartFrame;
      }
   } 

   m_pCoord->ClearInterMnvrState();
   pS->lastSchemaID=m_SchemaID;
   pS->lastControllerID=kMvrUID_Combat;

   Location *pLocation=(Location *)m_pMotor->GetLocation();

   if(m_FocusObj!=OBJ_NULL)
   {
      m_pMotor->SetFocus(m_FocusObj,m_TurnSpeed);
   }

   MvrFindGroundHeight(m_pMotor->GetObjID(),pLocation,&height,&standing_obj);
   mxs_vector buttPos;

   MvrSetStandingObj(m_pMotor->GetObjID(), standing_obj);

   mx_copy_vec(&buttPos,&pLocation->vec);
   if(!MvrGetEndButtHeight(m_pMotor,m_MotionNum,&buttPos.z))
      buttPos.z=0;
   buttPos.z+=height;

   // and set its offset
   if (!IsTextureObj(standing_obj))
      MvrSetStandingOffset(m_pMotor->GetObjID(), standing_obj, &buttPos);
   else
   {
      mxs_vector offset = {0, 0, height};
      MvrSetTerrStandingOffset(m_pMotor->GetObjID(), &offset);
   }

//   buttPos.z=height+m_pMotor->GetButtZOffset();

   if(m_DoRotate)
   {
      // NOTE: this assumes that direction of action in motion capture
      // is along the x-axis
      m_pMotor->SetTransform(&buttPos,&m_Direction);
   } else
   {
      m_pMotor->SetPosition(&buttPos);
   }
   if(m_MotionNum<0)
   {
      sMcMoveState state;
      // XXX need to rework this end state stuff

      AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   } else
   {
      if(m_pMotor)
      {
         ObjID me=m_pMotor->GetObjID();

         // @TODO:  Bodisafa 12/1/1999
         // mode hould be related to AI maneuver.
         if(!EquipAIWeapon(me, &m_WeaponObj, kWeaponModeMelee))
         {
            Warning(("Could not attach weapon to %d\n",me));
            m_WeaponObj=OBJ_NULL;
         } 
         mps_motion_param param;

         param.flags=0;

         if(m_TimeWarp!=1.0)
         {
            param.flags|=MP_DURATION_SCALE;
            param.duration_scalar=m_TimeWarp;
         }
         m_pMotor->StartMotionWithParam(m_MotionNum,&param,motFlags,startFrame);
         m_DoingSwing=TRUE;

         if(doingBlockContinue)
         {
            // @HACK
            // to physicalize, since this won't get triggered since start frame is
            // offset
            NotifyAboutFrameFlags(MF_TRIGGER2);
         }
      }
   }
}

void cCombatManeuver::Finish()
{
   if(m_ActionType!=kMSAT_GeneralBlock)
      return;

   if(m_pMotor)
   {
      ConfigSpew("MnvrTrace",("%d: told to finish\n",m_pMotor->GetObjID()));
   }

   // store off how far through motion you are etc
   // if blocking, set secret maneuver state so next one will know to 
   // start part-way through.
   // @TODO: calculate how far through to start next motion
   sMcMotorState *pMS=m_pCoord->GetInterMnvrState();
   pMS->flags|=kMnvrState_HackBlockThing;
   pMS->lastMotPercentCompleted=g_HackTestPercent;
}

// XXX need to rework this end state stuff
void cCombatManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
   
   // check that it isn't just the swing aborting 
   if(m_ReturningToRest&&m_MotionNum!=motionNum)
      return;

   if(m_WeaponObj!=OBJ_NULL)
   {
      // detach weapon
      if(!m_pMotor)
      {
         Warning(("Cannot detach weapon %d from creature!\n",m_WeaponObj));
      } else
      {
         ObjID me=m_pMotor->GetObjID();

         ConfigSpew("MnvrTrace",("%d: finished swing\n",me));
         if(m_IsPhysical)
         {
            ConfigSpew("MnvrTrace",("%d: de-physicalizing\n",me));
            MakeAIWeaponNonPhysical(me,m_WeaponObj);
            // @TODO: make this happen on frame callback
            if(m_ActionType==kMSAT_GeneralBlock)
               WeaponHaloDeflate(me,m_WeaponObj);
            m_IsPhysical=FALSE;
         }
      }
   }

   m_pCoord->NotifyAboutManeuverCompletion(this,state);
}

// XXX need to rework this end state stuff
void cCombatManeuver::NotifyAboutMotionAbortRequest()
{
   if (!m_DoingSwing)
      return;

   Assert_(m_pMotor);

   // check that not already returning to rest
   if(m_ReturningToRest)
   {
      return;
   }

   // make weapon non-physical
   if(m_WeaponObj!=OBJ_NULL)
   {
      // detach weapon
      if(!m_pMotor)
      {
         Warning(("Cannot detach weapon %d from creature!\n",m_WeaponObj));
      } else
      {
         ObjID me=m_pMotor->GetObjID();

         ConfigSpew("MnvrTrace",("%d: de-physicalizing and un-equipping\n",me));
         MakeAIWeaponNonPhysical(me,m_WeaponObj);
//         UnEquipAIWeapon(me,m_WeaponObj);
         m_IsPhysical=FALSE;
      }
      m_WeaponObj=OBJ_NULL;
   }

   m_ReturningToRest=TRUE;

   // if have recover motion, stop motion and
   // start rest motion, so creature will "recover" to rest
   if(m_MotionNum>=0 && m_pMotor && m_RestMotion>=0)
   {
      int curMot;

      ConfigSpew("MnvrTrace",("%d: aborting\n",m_pMotor->GetObjID()));

      curMot=m_MotionNum;
      m_MotionNum=m_RestMotion;
      m_pMotor->StopMotion(curMot);
      m_DoingSwing=FALSE;

      if(m_MotionNum<0)
      {
         sMcMoveState state;
         
         m_pCoord->NotifyAboutManeuverCompletion(this,state);
         return;
      } 
      // make recovery be grounded
      //

      mxs_real height;
      ObjID    standing_obj;
   
      // find ground height
      Location *pLocation=(Location *)m_pMotor->GetLocation();
      MvrFindGroundHeight(m_pMotor->GetObjID(),pLocation,&height,&standing_obj);

      MvrSetStandingObj(m_pMotor->GetObjID(), standing_obj);

      // find butt translation at end of motion
      mxs_vector buttPos;
      mx_copy_vec(&buttPos,&pLocation->vec);
      if(!MvrGetEndButtHeight(m_pMotor,m_MotionNum,&buttPos.z))
         buttPos.z=0;
      buttPos.z+=height;
      m_pMotor->SetPosition(&buttPos);
      m_pMotor->StartMotion(m_MotionNum);
   }
}

void cCombatManeuver::NotifyAboutFrameFlags(const int flag)
{
   Assert_(m_pMotor);

   ObjID obj=m_pMotor->GetObjID();

   if((flag&MF_TRIGGER2) && !m_IsPhysical) // then make physical
   {
      if(!MakeAIWeaponPhysical(obj,m_WeaponObj))
      {
         ConfigSpew("MnvrTrace",("%d: could not physicalize swing\n",obj));

         // stop the motion
         m_pMotor->StopMotion(m_MotionNum);
         return;
      }
      ConfigSpew("MnvrTrace",("%d: physicalized swing\n",obj));
      if(m_ActionType==kMSAT_GeneralBlock)
         WeaponHaloInflate(obj,m_WeaponObj);
      m_IsPhysical=TRUE;

   } 
   if((flag&MF_TRIGGER3) && m_IsPhysical)  // then make non-physical
   {
      MakeAIWeaponNonPhysical(obj,m_WeaponObj);
      if(m_ActionType==kMSAT_GeneralBlock)
         WeaponHaloDeflate(obj,m_WeaponObj); // @NOTE: this may get called twice
      m_IsPhysical=FALSE;
      ConfigSpew("MnvrTrace",("%d: de-physicalizing on flag\n",m_pMotor->GetObjID()));
   }
   MvrProcessStandardFlags(m_pMotor,m_pCoord,flag);
}
///////////////////////////////////////////////////////////////////////////////
// $Header: r:/t2repos/thief2/src/motion/mvrflags.cpp,v 1.7 1999/08/05 17:08:08 Justin Exp $
//

#include <lg.h>

#include <hashset.h>
#include <hshsttem.h>

#include <sdesc.h>
#include <sdesbase.h>

#include <medmenu.h>
#include <mvrflags.h>

// Must be last header
#include <dbmem.h>

////////////////////////////////////////////////////////////////////////////////

static const char *frame_flag_names[] = 
{
   "Standing",
   "Left Footfall",
   "Right Footfall",
   "Left Foot Up",
   "Right Foot Up", 
   "Fire Release",
   "Can Interrupt",
   "Start Motion Here",
   "End Motion Here",
   "",
   "",
   "",
   "Trigger 1",
   "Trigger 2",
   "Trigger 3",
   "Trigger 4",
   "Trigger 5",
   "Trigger 6",
   "Trigger 7",
   "Trigger 8",
};

static sFieldDesc frame_flag_fields[] =
{
   { "Flag Value", kFieldTypeBits, FieldLocation(sFlagValue, value), FullFieldNames(frame_flag_names) },
};

sStructDesc frame_flag_desc = StructDescBuild(sFlagValue, kStructFlagNone, frame_flag_fields);

////////////////////////////////////////////////////////////////////////////////

class cMotionFlagTable : public cHashSet <sFlagListen *, const ObjID *, cHashFunctions>
{
   virtual tHashSetKey GetKey(tHashSetNode p) const
   {
      return (tHashSetKey)&((sFlagListen *)p)->objID;
   }
};

cMotionFlagTable motionFlagTable;

////////////////////////////////////////////////////////////////////////////////

void MotionFlagsInit()
{
   motionFlagTable.DestroyAll();
}

////////////////////////////////////////

void MotionFlagsTerm()
{
   motionFlagTable.DestroyAll();
}

////////////////////////////////////////////////////////////////////////////////

void ClearMotionFlagListeners(ObjID objID)
{
   sFlagListen *pFlagListen;

   if ((pFlagListen = motionFlagTable.Search(&objID)) != NULL)
      delete motionFlagTable.Remove(pFlagListen);
}

////////////////////////////////////////

void AddMotionFlagListener(ObjID objID, ulong flags, tFlagListenFunc ListenerFunc)
{
   sFlagListen *pFlagListen;
   BOOL new_entry = FALSE;
   int i;

   if ((pFlagListen = motionFlagTable.Search(&objID)) == NULL)
   {
      new_entry = TRUE;
      pFlagListen = new sFlagListen;

      pFlagListen->objID = objID;
      pFlagListen->interestedFlags = flags;
      pFlagListen->triggeredFlags = 0;

      for (i=0; i<MF_MAX_BITS; i++)
         pFlagListen->fnFlagListeners[i] = NULL;
   }
   else
      pFlagListen->interestedFlags |= flags;

   for (i=0; i<MF_MAX_BITS; i++)
   {
      if (flags & (1 << i))
         pFlagListen->fnFlagListeners[i] = ListenerFunc;
   }

   if (new_entry)
      motionFlagTable.Insert(pFlagListen);
}

////////////////////////////////////////

void RemoveMotionFlagListener(ObjID objID, ulong flags)
{
   sFlagListen *pFlagListen;

   if ((pFlagListen = motionFlagTable.Search(&objID)) == NULL)
      return;

   BOOL any_flags = FALSE;

   for (int i=0; i<MF_MAX_BITS; i++)
   {
      if (flags & (1 << i))
      {
         pFlagListen->interestedFlags &= ~(1 << i);
         pFlagListen->fnFlagListeners[i] = NULL;
      }

      if (pFlagListen->interestedFlags & (1 << i))
         any_flags = TRUE;
   }

   if (!any_flags)
      delete motionFlagTable.Remove(pFlagListen);
}

////////////////////////////////////////

void NotifyMotionFlags(ObjID objID, ulong flags, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   sFlagListen *pFlagListen;

   if ((pFlagListen = motionFlagTable.Search(&objID)) == NULL)
      return;

   for (int i=0; i<MF_MAX_BITS; i++)
   {
      if ((flags & (1 << i)) && (pFlagListen->interestedFlags & (1 << i)))
      {
         // Either callback or set triggered flags
         if (pFlagListen->fnFlagListeners[i] != NULL)
            pFlagListen->fnFlagListeners[i](objID, pMotor, pCoord, (1 << i));
         else
            pFlagListen->triggeredFlags |= (1 << i);
      }
   }
}

////////////////////////////////////////

ulong PollMotionFlags(ObjID objID, ulong flags)
{
   sFlagListen *pFlagListen;

   if ((pFlagListen = motionFlagTable.Search(&objID)) == NULL)
   {
      Warning(("Polling motion flags of object without motion flag listener.\n"));
      return 0;
   }

   ulong triggered = 0;

   // Build triggered flags
   for (int i=0; i<MF_MAX_BITS; i++)
   {
      if (flags & (1 << i))
         triggered |= (pFlagListen->triggeredFlags & (1 << i));
   }

   // Clear triggered flags we are informing about
   pFlagListen->triggeredFlags &= ~triggered;

   return triggered;
}

////////////////////////////////////////////////////////////////////////////////





// $Header: r:/t2repos/thief2/src/motion/mvrflbow.cpp,v 1.8 1998/05/13 13:00:55 kate Exp $

#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <motdesc.h>
#include <mclntapi.h>
#include <plyrvmot.h>
#include <mschutil.h>
#include <mschbase.h>

// must be last header
#include <dbmem.h>

class cFlexBowManeuverFactory: public cManeuverFactory
{
public:

   virtual cMotionPlan *CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      
};

class cFlexBowManeuver: public cManeuver
{
public:
   cFlexBowManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams& params);
   ~cFlexBowManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();
    
   virtual void Finish();

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel); }
   virtual void NotifyAboutBeingStuck() { m_pMotor->StopMotion(m_MotionNum); }

   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);

private:
   int m_MotionNum;
   int m_FlexBowMotion;
   mxs_vector m_PosOffset;
   mxs_angvec m_AngOffset;
   float m_Duration;
   float m_TimeScale;
   float m_FlexDuration;
   mxs_ang m_MaxFlex;
};
                         
cFlexBowManeuverFactory g_FlexBowManeuverFactory;
EXTERN cManeuverFactory *g_pFlexBowManeuverFactory=&g_FlexBowManeuverFactory;


cMotionPlan *cFlexBowManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cFlexBowManeuver *pMnvr;

   pMnvr = new cFlexBowManeuver(pMotor, pCoord, pSchema, params);

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// Single MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

EXTERN float g_FlexDuration;

EXTERN quat g_FlexTopStartRot;
EXTERN quat g_FlexTopEndRot;
EXTERN quat g_FlexBotStartRot;
EXTERN quat g_FlexBotEndRot;

#define MAX_INTERESTED_MOTIONS 10

#define min(x,y) ((x)<(y)?(x):(y))

cFlexBowManeuver::cFlexBowManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams& params)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   

   if(params.mask&kMotParmFlag_MotNum)
   {
      m_MotionNum=params.motionNum;
   } else
   {
      if(!pSchema->GetRandomMotionInRange(1,pSchema->NumMotions()-1,&m_MotionNum))
         m_MotionNum=-1;
   }

   // get pos offset stuff from schema
   if(!MSchUGetPlayerPosOffset(pSchema,&m_PosOffset,&m_AngOffset))
   {
      Warning(("Could not get player pos offset for schema!\n"));
      mx_zero_vec(&m_PosOffset);
      m_AngOffset.tx=0;
      m_AngOffset.ty=0;
      m_AngOffset.tz=0;
   }

   if(!pSchema->GetDuration(&m_Duration))
      m_Duration=0;
   if(!pSchema->GetTimeWarp(&m_TimeScale))
      m_TimeScale=0;
   sMPlayerSkillData skillData;
   // get flex stuff from skill data
   if(!MSchUGetPlayerSkillData(pSchema,&skillData))
   {
      AssertMsg(FALSE,"No player skill data for schema");
   }
   m_FlexDuration=skillData.flexDuration;
   m_MaxFlex=degrees_to_fixang(skillData.flexDegree);

   // this should always be first motion in bow motion schema
   if(!pSchema->GetMotion(0,&m_FlexBowMotion))
   {
      Warning(("could not get flex bow motion\n"));
      m_FlexBowMotion=-1;
   }
}

cFlexBowManeuver::~cFlexBowManeuver()
{
   // need to check m_pMotor in case SetMotor(NULL) was called.
   if(!m_pMotor)
      return;

   // Stop motion if one is playing
   if(m_MotionNum>=0)
      m_pMotor->StopMotion(m_MotionNum);
   m_pMotor->StopMotion(m_FlexBowMotion);
}

void cFlexBowManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for player maneuver");
}

void cFlexBowManeuver::Execute()
{
   int virtMotion=m_FlexBowMotion;

   if(!m_pMotor)
   {
      sMcMoveState state;
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
      return;
   }

   PlyrVMotSetOffsets(&m_PosOffset,&m_AngOffset);
   // XXX NOTE: fixed duration doesn't work with mo-caps
   // note if motion number not valid, this maneuver will not auto-terminate
   if(m_MotionNum>=0)
   {
      mps_motion_param param;

      param.flags=NULL;

      if(m_TimeScale)
      {
         param.flags|=MP_DURATION_SCALE;
         param.duration_scalar=m_TimeScale;
      }
      m_pMotor->StartMotionWithParam(m_MotionNum,&param);
   } 
   if(m_Duration<=0)
   {
      m_pMotor->StartMotion(virtMotion);
   } else
   {
      mps_motion_param param;

      param.flags=MP_FIXED_DURATION;
      param.fixed_duration=m_Duration*1000; // uses millisec

      m_pMotor->StartMotionWithParam(virtMotion,&param);
   }
   
   // setup bow flexing
   mxs_angvec maxFlex={0,0,0};
   mxs_matrix mat;

   if(m_MaxFlex)
   {
      maxFlex.tx=m_MaxFlex;
      mx_ang2mat(&mat,&maxFlex);
      quat_from_matrix(&g_FlexTopEndRot,&mat);
      mx_transeq_mat(&mat); // invert
      quat_from_matrix(&g_FlexBotEndRot,&mat);
   } else
   {
      quat_identity(&g_FlexTopEndRot);
      quat_identity(&g_FlexBotEndRot);
   }

   quat_identity(&g_FlexTopStartRot);
   quat_identity(&g_FlexBotStartRot);
   g_FlexDuration=m_FlexDuration;
}

void cFlexBowManeuver::Finish()
{
   if(m_MotionNum<0)
   {
      sMcMoveState state;
      int virtMotion=m_FlexBowMotion;
   
      m_pMotor->StopMotion(virtMotion);
      m_pCoord->NotifyAboutManeuverCompletion(this, state);
   }
   // otherwise will auto-terminate when motion ends anyway
}


// XXX need to rework this end state stuff
void cFlexBowManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
//   m_pMotor->StopMotion(virtMotion); // XXX hopefully just stopping it on deletion will be enough
               // there's a weird glitching bug, where mp library things that
               // overlay hasn't ended, but base motion has.
   if(motionNum==m_MotionNum || motionNum==m_FlexBowMotion)
   {
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   }
}
// $Header: r:/t2repos/thief2/src/motion/mvrgact.cpp,v 1.16 1999/08/05 17:09:13 Justin Exp $

#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <motdesc.h>
#include <mclntapi.h>
#include <motschem.h>
#include <motmngr.h>
#include <ghostmvr.h>
#include <iobjsys.h>
#include <appagg.h>
#include <config.h>
#include <fix.h>
#include <textarch.h>

      // must be last header
#include <dbmem.h>

class cGroundActionManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      

   virtual IManeuver *LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile);
};

typedef struct
{
   int m_SchemaID;
   float m_Duration;
   float m_TimeWarp;
   float m_Distance;
   float m_Stretch;
   ObjID m_FocusObj;
   fix m_TurnSpeed;
protected:
   BOOL m_DoRotate;
   mxs_angvec m_Direction;
   int m_MotionNum;
} sGroundActionData;

class cGroundActionManeuver: public cManeuver, public sGroundActionData
{
public:
   cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema);
   cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const char *name);
   cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const mxs_angvec& direction);
   cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const int motionNum, const int dummy);
   cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success);
   ~cGroundActionManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();
   virtual void Save(ITagFile *pTagFile) { 
      ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
      ITagFile_Move(pTagFile,(char *)((sGroundActionData*)this),sizeof(*((sGroundActionData*)this)));
   }

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel); }
   virtual void NotifyAboutBeingStuck() { m_pMotor->StopMotion(m_MotionNum); }

#if 0
//
// Motion status notification functions
//
   virtual void NotifyAboutFrameUpdateBegin(const ObjID);
   virtual void NotifyAboutFrameUpdateEnd(const ObjID);
   virtual void NotifyAboutFrameFlags(const ObjID, const int);
#endif

   virtual void NotifyAboutFrameFlags(const int);
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);

};

cGroundActionManeuverFactory g_GroundActionManeuverFactory;
EXTERN cManeuverFactory *g_pGroundActionManeuverFactory=&g_GroundActionManeuverFactory;


cMotionPlan *cGroundActionManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cGroundActionManeuver *pMnvr;

   Assert_(pSchema);

   if(params.mask&kMotParmFlag_Name)
   {
      pMnvr = new cGroundActionManeuver(pMotor, pCoord, (char *)params.name);
   } else if(params.mask&kMotParmFlag_MotNum)
   {
      pMnvr = new cGroundActionManeuver(pMotor, pCoord, params.motionNum,-1);
   } else
   {
      if(params.mask&kMotParmFlag_Facing)
      {
         pMnvr = new cGroundActionManeuver(pMotor, pCoord, pSchema, params.facing);
      } else
      {
         pMnvr = new cGroundActionManeuver(pMotor, pCoord, pSchema);
      }
   }
   pMnvr->m_SchemaID=pSchema->GetSchemaID();
   pMnvr->m_Duration=-1.0;
   pMnvr->m_TimeWarp=1.0;
   pMnvr->m_Distance=-1.0;
   pMnvr->m_Stretch=1.0;

   if(params.mask&kMotParmFlag_FocusObj)
   {
      pMnvr->m_FocusObj=params.focus;
   } else
   {
      pMnvr->m_FocusObj=OBJ_NULL;
   }
   pMnvr->m_TurnSpeed = params.turnspeed;
   
   if(!pSchema->GetDuration(&pMnvr->m_Duration))
      pSchema->GetTimeWarp(&pMnvr->m_TimeWarp);
   if(!pSchema->GetDistance(&pMnvr->m_Distance))
      pSchema->GetStretch(&pMnvr->m_Stretch);

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}


IManeuver *cGroundActionManeuverFactory::LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile)
{
   BOOL success;
   cGroundActionManeuver *pMnvr=new cGroundActionManeuver(pMotor,pCoord,pTagFile,&success);

   if(!success)
   {
      delete pMnvr;
      return NULL;
   }
   return pMnvr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// GroundAction MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define MAX_INTERESTED_MOTIONS 10

cGroundActionManeuver::cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;
   m_SchemaID=pSchema->GetSchemaID();

   m_MotionNum=-1;
   if (IsRemoteGhost(pMotor->GetObjID()))
   {
      m_MotionNum = GetGhostMotionNumber();
#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("rGact: Remote ghost %d playing schema %d, motion %d\n", pMotor->GetObjID(), m_SchemaID, m_MotionNum);
      }
#endif
   }
   if (m_MotionNum==-1) // not a remoteghost, or remghost didnt want to deal 
   {
      if (!pSchema->GetRandomMotion(&m_MotionNum))
      {
         Warning(("rGact: CombatManeuver(False!): unable to find motion\n"));
         m_MotionNum=-1;
      }

      if (IsLocalGhost(pMotor->GetObjID()))
      {
#ifndef SHIP
         if (config_is_defined("ghost_motion_spew"))
         {
            mprintf("rGact: Local ghost %d informing remote about schema %d, motion %d\n", 
                    pMotor->GetObjID(), m_SchemaID, m_MotionNum);
         }
#endif
         GhostSendMoCap(pMotor->GetObjID(),m_SchemaID,m_MotionNum,FALSE);
      }
   }
}

cGroundActionManeuver::cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const char *name)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;

   if (IsRemoteGhost(pMotor->GetObjID()))
      Warning(("illegal cGroundActionManeuver constructor for remote ghost %d\n", pMotor->GetObjID()));

   m_MotionNum=MotDescNameGetNum((char *)name);
   if(m_MotionNum==-1)
   {
      Warning(("GroundActionManeuver: unable to find motion named %s\n",(char *)name));
   }
}

cGroundActionManeuver::cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const int motionNum, const int dummy)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   
   m_DoRotate=FALSE;

   if (IsRemoteGhost(pMotor->GetObjID()))
      Warning(("illegal cGroundActionManeuver constructor for remote ghost %d\n", pMotor->GetObjID()));

   m_MotionNum=motionNum;
   
   if(m_MotionNum==-1)
      Warning(("GroundActionManeuver: unable to find motion\n"));
}

cGroundActionManeuver::cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const mxs_angvec& direction)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_DoRotate=TRUE;
   m_Direction=direction;

   if (IsRemoteGhost(pMotor->GetObjID()))
      Warning(("illegal cGroundActionManeuver constructor for remote ghost %d\n", pMotor->GetObjID()));

   Assert_(pSchema);
   if(!pSchema->GetRandomMotion(&m_MotionNum))
   {
      Warning(("CombatManeuver: unable to find motion\n"));
      m_MotionNum=-1;
   }
}

cGroundActionManeuver::cGroundActionManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success)
{
   *success=TRUE;
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sGroundActionData*)this),sizeof(*((sGroundActionData*)this)));
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   Assert_(m_pMotor);

   if(m_pMotor&&m_MotionNum!=-1)
   {
      m_MotionNum=m_pMotor->SwizzleMotion(m_MotionNum);   
      if(m_MotionNum==-1) // couldn't swizzle
         *success=FALSE;
   }

   if (IsRemoteGhost(pMotor->GetObjID()))
      Warning(("illegal cGroundActionManeuver constructor for remote ghost %d\n", pMotor->GetObjID()));

   // check that motor is in same state we think we are
   if(m_pMotor->GetCurrentMotion()!=m_MotionNum)   // out of synch!
   {
      Warning(("cGroundActionManuever: cannot load maneuver because creature is out of synch\n"));
      m_MotionNum=-1;
      *success=FALSE;
   }

   // swizzle focus obj
   AutoAppIPtr_(ObjectSystem,pObjSys); 
   m_FocusObj=pObjSys->RemapOnLoad(m_FocusObj);
}

cGroundActionManeuver::~cGroundActionManeuver()
{
   if(!m_pMotor)
      return;

   // Stop motion if one is playing

   if(m_MotionNum>=0)
   {
      m_pMotor->StopMotion(m_MotionNum);

      // notify scripting system
      MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionEnd,NULL);
   }
   if(m_FocusObj!=OBJ_NULL)
   {
      m_pMotor->SetFocus(OBJ_NULL,m_TurnSpeed);
   }
}

void cGroundActionManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for GroundAction maneuver");
}

void cGroundActionManeuver::Execute()
{
   Assert_(m_pMotor);
   Assert_(m_pCoord);   
   m_pCoord->ClearInterMnvrState();
   sMcMotorState *pS=m_pCoord->GetInterMnvrState();
   pS->lastSchemaID=m_SchemaID;

   if(m_FocusObj!=OBJ_NULL)
   {
      m_pMotor->SetFocus(m_FocusObj,m_TurnSpeed);
   }

   if(m_MotionNum<0)
   {
      sMcMoveState state;
      // XXX need to rework this end state stuff

      if(m_DoRotate)
      {
         m_pMotor->SetOrientation(&m_Direction);
      }
      AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   } else
   {
      mxs_real groundHeight;
      ObjID    standingObj;
      Location *curLoc=(Location *)m_pMotor->GetLocation();

      Assert_(g_pMotionSet);

      // keep grounded
      if(MvrFindGroundHeight(m_pMotor->GetObjID(),curLoc,&groundHeight,&standingObj))
      {
         float desiredZ=0;
         mxs_vector buttPos;

         MvrSetStandingObj(m_pMotor->GetObjID(), standingObj);

         MvrGetEndButtHeight(m_pMotor,m_MotionNum,&desiredZ);
         desiredZ+=groundHeight;

         // and set its offset
         if (!IsTextureObj(standingObj))
         {
            mxs_vector offset = {curLoc->vec.x, curLoc->vec.y, desiredZ};
            MvrSetStandingOffset(m_pMotor->GetObjID(), standingObj, &offset);
         }
         else
         {
            mxs_vector offset = {0, 0, groundHeight};
            MvrSetTerrStandingOffset(m_pMotor->GetObjID(), &offset);
         }

         mx_copy_vec(&buttPos,&curLoc->vec);
         buttPos.z=desiredZ;

         if(m_DoRotate)
         {
            // NOTE: this assumes that direction of action in motion capture
            // is along the x-axis
            m_pMotor->SetTransform(&buttPos,&m_Direction);
         } else
         {
            m_pMotor->SetPosition(&buttPos);
         }
      } else
      {
         if(m_DoRotate)
         {
            // NOTE: this assumes that direction of action in motion capture
            // is along the x-axis
            m_pMotor->SetOrientation(&m_Direction);
         } 
      }

      mps_motion_param param;

      param.flags=0;

      if(m_Duration>=0)
      {
         param.flags|=MP_FIXED_DURATION;
         param.fixed_duration=m_Duration;
      } else if(m_TimeWarp!=1.0)
      {
         param.flags|=MP_DURATION_SCALE;
         param.duration_scalar=m_TimeWarp;
      }
      if(m_Distance>=0)
      {
         mxs_vector xlat;
         mxs_real mag;

         g_pMotionSet->GetTranslation(m_MotionNum,&xlat);
         mag=mx_mag_vec(&xlat);
         if(mag>0.1)
         {
            param.flags|=MP_STRETCH;
            param.stretch=m_Distance/mag;
         }
      } else if(m_Stretch!=1.0)
      {
         param.flags|=MP_STRETCH;
         param.stretch=m_Stretch;
      }
      m_pMotor->StartMotionWithParam(m_MotionNum,&param);

      // notify scripting system
      MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionStart,NULL);
   }
}

void cGroundActionManeuver::NotifyAboutFrameFlags(const int flags)
{
   if(m_pMotor)
   {
      MvrProcessStandardFlags(m_pMotor,m_pCoord,flags);
      MvrSendMotionMessage(m_pMotor->GetObjID(), m_MotionNum,kMotionFlagReached,flags);
   }
}

// XXX need to rework this end state stuff
void cGroundActionManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");

   // notify scripting system
   if(m_pMotor)
      MvrSendMotionMessage(m_pMotor->GetObjID(),m_MotionNum,kMotionEnd,NULL);

   m_MotionNum=-1;
   m_pCoord->NotifyAboutManeuverCompletion(this,state);
}
// $Header: r:/t2repos/thief2/src/motion/mvrglide.cpp,v 1.3 1997/12/19 15:28:32 TOML Exp $

#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>

      // must be last header
#include <dbmem.h>

class cGlideManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const tMSkillHandle skill,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      
};

class cGlideManeuver: public cManeuver
{
public:
   ~cGlideManeuver() {}
   cGlideManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_angvec& direction, const mxs_real speed, const ulong duration);

   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);
   virtual void Execute();
private:
   mxs_vector m_EndPos;
   mxs_angvec m_EndFac;
};

cGlideManeuverFactory g_GlideManeuverFactory;
EXTERN cManeuverFactory *g_pGlideManeuverFactory=&g_GlideManeuverFactory;


cMotionPlan *cGlideManeuverFactory::CreatePlan(const tMSkillHandle skill,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cGlideManeuver *pMnvr;
   sMGaitSkillData *pGait=MSkillGetGaitSkillData(skill);

   if(!(params.mask&kMotParmFlag_Duration) || !(params.mask&kMotParmFlag_Direction))
      return NULL;

   if(params.mask&kMotParmFlag_ExactSpeed)
      pMnvr = new cGlideManeuver(pMotor, pCoord, params.direction, params.exactSpeed, params.duration);
   else
      pMnvr = new cGlideManeuver(pMotor, pCoord, params.direction, (pGait->minVel+pGait->maxVel)/2, params.duration);

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// Glide MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

cGlideManeuver::cGlideManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const mxs_angvec& direction, const mxs_real speed, const ulong duration)
{
   mxs_vector delta;
   mxs_matrix mat;
   float frac;
   mxs_real groundHeight;

   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_EndFac=direction;

   const Location *loc=pMotor->GetLocation();
   mx_ang2mat(&mat,(mxs_angvec *)&direction);
   mx_unit_vec(&delta,0);
   mx_mat_muleq_vec(&mat,&delta);
   // duration is in msec.
   frac=speed*((float)duration)/1000;
   // speed and duration
   mx_scaleeq_vec(&delta,frac);

   mx_add_vec(&m_EndPos,(mxs_vector *)&loc->vec,&delta);
   if(!MvrFindGroundHeight(loc,&groundHeight))
      groundHeight=0;
   m_EndPos.z=groundHeight+pMotor->GetButtZOffset();
}

void cGlideManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   moveState.position=m_EndPos;
   moveState.facing=m_EndFac;
   moveState.speed=0;
   moveState.direction=m_EndFac;
}

void cGlideManeuver::Execute()
{
   Location toLoc,hitLoc;
   sMcMoveState moveState;

   const Location *fromLoc=m_pMotor->GetLocation();

   MakeHintedLocation(&toLoc,m_EndPos.x,m_EndPos.y,m_EndPos.z,(Location *)fromLoc);
   if(PortalRaycast((Location *)fromLoc,&toLoc,&hitLoc,TRUE))
   {
      // safe to update
      m_pMotor->SetTransform(&m_EndPos,&m_EndFac);
      GetExpectedEndMoveState(moveState);
   } else
   {
      m_pMotor->SetTransform(&fromLoc->vec,&m_EndFac);
      moveState.position=fromLoc->vec;
      moveState.facing=m_EndFac;
      moveState.direction=m_EndFac;
      moveState.speed=0;
   }
   m_pCoord->NotifyAboutManeuverCompletion(this,moveState);
}
// $Header: r:/t2repos/thief2/src/motion/mvrgloco.cpp,v 1.39 1999/08/05 17:09:46 Justin Exp $
// This is the maneuver builder/controller for solid ground locomotions -
// That is, one's in which the creature is affected by gravity and moving along
// the floor beneath its feet.
//
// XXX Need to add ability to check stride length and guesstimate end pos
//
// XXX end state stuff for maneuvers needs to be calculated.  I think 
// this should only have 2D position, since this faster to calculate and is
// all I think AI will really want anyway (yes?)
//
// XXX deal with case when no motion capture is found
//
// XXX apply gravity when a foot should be in contact with sground but isn't.
// This should help with recovering from miscalculations of end ground height

#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <fastflts.h>
#include <mschbase.h>
#include <physcast.h>
#include <ghostmvr.h>

#include <fix.h>
#include <mprintf.h>
#include <config.h>
#include <cfgdbg.h>
#include <mschutil.h>
#include <rand.h>
#include <textarch.h>

#include <math.h> // until fastflts works
      
// must be last header
#include <dbmem.h>

class cGroundLocoManeuverFactory: public cManeuverFactory
{
public:
   virtual cMotionPlan *CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      

   virtual IManeuver *LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile);
};

typedef struct
{
   BOOL m_DoRotate;
   BOOL m_UseBend;
   BOOL m_IsBeingDeleted;
   mxs_angvec m_NewDirection;
   mxs_angvec m_ExpectedEndFacing;
   mxs_vector m_ExpectedEndPos;
   mxs_vector m_StrideXlat;
   float m_ButtZOffset;
   int m_MotionNum;
   mps_motion_param m_MotionParam;
   mxs_ang m_RotAng;
   mxs_ang m_MotRotAng;
   sMGaitSkillData *m_pGaitData;
   int m_SchemaID;
   BOOL m_FirstStride;
} sGroundLocoData;

class cGroundLocoManeuver: public cManeuver, private sGroundLocoData
{
public:
   cGroundLocoManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams& params);
   cGroundLocoManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success);
   ~cGroundLocoManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();

   virtual void Save(ITagFile *pTagFile);

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel,kMvrUCF_MaintainSpeed); }
   virtual void NotifyAboutBeingStuck();

//
// Motion status notification functions
//
   virtual void NotifyAboutFrameFlags(const int flags) { MvrProcessStandardFlags(m_pMotor,m_pCoord, flags); }
   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);

private:
};

// XXX really want to return to stand position, but can't since end callback
// doesn't deal with more than one mo-cap in maneuver
inline void cGroundLocoManeuver::NotifyAboutBeingStuck()
{
   // XXX HACK: only update the phys models if doing non-combat locomotion,
   // since combat ones have the whole problem of being asked to go in
   // wacky directions where butt precedes knees.  KJ 2/98
   m_pMotor->SetOrientation(&m_ExpectedEndFacing,m_UseBend);
}

cGroundLocoManeuverFactory g_GroundLocoManeuverFactory;
EXTERN cManeuverFactory *g_pGroundLocoManeuverFactory=&g_GroundLocoManeuverFactory;


cMotionPlan *cGroundLocoManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cGroundLocoManeuver *pMnvr;
   sMcMoveParams usedParams=params;

   if(!(params.mask&kMotParmFlag_Direction))
   {
      // being told to locomote, but not in any direction.  Try to figure out
      // what request means.
      ConfigSpew("MnvrTrace",("Told to locomote, but not given a direction"));
      if(params.mask&kMotParmFlag_Facing)
      {
         usedParams.direction=usedParams.facing;
         usedParams.mask|=kMotParmFlag_Direction;
      } else
      {
         // assume direction wants to be current direction         
         Assert_(pMotor);
         const sMotorState *pState=pMotor->GetMotorState();
         usedParams.direction=pState->facing;
         usedParams.mask|=kMotParmFlag_Direction;
      }
   }

   pMnvr = new cGroundLocoManeuver(pMotor, pCoord, pSchema, usedParams);

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

IManeuver *cGroundLocoManeuverFactory::LoadManeuver(IMotor *pMotor,cMotionCoordinator *pCoord,ITagFile *pTagFile)
{
   BOOL success;
   cGroundLocoManeuver *pMnvr=new cGroundLocoManeuver(pMotor,pCoord,pTagFile,&success);

   if(!success)
   {
      delete pMnvr;
      return NULL;
   }
   return pMnvr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// GroundLoco MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define MAX_INTERESTED_MOTIONS 10

#include <locobase.h> // for footfall flags

cGroundLocoManeuver::cGroundLocoManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, ITagFile *pTagFile,BOOL *success)
{
   *success=TRUE;
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sGroundLocoData *)this),sizeof(*((sGroundLocoData*)this)));
   m_pMotor=pMotor;
   m_pCoord=pCoord;
   m_pGaitData=NULL;
   Assert_(m_pMotor);
   if(m_pMotor&&m_MotionNum!=-1)
   {
      m_MotionNum=m_pMotor->SwizzleMotion(m_MotionNum);   
      if(m_MotionNum==-1) // couldn't swizzle
         *success=FALSE;
   }
   // check that motor is in same state we think we are
   if(m_pMotor->GetCurrentMotion()!=m_MotionNum)   // out of synch!
   {
      Warning(("cGroundLocoManuever: cannot load maneuver because creature is out of synch\n"));
      m_MotionNum=-1;
      *success=FALSE;
   }
}

void cGroundLocoManeuver::Save(ITagFile *pTagFile)
{
   // write app data (cManeuver stuff)
   ITagFile_Move(pTagFile,(char *)&m_AppData,sizeof(m_AppData));
   ITagFile_Move(pTagFile,(char *)((sGroundLocoData *)this),sizeof(*((sGroundLocoData *)this)) );
}


cGroundLocoManeuver::cGroundLocoManeuver(IMotor *pMotor, cMotionCoordinator *pCoord,\
    const cMotionSchema *pSchema, const sMcMoveParams& params )
{
   BOOL turning=FALSE;
   int i;
   float dist;

   m_pMotor=pMotor;
   m_pCoord=pCoord;   

   if(pSchema)
      m_SchemaID=pSchema->GetSchemaID();
   else
      m_SchemaID=kMotSchemaID_Invalid;

   m_IsBeingDeleted=FALSE;

   sMcMotorState *pS=m_pCoord->GetInterMnvrState();

   // check if just did this schema
   if(pS->lastSchemaID!=m_SchemaID)
   {
      ConfigSpew("MnvrTrace",("starting to %d\n",m_SchemaID));
      m_FirstStride=TRUE;
   } else
   {
      ConfigSpew("MnvrTrace",("still %d-ing\n",m_SchemaID));
      m_FirstStride=FALSE;
   }

// Get skill and motor information
//
   const sMotorState *pState=m_pMotor->GetMotorState();

   Assert_(pSchema);

   if(!MSchUGetGaitData(pSchema,&m_pGaitData))
   {
      m_pGaitData=NULL;
      Assert_(FALSE);
   }

   float timeWarp=m_pGaitData->timeWarp;
   float tw;
   if(pSchema->GetTimeWarp(&tw))
      timeWarp*=tw;
   if(m_pGaitData->noise)
   {
      float noise=(2*m_pGaitData->noise*Rand())/RAND_MAX;
      timeWarp=(1.0-m_pGaitData->noise+noise)*timeWarp; // since 0<=noise<=2*m_pGaitData->noise;
   }

   int off=-1;

// Decide whether or not to use turn
//
// XXX using mxs_ang instead of degrees for wrapping
// XXX this doesn't distinguish between starting with left or right foot in turn
// XXX get facing vs direction to work correctly

   mxs_ang turnTol=degrees_to_fixang(m_pGaitData->turnTolerance);
   mxs_ang adelta=pState->facing.tz-params.direction.tz;
   mxs_ang minDelta=MX_ANG_PI,diff;
   sMGaitTurn *pTurn=m_pGaitData->turns;

   // check if delta outside turn tolerance
   if(m_pGaitData->numTurns>0 &&  ((adelta<=MX_ANG_PI&&adelta>turnTol)||(adelta>=MX_ANG_PI&&adelta<2*MX_ANG_PI-turnTol)))
   {
      turning=TRUE;
      for(i=0;i<m_pGaitData->numTurns;i++,pTurn++)
      {
         mxs_ang angle=degrees_to_fixang(pTurn->angle);
         diff=angle-adelta;
         if(diff>MX_ANG_PI)
            diff=2*MX_ANG_PI-diff;
         if(diff<=minDelta)
         {
            minDelta=diff;
            off=pTurn->mot;
         }
      }
   }

// Decide whether to do left or right stride, if not turning
//
   if(!turning)
   {
      if(pState->contactFlags&LEFT_FOOT) // XXX this will only work for bipeds
      {
         off=m_pGaitData->rightStride;
      } else
      {
         off=m_pGaitData->leftStride;
      }
   }

   m_MotionNum=-1;
#ifdef NETWORK_LOCOS   
   if (IsRemoteGhost(pMotor->GetObjID()))
   {
      m_MotionNum = GetGhostMotionNumber();
#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("Remote ghost %d playing schema %d, motion %d\n", pMotor->GetObjID(), m_SchemaID, m_MotionNum);
      }
#endif
   }
#endif   
   if (m_MotionNum==-1) // not a remoteghost, or remghost didnt want to deal 
   {
      if(!pSchema->GetMotion(off,&m_MotionNum))
         m_MotionNum=-1;
   }

   if(m_MotionNum==-1)
   {
      Warning(("GroundLocoManeuver: unable to find motion at offset %d\n",off));
   }

   if (IsLocalGhost(pMotor->GetObjID()))
   {
#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("rGloco: Local ghost %d informing remote about schema %d, motion %d\n", 
                 pMotor->GetObjID(), m_SchemaID, m_MotionNum);
      }
#endif
      // this is actually going to be intercepted inside here, and we're
      // going to do something tricky, which is why the reception of gloco
      // maneuvers is still in the NETWORK_LOCOS up there...
      GhostSendMoCap(pMotor->GetObjID(),m_SchemaID,m_MotionNum,TRUE);
   }

   mxs_vector xlat;
   float duration;
   sMotionPhys phys;

   m_MotionParam.flags=NULL;

//   if(!MvrGetRawMovement(m_pMotor,m_MotionNum, xlat, duration,m_ButtZOffset))
   if(!MvrGetRawMovement(m_pMotor,m_MotionNum, phys))
   {
   // couldn't get motion capture. just rotate
      m_DoRotate=TRUE;
      m_NewDirection=params.direction;
      mx_zero_vec(&m_StrideXlat);
      m_RotAng=m_NewDirection.tz-pState->facing.tz;
      m_UseBend=FALSE;
      m_MotRotAng=0;
      return;
   }
   xlat=phys.xlat;
   m_MotRotAng=phys.endDir;
   duration=phys.duration;
   m_ButtZOffset=phys.buttZOffset;

   m_DoRotate=TRUE;

   float stretch=1.0;

   if(pSchema->GetDistance(&dist))
   {
      if(phys.distance>0.1)
         stretch=dist/phys.distance;
   } else 
   {
      pSchema->GetStretch(&stretch);
   }
   if(m_pGaitData->stretch!=1.0) // get multiplied by schema stretch
   {
      stretch*=m_pGaitData->stretch;
   }
   if(stretch!=1.0)
   {
      m_MotionParam.flags|=MP_STRETCH;
      m_MotionParam.stretch=stretch;
      mx_scaleeq_vec(&xlat,stretch);
   } else
   {
      m_MotionParam.stretch=1.0;
   }

   // shrink motion xlat if desired 2D distance to travel is less
   // than xlat
   //

   m_UseBend=!m_FirstStride;  // never bend on first stride

   // calc how much to shrink mocap, and scale xlat accordingly
   if(params.mask&kMotParmFlag_Distance)
   {
      mxs_vector tmp;
      float mag;

      tmp.x=xlat.x;
      tmp.y=xlat.y;
      tmp.z=0;

      ConfigSpew("MnvrTrace",("dist param %g\n",params.distance));

      // check xlat big enough for this to matter
      mag=mx_mag2_vec(&tmp); 
      if(mag>0.3)
      {
         float frac=(params.distance*params.distance)/mag;

         if(frac<1.0) // shrink the motion
         {
            // take sqrt to get accurate frac
            frac=sqrt(frac);

            m_UseBend=FALSE; // since want to hit point exactly
            ConfigSpew("MnvrTrace",("shrink %d by %g\n",m_MotionNum,frac));
            mx_scaleeq_vec(&xlat,frac);
            m_MotionParam.flags|=MP_STRETCH;
            m_MotionParam.stretch*=frac;
         }
      }
   }

   m_NewDirection=params.direction;

// @TODO: modify desired direction of motion, due to
// physical constraints etc.

   m_ExpectedEndFacing=m_NewDirection;

// Compute motion parameters and endpoints
//
   mxs_matrix mat;
   mxs_ang rot;

   // if want to use bend,
   // rotate xlat by facing/2, since motion bending will have this effect
   // (which is different from rotating multiped and then doing motion.
   // NOTE: this assumes that raw translation is along x-axis, so motion
   // must be processed as a locomotion
   
   m_RotAng=m_NewDirection.tz-pState->facing.tz-m_MotRotAng;

   if(m_UseBend)
   {
      if(m_RotAng>MX_ANG_PI)
      {
         rot=2*MX_ANG_PI-((2*MX_ANG_PI-m_RotAng)/2);
      } else
      {
         rot=m_RotAng/2;
      }
   } else
   {
      rot=m_RotAng;
   }
   mx_mk_rot_z_mat(&mat,pState->facing.tz+rot);
   mx_mat_muleq_vec(&mat,&xlat);

   // assume always timewarp, since noise always applied.
   duration*=timeWarp;
   m_MotionParam.flags|=MP_DURATION_SCALE;
   m_MotionParam.duration_scalar=timeWarp;

   // compute motion stretch and bend params
   // XXX NOTE: this won't work properly if distance flag is also
   // set!
   if(params.mask&kMotParmFlag_ExactSpeed)
   {
      // stretch motion by fraction of distance it will cover by default vs
      // distance that we want covered.
      float desiredDist=params.exactSpeed*duration;
      float actualDist=phys.distance;
      float frac=(actualDist>0.1)?(desiredDist/actualDist):1.0;

      mx_scale_vec(&m_StrideXlat,&xlat,frac);
      m_MotionParam.flags|=MP_STRETCH;
      m_MotionParam.stretch=frac;
   } else
   {
      m_StrideXlat=xlat;
   }
}

cGroundLocoManeuver::~cGroundLocoManeuver()
{
   m_IsBeingDeleted=TRUE;

   // Stop motion if one is playing
   if(m_MotionNum>=0 && m_pMotor!= NULL)
      m_pMotor->StopMotion(m_MotionNum);
}

void cGroundLocoManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for GroundLoco maneuver");
}

#define kVerticalTolerance 0.2 // feet
#define kGroundRaycastOffset 1.5 // feet

#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))

void cGroundLocoManeuver::Execute()
{
   Assert_(m_pCoord);   
   sMcMotorState *pS=m_pCoord->GetInterMnvrState();
   m_pCoord->ClearInterMnvrState();
   pS->lastSchemaID=m_SchemaID;

   if(m_DoRotate)
   {
      if(m_UseBend)
      {
         ConfigSpew("MnvrTrace",("bend %d\n",fixang_to_degrees(m_RotAng)));
         m_MotionParam.flags|=MP_BEND;
         if(m_RotAng>MX_ANG_PI)
         {
            m_MotionParam.bend=(mx_ang2rad(m_RotAng)-2*MX_REAL_PI)/2;
         } else
         {
            m_MotionParam.bend=mx_ang2rad(m_RotAng/2);
         }
      } else
      {
                                                   // with not-forward-facing motions
         // NOTE: this assumes that direction of action in motion capture
         // is along the x-axis

         ConfigSpew("MnvrTrace",("rotate so dir %x\n",m_NewDirection.tz));

         mxs_angvec dir=m_NewDirection;
         dir.tz-=m_MotRotAng;

         m_pMotor->SetOrientation(&dir,FALSE);
      }
   }
   if(m_MotionNum<0)
   {
      sMcMoveState state;
      // XXX need to rework this end state stuff

      AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   } else
   {
      // check ground height
      Location curLoc=*m_pMotor->GetLocation();
      mxs_vector newPos;
      Location newLoc,hitLoc,fromLoc;
      ObjID hitObj;
      float offset;
      mxs_real groundHeight;
      BOOL foundGround;
      float desiredZ=0;

      // first, move to ground if not already grounded 
      // @TODO: enter into freefall instead.
      if(MvrFindGroundHeight(m_pMotor->GetObjID(),&curLoc,&groundHeight,&hitObj))
      {
         mxs_vector buttPos;

         MvrGetEndButtHeight(m_pMotor,m_MotionNum,&desiredZ);
         desiredZ+=groundHeight;
         if(fabs(desiredZ-curLoc.vec.z)>kVerticalTolerance)
         {
            mx_copy_vec(&buttPos,&curLoc.vec);
            buttPos.z=desiredZ;
            m_pMotor->SetPosition(&buttPos);
            curLoc.vec.z=desiredZ;
         } 
      } 

      // raycast to see if terrain in the way
      // want to raycast from around knee height, so balconies work etc.
      // NOTE: really don't want to be doing this at all anyway. (KJ 1/98)

      // first find current ground height
      fromLoc=curLoc;
      if(MvrFindGroundHeight(m_pMotor->GetObjID(),&fromLoc,&groundHeight,&hitObj))
      {
         fromLoc.vec.z=groundHeight+kGroundRaycastOffset;
      }
      mx_add_vec(&newPos,(mxs_vector *)&fromLoc.vec,&m_StrideXlat);
      MakeHintedLocationFromVector(&newLoc,&newPos,&curLoc);

      if (PhysRaycast(fromLoc, newLoc, &hitLoc, &hitObj, 0.0) == kCollideNone)
      {
         // find ground height at end of stride
         foundGround=MvrFindGroundHeight(m_pMotor->GetObjID(), &newLoc,&groundHeight,&hitObj);
      } else
      {
         // find ground height at just before terrain collision
         // XXX this should not really be fractional, but 'tis simpler
         mx_interpolate_vec(&newLoc.vec,&curLoc.vec,&hitLoc.vec,0.95);
         foundGround=MvrFindGroundHeight(m_pMotor->GetObjID(),&newLoc,&groundHeight,&hitObj);
      }

      // NOTE: this should work even though newPos.z isn't new butt
      // height, since newpos term cancels out
      mx_copy_vec(&m_ExpectedEndPos,&newPos);
      if(foundGround)
      {
         offset=(groundHeight+m_ButtZOffset-(curLoc.vec.z+m_StrideXlat.z));
         m_ExpectedEndPos.z=groundHeight+m_ButtZOffset;
      } else
      { 
         hitObj = OBJ_NULL;
         offset=0;
         m_ExpectedEndPos.z=curLoc.vec.z+m_StrideXlat.z;
      }

      // set the standing obj
      MvrSetStandingObj(m_pMotor->GetObjID(), hitObj);

      // and set its offset
      if (!IsTextureObj(hitObj))
         MvrSetStandingOffset(m_pMotor->GetObjID(), hitObj, &m_ExpectedEndPos);
      else
      {
         mxs_vector offset = {0, 0, m_ButtZOffset};
         MvrSetTerrStandingOffset(m_pMotor->GetObjID(), &offset);
      }

//      if(ffabsf(offset)>kVerticalTolerance)
      if(fabs(offset)>kVerticalTolerance)
      {
         
         // XXX checking vertical tolereances
         // should really happen at motion coordinator level, I think,
         // since AI can force non-physical velocities also.  Should be up
         // to coordinator or cerebellum to decide to discard path because of
         // ground height or passing through terrain.  Doing it here for
         // now, since there is currently no path checking

         AssertMsg(m_pGaitData,"no gait data");
         // truncate offset to max for gait
         offset=min(offset,m_pGaitData->maxAscend);
         offset=max(offset,m_pGaitData->maxDescend);

         m_MotionParam.flags|=MP_VINC;
         m_MotionParam.vinc=offset;
      }
      if(m_FirstStride)
         m_pMotor->StartMotionWithParam(m_MotionNum,&m_MotionParam,kMotStartFlag_ForceBlend);
      else
         m_pMotor->StartMotionWithParam(m_MotionNum,&m_MotionParam);
   }
}

// XXX need to rework this end state stuff
void cGroundLocoManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
   // only tell coordinator if maneuver not in middle of being deleted
   if(!m_IsBeingDeleted&&motionNum==m_MotionNum)
   {
      mxs_vector diff,pos;
      mxs_angvec ang;

      // see if really ended up where thought it would
      m_pMotor->GetTransform(&pos,&ang);
      mx_sub_vec(&diff,&m_ExpectedEndPos,&pos);
      diff.z=0;
      if(config_is_defined("MnvrTrace"))
      {
         ConfigSpew("MnvrTrace",("delta %g, %g  mag %g   ang %d\n",diff.x,diff.y,mx_mag_vec(&diff),\
            fixang_to_degrees(ang.tz-m_NewDirection.tz) ));
      }
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
   }
}
// $Header: r:/t2repos/thief2/src/motion/mvrplyr.cpp,v 1.13 1999/08/05 17:10:19 Justin Exp $

#include <config.h>
#include <mmanuver.h>
#include <mcoord.h>
#include <wrtype.h>
#include <portal.h>
#include <mvrutils.h>
#include <motdesc.h>
#include <mclntapi.h>
#include <plyrvmot.h>
#include <mschutil.h>
#include <mschbase.h>
#include <ghostmvr.h>

      // must be last header
#include <dbmem.h>

class cPlayerManeuverFactory: public cManeuverFactory
{
public:

   virtual cMotionPlan *CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord);      
};

class cPlayerManeuver: public cManeuver
{
public:
   cPlayerManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams& params);
   ~cPlayerManeuver();

////////
// Motion System Client Functions
////////
   virtual void GetExpectedEndMoveState(sMcMoveState& moveState);

////////
// Motion Coordinator Functions
////////
   virtual void Execute();
    
   virtual void Finish();

////////
// Motor Resolver Functions
////////
   virtual void CalcEnvironmentEffect() {}
   virtual void CalcCollisionResponse(const mxs_vector *pForces, const int nForces,\
      const mxs_vector *pCurrentVel, mxs_vector *pNewVel) \
      { MvrCalcSlidingCollisionResponse(pForces,nForces,pCurrentVel,pNewVel); }
   virtual void NotifyAboutBeingStuck() { m_pMotor->StopMotion(m_MotionNum); }

   virtual void NotifyAboutFrameFlags(const int flags) { MvrProcessStandardFlags(m_pMotor, m_pCoord, flags); }

   virtual void NotifyAboutMotionEnd(int motionNum, int frame, ulong flags);
   virtual void NotifyAboutMotionAbortRequest();

private:
   int m_MotionNum;
   int m_SynchMotion;
   mxs_vector m_PosOffset;
   mxs_angvec m_AngOffset;
   float m_Duration;
   float m_TimeScale;
};
                         
cPlayerManeuverFactory g_PlayerManeuverFactory;
EXTERN cManeuverFactory *g_pPlayerManeuverFactory=&g_PlayerManeuverFactory;


cMotionPlan *cPlayerManeuverFactory::CreatePlan(const cMotionSchema *pSchema,const sMcMotorState& motState, \
      const sMcMoveState& moveState, const sMcMoveParams& params, IMotor *pMotor, cMotionCoordinator *pCoord)
{
   cPlayerManeuver *pMnvr;

   pMnvr = new cPlayerManeuver(pMotor, pCoord, pSchema, params);

   AssertMsg(pMnvr,"could not alloc maneuver");

   cMotionPlan *pPlan= new cMotionPlan;

   AssertMsg(pPlan,"could not alloc plan");

   pPlan->Prepend(pMnvr);

   return pPlan;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//// Single MANEUVER IMPLEMENTATION
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#define MAX_INTERESTED_MOTIONS 10

cPlayerManeuver::cPlayerManeuver(IMotor *pMotor, cMotionCoordinator *pCoord, const cMotionSchema *pSchema, const sMcMoveParams& params)
{
   m_pMotor=pMotor;
   m_pCoord=pCoord;   

   m_MotionNum=-1;
   if (IsRemoteGhost(pMotor->GetObjID()))
   {
      m_MotionNum = GetGhostMotionNumber();

#ifndef SHIP
      if (config_is_defined("ghost_motion_spew"))
      {
         mprintf("rPlyr: Remote ghost %d playing schema %d, motion %d\n", 
                 pMotor->GetObjID(), pSchema->GetSchemaID(), m_MotionNum);
      }
#endif
   }
   if (m_MotionNum==-1)  // not a remoteghost, or remghost didnt want to deal 
   {
      if(params.mask&kMotParmFlag_MotNum)
      {
         m_MotionNum=params.motionNum;
      } else
      {
         if(!pSchema->GetRandomMotionInRange(1,pSchema->NumMotions()-1,&m_MotionNum))
            m_MotionNum=-1;
      }

      if (IsLocalGhost(pMotor->GetObjID()))
      {
#ifndef SHIP
         if (config_is_defined("ghost_motion_spew"))
         {
            mprintf("rPlyr: Local ghost %d informing remote about schema %d, motion %d\n", 
                    pMotor->GetObjID(), pSchema->GetSchemaID(), m_MotionNum);
         }
#endif
         GhostSendMoCap(pMotor->GetObjID(),pSchema->GetSchemaID(),m_MotionNum,FALSE);
      }
   }


   if(!pSchema->GetDuration(&m_Duration))
      m_Duration=0;
   if(!pSchema->GetTimeWarp(&m_TimeScale))
      m_TimeScale=0;

   // get pos offset stuff from schema
   if(!MSchUGetPlayerPosOffset(pSchema,&m_PosOffset,&m_AngOffset))
   {
      Warning(("Could not get player pos offset for schema!\n"));
      mx_zero_vec(&m_PosOffset);
      m_AngOffset.tx=0;
      m_AngOffset.ty=0;
      m_AngOffset.tz=0;
   }

   // this should always be first motion in player arm motion schema
   if(!pSchema->GetMotion(0,&m_SynchMotion))
   {
      Warning(("could not get cam synch motion\n"));
      m_SynchMotion=-1;
   }
}

cPlayerManeuver::~cPlayerManeuver()
{
   // need to check if motor valid, since SetMotor(NULL) may have been
   // called.
   if(!m_pMotor)
      return;

   // Stop motion if one is playing

   if(m_MotionNum>=0)
      m_pMotor->StopMotion(m_MotionNum);
   m_pMotor->StopMotion(m_SynchMotion);
}

void cPlayerManeuver::GetExpectedEndMoveState(sMcMoveState &moveState)
{
   AssertMsg(FALSE,"GetExpectedEndMoveState not implemented for player maneuver");
}

void cPlayerManeuver::Execute()
{
   int virtMotion=m_SynchMotion;

   if(!m_pMotor)
   {
      sMcMoveState state;
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
      return;
   }

   PlyrVMotSetOffsets(&m_PosOffset,&m_AngOffset);
   // XXX NOTE: fixed duration doesn't work with mo-caps
   if(m_MotionNum>=0)
   {
      mps_motion_param param;

      param.flags=NULL;

      if(m_TimeScale)
      {
         param.flags|=MP_DURATION_SCALE;
         param.duration_scalar=m_TimeScale;
      }
      m_pMotor->StartMotionWithParam(m_MotionNum,&param);
   } 
   if(m_Duration<=0)
   {
      m_pMotor->StartMotion(virtMotion);
   } else
   {
      mps_motion_param param;

      param.flags=MP_FIXED_DURATION;
      param.fixed_duration=m_Duration*1000; // uses millisec

      m_pMotor->StartMotionWithParam(virtMotion,&param);
   }
   // note if motion number not valid, this maneuver will not auto-terminate
}

void cPlayerManeuver::Finish()
{
   if(!m_pMotor)
   {
      sMcMoveState state;
      m_pCoord->NotifyAboutManeuverCompletion(this,state);
      return;
   }

   if(m_MotionNum<0)
   {
      sMcMoveState state;
      int virtMotion=m_SynchMotion;

      m_pMotor->StopMotion(virtMotion);
      m_pCoord->NotifyAboutManeuverCompletion(this, state);
   }
   // otherwise will auto-terminate when motion ends anyway
}


// XXX need to rework this end state stuff
void cPlayerManeuver::NotifyAboutMotionEnd(int motionNum, int frame, ulong flags)
{
   sMcMoveState state;

   AssertMsg(m_pCoord,"No motion coordinator for maneuver!");
//   m_pMotor->StopMotion(virtMotion); // XXX hopefully just stopping it on deletion will be enough
               // there's a weird glitching bug, where mp library things that
               // overlay hasn't ended, but base motion has.

   m_pCoord->NotifyAboutManeuverCompletion(this,state);
}

// XXX need to rework this end state stuff
void cPlayerManeuver::NotifyAboutMotionAbortRequest()
{
   // need to check if motor valid, since SetMotor(NULL) may have been
   // called.
   if(!m_pMotor)
      return;

   // Stop motion if one is playing
   if(m_MotionNum>=0)
      m_pMotor->StopMotion(m_MotionNum);
   m_pMotor->StopMotion(m_SynchMotion);

   sMcMoveState state;
   m_pCoord->NotifyAboutManeuverCompletion(this,state);
}
