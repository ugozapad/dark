/* This File Automatically Generated by the build system */ 
#include <matrix.h> #include <r3d3s.h> #include <g2.h> 
#ifndef __R3D3_H 
#define  __R3D3_H 
/*
 * $Source: x:/prj/tech/libsrc/r3d3/RCS/xfrmtab.h $
 * $Revision: 1.5 $
 * $Author: JAEMZ $
 * $Date: 1996/09/29 19:44:39 $
 *
 * Transform and projection definitions
 *
 */

typedef struct _r3s_xform_tab {
   void (*rotate_block)(int n,r3s_point dst[],mxs_vector src[]);
   void (*project_block)(int n,r3s_point p[]);
} r3s_xform_tab;

extern r3s_xform_tab *r3d_xform_ftabs[];

// $Header: x:/prj/tech/libsrc/r3d/RCS/xform.h 1.7 1996/05/06 01:11:42 dc Exp $
// Transform and projection definitions

// define to dereference global f pointer
#define R3_XFORM(x) (*((r3d_glob.xform_tab).x))

// The basic set of transformers and projectors are as follows.  The
// project class of functions just projects, stuffing the sx,sy, and w
// values into the 2d part of the point.  The rotate class of functions
// just

// some of these will be function pointers
void r3_transform_block(int n,r3s_point dst[],mxs_vector src[]);
#define r3_rotate_block(n,dst,src) (R3_XFORM(rotate_block)((n),(dst),(src)))
#define r3_project_block(n,p) (R3_XFORM(project_block)((n),(p)))

void r3_transform_list(int n,r3s_phandle dst[],mxs_vector *src[]);
void r3_rotate_list(int n,r3s_phandle dst[],mxs_vector *src[]);
void r3_project_list(int n,r3s_phandle p[]);

#define r3_transform_point(dst,src) r3_transform_block(1,(dst),(src))
#define r3_rotate_point(dst,src) (R3_XFORM(rotate_block)(1,(dst),(src)))
#define r3_project_point(p) (R3_XFORM(project_block)(1,(p)))

// This is the preferred model, especially since every tile renderer is
// fixed anyway it gets you the delta to add to your transformed points. 
// It stuffs the delta into dst.

void r3_get_delta(mxs_vector *dst,mxs_vector *src);
void r3_copy_add_delta(r3s_point *dst,r3s_point *src,mxs_vector *delta);

// $Header: x:/prj/tech/libsrc/r3d/RCS/clip.h 1.7 1996/06/13 11:51:44 JAEMZ Exp $

typedef enum {
   R3_INSIDE=0,
   R3_OUTSIDE=1,
   R3_CROSSES=2
} r3e_clipinfo;

typedef enum {
   R3_CLIP,        // do all clipping
   R3_NO_CLIP,     // do no clipping
   R3_USER_CLIP    // don't view clip, but do user clipping
} r3e_clipmode;

void r3_set_clipmode(r3e_clipmode e);
void r3_set_clip_flags(int flags);
void r3_set_near_plane(mxs_real dist);

// $Header: x:/prj/tech/libsrc/r3d/RCS/clipcon.h 1.7 1996/06/13 11:51:46 JAEMZ Exp $

typedef struct {
   void *clip_data;
   mxs_plane world_clip[5];
   int   num_user_planes;
   int   max_user_planes;
   int   clip_flags;   // which u,v coordinate type stuff to clip
   mxs_real  near_plane;   // in view space
   r3e_clipmode clip_mode;
} r3s_clip_context;

#define R3_CLIP_I      1
#define R3_CLIP_U      2
#define R3_CLIP_V      4
#define R3_CLIP_UV     6
#define R3_CLIP_ALL    7
#define R3_CLIP_RGB    7   // for now store RGB as I,U,V

// $Header: x:/prj/tech/libsrc/r3d/RCS/clipplan.h 1.2 1996/06/06 19:08:32 JAEMZ Exp $

void r3_clear_clip_planes(void);
void r3_pop_clip_plane(void);
void r3_push_clip_plane(mxs_plane *p);

// $Header: x:/prj/tech/libsrc/r3d3/RCS/clipprim.h 1.6 1996/09/29 19:43:19 JAEMZ Exp $   Internal clipping of primitives

#ifndef _CLIPPRIM_H
#define _CLIPPRIM_H

int r3_clip_polygon(int n,r3s_phandle *src,r3s_phandle **dest);
int r3_raw_clip_polygon(int n,r3s_phandle *src,r3s_phandle **dest);
bool r3_clip_line(r3s_phandle *src, r3s_phandle **dest);
void r3_compute_camera_planes(void);

#endif

// $Header: x:/prj/tech/libsrc/r3d3/RCS/primcon.h 1.6 1996/09/29 19:43:20 JAEMZ Exp $

typedef struct
{
   ulong color;

   r3s_texture bm;    // default texture if poly

      // flags which indicate what function we use
   uchar clip_2d;

   uchar point_flags;
   uchar line_flags;
   uchar poly_flags;

   uchar bm_type;  // plus transparency flag
} r3s_prim_context;

// $Header: x:/prj/tech/libsrc/r3d3/RCS/prim.h 1.8 1996/09/29 19:43:50 JAEMZ Exp $

void r3_set_2d_clip(bool context);
void r3_set_color(int color);
void r3_set_point_context(int context);
void r3_set_line_context(int context);
void r3_set_polygon_context(int context);
void r3_set_texture(r3s_texture id);

int r3_draw_point(r3s_phandle p);
int r3_draw_line(r3s_phandle p0,r3s_phandle p1);
int r3_bitmap (r3s_texture bm, r3s_phandle p);

#define r3_draw_poly     (r3d_glob.prim_tab.draw_3d_poly)
#define r3_draw_tmap     (r3d_glob.prim_tab.draw_3d_tmap)
#define r3_draw_2d_tmap  (r3d_glob.prim_tab.draw_2d_tmap)

// flags for draw_point context
#define R3_PT_TRANSLUCENT 1
#define R3_PT_ANTI_ALIAS  2

// flags for draw_line context
#define R3_LN_FLAT             0
#define R3_LN_RGB_GOURAUD      1
#define R3_LN_CLUT_GOURUAD     2
#define R3_LN_PALETTE_GOURAUD  3

// flags for polygon drawing

   // primary drawing mode
#define R3_PL_POLYGON          0
#define R3_PL_TRISTRIP         1
#define R3_PL_TRIFAN           2
#define R3_PL_QUADSTRIP        3

   // lighting mode
#define R3_PL_UNLIT            0
#define R3_PL_GOURAUD          4
#define R3_PL_RGB_GOURUAD      8
#define R3_PL_PALETTE_GOURUAD  12

   // fill modes
#define R3_PL_SOLID             0
#define R3_PL_TRANSLUCENT      16
#define R3_PL_TEXTURE          32
#define R3_PL_TEXTURE_LINEAR   48

   // outline in wireframe as well as draw normally
#define R3_PL_WIRE             64

   // check facing using vertices
#define R3_PL_CHECK_FACING     128

#define R3_PL_MODE_MASK         3
#define R3_PL_LIGHT_MASK       12
#define R3_PL_TEXTURE_MASK     48

// $Header: x:/prj/tech/libsrc/r3d3/RCS/primtab.h 1.4 1996/09/29 19:43:52 JAEMZ Exp $

// primitive function table type

typedef struct {
   int (*draw_3d_poly) (int n, r3s_phandle *vp);
   int (*draw_3d_tmap) (int n, r3s_phandle *vp, r3s_texture bm);
   int (*draw_2d_tmap) (r3s_texture bm, int n, grs_vertex **vp);
   int (*draw_2d_line) (int c, grs_vertex *v0, grs_vertex *v1);
   int (*draw_2d_point)(int c, grs_vertex *v0);
} r3s_prim_tab;

// $Header: x:/prj/tech/libsrc/r3d/RCS/primface.h 1.3 1996/05/26 23:04:26 buzzard Exp $

   // check three pts to see if forward facing
extern bool r3_check_facing_3(r3s_phandle *vp);

   // find first 3 non-colinear points and check if forward facing
extern bool r3_check_facing_n(int n, r3s_phandle *vp);

   // check viewspace pt & normal to see if forward facing
extern bool r3_check_v_normal_vec(mxs_vector *p, mxs_vector *n);

   // check worldspace pt & normal to see if forward facing
extern bool r3_check_w_normal_vec(mxs_vector *p, mxs_vector *n);

   // check object space pt & normal to see if forward facing
extern bool r3_check_o_normal_vec(mxs_vector *p, mxs_vector *n);

   // check 3d point & normal to see if forward facing

#define r3_check_v_normal_pt(a,b)  r3_check_v_normal_vec(&(a)->p, b)

// $Header: x:/prj/tech/libsrc/r3d/RCS/primconv.h 1.4 1996/08/09 12:40:24 JAEMZ Exp $

////////  convert between 3d points and 2d points  ////////

void r3_phandle_to_vertex_list(int n, r3s_phandle *src, grs_point **vp);
   // convert an array of phandles into an array vertices
   // this automatically reverses the winding in a left-handed space

#define r3_phandle_to_vertex(src)    (&((src)->grp))
   // convert a phandle into a grs_vertex *

void r3_reverse_vertex_list(int n, grs_point **src);
   // reverse 2d vertex list by hand

void r3_maybe_reverse_vertex_list(int n, grs_point **src);
   // reverse 2d vertex list if we're in a left-handed space

void r3_new2d_to_old2d(int n, grs_point **src, grs_vertex ***dest, grs_bitmap *hack);
   // back-compatibility: convert from grs_point to grs_vertex

extern int r3d_shad_rows_hack;
#define r3_set_shad_rows_hack(r) (r3d_shad_rows_hack=(r))

// $Header: x:/prj/tech/libsrc/r3d3/RCS/ctxts.h 1.12 1996/09/29 21:01:45 JAEMZ Exp $

// these really belong with the h files that take these

// typedef enum for camera spaces
// clipping is optimized for clipping alot
// project is optimizd for fast projection
// unscaled is slow at projection and clipping
// linear is super fast but only good for far objects
typedef enum {
   R3_CLIPPING_SPACE=0,
   R3_PROJECT_SPACE=1,
   R3_UNSCALED_SPACE=2,
   R3_LINEAR_SPACE=3,
   R3_NUM_SPACE=4
} r3e_space;

typedef enum {
   R3_XYZ=6,    //00 01 10
   R3_XZY=9,    //00 10 01
   R3_YXZ=18,   //01 00 10
   R3_YZX=24,   //01 10 00
   R3_ZXY=33,   //10 00 01
   R3_ZYX=36,   //10 01 00
   R3_DEFANG=6  //00 01 10
} r3e_order;

// Special transform that contains explicit handedness info
typedef struct _r3s_trans {
   mxs_trans t;   // transform part of it
   bool left;     // is it left handed or not                        
} r3s_trans;

// this is the transform context
// it has all the goodies for the stack and the like
typedef struct _r3s_xform_context {
   r3e_space cspace; // camera space
   mxs_vector cspace_vec;  // camera space vector
   r3s_trans world;  // custom world to 3d world space transform
   r3s_trans o2w;    // object to world
   r3s_trans w2v;    // world to viewer, no cspace, built from world and in(view trans);
   r3s_trans w2c;    // world to camera with cspace added, built from w2v, and space_vec
   r3s_trans o2c;    // object to camera space
   mxs_vector vino;  // viewer coords in object space
   bool w2c_invalid; // w2v invalid, need to reconcatenate before cur
   bool o2c_invalid; // set when cur is invalid
   bool world_set;   // set if the user has set world
   r3s_trans view_trans;   // raw view pos and matrix, for getting
   mxs_angvec view_ang; // raw view angles
   mxs_real zoom;     // zoom factor 90 degrees horizontal = 1
   mxs_real aspect;   // aspect ratio height/width
   float bias_x;     // x bias to the right of center of the viewer
   float bias_y;     // y bias down of center of the viewer
   mxs_vector lin_cen; // center of linear space
   mxs_real  lin_width;   // linear screen width or zero if using lin_cen
   r3s_trans lin_trans; // linear trans
   mxs_real  lin_w;      // linear w value

   int   stack_size; // current size of stack, ie, number of elements
   r3s_trans *stack_cur;   // pointer to next entry on stack
   int   stack_max;  // maximum num elements on stack
   r3s_trans *stack_base;  // pointer to base of stack

   int   block_state;   // optimization block flags
} r3s_xform_context;

typedef struct _r3s_context {
   // canvas and related processed information
   grs_canvas *cnv;     // 2d canvas to render to
   r3s_clip_context clip;  // clip context structure har
   r3s_xform_context trans;   // transform context structure har har
   r3s_prim_context prim;  // primitive context
   // context management info
   int flags;        // yea, ok, here they are.  neat, huh?
} r3s_context;

// global context that doesn't get copied
typedef struct {
   r3s_context *cur_con; // current context, null when none
   bool in_block;    // am I in a block
   int trans_depth;  // default nesting of transform stack
   int clip_planes;  // default number of clipping planes above the basic 5
   r3e_space space;  // default camera space
   r3s_trans world;  // default world coordinates
   // context stack info
   r3s_context **ctxt_stack;
   int stack_depth, stack_pos;
} r3s_global_state;

// global context that gets changed by current context
typedef struct {
   r3e_space cur_space;       // current space
   r3s_xform_tab  xform_tab;  // transform function tables
   r3s_prim_tab   prim_tab;   // primitive dispatch tables
   mxs_real x_prj;  // x projection constant
   mxs_real y_prj;  // y projection constant
   fix x_off;  // screen x offset constant
   fix y_off;  // screen y offset constant
   mxs_real x_clip;  // x clip constant
   mxs_real y_clip;  // y clip constant
} r3s_global_context;

extern r3s_global_state   r3d_state;      // global state
extern r3s_global_context r3d_glob;       // global context

// everyone will hate this, as the debugger wont know what it is
// cause life is so darn sad
// so i guess we wont do it
// #define r3d_context (r3d_state.cur_con)

//------- flags for r3s_context
// flags for dealing with having a stack/multicontext model
#define R3F_CTXT_CURRENT   (1<<0)      // current context?
#define R3F_CTXT_ACTIVE    (1<<1)      // currently started/in progress?
#define R3F_CTXT_ONSTACK   (1<<2)      // on the stack?
#define R3F_CTXT_USEDONE   (1<<3)      // in a use/done block?
// flag for bonus internal/external memory fun
#define R3F_CTXT_ALLOCED   (1<<4)      // memory that r3d allocated?
#define R3F_CTXT_IAM1ST    (1<<5)      // secret interal 1st context memory
// flags for allowing persistant canvii
#define R3F_CTXT_PERSIST   (1<<6)      // a persistant context?
#define R3F_CTXT_RELOAD2D  (1<<7)      // reload canvas from 2d each frame?
// flag we need if context drives start and end frame
#define R3F_CTXT_PRIMARY   (1<<8)      // "primary, frame rate" context?
                                       // not set means a "background" context

// $Header: x:/prj/tech/libsrc/r3d/RCS/object.h 1.5 1996/07/26 00:08:11 JAEMZ Exp $
// object stack routines

// Starts an object coordinate system, with no orientation.  What happens
// is the object stack is incremented, and the new transform is
// calculated.  Sets o2c_invalid.  All of them do. 

void r3_start_object(mxs_vector *v);
void r3_start_object_angles(mxs_vector *v, mxs_angvec *a,r3e_order o);
void r3_start_object_trans(mxs_trans *t);

// takes a number representing which axis to rotate about 0=x,1=y,2=z
// real angs are in radian, if you didn't know
void r3_start_object_n(mxs_vector *v,mxs_ang ang, int n);

// These next three are useful for retardo-vision objects, and internally
// for bsp objects that are hinged.

#define r3_start_object_x(vecptr,realang) r3_start_object_n((vecptr),(realang),0)
#define r3_start_object_y(vecptr,realang) r3_start_object_n((vecptr),(realang),1)
#define r3_start_object_z(vecptr,realang) r3_start_object_n((vecptr),(realang),2)

// Pops the transform stack

void r3_end_object();

// Exotic Transforms

// The other transforms are to go from object to world, on a point by
// point basis.  These are considered pathological, and so, aren't
// implemented as block calls or anything like that.

// Rotate a vector from object space to camera space,
// meaning this is non-orthogonal, beware
void r3_rotate_o2c(mxs_vector *dst,mxs_vector *src);

void r3_transform_o2w(mxs_vector *dst, mxs_vector *src);
void r3_rotate_o2w(mxs_vector *dst, mxs_vector *src);

// this definitely assumes o2w is always orthogonal.  Because it uses
// transpose as inverse.
void r3_transform_w2o(mxs_vector *dst, mxs_vector *src);
void r3_rotate_w2o(mxs_vector *dst, mxs_vector *src);

// $Header: x:/prj/tech/libsrc/r3d3/RCS/space.h 1.13 1996/09/29 19:44:37 JAEMZ Exp $
// Camera Space related functions

// Changes the world coordinate system to the one pointed at.  This is for
// losers who want to change for a given context after its built, or for doing
// wacky world inversion or maybe mirrors.  The handedness bit

void r3_set_world(mxs_trans *w);
mxs_trans *r3_get_world();

// Changes all the function pointers for xform and clipping, sets cspace and
// cspace_vec, and sets o2c_invalid, and w2c_invalid.  

void r3_set_space(r3e_space s);
r3e_space r3_get_space();

// Let's the user sneakily change the space for their own custom
// transform wackiness.   Note that this does not do anything to the
// clippers or any of that, so they better set it back again.

void r3_set_space_vector(mxs_vector *v);
mxs_vector *r3_get_space_vector();

// Routine to set the linear space mode center in world space
void r3_set_linear_center(mxs_vector *v);

// Routine to set the linear space projected from the center of the
// screen making the screen width be world space size w
// used for top down or anything like that view
void r3_set_linear_screen_width(mxs_real w);

// get the pixel size of something x wide at z distance from the camera,
// assumes it's centered, h means horizontal.  You can get z from a 
// transformed points z, since we're so groovy and don't scale it
mxs_real r3_get_hsize(mxs_real z,mxs_real h);
mxs_real r3_get_vsize(mxs_real z,mxs_real v);

// Unproject points into camera space, just give it screen coords
// and the distance at which you want it from the camera
void r3_unproject(mxs_vector *v,float z,float sx,float sy);

// Takes field of view in degrees, and the screen width in pixels
mxs_real r3_fov_2_zoom(mxs_real degrees);

// Returns necessary zoom to get the number of pixels for that 
// width and distance.  Basically opposite of r3_get_hsize
// z and w are in world coords, pixw is in screen pixels
mxs_real r3_hsize_2_zoom(mxs_real z,mxs_real w,mxs_real pixw);

// Get the pixel accuracy of linear space about a world point
// and radius.  This represents worst possible popping in screen
// pixels
mxs_real r3_linear_accuracy(mxs_vector *wcen,mxs_real rad);

// Transform a plane from world space to world space, preserving dot product
// equals zero.  Assumes w2v is unitary, but the csp vector doesn't have to 
// be
// Also, you must be outside of a block
void r3_w2c_plane(mxs_plane *dst,mxs_plane *src);

/*
 * $Source: x:/prj/tech/libsrc/r3d3/RCS/view.h $
 * $Revision: 1.7 $
 * $Author: JAEMZ $
 * $Date: 1996/09/29 19:44:38 $
 *
 * View point related functions
 *
 */

// Sets the view position, position only.  Note that orientationless cameras
// and objects all are assumed to be heading==0 pitch==0 bank==0, meaning that
// under the default world space, you all point down the x a Also, 
// o2c_invalid, and w2c_invalid get set.

void r3_set_view(mxs_vector *v);
mxs_trans *r3_get_view_trans();

// Sets the view transform pretty damn directly.  The meaning of it is the
// position in world space, and the columns of the matrix point along the
// viewer x, y, and z directions.

void r3_set_view_trans(mxs_trans *t);

// Takes an angvec for angles about the x,y,z axes, and and order which
// indicates from left to right how the angles should be applied.  There
// is a default, which is XYZ which means bank the thing first, pitch i

void r3_set_view_angles(mxs_vector *v, mxs_angvec *a,r3e_order o);

// Gets the view position in world space, and the angles in world space

mxs_vector *r3_get_view_pos();
mxs_angvec *r3_get_view_ang();

// This gives you the current viewer position in object space.   This
// must be in a block.  Or at least after a block and before any other
// space changing call. 

mxs_vector *r3_get_view_in_obj();

// These are always true, don't need to be in or out of a block
// The slew function gets you the slew matrix of the viewer.  That is,
// the first column, would be the vector to move you one unit in the
// viewer x, ie forward, the second column is y, ie, left, the third
// column.

mxs_matrix *r3_get_slew_matrix();
mxs_vector *r3_get_forward_slew();
mxs_vector *r3_get_left_slew();
mxs_vector *r3_get_up_slew();

// get the view pyramid in world space
// as a set of planes that get stuffed
// you need space for five planes,
// left,top,right,bottom, front

void r3_get_view_pyr_planes(mxs_plane *planes);

// get the view pyramid as 4 vectors
// upper left, upper right, lower right, lower left
// Note that these are deltas in world space off of the viewer position

void r3_get_view_pyr_vecs(mxs_vector *vecs);

// Stuff a world space vector into dst describing a vector
// at screen coordinates, sx, and sy.  dst->z is equal to one
// can call at any time during a context
void r3_get_view_vec(mxs_vector *dst,mxs_real sx,mxs_real sy);

// get and set zoom factors, defaults to 1.0 = 90 degrees
// need a current context, not in a block

void r3_set_zoom(mxs_real zoom);
mxs_real r3_get_zoom();

// set and get aspect ratio, since you may want to change
// it, and the 2d has no aspect per canvas
// note aspect ratio is defined as height of pixel over
// width of pixel.

void r3_set_aspect(mxs_real aspect);
mxs_real r3_get_aspect();

// set and get the current view canvas, this is also called internally
// assumes in context, and not in block.

void r3_set_view_canvas(grs_canvas *canv);
grs_canvas *r3_get_view_canvas();

// Block commands

// These define whether or not you are invariant or invisible
// or both.  You use this when you know you have special information
// about the points.  Used for r3_start_block_special

#define R3_INVARIANT 1
#define R3_INVISIBLE 2

// Start an optimized block, takes any or none of the above flags
void r3_start_oblock(int opts);

void r3_start_block();
void r3_end_block();

// $Header: x:/prj/tech/libsrc/r3d/RCS/r3dctxt.h 1.3 1996/05/25 23:15:26 dc Exp $
// public functions for the context system

// super basic start and end frame, implicitly create, set and destroy a context
r3s_context *r3_start_frame(void);
bool r3_end_frame(void);
// for using a context you have built to start a frame
bool r3_start_frame_context(r3s_context *ctxt);

// basic special context support, for building and playing with persistant contexts
r3s_context *r3_alloc_context(bool pers, r3s_context *ctxt);
bool r3_use_context(r3s_context *ctxt);
bool r3_done_with_context(void);
bool r3_free_context(r3s_context *ctxt);

// fancy pants context stuff for cool people who use multicontext support
bool r3_switch_context(r3s_context *dst);
bool r3_push_context(r3s_context *dst);
bool r3_pop_context(void);
bool r3_abort_context(r3s_context *ctxt);

// Initializing commands

void r3_init_defaults(int trans_depth,int clip_planes,r3e_space space,int ctxt_cnt);

// simple init call that most users will use, that just uses all the default
void r3_init(void);

void r3_close(void);

// Sets a world coord system inherited by all subsequent context creations.  
// The default is the identity transform.  As well, the handedness bit is set
// in the transform.  If you have a current context.

void r3_set_default_world(mxs_trans *w);

mxs_trans *r3_get_default_world();

// Sets the default camera space that all new contexts inherit.  The default
// is R3_CLIPPING.

void r3_set_default_space(r3e_space s);

r3e_space r3_get_default_space();

/*
 * $Source: x:/prj/tech/libsrc/r3d/RCS/utils.h $
 * $Revision: 1.1 $
 * $Author: JAEMZ $
 * $Date: 1996/09/16 14:44:47 $
 *
 * View point related functions
 *
 */

// Render a wire frame of radius rad.
// The caller is responsible for setting
// object space and color and block
void r3_wire_cube(float rad);

// Draws a vector at position pos, and extending towards vec.
// You can scale it and set the maximum size of the vector
// The user is responsible for setting color and block and frame
void r3_render_vector(mxs_vector pos,mxs_vector vec,float scale,float maxv);

#endif /* __R3D3_H */ 
